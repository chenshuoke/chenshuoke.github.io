<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第三十七章 奇珍异宝</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%A5%87%E7%8F%8D%E5%BC%82%E5%AE%9D/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%A5%87%E7%8F%8D%E5%BC%82%E5%AE%9D/</url>
      
        <content type="html"><![CDATA[<p>In this, the final chapter of our journey, we will look at some odds and ends. While we have certainly covered a lot of ground in the previous chapters, there are many bash features that we have not covered. Most are fairly obscure, and useful mainly to those integrating bash into a Linux distribution. However, there are a few that, while not in common use, are helpful for certain programming problems. We will cover them here.</p><p>在我们 bash 学习旅程中的最后一站，我们将看一些零星的知识点。当然我们在之前的章节中已经 涵盖了很多方面，但是还有许多 bash 特性我们没有涉及到。其中大部分特性相当晦涩，主要对 那些把 bash 集成到 Linux 发行版的程序有用处。然而还有一些特性，虽然不常用， 但是对某些程序问题是很有帮助的。我们将在这里介绍它们。</p><h3 id="组命令和子-shell"><a href="#组命令和子-shell" class="headerlink" title="组命令和子 shell"></a>组命令和子 shell</h3><p>bash allows commands to be grouped together. This can be done in one of two ways; either with a group command or with a subshell. Here are examples of the syntax of each:</p><p>bash 允许把命令组合在一起。可以通过两种方式完成；要么用一个 group 命令，要么用一个子 shell。 这里是每种方式的语法示例：</p><p>Group command:</p><p>组命令：</p><pre><code>{ command1; command2; [command3; ...] }</code></pre><p>Subshell:</p><p>子 shell：</p><pre><code>(command1; command2; [command3;...])</code></pre><p>The two forms differ in that a group command surrounds its commands with braces and a subshell uses parentheses. It is important to note that, due to the way bash implements group commands, the braces must be separated from the commands by a space and the last command must be terminated with either a semicolon or a newline prior to the closing brace.</p><p>这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式， 花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。</p><p>So what are group commands and subshells good for? While they have an important difference (which we will get to in a moment), they are both used to manage redirection. Let’s consider a script segment that performs redirections on multiple commands:</p><p>那么组命令和子 shell 命令对什么有好处呢？ 尽管它们有一个很重要的差异（我们马上会接触到），但它们都是用来管理重定向的。 让我们考虑一个对多个命令执行重定向的脚本片段。</p><pre><code>ls -l &gt; output.txtecho &quot;Listing of foo.txt&quot; &gt;&gt; output.txtcat foo.txt &gt;&gt; output.txt</code></pre><p>This is pretty straightforward. Three commands with their output redirected to a file named output.txt. Using a group command, we could code this as follows:</p><p>这些代码相当简洁明了。三个命令的输出都重定向到一个名为 output.txt 的文件中。 使用一个组命令，我们可以重新编 写这些代码，如下所示：</p><pre><code>{ ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt; } &gt; output.txt</code></pre><p>Using a subshell is similar:</p><p>使用一个子 shell 是相似的：</p><pre><code>(ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt) &gt; output.txt</code></pre><p>Using this technique we have saved ourselves some typing, but where a group command or subshell really shines is with pipelines. When constructing a pipeline of commands, it is often useful to combine the results of several commands into a single stream. Group commands and subshells make this easy:</p><p>使用这样的技术，我们为我们自己节省了一些打字时间，但是组命令和子 shell 真正闪光的地方是与管道线相结合。 当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一个流是很有用的。 组命令和子 shell 使这种操作变得很简单：</p><pre><code>{ ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt; } | lpr</code></pre><p>Here we have combined the output of our three commands and piped them into the input of lpr to produce a printed report.</p><p>这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr 的输入，以便产生一个打印报告。</p><p>In the script that follows, we will use groups commands and look at several programming techniques that can be employed in conjunction with associative arrays. This script, called array-2, when given the name of a directory, prints a listing of the files in the directory along with the names of the the file’s owner and group owner. At the end of listing, the script prints a tally of the number of files belonging to each owner and group. Here we see the results (condensed for brevity) when the script is given the directory /usr/bin:</p><p>在下面的脚本中，我们将使用组命令，看几个与关联数组结合使用的编程技巧。这个脚本，称为 array-2，当给定一个目录名，打印出目录中的文件列表， 伴随着每个文件的文件所有者和组所有者。在文件列表的末尾，脚本打印出属于每个所有者和组的文件数目。 这里我们看到的（为简单起见而缩短的）结果，是给定脚本的目录为 /usr/bin 的时候：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ array-2 /usr/bin/usr/bin/2to3-2.6                 root        root/usr/bin/2to3                     root        root/usr/bin/a2p                      root        root/usr/bin/abrowser                 root        root/usr/bin/aconnect                 root        root/usr/bin/acpi_fakekey             root        root/usr/bin/acpi_listen              root        root/usr/bin/add-apt-repository       root        root.../usr/bin/zipgrep                  root        root/usr/bin/zipinfo                  root        root/usr/bin/zipnote                  root        root/usr/bin/zip                      root        root/usr/bin/zipsplit                 root        root/usr/bin/zjsdecode                root        root/usr/bin/zsoelim                  root        rootFile owners:daemon  : 1 file(s)root    : 1394 file(s) File group owners:crontab : 1 file(s)daemon  : 1 file(s)lpadmin : 1 file(s)mail    : 4 file(s)mlocate : 1 file(s)root    : 1380 file(s)shadow  : 2 file(s)ssh     : 1 file(s)tty     : 2 file(s)utmp    : 2 file(s)</code></pre><p>Here is a listing (with line numbers) of the script:</p><p>这里是脚本代码列表（带有行号）：</p><pre class=" language-shell"><code class="language-shell">1     #!/bin/bash23     # array-2: Use arrays to tally file owners45     declare -A files file_group file_owner groups owners67     if [[ ! -d "$1" ]]; then8        echo "Usage: array-2 dir" >&29        exit 110    fi1112    for i in "$1"/*; do13       owner=$(stat -c %U "$i")14       group=$(stat -c %G "$i")15        files["$i"]="$i"16        file_owner["$i"]=$owner17        file_group["$i"]=$group18        ((++owners[$owner]))19        ((++groups[$group]))20    done2122    # List the collected files23    { for i in "${files[@]}"; do24    printf "%-40s %-10s %-10s\n" \25    "$i" ${file_owner["$i"]} ${file_group["$i"]}26    done } | sort27    echo2829   # List owners30    echo "File owners:"31    { for i in "${!owners[@]}"; do32    printf "%-10s: %5d file(s)\n" "$i" ${owners["$i"]}33    done } | sort34    echo3536    # List groups37    echo "File group owners:"38    { for i in "${!groups[@]}"; do39    printf "%-10s: %5d file(s)\n" "$i" ${groups["$i"]}40    done } | sort</code></pre><p>Let’s take a look at the mechanics of this script:</p><p>让我们看一下这个脚本的运行机制：</p><p>Line 5: Associative arrays must be created with the declare command using the -A option. In this script we create five arrays as follows:</p><p>行5： 关联数组必须用带有 -A 选项的 declare 命令创建。在这个脚本中我们创建了如下五个数组：</p><p>files contains the names of the files in the directory, indexed by filename</p><p>file_group contains the group owner of each file, indexed by filename</p><p>file_owner contains the owner of each file, indexed by file name</p><p>groups contains the number of files belonging to the indexed group</p><p>owners contains the number of files belonging to the indexed owner</p><p>files 包含了目录中文件的名字，按文件名索引</p><p>file_group 包含了每个文件的组所有者，按文件名索引</p><p>file_owner 包含了每个文件的所有者，按文件名索引</p><p>groups 包含了属于索引的组的文件数目</p><p>owners 包含了属于索引的所有者的文件数目</p><p>Lines 7-10: Checks to see that a valid directory name was passed as a positional parameter. If not, a usage message is displayed and the script exits with an exit status of 1.</p><p>行7-10：查看是否一个有效的目录名作为位置参数传递给程序。如果不是，就会显示一条使用信息，并且脚本退出，退出状态为1。</p><p>Lines 12-20: Loop through the files in the directory. Using the stat command, lines 13 and 14 extract the names of the file owner and group owner and assign the values to their respective arrays (lines 16, 17) using the name of the file as the array index. Likewise the file name itself is assigned to the files array (line 15).</p><p>行12-20：循环遍历目录中的所有文件。使用 stat 命令，行13和行14抽取文件所有者和组所有者， 并把值赋给它们各自的数组（行16，17），使用文件名作为数组索引。同样地，文件名自身也赋值给 files 数组。</p><p>Lines 18-19: The total number of files belonging to the file owner and group owner are incremented by one.</p><p>行18-19：属于文件所有者和组所有者的文件总数各自加1。</p><p>Lines 22-27: The list of files is output. This is done using the “${array[@]}” parameter expansion which expands into the entire list of array element with each element treated as a separate word. This allows for the possibility that a file name may contain embedded spaces. Also note that the entire loop is enclosed in braces thus forming a group command. This permits the entire output of the loop to be piped into the sort command. This is necessary because the expansion of the array elements is not sorted.</p><p>行22-27：输出文件列表。为做到这一点，使用了 “${array[@]}” 参数展开，展开成整个的数组元素列表， 并且每个元素被当做是一个单独的词。从而允许文件名包含空格的情况。也要注意到整个循环是包裹在花括号中， 从而形成了一个组命令。这样就允许整个循环输出会被管道输送给 sort 命令的输入。这是必要的，因为 展开的数组元素是无序的。</p><p>Lines 29-40: These two loops are similar to the file list loop except that they use the “${! array[@]}” expansion which expands into the list of array indexes rather than the list of array elements.</p><p>行29-40：这两个循环与文件列表循环相似，除了它们使用 “${!array[@]}” 展开，展开成数组索引的列表 而不是数组元素的。</p><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>While they look similar and can both be used to combine streams for redirection, there is an important difference between group commands and subshells. Whereas a group command executes all of its commands in the current shell, a subshell (as the name suggests) executes its commands in a child copy of the current shell. This means that the environment is copied and given to a new instance of the shell. When the subshell exits, the copy of the environment is lost, so any changes made to the subshell’s environment (including variable assignment) is lost as well. Therefore, in most cases, unless a script requires a subshell, group commands are preferable to subshells. Group commands are both faster and require less memory.</p><p>虽然组命令和子 shell 看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个很重要的不同之处。 然而，一个组命令在当前 shell 中执行它的所有命令，而一个子 shell（顾名思义）在当前 shell 的一个 子副本中执行它的命令。这意味着运行环境被复制给了一个新的 shell 实例。当这个子 shell 退出时，环境副本会消失， 所以在子 shell 环境（包括变量赋值）中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell， 组命令比子 shell 更受欢迎。组命令运行很快并且占用的内存也少。</p><p>We saw an example of the subshell environment problem in Chapter 28, when we discovered that a read command in a pipeline does not work as we might intuitively expect. To recap, if we construct a pipeline like this:</p><p>我们在第20章中看到过一个子 shell 运行环境问题的例子，当我们发现管道线中的一个 read 命令 不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线：</p><pre><code>echo &quot;foo&quot; | readecho $REPLY</code></pre><p>The content of the REPLY variable is always empty because the read command is executed in a subshell, and its copy of REPLY is destroyed when the subshell terminates. Because commands in pipelines are always executed in subshells, any command that assigns variables will encounter this issue. Fortunately, the shell provides an exotic form of expansion called process substitution that can be used to work around this problem. Process substitution is expressed in two ways:</p><p>该 REPLY 变量的内容总是为空，是因为这个 read 命令在一个子 shell 中执行，所以当该子 shell 终止的时候， 它的 REPLY 副本会被毁掉。因为管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题。 幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式：</p><p>For processes that produce standard output:</p><p>一种适用于产生标准输出的进程：</p><pre><code>&lt;(list)</code></pre><p>or, for processes that intake standard input:</p><p>另一种适用于接受标准输入的进程：</p><pre><code>&gt;(list)</code></pre><p>where list is a list of commands.</p><p>这里的 list 是一串命令列表：</p><p>To solve our problem with read, we can employ process substitution like this:</p><p>为了解决我们的 read 命令问题，我们可以雇佣进程替换，像这样：</p><pre><code>read &lt; &lt;(echo &quot;foo&quot;)echo $REPLY</code></pre><p>Process substitution allows us to treat the output of a subshell as an ordinary file for purposes of redirection. In fact, since it is a form of expansion, we can examine its real value:</p><p>进程替换允许我们把一个子 shell 的输出结果当作一个用于重定向的普通文件。事实上，因为它是一种展开形式，我们可以检验它的真实值：</p><pre><code>[me@linuxbox ~]$ echo &lt;(echo &quot;foo&quot;)/dev/fd/63</code></pre><p>By using echo to view the result of the expansion, we see that the output of the subshell is being provided by a file named /dev/fd/63.</p><p>通过使用 echo 命令，查看展开结果，我们看到子 shell 的输出结果，由一个名为 /dev/fd/63 的文件提供。</p><p>Process substitution is often used with loops containing read. Here is an example of a read loop that processes the contents of a directory listing created by a subshell:</p><p>进程替换经常被包含 read 命令的循环用到。这里是一个 read 循环的例子，处理一个目录列表的内容，内容创建于一个子 shell：</p><pre><code>#!/bin/bash# pro-sub : demo of process substitutionwhile read attr links owner group size date time filename; do    cat &lt;&lt;- EOF        Filename:     $filename        Size:         $size        Owner:        $owner        Group:        $group        Modified:     $date $time        Links:        $links        Attributes:   $attr    EOFdone &lt; &lt;(ls -l | tail -n +2)</code></pre><p>The loop executes read for each line of a directory listing. The listing itself is produced on the final line of the script. This line redirects the output of the process substitution into the standard input of the loop. The tail command is included in the process substitution pipeline to eliminate the first line of the listing, which is not needed.</p><p>这个循环对目录列表的每一个条目执行 read 命令。列表本身产生于该脚本的最后一行代码。这一行代码把从进程替换得到的输出 重定向到这个循环的标准输入。这个包含在管道线中的 tail 命令，是为了消除列表的第一行文本，这行文本是多余的。</p><p>When executed, the script produces output like this:</p><p>当脚本执行后，脚本产生像这样的输出：</p><pre><code>[me@linuxbox ~]$ pro_sub | head -n 20Filename: addresses.ldifSize: 14540Owner: meGroup: meModified: 2009-04-02 11:12Links:1Attributes: -rw-r--r--Filename: binSize: 4096Owner: meGroup: meModified: 2009-07-10 07:31Links: 2Attributes: drwxr-xr-xFilename: bookmarks.htmlSize: 394213Owner: meGroup: me</code></pre><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>In Chapter 10, we saw how programs can respond to signals. We can add this capability to our scripts, too. While the scripts we have written so far have not needed this capabil- ity (because they have very short execution times, and do not create temporary files), larger and more complicated scripts may benefit from having a signal handling routine.</p><p>在第10章中，我们看到过程序是怎样响应信号的。我们也可以把这个功能添加到我们的脚本中。然而到目前为止， 我们所编写过的脚本还不需要这种功能（因为它们运行时间非常短暂，并且不创建临时文件），大且更复杂的脚本 可能会受益于一个信息处理程序。</p><p>When we design a large, complicated script, it is important to consider what happens if the user logs off or shuts down the computer while the script is running. When such an event occurs, a signal will be sent to all affected processes. In turn, the programs repre- senting those processes can perform actions to ensure a proper and orderly termination of the program. Let’s say, for example, that we wrote a script that created a temporary file during its execution. In the course of good design, we would have the script delete the file when the script finishes its work. It would also be smart to have the script delete the file if a signal is received indicating that the program was going to be terminated prematurely.</p><p>当我们设计一个大的，复杂的脚本的时候，若脚本仍在运行时，用户注销或关闭了电脑，这时候会发生什么，考虑到这一点非常重要。 当像这样的事情发生了，一个信号将会发送给所有受到影响的进程。依次地，代表这些进程的程序会执行相应的动作，来确保程序 合理有序的终止。比方说，例如，我们编写了一个会在执行时创建临时文件的脚本。在一个好的设计流程，我们应该让脚本删除创建的 临时文件，当脚本完成它的任务之后。若脚本接收到一个信号，表明该程序即将提前终止的信号， 此时让脚本删除创建的临时文件，也会是很精巧的设计。</p><p>bash provides a mechanism for this purpose known as a trap. Traps are implemented with the appropriately named builtin command, trap. trap uses the following syntax:</p><p>为满足这样需求，bash 提供了一种机制，众所周知的 trap。陷阱正好由内部命令 trap 实现。 trap 使用如下语法：</p><pre><code>trap argument signal [signal...]</code></pre><p>where argument is a string which will be read and treated as a command and signal is the specification of a signal that will trigger the execution of the interpreted command.</p><p>这里的 argument 是一个字符串，它被读取并被当作一个命令，signal 是一个信号的说明，它会触发执行所要解释的命令。</p><p>Here is a simple example:</p><p>这里是一个简单的例子：</p><pre><code>#!/bin/bash# trap-demo : simple signal handling demotrap &quot;echo &#39;I am ignoring you.&#39;&quot; SIGINT SIGTERMfor i in {1..5}; do    echo &quot;Iteration $i of 5&quot;    sleep 5done</code></pre><p>This script defines a trap that will execute an echo command each time either the SIGINT or SIGTERM signal is received while the script is running. Execution of the program looks like this when the user attempts to stop the script by pressing Ctrl-c:</p><p>这个脚本定义一个陷阱，当脚本运行的时候，这个陷阱每当接受到一个 SIGINT 或 SIGTERM 信号时，就会执行一个 echo 命令。 当用户试图通过按下 Ctrl-c 组合键终止脚本运行的时候，该程序的执行结果看起来像这样：</p><pre><code>[me@linuxbox ~]$ trap-demoIteration 1 of 5Iteration 2 of 5I am ignoring you.Iteration 3 of 5I am ignoring you.Iteration 4 of 5Iteration 5 of 5</code></pre><p>As we can see, each time the user attempts to interrupt the program, the message is printed instead.</p><p>正如我们所看到的，每次用户试图中断程序时，会打印出这条信息。</p><p>Constructing a string to form a useful sequence of commands can be awkward, so it is common practice to specify a shell function as the command. In this example, a separate shell function is specified for each signal to be handled:</p><p>构建一个字符串来形成一个有用的命令序列是很笨拙的，所以通常的做法是指定一个 shell 函数作为命令。在这个例子中， 为每一个信号指定了一个单独的 shell 函数来处理：</p><pre><code>#!/bin/bash# trap-demo2 : simple signal handling demoexit_on_signal_SIGINT () {    echo &quot;Script interrupted.&quot; 2&gt;&amp;1    exit 0}exit_on_signal_SIGTERM () {    echo &quot;Script terminated.&quot; 2&gt;&amp;1    exit 0}trap exit_on_signal_SIGINT SIGINTtrap exit_on_signal_SIGTERM SIGTERMfor i in {1..5}; do    echo &quot;Iteration $i of 5&quot;    sleep 5done</code></pre><p>This script features two trap commands, one for each signal. Each trap, in turn, speci- fies a shell function to be executed when the particular signal is received. Note the inclu- sion of an exit command in each of the signal-handling functions. Without an exit, the script would continue after completing the function.</p><p>这个脚本的特色是有两个 trap 命令，每个命令对应一个信号。每个 trap，依次，当接受到相应的特殊信号时， 会执行指定的 shell 函数。注意每个信号处理函数中都包含了一个 exit 命令。没有 exit 命令， 信号处理函数执行完后，该脚本将会继续执行。</p><p>When the user presses Ctrl-c during the execution of this script, the results look like this:</p><p>当用户在这个脚本执行期间，按下 Ctrl-c 组合键的时候，输出结果看起来像这样：</p><pre><code>[me@linuxbox ~]$ trap-demo2Iteration 1 of 5Iteration 2 of 5Script interrupted.</code></pre><blockquote><p><em>Temporary Files</em></p><p><em>临时文件</em></p><p>One reason signal handlers are included in scripts is to remove temporary files that the script may create to hold intermediate results during execution. There is something of an art to naming temporary files. Traditionally, programs on Unix-like systems create their temporary files in the /tmp directory, a shared directory intended for such files. However, since the directory is shared, this poses certain security concerns, particularly for programs running with superuser privileges. Aside from the obvious step of setting proper permissions for files exposed to all users of the system, it is important to give temporary files non-predictable filenames. This avoids an exploit known as a temp race attack. One way to create a non-predictable (but still descriptive) name is to do something like this:</p><p>把信号处理程序包含在脚本中的一个原因是删除临时文件，在脚本执行期间，脚本可能会创建临时文件来存放中间结果。 命名临时文件是一种艺术。传统上，在类似于 unix 系统中的程序会在 /tmp 目录下创建它们的临时文件，/tmp 是 一个服务于临时文件的共享目录。然而，因为这个目录是共享的，这会引起一定的安全顾虑，尤其对那些用 超级用户特权运行的程序。除了为暴露给系统中所有用户的文件设置合适的权限这一明显步骤之外， 给临时文件一个不可预测的文件名是很重要的。这就避免了一种为大众所知的 temp race 攻击。 一种创建一个不可预测的（但是仍有意义的）临时文件名的方法是，做一些像这样的事情：</p><p><em>tempfile=/tmp/$(basename $0).$$.$RANDOM</em></p><p>This will create a filename consisting of the program’s name, followed by its process ID (PID), followed by a random integer. Note, however, that the $RANDOM shell variable only returns a value in the range of 1-32767, which is not a very large range in computer terms, so a single instance of the variable is not sufficient to overcome a determined attacker.</p><p>这将创建一个由程序名字，程序进程的 ID（PID）文件名，和一个随机整数组成。注意，然而，该 $RANDOM shell 变量 只能返回一个范围在1-32767内的整数值，这在计算机术语中不是一个很大的范围，所以一个单一的该变量实例是不足以克服一个坚定的攻击者的。</p><p>A better way is to use the mktemp program (not to be confused with the mktemp standard library function) to both name and create the temporary file. The mktemp program accepts a template as an argument that is used to build the filename. The template should include a series of “X” characters, which are replaced by a corresponding number of random letters and numbers. The longer the series of “X” characters, the longer the series of random characters. Here is an example:</p><p>一个比较好的方法是使用 mktemp 程序（不要和 mktemp 标准库函数相混淆）来命名和创建临时文件。 这个 mktemp 程序接受一个用于创建文件名的模板作为参数。这个模板应该包含一系列的 “X” 字符， 随后这些字符会被相应数量的随机字母和数字替换掉。一连串的 “X” 字符越长，则一连串的随机字符也就越长。 这里是一个例子：</p><p><em>tempfile=$(mktemp /tmp/foobar.$$.XXXXXXXXXX)</em></p><p>This creates a temporary file and assigns its name to the variable tempfile. The “X” characters in the template are replaced with random letters and numbers so that the final filename (which, in this example, also includes the expanded value of the special parameter $$ to obtain the PID) might be something like:</p><p>这里创建了一个临时文件，并把临时文件的名字赋值给变量 tempfile。因为模板中的 “X” 字符会被随机字母和 数字代替，所以最终的文件名（在这个例子中，文件名也包含了特殊参数 $$ 的展开值，进程的 PID）可能像这样：</p><p><em>/tmp/foobar.6593.UOZuvM6654</em></p><p>For scripts that are executed by regular users, it may be wise to avoid the use of the /tmp directory and create a directory for temporary files within the user’s home directory, with a line of code such as this:</p><p>对于那些由普通用户操作执行的脚本，避免使用 /tmp 目录，而是在用户家目录下为临时文件创建一个目录， 通过像这样的一行代码：</p><p><em>[[ -d $HOME/tmp ]] || mkdir $HOME/tmp</em></p></blockquote><h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>It is sometimes desirable to perform more than one task at the same time. We have seen how all modern operating systems are at least multitasking if not multiuser as well. Scripts can be constructed to behave in a multitasking fashion.</p><p>有时候需要同时执行多个任务。我们已经知道现在所有的操作系统若不是多用户的但至少是多任务的。 脚本也可以构建成多任务处理的模式。</p><p>Usually this involves launching a script that, in turn, launches one or more child scripts that perform an additional task while the parent script continues to run. However, when a series of scripts runs this way, there can be problems keeping the parent and child coordinated. That is, what if the parent or child is dependent on the other, and one script must wait for the other to finish its task before finishing its own?</p><p>通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办？</p><p>bash has a builtin command to help manage asynchronous execution such as this. The wait command causes a parent script to pause until a specified process (i.e., the child script) finishes.</p><p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程（例如，子脚本）运行结束。</p><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>We will demonstrate the wait command first. To do this, we will need two scripts, a par- ent script:</p><p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本：</p><pre><code>#!/bin/bash# async-parent : Asynchronous execution demo (parent)echo &quot;Parent: starting...&quot;echo &quot;Parent: launching child script...&quot;async-child &amp;pid=$!echo &quot;Parent: child (PID= $pid) launched.&quot;echo &quot;Parent: continuing...&quot;sleep 2echo &quot;Parent: pausing to wait for child to finish...&quot;wait $pidecho &quot;Parent: child is finished. Continuing...&quot;echo &quot;Parent: parent is done. Exiting.&quot;</code></pre><p>and a child script:</p><p>和一个子脚本：</p><pre><code>#!/bin/bash# async-child : Asynchronous execution demo (child)echo &quot;Child: child is running...&quot;sleep 5echo &quot;Child: child is done. Exiting.&quot;</code></pre><p>In this example, we see that the child script is very simple. The real action is being per- formed by the parent. In the parent script, the child script is launched and put into the background. The process ID of the child script is recorded by assigning the pid variable with the value of the $! shell parameter, which will always contain the process ID of the last job put into the background.</p><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p><p>The parent script continues and then executes a wait command with the PID of the child process. This causes the parent script to pause until the child script exits, at which point the parent script concludes.</p><p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出，父脚本随之结束。</p><p>When executed, the parent and child scripts produce the following output:</p><p>当执行后，父子脚本产生如下输出：</p><pre><code>[me@linuxbox ~]$ async-parentParent: starting...Parent: launching child script...Parent: child (PID= 6741) launched.Parent: continuing...Child: child is running...Parent: pausing to wait for child to finish...Child: child is done. Exiting.Parent: child is finished. Continuing...Parent: parent is done. Exiting.</code></pre><h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>In most Unix-like systems, it is possible to create a special type of file called a named pipe. Named pipes are used to create a connection between two processes and can be used just like other types of files. They are not that popular, but they’re good to know about.</p><p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。虽然它们不是那么流行，但是它们值得我们去了解。</p><p>There is a common programming architecture called client-server, which can make use of a communication method such as named pipes, as well as other kinds of interprocess communication such as network connections.</p><p>有一种常见的编程架构，叫做客户端-服务器，它可以利用像命名管道这样的通信方式， 也可以使用其它类型的进程间通信方式，比如网络连接。</p><p>The most widely used type of client-server system is, of course, a web browser communicating with a web server. The web browser acts as the client, making requests to the server and the server responds to the browser with web pages.</p><p>最为广泛使用的客户端-服务器系统类型当然是一个web浏览器与一个web服务器之间进行通信。 web 浏览器作为客户端，向服务器发出请求，服务器响应请求，并把对应的网页发送给浏览器。</p><p>Named pipes behave like files, but actually form first-in first-out (FIFO) buffers. As with ordinary (unnamed) pipes, data goes in one end and emerges out the other. With named pipes, it is possible to set up something like this:</p><p>命令管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西：</p><pre><code>process1 &gt; named_pipe</code></pre><p>and</p><p>和</p><pre><code>process2 &lt; named_pipe</code></pre><p>and it will behave as if:</p><p>表现出来就像这样：</p><pre><code>process1 | process2</code></pre><h4 id="设置一个命名管道"><a href="#设置一个命名管道" class="headerlink" title="设置一个命名管道"></a>设置一个命名管道</h4><p>First, we must create a named pipe. This is done using the mkfifo command:</p><p>首先，我们必须创建一个命名管道。使用 mkfifo 命令能够创建命令管道：</p><pre><code>[me@linuxbox ~]$ mkfifo pipe1[me@linuxbox ~]$ ls -l pipe1prw-r--r-- 1 meme0 2009-07-17 06:41 pipe1</code></pre><p>Here we use mkfifo to create a named pipe called pipe1. Using ls, we examine the file and see that the first letter in the attributes field is “p”, indicating that it is a named pipe.</p><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p><h4 id="使用命名管道"><a href="#使用命名管道" class="headerlink" title="使用命名管道"></a>使用命名管道</h4><p>To demonstrate how the named pipe works, we will need two terminal windows (or alternately, two virtual consoles). In the first terminal, we enter a simple command and redirect its output to the named pipe:</p><p>为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：</p><pre><code>[me@linuxbox ~]$ ls -l &gt; pipe1</code></pre><p>After we press the Enter key, the command will appear to hang. This is because there is nothing receiving data from the other end of the pipe yet. When this occurs, it is said that the pipe is blocked. This condition will clear once we attach a process to the other end and it begins to read input from the pipe. Using the second terminal window, we enter this command:</p><p>我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何对象来接收数据。这种现象被称为管道阻塞。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，管道阻塞现象就不存在了。 使用第二个终端窗口，我们输入这个命令：</p><pre><code>[me@linuxbox ~]$ cat &lt; pipe1</code></pre><p>and the directory listing produced from the first terminal window appears in the second terminal as the output from the cat command. The ls command in the first terminal successfully completes once it is no longer blocked.</p><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Well, we have completed our journey. The only thing left to do now is practice, practice, practice. Even though we covered a lot of ground in our trek, we barely scratched the surface as far as the command line goes. There are still thousands of command line programs left to be discovered and enjoyed. Start digging around in /usr/bin and you’ll see!</p><p>嗯，我们已经完成了我们的旅程。现在剩下的唯一要做的事就是练习，练习，再练习。 纵然在我们的长途跋涉中，我们涉及了很多命令，但是就命令行而言，我们只是触及了它的表面。 仍留有成千上万的命令行程序，需要去发现和享受。开始挖掘 /usr/bin 目录吧，你将会看到！</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The “Compound Commands” section of the bash man page contains a full description of group command and subshell notations.</p></li><li><p>bash 手册页的 “复合命令” 部分包含了对组命令和子 shell 表示法的详尽描述。</p></li><li><p>The EXPANSION section of the bash man page contains a subsection of process substitution.</p></li><li><p>bash 手册也的 EXPANSION 部分包含了一小部分进程替换的内容：</p></li><li><p>The Advanced Bash-Scripting Guide also has a discussion of process substitution:</p></li><li><p>《高级 Bash 脚本指南》也有对进程替换的讨论：</p><p><a href="http://tldp.org/LDP/abs/html/process-sub.html" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/process-sub.html</a></p></li><li><p>Linux Journal has two good articles on named pipes. The first, from September 1997:</p></li><li><p>《Linux 杂志》有两篇关于命令管道的好文章。第一篇，源于1997年9月：</p><p><a href="http://www.linuxjournal.com/article/2156" target="_blank" rel="noopener">http://www.linuxjournal.com/article/2156</a></p></li><li><p>and the second, from March 2009:</p></li><li><p>和第二篇，源于2009年3月：</p><p><a href="http://www.linuxjournal.com/content/using-named-pipes-fifos-bash" target="_blank" rel="noopener">http://www.linuxjournal.com/content/using-named-pipes-fifos-bash</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十六章 数组</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%95%B0%E7%BB%84/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>In the last chapter, we looked at how the shell can manipulate strings and numbers. The data types we have looked at so far are known in computer science circles as scalar variables; that is, variables that contain a single value.</p><p>在上一章中，我们查看了 shell 怎样操作字符串和数字的。目前我们所见到的数据类型在计算机科学圈里被 称为标量变量；也就是说，只能包含一个值的变量。</p><p>In this chapter, we will look at another kind of data structure called an array, which holds multiple values. Arrays are a feature of virtually every programming language. The shell supports them, too, though in a rather limited fashion. Even so, they can be very useful for solving programming problems.</p><p>在本章中，我们将看看另一种数据结构叫做数组，数组能存放多个值。数组几乎是所有编程语言的一个特性。 shell 也支持它们，尽管以一个相当有限的形式。即便如此，为解决编程问题，它们是非常有用的。</p><h3 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h3><p>Arrays are variables that hold more than one value at a time. Arrays are organized like a table. Let’s consider a spreadsheet as an example. A spreadsheet acts like a two-dimensional array. It has both rows and columns, and an individual cell in the spreadsheet can be located according to its row and column address. An array behaves the same way. An array has cells, which are called elements, and each element contains data. An individual array element is accessed using an address called an index or subscript.</p><p>数组是一次能存放多个数据的变量。数组的组织结构就像一张表。我们拿电子表格举例。一张电子表格就像是一个 二维数组。它既有行也有列，并且电子表格中的一个单元格，可以通过单元格所在的行和列的地址定位它的位置。 数组行为也是如此。数组有单元格，被称为元素，而且每个元素会包含数据。 使用一个称为索引或下标的地址可以访问一个单独的数组元素。</p><p>Most programming languages support multidimensional arrays. A spreadsheet is an example of a multidimensional array with two dimensions, width and height. Many languages support arrays with an arbitrary number of dimensions, though two- and three-dimensional arrays are probably the most commonly used.</p><p>大多数编程语言支持多维数组。一个电子表格就是一个多维数组的例子，它有两个维度，宽度和高度。 许多语言支持任意维度的数组，虽然二维和三维数组可能是最常用的。</p><p>Arrays in bash are limited to a single dimension. We can think of them as a spreadsheet with a single column. Even with this limitation, there are many applications for them. Array support first appeared in bash version 2. The original Unix shell program, sh, did not support arrays at all.</p><p>Bash 中的数组仅限制为单一维度。我们可以把它们看作是只有一列的电子表格。尽管有这种局限，但是有许多应用使用它们。 对数组的支持第一次出现在 bash 版本2中。原来的 Unix shell 程序，sh，根本就不支持数组。</p><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p>Array variables are named just like other bash variables, and are created automatically when they are accessed. Here is an example:</p><p>数组变量就像其它 bash 变量一样命名，当被访问的时候，它们会被自动地创建。这里是一个例子：</p><pre><code>[me@linuxbox ~]$ a[1]=foo[me@linuxbox ~]$ echo ${a[1]}foo</code></pre><p>Here we see an example of both the assignment and access of an array element. With the first command, element 1 of array a is assigned the value “foo”. The second command displays the stored value of element 1. The use of braces in the second command is re- quired to prevent the shell from attempting pathname expansion on the name of the array element.</p><p>这里我们看到一个赋值并访问数组元素的例子。通过第一个命令，把数组 a 的元素1赋值为 “foo”。 第二个命令显示存储在元素1中的值。在第二个命令中使用花括号是必需的， 以便防止 shell 试图对数组元素名执行路径名展开操作。</p><p>An array can also be created with the declare command:</p><p>也可以用 declare 命令创建一个数组：</p><pre><code>[me@linuxbox ~]$ declare -a a</code></pre><p>Using the -a option, this example of declare creates the array a.</p><p>使用 -a 选项，declare 命令的这个例子创建了数组 a。</p><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><p>Values may be assigned in one of two ways. Single values may be assigned using the fol- lowing syntax:</p><p>有两种方式可以给数组赋值。单个值赋值使用以下语法：</p><pre><code>name[subscript]=value</code></pre><p>where name is the name of the array and subscript is an integer (or arithmetic expression) greater than or equal to zero. Note that the first element of an array is subscript zero, not one. value is a string or integer assigned to the array element.</p><p>这里的 name 是数组的名字，subscript 是一个大于或等于零的整数（或算术表达式）。注意数组第一个元素的下标是0， 而不是1。数组元素的值可以是一个字符串或整数。</p><p>Multiple values may be assigned using the following syntax:</p><p>多个值赋值使用下面的语法：</p><pre><code>name=(value1 value2 ...)</code></pre><p>where name is the name of the array and value… are values assigned sequentially to elements of the array, starting with element zero. For example, if we wanted to assign abbreviated days of the week to the array days, we could do this:</p><p>这里的 name 是数组的名字，value… 是要按照顺序赋给数组的值，从元素0开始。例如，如果我们希望 把星期几的英文简写赋值给数组 days，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)</code></pre><p>It is also possible to assign values to a specific element by specifying a subscript for each value:</p><p>还可以通过指定下标，把值赋给数组中的特定元素：</p><pre><code>[me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)</code></pre><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>So what are arrays good for? Just as many data-management tasks can be performed with a spreadsheet program, many programming tasks can be performed with arrays.</p><p>那么数组对什么有好处呢？ 就像许多数据管理任务一样，可以用电子表格程序来完成，许多编程任务则可以用数组完成。</p><p>Let’s consider a simple data-gathering and presentation example. We will construct a script that examines the modification times of the files in a specified directory. From this data, our script will output a table showing at what hour of the day the files were last modified. Such a script could be used to determine when a system is most active. This script, called hours, produces this result:</p><p>让我们考虑一个简单的数据收集和展示的例子。我们将构建一个脚本，用来检查一个特定目录中文件的修改次数。 从这些数据中，我们的脚本将输出一张表，显示这些文件最后是在一天中的哪个小时被修改的。这样一个脚本 可以被用来确定什么时段一个系统最活跃。这个脚本，称为 hours，输出这样的结果：</p><pre><code>[me@linuxbox ~]$ hours .Hour Files Hour Files---- ----- ---- ----00   0     12   1101   1     13   702   0     14   103   0     15   704   1     16   604   1     17   506   6     18   407   3     19   408   1     20   109   14    21   010   2     22   011   5     23   0Total files = 80</code></pre><p>We execute the hours program, specifying the current directory as the target. It produces a table showing, for each hour of the day (0-23), how many files were last modified. The code to produce this is as follows:</p><p>当执行该 hours 程序时，指定当前目录作为目标目录。它打印出一张表显示一天（0-23小时）每小时内， 有多少文件做了最后修改。程序代码如下所示：</p><pre><code>#!/bin/bash# hours : script to count files by modification timeusage () {    echo &quot;usage: $(basename $0) directory&quot; &gt;&amp;2}# Check that argument is a directoryif [[ ! -d $1 ]]; then    usage    exit 1fi# Initialize arrayfor i in {0..23}; do hours[i]=0; done# Collect datafor i in $(stat -c %y &quot;$1&quot;/* | cut -c 12-13); do    j=${i/#0}    ((++hours[j]))    ((++count))done# Display dataecho -e &quot;Hour\tFiles\tHour\tFiles&quot;echo -e &quot;----\t-----\t----\t-----&quot;for i in {0..11}; do    j=$((i + 12))    printf &quot;%02d\t%d\t%02d\t%d\n&quot; $i ${hours[i]} $j ${hours[j]}doneprintf &quot;\nTotal files = %d\n&quot; $count</code></pre><p>The script consists of one function (usage) and a main body with four sections. In the first section, we check that there is a command line argument and that it is a directory. If it is not, we display the usage message and exit.</p><p>这个脚本由一个函数（名为 usage），和一个分为四个区块的主体组成。在第一部分，我们检查是否有一个命令行参数， 且该参数为目录。如果不是目录，会显示脚本使用信息并退出。</p><p>The second section initializes the array hours. It does this by assigning each element a value of zero. There is no special requirement to prepare arrays prior to use, but our script needs to ensure that no element is empty. Note the interesting way the loop is constructed. By employing brace expansion ({0..23}), we are able to easily generate a sequence of words for the for command.</p><p>第二部分初始化一个名为 hours 的数组。给每一个数组元素赋值一个0。虽然没有特殊需要在使用之前准备数组，但是 我们的脚本需要确保没有元素是空值。注意这个循环构建方式很有趣。通过使用花括号展开（{0..23}），我们能 很容易为 for 命令产生一系列的数据（words）。</p><p>The next section gathers the data by running the stat program on each file in the directory. We use cut to extract the two-digit hour from the result. Inside the loop, we need to remove leading zeros from the hour field, since the shell will try (and ultimately fail) to interpret values “00” through “09” as octal numbers (see Table 35-1). Next, we increment the value of the array element corresponding with the hour of the day. Finally, we increment a counter (count) to track the total number of files in the directory.</p><p>接下来的一部分收集数据，对目录中的每一个文件运行 stat 程序。我们使用 cut 命令从结果中抽取两位数字的小时字段。 在循环里面，我们需要把小时字段开头的零清除掉，因为 shell 将试图（最终会失败）把从 “00” 到 “09” 的数值解释为八进制（见表35-1）。 下一步，我们以小时为数组索引，来增加其对应的数组元素的值。最后，我们增加一个计数器的值（count），记录目录中总共的文件数目。</p><p>The last section of the script displays the contents of the array. We first output a couple of header lines and then enter a loop that produces two columns of output. Lastly, we output the final tally of files.</p><p>脚本的最后一部分显示数组中的内容。我们首先输出两行标题，然后进入一个循环产生两栏输出。最后，输出总共的文件数目。</p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>There are many common array operations. Such things as deleting arrays, determining their size, sorting, etc. have many applications in scripting.</p><p>有许多常见的数组操作。比方说删除数组，确定数组大小，排序，等等。有许多脚本应用程序。</p><h4 id="输出整个数组的内容"><a href="#输出整个数组的内容" class="headerlink" title="输出整个数组的内容"></a>输出整个数组的内容</h4><p>The subscripts * and @ can be used to access every element in an array. As with positional parameters, the @ notation is the more useful of the two. Here is a demonstration:</p><p>下标 * 和 @ 可以被用来访问数组中的每一个元素。与位置参数一样，@ 表示法在两者之中更有用处。 这里是一个演示：</p><pre><code>[me@linuxbox ~]$ animals=(&quot;a dog&quot; &quot;a cat&quot; &quot;a fish&quot;)[me@linuxbox ~]$ for i in ${animals[*]}; do echo $i; doneadogacatafish[me@linuxbox ~]$ for i in ${animals[@]}; do echo $i; doneadogacatafish[me@linuxbox ~]$ for i in &quot;${animals[*]}&quot;; do echo $i; donea dog a cat a fish[me@linuxbox ~]$ for i in &quot;${animals[@]}&quot;; do echo $i; donea doga cata fish</code></pre><p>We create the array animals and assign it three two-word strings. We then execute four loops to see the affect of word-splitting on the array contents. The behavior of notations $ {animals[*]} and ${animals[@]} is identical until they are quoted. The * notation results in a single word containing the array’s contents, while the @ notation results in three words, which matches the arrays “real” contents.</p><p>我们创建了数组 animals，并把三个含有两个字的字符串赋值给数组。然后我们执行四个循环看一下对数组内容进行分词的效果。 表示法 ${animals[*]} 和 ${animals[@]}的行为是一致的直到它们被用引号引起来。</p><h4 id="确定数组元素个数"><a href="#确定数组元素个数" class="headerlink" title="确定数组元素个数"></a>确定数组元素个数</h4><p>Using parameter expansion, we can determine the number of elements in an array in much the same way as finding the length of a string. Here is an example:</p><p>使用参数展开，我们能够确定数组元素的个数，与计算字符串长度的方式几乎相同。这里是一个例子:</p><pre><code>[me@linuxbox ~]$ a[100]=foo[me@linuxbox ~]$ echo ${#a[@]} # number of array elements1[me@linuxbox ~]$ echo ${#a[100]} # length of element 1003</code></pre><p>We create array a and assign the string “foo” to element 100. Next, we use parameter ex- pansion to examine the length of the array, using the @ notation. Finally, we look at the length of element 100 which contains the string “foo”. It is interesting to note that while we assigned our string to element 100, bash only reports one element in the array. This differs from the behavior of some other languages in which the unused elements of the array (elements 0-99) would be initialized with empty values and counted.</p><p>我们创建了数组 a，并把字符串 “foo” 赋值给数组元素100。下一步，我们使用参数展开来检查数组的长度，使用 @ 表示法。 最后，我们查看了包含字符串 “foo” 的数组元素 100 的长度。有趣的是，尽管我们把字符串赋值给数组元素100， bash 仅仅报告数组中有一个元素。这不同于一些其它语言的行为，这种行为是数组中未使用的元素（元素0-99）会初始化为空值， 并把它们计入数组长度。</p><h4 id="找到数组使用的下标"><a href="#找到数组使用的下标" class="headerlink" title="找到数组使用的下标"></a>找到数组使用的下标</h4><p>As bash allows arrays to contain “gaps” in the assignment of subscripts, it is sometimes useful to determine which elements actually exist. This can be done with a parameter ex- pansion using the following forms:</p><p>因为 bash 允许赋值的数组下标包含 “间隔”，有时候确定哪个元素真正存在是很有用的。为做到这一点， 可以使用以下形式的参数展开：</p><p><em>${!array[*]}</em></p><p><em>${!array[@]}</em></p><p>where array is the name of an array variable. Like the other expansions that use * and @, the @ form enclosed in quotes is the most useful, as it expands into separate words:</p><p>这里的 array 是一个数组变量的名字。和其它使用符号 * 和 @ 的展开一样，用引号引起来的 @ 格式是最有用的， 因为它能展开成分离的词。</p><pre><code>[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)[me@linuxbox ~]$ for i in &quot;${foo[@]}&quot;; do echo $i; doneabc[me@linuxbox ~]$ for i in &quot;${!foo[@]}&quot;; do echo $i; done246</code></pre><h4 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h4><p>Knowing the number of elements in an array is no help if we need to append values to the end of an array, since the values returned by the * and @ notations do not tell us the maxi- mum array index in use. Fortunately, the shell provides us with a solution. By using the += assignment operator, we can automatically append values to the end of an array. Here, we assign three values to the array foo, and then append three more.</p><p>如果我们需要在数组末尾附加数据，那么知道数组中元素的个数是没用的，因为通过 * 和 @ 表示法返回的数值不能 告诉我们使用的最大数组索引。幸运地是，shell 为我们提供了一种解决方案。通过使用 += 赋值运算符， 我们能够自动地把值附加到数组末尾。这里，我们把三个值赋给数组 foo，然后附加另外三个。</p><pre><code>[me@linuxbox~]$ foo=(a b c)[me@linuxbox~]$ echo ${foo[@]}a b c[me@linuxbox~]$ foo+=(d e f)[me@linuxbox~]$ echo ${foo[@]}a b c d e f</code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>Just as with spreadsheets, it is often necessary to sort the values in a column of data. The shell has no direct way of doing this, but it’s not hard to do with a little coding:</p><p>就像电子表格，经常有必要对一列数据进行排序。Shell 没有这样做的直接方法，但是通过一点儿代码，并不难实现。</p><pre><code>#!/bin/bash# array-sort : Sort an arraya=(f e d c b a)echo &quot;Original array: ${a[@]}&quot;a_sorted=($(for i in &quot;${a[@]}&quot;; do echo $i; done | sort))echo &quot;Sorted array: ${a_sorted[@]}&quot;</code></pre><p>When executed, the script produces this:</p><p>当执行之后，脚本产生这样的结果：</p><pre><code>[me@linuxbox ~]$ array-sortOriginal array: f e d c b aSorted array:a b c d e f</code></pre><p>The script operates by copying the contents of the original array (a) into a second array (a_sorted) with a tricky piece of command substitution. This basic technique can be used to perform many kinds of operations on the array by changing the design of the pipeline.</p><p>脚本运行成功，通过使用一个复杂的命令替换把原来的数组（a）中的内容复制到第二个数组（a_sorted）中。 通过修改管道线的设计，这个基本技巧可以用来对数组执行各种各样的操作。</p><h4 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h4><p>To delete an array, use the unset command:</p><p>删除一个数组，使用 unset 命令：</p><pre><code>[me@linuxbox ~]$ foo=(a b c d e f)[me@linuxbox ~]$ echo ${foo[@]}a b c d e f[me@linuxbox ~]$ unset foo[me@linuxbox ~]$ echo ${foo[@]}[me@linuxbox ~]$</code></pre><p>unset may also be used to delete single array elements:</p><p>也可以使用 unset 命令删除单个的数组元素：</p><pre><code>[me@linuxbox~]$ foo=(a b c d e f)[me@linuxbox~]$ echo ${foo[@]}a b c d e f[me@linuxbox~]$ unset &#39;foo[2]&#39;[me@linuxbox~]$ echo ${foo[@]}a b d e f</code></pre><p>In this example, we delete the third element of the array, subscript 2. Remember, arrays start with subscript zero, not one! Notice also that the array element must be quoted to prevent the shell from performing pathname expansion.</p><p>在这个例子中，我们删除了数组中的第三个元素，下标为2。记住，数组下标开始于0，而不是1！也要注意数组元素必须 用引号引起来为的是防止 shell 执行路径名展开操作。</p><p>Interestingly, the assignment of an empty value to an array does not empty its contents:</p><p>有趣地是，给一个数组赋空值不会清空数组内容：</p><pre><code>[me@linuxbox ~]$ foo=(a b c d e f)[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo ${foo[@]}b c d e f</code></pre><p>Any reference to an array variable without a subscript refers to element zero of the array:</p><p>任何没有下标的对数组变量的引用都指向数组元素0：</p><pre><code>[me@linuxbox~]$ foo=(a b c d e f)[me@linuxbox~]$ echo ${foo[@]}a b c d e f[me@linuxbox~]$ foo=A[me@linuxbox~]$ echo ${foo[@]}A b c d e f</code></pre><h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p>Recent versions of bash now support associative arrays. Associative arrays use strings rather than integers as array indexes. This capability allow interesting new approaches to managing data. For example, we can create an array called “colors” and use color names as indexes:</p><p>现在最新的 bash 版本支持关联数组了。关联数组使用字符串而不是整数作为数组索引。 这种功能给出了一种有趣的新方法来管理数据。例如，我们可以创建一个叫做 “colors” 的数组，并用颜色名字作为索引。</p><pre><code>declare -A colorscolors[&quot;red&quot;]=&quot;#ff0000&quot;colors[&quot;green&quot;]=&quot;#00ff00&quot;colors[&quot;blue&quot;]=&quot;#0000ff&quot;</code></pre><p>Unlike integer indexed arrays, which are created by merely referencing them, associative arrays must be created with the declare command using the new -A option.</p><p>不同于整数索引的数组，仅仅引用它们就能创建数组，关联数组必须用带有 -A 选项的 declare 命令创建。</p><p>Associative array elements are accessed in much the same way as integer indexed arrays:</p><p>访问关联数组元素的方式几乎与整数索引数组相同：</p><pre><code>echo ${colors[&quot;blue&quot;]}</code></pre><p>In the next chapter, we will look at a script that makes good use of associative arrays to produce an interesting report.</p><p>在下一章中，我们将看一个脚本，很好地利用关联数组，生产出了一个有意思的报告。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>If we search the bash man page for the word “array,” we find many instances of where bash makes use of array variables. Most of these are rather obscure, but they may provide occasional utility in some special circumstances.In fact, the entire topic of arrays is rather under-utilized in shell programming owing largely to the fact that the traditional Unix shell programs (such as sh) lacked any support for arrays. This lack of popularity is unfortunate because arrays are widely used in other programming languages and provide a powerful tool for solving many kinds of programming problems.</p><p>如果我们在 bash 手册页中搜索单词 “array”的话，我们能找到许多 bash 在哪里会使用数组变量的实例。其中大部分相当晦涩难懂， 但是它们可能在一些特殊场合提供临时的工具。事实上，在 shell 编程中，整套数组规则利用率相当低，很大程度上归咎于 传统 Unix shell 程序（比如说 sh）缺乏对数组的支持。这样缺乏人气是不幸的，因为数组广泛应用于其它编程语言， 并为解决各种各样的编程问题，提供了一个强大的工具。</p><p>Arrays and loops have a natural affinity and are often used together. The</p><p>数组和循环有一种天然的姻亲关系，它们经常被一起使用。该</p><pre><code>for ((expr; expr; expr))</code></pre><p>form of loop is particularly well-suited to calculating array subscripts.</p><p>形式的循环尤其适合计算数组下标。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>A couple of Wikipedia articles about the data structures found in this chapter:</p></li><li><p>Wikipedia 上面有两篇关于在本章提到的数据结构的文章：</p><p><a href="http://en.wikipedia.org/wiki/Scalar_(computing)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Scalar_(computing)</a></p><p><a href="http://en.wikipedia.org/wiki/Associative_array" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Associative_array</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十五章 字符串和数字</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>Computer programs are all about working with data. In past chapters, we have focused on processing data at the file level. However, many programming problems need to be solved using smaller units of data such as strings and numbers.</p><p>所有的计算机程序都是用来和数据打交道的。在过去的章节中，我们专注于处理文件级别的数据。 然而，许多编程问题需要使用更小的数据单位来解决，比方说字符串和数字。</p><p>In this chapter, we will look at several shell features that are used to manipulate strings and numbers. The shell provides a variety of parameter expansions that perform string operations. In addition to arithmetic expansion (which we touched upon in Chapter 7), there is a common command line program called bc, which performs higher level math.</p><p>在这一章中，我们将查看几个用来操作字符串和数字的 shell 功能。shell 提供了各种执行字符串操作的参数展开功能。 除了算术展开（在第七章中接触过），还有一个常见的命令行程序叫做 bc，能执行更高级别的数学运算。</p><h3 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h3><p>Though parameter expansion came up in Chapter 7, we did not cover it in detail because most parameter expansions are used in scripts rather than on the command line. We have already worked with some forms of parameter expansion; for example, shell variables. The shell provides many more.</p><p>尽管参数展开在第七章中出现过，但我们并没有详尽地介绍它，因为大多数的参数展开会用在脚本中，而不是命令行中。 我们已经使用了一些形式的参数展开；例如，shell 变量。shell 提供了更多方式。</p><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>The simplest form of parameter expansion is reflected in the ordinary use of variables.</p><p>最简单的参数展开形式反映在平常使用的变量上。</p><p>For example:</p><p>例如：</p><p><em>$a</em></p><p>when expanded, becomes whatever the variable a contains. Simple parameters may also be surrounded by braces:</p><p>当 $a 展开后，会变成变量 a 所包含的值。简单参数也可能用花括号引起来：</p><p><em>$&#123;a&#125;</em></p><p>This has no effect on the expansion, but is required if the variable is adjacent to other text, which may confuse the shell. In this example, we attempt to create a filename by ap- pending the string “_file” to the contents of the variable a.</p><p>虽然这对展开没有影响，但若该变量 a 与其它的文本相邻，可能会把 shell 搞糊涂了。在这个例子中，我们试图 创建一个文件名，通过把字符串 “_file” 附加到变量 a 的值的后面。</p><pre><code>[me@linuxbox ~]$ a=&quot;foo&quot;[me@linuxbox ~]$ echo &quot;$a_file&quot;</code></pre><p>If we perform this sequence, the result will be nothing, because the shell will try to ex- pand a variable named a_file rather than a. This problem can be solved by adding braces:</p><p>如果我们执行这个序列，没有任何输出结果，因为 shell 会试着展开一个称为 a_file 的变量，而不是 a。通过 添加花括号可以解决这个问题：</p><pre><code>[me@linuxbox ~]$ echo &quot;${a}_file&quot;foo_file</code></pre><p>We have also seen that positional parameters greater than 9 can be accessed by surround- ing the number in braces. For example, to access the eleventh positional parameter, we can do this:</p><p>我们已经知道通过把数字包裹在花括号中，可以访问大于9的位置参数。例如，访问第十一个位置参数，我们可以这样做：</p><p><em>$&#123;11&#125;</em></p><h4 id="管理空变量的展开"><a href="#管理空变量的展开" class="headerlink" title="管理空变量的展开"></a>管理空变量的展开</h4><p>Several parameter expansions deal with nonexistent and empty variables. These expan- sions are handy for handling missing positional parameters and assigning default values to parameters.</p><p>几种用来处理不存在和空变量的参数展开形式。这些展开形式对于解决丢失的位置参数和给参数指定默认值的情况很方便。</p><p><em>$&#123;parameter:-word&#125;</em></p><p>If parameter is unset (i.e., does not exist) or is empty, this expansion results in the value of word. If parameter is not empty, the expansion results in the value of parameter.</p><p>若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter 不为空，则展开结果是 parameter 的值。</p><pre><code>[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo ${foo:-&quot;substitute value if unset&quot;&amp;}if unsetsubstitute value[me@linuxbox ~]$ echo $foo[me@linuxbox ~]$ foo=bar[me@linuxbox ~]$ echo ${foo:-&quot;substitute value if unset&quot;}bar[me@linuxbox ~]$ echo $foobar</code></pre><p><em>$&#123;parameter:=word&#125;</em></p><p>If parameter is unset or empty, this expansion results in the value of word. In addition, the value of word is assigned to parameter. If parameter is not empty, the expansion re- sults in the value of parameter.</p><p>若 parameter 没有设置或为空，展开结果是 word 的值。另外，word 的值会赋值给 parameter。 若 parameter 不为空，展开结果是 parameter 的值。</p><pre><code>[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo ${foo:=&quot;default value if unset&quot;}default value if unset[me@linuxbox ~]$ echo $foodefault value if unset[me@linuxbox ~]$ foo=bar[me@linuxbox ~]$ echo ${foo:=&quot;default value if unset&quot;}bar[me@linuxbox ~]$ echo $foobar</code></pre><hr><p>Note: Positional and other special parameters cannot be assigned this way.</p><p>注意： 位置参数或其它的特殊参数不能以这种方式赋值。</p><hr><p><em>$&#123;parameter:?word&#125;</em></p><p>If parameter is unset or empty, this expansion causes the script to exit with an error, and the contents of word are sent to standard error. If parameter is not empty, the expansion results in the value of parameter.</p><p>若 parameter 没有设置或为空，这种展开导致脚本带有错误退出，并且 word 的内容会发送到标准错误。若 parameter 不为空， 展开结果是 parameter 的值。</p><pre><code>[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo ${foo:?&quot;parameter is empty&quot;}bash: foo: parameter is empty[me@linuxbox ~]$ echo $?1[me@linuxbox ~]$ foo=bar[me@linuxbox ~]$ echo ${foo:?&quot;parameter is empty&quot;}bar[me@linuxbox ~]$ echo $?0</code></pre><p><em>$&#123;parameter:+word&#125;</em></p><p>If parameter is unset or empty, the expansion results in nothing. If parameter is not empty, the value of word is substituted for parameter; however, the value of parameter is not changed.</p><p>若 parameter 没有设置或为空，展开结果为空。若 parameter 不为空， 展开结果是 word 的值会替换掉 parameter 的值；然而，parameter 的值不会改变。</p><pre><code>[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo ${foo:+&quot;substitute value if set&quot;}[me@linuxbox ~]$ foo=bar[me@linuxbox ~]$ echo ${foo:+&quot;substitute value if set&quot;}substitute value if set</code></pre><h3 id="返回变量名的参数展开"><a href="#返回变量名的参数展开" class="headerlink" title="返回变量名的参数展开"></a>返回变量名的参数展开</h3><p>The shell has the ability to return the names of variables. This is used in some rather exotic situations.</p><p>shell 具有返回变量名的能力。这会用在一些相当独特的情况下。</p><p><em>$&#123;!prefix\</em>&#125;*</p><p><em>$&#123;!prefix@&#125;</em></p><p>This expansion returns the names of existing variables with names beginning with prefix. According to the bash documentation, both forms of the expansion perform identically. Here, we list all the variables in the environment with names that begin with BASH:</p><p>这种展开会返回以 prefix 开头的已有变量名。根据 bash 文档，这两种展开形式的执行结果相同。 这里，我们列出了所有以 BASH 开头的环境变量名：</p><pre><code>[me@linuxbox ~]$ echo ${!BASH*}BASH BASH_ARGC BASH_ARGV BASH_COMMAND BASH_COMPLETIONBASH_COMPLETION_DIR BASH_LINENO BASH_SOURCE BASH_SUBSHELLBASH_VERSINFO BASH_VERSION</code></pre><h4 id="字符串展开"><a href="#字符串展开" class="headerlink" title="字符串展开"></a>字符串展开</h4><p>There is a large set of expansions that can be used to operate on strings. Many of these expansions are particularly well suited for operations on pathnames.</p><p>有大量的展开形式可用于操作字符串。其中许多展开形式尤其适用于路径名的展开。</p><p><em>$&#123;#parameter&#125;</em></p><p>expands into the length of the string contained by parameter. Normally, parameter is a string; however, if parameter is either @ or *, then the expansion results in the number of positional parameters.</p><p>展开成由 parameter 所包含的字符串的长度。通常，parameter 是一个字符串；然而，如果 parameter 是 @ 或者是 * 的话， 则展开结果是位置参数的个数。</p><pre><code>[me@linuxbox ~]$ foo=&quot;This string is long.&quot;[me@linuxbox ~]$ echo &quot;&#39;$foo&#39; is ${#foo} characters long.&quot;&#39;This string is long.&#39; is 20 characters long.</code></pre><p><em>$&#123;parameter:offset&#125;</em></p><p><em>$&#123;parameter:offset:length&#125;</em></p><p>These expansions are used to extract a portion of the string contained in parameter. The extraction begins at offset characters from the beginning of the string and continues until the end of the string, unless the length is specified.</p><p>这些展开用来从 parameter 所包含的字符串中提取一部分字符。提取的字符始于 第 offset 个字符（从字符串开头算起）直到字符串的末尾，除非指定提取的长度。</p><pre><code>[me@linuxbox ~]$ foo=&quot;This string is long.&quot;[me@linuxbox ~]$ echo ${foo:5}string is long.[me@linuxbox ~]$ echo ${foo:5:6}string</code></pre><p>If the value of offset is negative, it is taken to mean it starts from the end of the string rather than the beginning. Note that negative values must be preceded by a space to pre- vent confusion with the $&#123;parameter:-word&#125; expansion. length, if present, must not be less than zero.</p><p>若 offset 的值为负数，则认为 offset 值是从字符串的末尾开始算起，而不是从开头。注意负数前面必须有一个空格， 为防止与 $&#123;parameter:-word&#125; 展开形式混淆。length，若出现，则必须不能小于零。</p><p>If parameter is @, the result of the expansion is length positional parameters, starting at offset.</p><p>如果 parameter 是 @，展开结果是 length 个位置参数，从第 offset 个位置参数开始。</p><pre><code>[me@linuxbox ~]$ foo=&quot;This string is long.&quot;[me@linuxbox ~]$ echo ${foo: -5}long.[me@linuxbox ~]$ echo ${foo: -5:2}lo</code></pre><p><em>$&#123;parameter#pattern&#125;</em></p><p><em>$&#123;parameter##pattern&#125;</em></p><p>These expansions remove a leading portion of the string contained in parameter defined by pattern. pattern is a wildcard pattern like those used in pathname expansion. The dif- ference in the two forms is that the # form removes the shortest match, while the ## form removes the longest match.</p><p>这些展开会从 paramter 所包含的字符串中清除开头一部分文本，这些字符要匹配定义的 pattern。pattern 是 通配符模式，就如那些用在路径名展开中的模式。这两种形式的差异之处是该 # 形式清除最短的匹配结果， 而该 ## 模式清除最长的匹配结果。</p><pre><code>[me@linuxbox ~]$ foo=file.txt.zip[me@linuxbox ~]$ echo ${foo#*.}txt.zip[me@linuxbox ~]$ echo ${foo##*.&amp;}zip</code></pre><p><em>$&#123;parameter%pattern&#125;</em></p><p><em>$&#123;parameter%%pattern&#125;</em></p><p>These expansions are the same as the # and ## expansions above, except they remove text from the end of the string contained in parameter rather than from the beginning.</p><p>这些展开和上面的 # 和 ## 展开一样，除了它们清除的文本从 parameter 所包含字符串的末尾开始，而不是开头。</p><pre><code>[me@linuxbox ~]$ foo=file.txt.zip[me@linuxbox ~]$ echo ${foo%.*}file.txt[me@linuxbox ~]$ echo ${foo%%.*}file</code></pre><p><em>$&#123;parameter/pattern/string&#125;</em></p><p><em>$&#123;parameter//pattern/string&#125;</em></p><p><em>$&#123;parameter/#pattern/string&#125;</em></p><p><em>$&#123;parameter/%pattern/string&#125;</em></p><p>This expansion performs a search-and-replace upon the contents of parameter. If text is found matching wildcard pattern, it is replaced with the contents of string. In the normal form, only the first occurrence of pattern is replaced. In the // form, all occurrences are replaced. The /# form requires that the match occur at the beginning of the string, and the /% form requires the match to occur at the end of the string. /string may be omitted, which causes the text matched by pattern to be deleted.</p><p>这种形式的展开对 parameter 的内容执行查找和替换操作。如果找到了匹配通配符 pattern 的文本， 则用 string 的内容替换它。在正常形式下，只有第一个匹配项会被替换掉。在该 // 形式下，所有的匹配项都会被替换掉。 该 /# 要求匹配项出现在字符串的开头，而 /% 要求匹配项出现在字符串的末尾。/string 可能会省略掉，这样会 导致删除匹配的文本。</p><pre><code>[me@linuxbox~]$ foo=JPG.JPG[me@linuxbox ~]$ echo ${foo/JPG/jpg}jpg.JPG[me@linuxbox~]$ echo ${foo//JPG/jpg}jpg.jpg[me@linuxbox~]$ echo ${foo/#JPG/jpg}jpg.JPG[me@linuxbox~]$ echo ${foo/%JPG/jpg}JPG.jpg</code></pre><p>Parameter expansion is a good thing to know. The string manipulation expansions can be used as substitutes for other common commands such as sed and cut. Expansions improve the efficiency of scripts by eliminating the use of external programs. As an example, we will modify the longest-word program discussed in the previous chapter to use the parameter expansion $&#123;#j&#125; in place of the command substitution <em>$(echo $j | wc -c)</em> and its resulting subshell, like so:</p><p>知道参数展开是件很好的事情。字符串操作展开可以用来替换其它常见命令比方说 sed 和 cut。 通过减少使用外部程序，展开提高了脚本的效率。举例说明，我们将修改在之前章节中讨论的 longest-word 程序， 用参数展开 $&#123;#j&#125; 取代命令 $(echo $j | wc -c) 及其 subshell ，像这样：</p><pre><code>#!/bin/bash# longest-word3 : find longest string in a filefor i; do    if [[ -r $i ]]; then        max_word=        max_len=        for j in $(strings $i); do            len=${#j}            if (( len &gt; max_len )); then                max_len=$len                max_word=$j            fi        done        echo &quot;$i: &#39;$max_word&#39; ($max_len characters)&quot;    fi    shiftdone</code></pre><p>Next, we will compare the efficiency of the two versions by using the time command:</p><p>下一步，我们将使用 time 命令来比较这两个脚本版本的效率：</p><pre><code>[me@linuxbox ~]$ time longest-word2 dirlist-usr-bin.txtdirlist-usr-bin.txt: &#39;scrollkeeper-get-extended-content-list&#39; (38characters)real 0m3.618suser 0m1.544ssys 0m1.768s[me@linuxbox ~]$ time longest-word3 dirlist-usr-bin.txtdirlist-usr-bin.txt: &#39;scrollkeeper-get-extended-content-list&#39; (38characters)real 0m0.060suser 0m0.056ssys 0m0.008s</code></pre><p>The original version of the script takes 3.618 seconds to scan the text file, while the new version, using parameter expansion, takes only 0.06 seconds — a very significant improvement.</p><p>原来的脚本扫描整个文本文件需耗时3.168秒，而该新版本，使用参数展开，仅仅花费了0.06秒 —— 一个非常巨大的提高。</p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>Recent versions of bash have support for upper/lowercase conversion of strings. bash has four parameter expansions and two options to the declare command to support it.</p><p>最新的 bash 版本已经支持字符串的大小写转换了。bash 有四个参数展开和 declare 命令的两个选项来支持大小写转换。</p><p>So what is case conversion good for? Aside from the obvious aesthetic value, it has an important role in programming. Let’s consider the case of a database look-up. Imagine that a user has entered a string into a data input field that we want to look up in a database. It’s possible the user will enter the value in all uppercase letters or lowercase letters or a combination of both. We certainly don’t want to populate our database with every possible permutation of upper and lower case spellings. What to do?</p><p>那么大小写转换对什么有好处呢？ 除了明显的审美价值，它在编程领域还有一个重要的角色。 让我们考虑一个数据库查询的案例。假设一个用户已经敲写了一个字符串到数据输入框中， 而我们想要在一个数据库中查找这个字符串。该用户输入的字符串有可能全是大写字母或全是小写或是两者的结合。 我们当然不希望把每个可能的大小写拼写排列填充到我们的数据库中。那怎么办？</p><p>A common approach to this problem is to normalize the user’s input. That is, convert it into a standardized form before we attempt the database look-up. We can do this by converting all of the characters in the user’s input to either lower or uppercase and ensure that the database entries are normalized the same way.</p><p>解决这个问题的常见方法是规范化用户输入。也就是，在我们试图查询数据库之前，把用户的输入转换成标准化。 我们能做到这一点，通过把用户输入的字符全部转换成小写字母或大写字母，并且确保数据库中的条目 按同样的方式规范化。</p><p>The declare command can be used to normalize strings to either upper or lowercase. Using declare, we can force a variable to always contain the desired format no matter what is assigned to it:</p><p>这个 declare 命令可以用来把字符串规范成大写或小写字符。使用 declare 命令，我们能强制一个 变量总是包含所需的格式，无论如何赋值给它。</p><pre><code>#!/bin/bash# ul-declare: demonstrate case conversion via declaredeclare -u upperdeclare -l lowerif [[ $1 ]]; then    upper=&quot;$1&quot;    lower=&quot;$1&quot;    echo $upper    echo $lowerfi</code></pre><p>In the above script, we use declare to create two variables, upper and lower. We assign the value of the first command line argument (positional parameter 1) to each of the variables and then display them on the screen:</p><p>在上面的脚本中，我们使用 declare 命令来创建两个变量，upper 和 lower。我们把第一个命令行参数的值（位置参数1）赋给 每一个变量，然后把变量值在屏幕上显示出来：</p><pre><code>[me@linuxbox ~]$ ul-declare aBcABCabc</code></pre><p>As we can see, the command line argument (“aBc”) has been normalized.</p><p>正如我们所看到的，命令行参数（“aBc”）已经规范化了。</p><p>There are four parameter expansions that perform upper/lowercase conversion:</p><p>有四个参数展开，可以执行大小写转换操作：</p><table><thead><tr><th align="left">Format</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">$&#123;parameter,,&#125;</td><td align="left">Expand the value of parameter into all lowercase.</td></tr><tr><td align="left">$&#123;parameter,&#125;</td><td align="left">Expand the value of parameter changing only the first character to lowercase.</td></tr><tr><td align="left">$&#123;parameter^^&#125;</td><td align="left">Expand the value of parameter into all uppercase letters.</td></tr><tr><td align="left">$&#123;parameter^&#125;</td><td align="left">Expand the value of parameter changing only the first character to uppercase (capitalization).</td></tr></tbody></table><table><thead><tr><th align="left">格式</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">$&#123;parameter,,&#125;</td><td align="left">把 parameter 的值全部展开成小写字母。</td></tr><tr><td align="left">$&#123;parameter,&#125;</td><td align="left">仅仅把 parameter 的第一个字符展开成小写字母。</td></tr><tr><td align="left">$&#123;parameter^^&#125;</td><td align="left">把 parameter 的值全部转换成大写字母。</td></tr><tr><td align="left">$&#123;parameter^&#125;</td><td align="left">仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）。</td></tr></tbody></table><p>Here is a script that demonstrates these expansions:</p><p>这里是一个脚本，演示了这些展开格式：</p><pre><code>#!/bin/bash# ul-param - demonstrate case conversion via parameter expansionif [[ $1 ]]; then    echo ${1,,}    echo ${1,}    echo ${1^^}    echo ${1^}fi</code></pre><p>Here is the script in action:</p><p>这里是脚本运行后的结果：</p><pre><code>[me@linuxbox ~]$ ul-param aBcabcaBcABCABc</code></pre><p>Again, we process the first command line argument and output the four variations supported by the parameter expansions. While this script uses the first positional parameter, parameter my be any string, variable, or string expression.</p><p>再次，我们处理了第一个命令行参数，输出了由参数展开支持的四种变体。尽管这个脚本使用了第一个位置参数， 但参数可以是任意字符串，变量，或字符串表达式。</p><h3 id="算术求值和展开"><a href="#算术求值和展开" class="headerlink" title="算术求值和展开"></a>算术求值和展开</h3><p>We looked at arithmetic expansion in Chapter 7. It is used to perform various arithmetic operations on integers. Its basic form is:</p><p>我们在第七章中已经接触过算术展开了。它被用来对整数执行各种算术运算。它的基本格式是：</p><pre><code>$((expression))</code></pre><p>where expression is a valid arithmetic expression.</p><p>这里的 expression 是一个有效的算术表达式。</p><p>This is related to the compound command (( )) used for arithmetic evaluation (truth tests) we encountered in Chapter 27.</p><p>这个与复合命令 (( )) 有关，此命令用做算术求值（真测试），我们在第27章中遇到过。</p><p>In previous chapters, we saw some of the common types of expressions and operators. Here, we will look at a more complete list.</p><p>在之前的章节中，我们看到过一些类型的表达式和运算符。这里，我们将看到一个更完整的列表。</p><h4 id="数基"><a href="#数基" class="headerlink" title="数基"></a>数基</h4><p>Back in Chapter 9, we got a look at octal (base 8) and hexadecimal (base 16) numbers. In arithmetic expressions, the shell supports integer constants in any base.</p><p>回到第9章，我们看过八进制（以8为底）和十六进制（以16为底）的数字。在算术表达式中，shell 支持任意进制的整型常量。</p><table><thead><tr><th align="left">Notation</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">number</td><td align="left">By default, numbers without any notation are treated as decimal (base 10) integers.</td></tr><tr><td align="left">0number</td><td align="left">In arithmetic expressions, numbers with a leading zero are considered octal.</td></tr><tr><td align="left">0xnumber</td><td align="left">Hexadecimal notation</td></tr><tr><td align="left">base#number</td><td align="left">number is in base</td></tr></tbody></table><table><thead><tr><th align="left">表示法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">number</td><td align="left">默认情况下，没有任何表示法的数字被看做是十进制数（以10为底）。</td></tr><tr><td align="left">0number</td><td align="left">在算术表达式中，以零开头的数字被认为是八进制数。</td></tr><tr><td align="left">0xnumber</td><td align="left">十六进制表示法</td></tr><tr><td align="left">base#number</td><td align="left">number 以 base 为底</td></tr></tbody></table><p>Some examples:</p><p>一些例子：</p><pre><code>[me@linuxbox ~]$ echo $((0xff))255[me@linuxbox ~]$ echo $((2#11111111))255</code></pre><p>In the examples above, we print the value of the hexadecimal number ff (the largest two-digit number) and the largest eight-digit binary (base 2) number.</p><p>在上面的示例中，我们打印出十六进制数 ff（最大的两位数）的值和最大的八位二进制数（以2为底）。</p><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>There are two unary operators, the + and -, which are used to indicate if a number is pos- itive or negative, respectively. For example, -5.</p><p>有两个一元运算符，+ 和 -，它们被分别用来表示一个数字是正数还是负数。例如，-5。</p><h4 id="简单算术"><a href="#简单算术" class="headerlink" title="简单算术"></a>简单算术</h4><p>The ordinary arithmetic operators are listed in the table below:</p><p>下表中列出了普通算术运算符：</p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">Addition</td></tr><tr><td align="left">-</td><td align="left">Subtraction</td></tr><tr><td align="left">*</td><td align="left">Multiplication</td></tr><tr><td align="left">/</td><td align="left">Integer division</td></tr><tr><td align="left">**</td><td align="left">Exponentiation</td></tr><tr><td align="left">%</td><td align="left">Modulo (remainder)</td></tr></tbody></table><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加</td></tr><tr><td align="left">-</td><td align="left">减</td></tr><tr><td align="left">*</td><td align="left">乘</td></tr><tr><td align="left">/</td><td align="left">整除</td></tr><tr><td align="left">**</td><td align="left">乘方</td></tr><tr><td align="left">%</td><td align="left">取模（余数）</td></tr></tbody></table><p>Most of these are self-explanatory, but integer division and modulo require further discussion.</p><p>其中大部分运算符是不言自明的，但是整除和取模运算符需要进一步解释一下。</p><p>Since the shell’s arithmetic only operates on integers, the results of division are always whole numbers:</p><p>因为 shell 算术只操作整型，所以除法运算的结果总是整数：</p><pre><code>[me@linuxbox ~]$ echo $(( 5 / 2 ))2</code></pre><p>This makes the determination of a remainder in a division operation more important:</p><p>这使得确定除法运算的余数更为重要：</p><pre><code>[me@linuxbox ~]$ echo $(( 5 % 2 ))1</code></pre><p>By using the division and modulo operators, we can determine that 5 divided by 2 results in 2, with a remainder of 1.</p><p>通过使用除法和取模运算符，我们能够确定5除以2得数是2，余数是1。</p><p>Calculating the remainder is useful in loops. It allows an operation to be performed at specified intervals during the loop’s execution. In the example below, we display a line of numbers, highlighting each multiple of 5:</p><p>在循环中计算余数是很有用处的。在循环执行期间，它允许某一个操作在指定的间隔内执行。在下面的例子中， 我们显示一行数字，并高亮显示5的倍数：</p><pre><code>#!/bin/bash# modulo : demonstrate the modulo operatorfor ((i = 0; i &lt;= 20; i = i + 1)); do    remainder=$((i % 5))    if (( remainder == 0 )); then        printf &quot;&lt;%d&gt; &quot; $i    else        printf &quot;%d &quot; $i    fidoneprintf &quot;\n&quot;</code></pre><p>When executed, the results look like this:</p><p>当脚本执行后，输出结果看起来像这样：</p><pre><code>[me@linuxbox ~]$ modulo&lt;0&gt; 1 2 3 4 &lt;5&gt; 6 7 8 9 &lt;10&gt; 11 12 13 14 &lt;15&gt; 16 17 18 19 &lt;20&gt;</code></pre><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>Although its uses may not be immediately apparent, arithmetic expressions may perform assignment. We have performed assignment many times, though in a different context. Each time we give a variable a value, we are performing assignment. We can also do it within arithmetic expressions:</p><p>尽管它的使用不是那么明显，算术表达式可能执行赋值运算。虽然在不同的上下文中，我们已经执行了许多次赋值运算。 每次我们给变量一个值，我们就执行了一次赋值运算。我们也能在算术表达式中执行赋值运算：</p><pre><code>[me@linuxbox ~]$ foo=[me@linuxbox ~]$ echo $foo[me@linuxbox ~]$ if (( foo = 5 ));then echo &quot;It is true.&quot;; fiIt is true.[me@linuxbox ~]$ echo $foo5</code></pre><p>In the example above, we first assign an empty value to the variable foo and verify that it is indeed empty. Next, we perform an if with the compound command (( foo = 5 )). This process does two interesting things: 1) it assigns the value of 5 to the variable foo, and 2) it evaluates to true because foo was assigned a nonzero value.</p><p>在上面的例子中，首先我们给变量 foo 赋了一个空值，然后验证 foo 的确为空。下一步，我们执行一个 if 复合命令 (( foo = 5 ))。 这个过程完成两件有意思的事情：1）它把5赋值给变量 foo，2）它计算测试条件为真，因为 foo 的值非零。</p><hr><p>Note: It is important to remember the exact meaning of the = in the expression above. A single = performs assignment. foo = 5 says “make foo equal to 5,” while == evaluates equivalence. foo == 5 says “does foo equal 5?” This can be very confusing because the test command accepts a single = for string equiva- lence. This is yet another reason to use the more modern [[ ]] and (( )) com- pound commands in place of test.</p><p>注意： 记住上面表达式中 = 符号的真正含义非常重要。单个 = 运算符执行赋值运算。foo = 5 是说“使得 foo 等于5”， 而 == 运算符计算等价性。foo == 5 是说“是否 foo 等于5？”。这会让人感到非常迷惑，因为 test 命令接受单个 = 运算符 来测试字符串等价性。这也是使用更现代的 [[ ]] 和 (( )) 复合命令来代替 test 命令的另一个原因。</p><hr><p>In addition to the =, the shell also provides notations that perform some very useful as- signments:</p><p>除了 = 运算符，shell 也提供了其它一些表示法，来执行一些非常有用的赋值运算：</p><table><thead><tr><th align="left">Notation</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">parameter = value</td><td align="left">Simple assignment. Assigns value to parameter.</td></tr><tr><td align="left">parameter += value</td><td align="left">Addition. Equivalent to parameter = parameter + value.</td></tr><tr><td align="left">parameter -= value</td><td align="left">Subtraction. Equivalent to parameter = parameter - value.</td></tr><tr><td align="left">parameter *= value</td><td align="left">Multiplication. Equivalent to parameter = parameter * value.</td></tr><tr><td align="left">parameter /= value</td><td align="left">Integer division. Equivalent to parameter = parameter / value.</td></tr><tr><td align="left">parameter %= value</td><td align="left">Modulo. Equivalent to parameter = parameter % value.</td></tr><tr><td align="left">parameter++</td><td align="left">Variable post-increment. Equivalent to parameter = parameter + 1 (however, see discussion below).</td></tr><tr><td align="left">parameter–</td><td align="left">Variable post-decrement. Equivalent to parameter = parameter - 1.</td></tr><tr><td align="left">++parameter</td><td align="left">Variable pre-increment. Equivalent to parameter = parameter + 1.</td></tr><tr><td align="left">–parameter</td><td align="left">Variable pre-decrement. Equivalent to parameter = parameter - 1.</td></tr></tbody></table><table><thead><tr><th align="left">表示法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">parameter = value</td><td align="left">简单赋值。给 parameter 赋值。</td></tr><tr><td align="left">parameter += value</td><td align="left">加。等价于 parameter = parameter + value。</td></tr><tr><td align="left">parameter -= value</td><td align="left">减。等价于 parameter = parameter – value。</td></tr><tr><td align="left">parameter *= value</td><td align="left">乘。等价于 parameter = parameter * value。</td></tr><tr><td align="left">parameter /= value</td><td align="left">整除。等价于 parameter = parameter / value。</td></tr><tr><td align="left">parameter %= value</td><td align="left">取模。等价于 parameter = parameter % value。</td></tr><tr><td align="left">parameter++</td><td align="left">后缀自增变量。等价于 parameter = parameter + 1 (但，要看下面的讨论)。</td></tr><tr><td align="left">parameter–</td><td align="left">后缀自减变量。等价于 parameter = parameter - 1。</td></tr><tr><td align="left">++parameter</td><td align="left">前缀自增变量。等价于 parameter = parameter + 1。</td></tr><tr><td align="left">–parameter</td><td align="left">前缀自减变量。等价于 parameter = parameter - 1。</td></tr></tbody></table><p>These assignment operators provide a convenient shorthand for many common arithmetic tasks. Of special interest are the increment (++) and decrement (–) operators, which increase or decrease the value of their parameters by one. This style of notation is taken from the C programming language and has been incorporated by several other programming languages, including bash.</p><p>这些赋值运算符为许多常见算术任务提供了快捷方式。特别关注一下自增（++）和自减（–）运算符，它们会把它们的参数值加1或减1。 这种风格的表示法取自C 编程语言并且被其它几种编程语言吸收，包括 bash。</p><p>The operators may appear either at the front of a parameter or at the end. While they both either increment or decrement the parameter by one, the two placements have a subtle difference. If placed at the front of the parameter, the parameter is incremented (or decre- mented) before the parameter is returned. If placed after, the operation is performed after the parameter is returned. This is rather strange, but it is the intended behavior. Here is a demonstration:</p><p>自增和自减运算符可能会出现在参数的前面或者后面。然而它们都是把参数值加1或减1，这两个位置有个微小的差异。 若运算符放置在参数的前面，参数值会在参数返回之前增加（或减少）。若放置在后面，则运算会在参数返回之后执行。 这相当奇怪，但这是它预期的行为。这里是个演示的例子：</p><pre><code>[me@linuxbox ~]$ foo=1[me@linuxbox ~]$ echo $((foo++))1[me@linuxbox ~]$ echo $foo2</code></pre><p>If we assign the value of one to the variable foo and then increment it with the ++ operator placed after the parameter name, foo is returned with the value of one. However, if we look at the value of the variable a second time, we see the incremented value. If we place the ++ operator in front of the parameter, we get the more expected behavior:</p><p>如果我们把1赋值给变量 foo，然后通过把自增运算符 ++ 放到参数名 foo 之后来增加它，foo 返回1。 然而，如果我们第二次查看变量 foo 的值，我们看到它的值增加了1。若我们把 ++ 运算符放到参数 foo 之前， 我们得到更期望的行为：</p><pre><code>[me@linuxbox ~]$ foo=1[me@linuxbox ~]$ echo $((++foo))2[me@linuxbox ~]$ echo $foo2</code></pre><p>For most shell applications, prefixing the operator will be the most useful.</p><p>对于大多数 shell 应用来说，前缀运算符最有用。</p><p>The ++ and – operators are often used in conjunction with loops. We will make some improvements to our modulo script to tighten it up a bit:</p><p>自增 ++ 和 自减 – 运算符经常和循环操作结合使用。我们将改进我们的 modulo 脚本，让代码更紧凑些：</p><pre><code>#!/bin/bash# modulo2 : demonstrate the modulo operatorfor ((i = 0; i &lt;= 20; ++i )); do    if (((i % 5) == 0 )); then        printf &quot;&lt;%d&gt; &quot; $i    else        printf &quot;%d &quot; $i    fidoneprintf &quot;\n&quot;</code></pre><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>One class of operators manipulates numbers in an unusual way. These operators work at the bit level. They are used for certain kinds of low level tasks, often involving setting or reading bit-flags.</p><p>位运算符是一类以不寻常的方式操作数字的运算符。这些运算符工作在位级别的数字。它们被用在某类底层的任务中， 经常涉及到设置或读取位标志。</p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">~</td><td align="left">Bitwise negation. Negate all the bits in a number.</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">Left bitwise shift. Shift all the bits in a number to the left.</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">Right bitwise shift. Shift all the bits in a number to the right.</td></tr><tr><td align="left">&amp;</td><td align="left">Bitwise AND. Perform an AND operation on all the bits in two numbers.</td></tr><tr><td align="left">|</td><td align="left">Bitwise OR. Perform an OR operation on all the bits in two numbers.</td></tr><tr><td align="left">^</td><td align="left">Bitwise XOR. Perform an exclusive OR operation on all the bits in two numbers.</td></tr></tbody></table><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">~</td><td align="left">按位取反。对一个数字所有位取反。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">位左移. 把一个数字的所有位向左移动。</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">位右移. 把一个数字的所有位向右移动。</td></tr><tr><td align="left">&amp;</td><td align="left">位与。对两个数字的所有位执行一个 AND 操作。</td></tr><tr><td align="left">|</td><td align="left">位或。对两个数字的所有位执行一个 OR 操作。</td></tr><tr><td align="left">^</td><td align="left">位异或。对两个数字的所有位执行一个异或操作。</td></tr></tbody></table><p>Note that there are also corresponding assignment operators (for example, &lt;&lt;=) for all but bitwise negation.</p><p>注意除了按位取反运算符之外，其它所有位运算符都有相对应的赋值运算符（例如，&lt;&lt;=）。</p><p>Here we will demonstrate producing a list of powers of 2, using the left bitwise shift operator:</p><p>这里我们将演示产生2的幂列表的操作，使用位左移运算符：</p><pre><code>[me@linuxbox ~]$ for ((i=0;i&lt;8;++i)); do echo $((1&lt;&lt;i)); done1248163264128</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>As we discovered in Chapter 27, the (( )) compound command supports a variety of comparison operators. There are a few more that can be used to evaluate logic. Here is the complete list:</p><p>正如我们在第27章中所看到的，复合命令 (( )) 支持各种各样的比较运算符。还有一些可以用来计算逻辑运算。 这里是比较运算符的完整列表：</p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">&lt;=</td><td align="left">Less than or equal to</td></tr><tr><td align="left">&gt;=</td><td align="left">great than or equal to</td></tr><tr><td align="left">&lt;</td><td align="left">less than</td></tr><tr><td align="left">&gt;</td><td align="left">greater than</td></tr><tr><td align="left">==</td><td align="left">Equal to</td></tr><tr><td align="left">!=</td><td align="left">Not equal to</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">Logical AND</td></tr><tr><td align="left">||</td><td align="left">Logical OR</td></tr><tr><td align="left">expr1?expr2:expr3</td><td align="left">Comparison (ternary) operator. If expression expr1 evaluates to be non-zero (arithmetic true) then expr2, else expr3.</td></tr></tbody></table><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&lt;=</td><td align="left">小于或相等</td></tr><tr><td align="left">&gt;=</td><td align="left">大于或相等</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">==</td><td align="left">相等</td></tr><tr><td align="left">!=</td><td align="left">不相等</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">逻辑与</td></tr><tr><td align="left">||</td><td align="left">逻辑或</td></tr><tr><td align="left">expr1?expr2:expr3</td><td align="left">条件（三元）运算符。若表达式 expr1 的计算结果为非零值（算术真），则 执行表达式 expr2，否则执行表达式 expr3。</td></tr></tbody></table><p>When used for logical operations, expressions follow the rules of arithmetic logic; that is, expressions that evaluate as zero are considered false, while non-zero expressions are considered true. The (( )) compound command maps the results into the shell’s normal exit codes:</p><p>当表达式用于逻辑运算时，表达式遵循算术逻辑规则；也就是，表达式的计算结果是零，则认为假，而非零表达式认为真。 该 (( )) 复合命令把结果映射成 shell 正常的退出码：</p><pre><code>[me@linuxbox ~]$ if ((1)); then echo &quot;true&quot;; else echo &quot;false&quot;; fitrue[me@linuxbox ~]$ if ((0)); then echo &quot;true&quot;; else echo &quot;false&quot;; fifalse</code></pre><p>The strangest of the logical operators is the ternary operator. This operator (which is modeled after the one in the C programming language) performs a standalone logical test. It can be used as a kind of if/then/else statement. It acts on three arithmetic expressions (strings won’t work), and if the first expression is true (or non-zero) the second expression is performed. Otherwise, the third expression is performed. We can try this on the command line:</p><p>最陌生的逻辑运算符就是这个三元运算符了。这个运算符（仿照于 C 编程语言里的三元运算符）执行一个单独的逻辑测试。 它用起来类似于 if/then/else 语句。它操作三个算术表达式（字符串不会起作用），并且若第一个表达式为真（或非零）， 则执行第二个表达式。否则，执行第三个表达式。我们可以在命令行中实验一下：</p><pre><code>[me@linuxbox~]$ a=0[me@linuxbox~]$ ((a&lt;1?++a:--a))[me@linuxbox~]$ echo $a1[me@linuxbox~]$ ((a&lt;1?++a:--a))[me@linuxbox~]$ echo $a0</code></pre><p>Here we see a ternary operator in action. This example implements a toggle. Each time the operator is performed, the value of the variable a switches from zero to one or vice versa.</p><p>这里我们看到一个实际使用的三元运算符。这个例子实现了一个切换。每次运算符执行的时候，变量 a 的值从零变为1，或反之亦然。</p><p>Please note that performing assignment within the expressions is not straightforward.</p><p>请注意在表达式内执行赋值却并非易事。</p><p>When attempted, bash will declare an error:</p><p>当企图这样做时，bash 会声明一个错误：</p><pre><code>[me@linuxbox ~]$ a=0[me@linuxbox ~]$ ((a&lt;1?a+=1:a-=1))bash: ((: a&lt;1?a+=1:a-=1: attempted assignment to non-variable (error token is &quot;-=1&quot;)</code></pre><p>This problem can be mitigated by surrounding the assignment expression with parentheses:</p><p>通过把赋值表达式用括号括起来，可以解决这个错误：</p><pre><code>[me@linuxbox ~]$ ((a&lt;1?(a+=1):(a-=1)))</code></pre><p>Next, we see a more complete example of using arithmetic operators in a script that produces a simple table of numbers:</p><p>下一步，我们看一个使用算术运算符更完备的例子，该示例产生一个简单的数字表格：</p><pre><code>#!/bin/bash# arith-loop: script to demonstrate arithmetic operatorsfinished=0a=0printf &quot;a\ta**2\ta**3\n&quot;printf &quot;=\t====\t====\n&quot;until ((finished)); do    b=$((a**2))    c=$((a**3))    printf &quot;%d\t%d\t%d\n&quot; $a $b $c    ((a&lt;10?++a:(finished=1)))done</code></pre><p>In this script, we implement an until loop based on the value of the finished variable. Initially, the variable is set to zero (arithmetic false) and we continue the loop until it becomes non-zero. Within the loop, we calculate the square and cube of the counter variable <strong>a</strong>. At the end of the loop, the value of the counter variable is evaluated. If it is less than 10 (the maximum number of iterations), it is incremented by one, else the variable <strong>finished</strong> is given the value of one, making finished arithmetically true, thereby terminating the loop. Running the script gives this result:</p><p>在这个脚本中，我们基于变量 finished 的值实现了一个 until 循环。首先，把变量 finished 的值设为零（算术假）， 继续执行循环之道它的值变为非零。在循环体内，我们计算计数器 a 的平方和立方。在循环末尾，计算计数器变量 a 的值。 若它小于10（最大迭代次数），则 a 的值加1，否则给变量 finished 赋值为1，使得变量 finished 算术为真， 从而终止循环。运行该脚本得到这样的结果：</p><pre><code>[me@linuxbox ~]$ arith-loopa    a**2     a**3=    ====     ====0    0        01    1        12    4        83    9        274    16       645    25       1256    36       2167    49       3438    64       5129    81       72910   100      1000</code></pre><h3 id="bc-一种高精度计算器语言"><a href="#bc-一种高精度计算器语言" class="headerlink" title="bc - 一种高精度计算器语言"></a>bc - 一种高精度计算器语言</h3><p>We have seen how the shell can handle all types of integer arithmetic, but what if we need to perform higher math or even just use floating point numbers? The answer is, we can’t. At least not directly with the shell. To do this, we need to use an external program. There are several approaches we can take. Embedding Perl or AWK programs is one possible solution, but unfortunately, outside the scope of this book. Another approach is to use a specialized calculator program. One such program found on most Linux systems is called bc.</p><p>我们已经看到 shell 是可以处理所有类型的整型算术的，但是如果我们需要执行更高级的数学运算或仅使用浮点数，该怎么办？ 答案是，我们不能这样做。至少不能直接用 shell 完成此类运算。为此，我们需要使用外部程序。 有几种途径可供我们采用。嵌入的 Perl 或者 AWK 程序是一种可能的方案，但是不幸的是，超出了本书的内容大纲。 另一种方式就是使用一种专业的计算器程序。这样一个程序叫做 bc，在大多数 Linux 系统中都可以找到。</p><p>The bc program reads a file written in its own C-like language and executes it. A bc script may be a separate file or it may be read from standard input. The bc language supports quite a few features including variables, loops, and programmer-defined functions. We won’t cover bc entirely here, just enough to get a taste. bc is well documented by its man page.</p><p>该 bc 程序读取一个用它自己的类似于 C 语言的语法编写的脚本文件。一个 bc 脚本可能是一个分离的文件或者是从 标准输入读入。bc 语言支持相当少的功能，包括变量，循环和程序员定义的函数。这里我们不会讨论整个 bc 语言， 仅仅体验一下。查看 bc 的手册页，其文档整理得非常好。</p><p>Let’s start with a simple example. We’ll write a bc script to add 2 plus 2:</p><p>让我们从一个简单的例子开始。我们将编写一个 bc 脚本来执行2加2运算：</p><pre><code>/* A very simple bc script */2 + 2</code></pre><p>The first line of the script is a comment. bc uses the same syntax for comments as the C programming language. Comments, which may span multiple lines, begin with <code>/*</code> and end with <code>*/</code>.</p><p>脚本的第一行是一行注释。bc 使用和 C 编程语言一样的注释语法。注释，可能会跨越多行，开始于 <code>/*</code> 结束于 <code>*/</code>。</p><h4 id="使用-bc"><a href="#使用-bc" class="headerlink" title="使用 bc"></a>使用 bc</h4><p>If we save the bc script above as foo.bc, we can run it this way:</p><p>如果我们把上面的 bc 脚本保存为 foo.bc，然后我们就能这样运行它：</p><pre><code>[me@linuxbox ~]$ bc foo.bcbc 1.06.94Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free SoftwareFoundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&#39;.4</code></pre><p>If we look carefully, we can see the result at the very bottom, after the copyright message. This message can be suppressed with the -q (quiet) option. bc can also be used interactively:</p><p>如果我们仔细观察，我们看到算术结果在最底部，版权信息之后。可以通过 -q（quiet）选项禁止这些版权信息。 bc 也能够交互使用：</p><pre><code>[me@linuxbox ~]$ bc -q2 + 24quit</code></pre><p>When using bc interactively, we simply type the calculations we wish to perform, and the results are immediately displayed. The bc command quit ends the interactive session.</p><p>当使用 bc 交互模式时，我们简单地输入我们希望执行的运算，结果就立即显示出来。bc 的 quit 命令结束交互会话。</p><p>It is also possible to pass a script to bc via standard input:</p><p>也可能通过标准输入把一个脚本传递给 bc 程序：</p><pre><code>[me@linuxbox ~]$ bc &lt; foo.bc4</code></pre><p>The ability to take standard input means that we can use here documents, here strings, and pipes to pass scripts. This is a here string example:</p><p>这种接受标准输入的能力，意味着我们可以使用 here 文档，here字符串，和管道来传递脚本。这里是一个使用 here 字符串的例子：</p><pre><code>[me@linuxbox ~]$ bc &lt;&lt;&lt; &quot;2+2&quot;4</code></pre><h4 id="一个脚本实例"><a href="#一个脚本实例" class="headerlink" title="一个脚本实例"></a>一个脚本实例</h4><p>As a real-world example, we will construct a script that performs a common calculation, monthly loan payments. In the script below, we use a here document to pass a script to bc:</p><p>作为一个真实世界的例子，我们将构建一个脚本，用于计算每月的还贷金额。在下面的脚本中， 我们使用了 here 文档把一个脚本传递给 bc：</p><pre><code>#!/bin/bash# loan-calc : script to calculate monthly loan paymentsPROGNAME=$(basename $0)usage () {    cat &lt;&lt;- EOF    Usage: $PROGNAME PRINCIPAL INTEREST MONTHS    Where:    PRINCIPAL is the amount of the loan.    INTEREST is the APR as a number (7% = 0.07).    MONTHS is the length of the loan&#39;s term.    EOF}if (($# != 3)); then    usage    exit 1fiprincipal=$1interest=$2months=$3bc &lt;&lt;- EOF    scale = 10    i = $interest / 12    p = $principal    n = $months    a = p * ((i * ((1 + i) ^ n)) / (((1 + i) ^ n) - 1))    print a, &quot;\n&quot;EOF</code></pre><p>When executed, the results look like this:</p><p>当脚本执行后，输出结果像这样：</p><pre><code>[me@linuxbox ~]$ loan-calc 135000 0.0775 1804751270.7222490000</code></pre><p>This example calculates the monthly payment for a $135,000 loan at 7.75% APR for 180 months (15 years). Notice the precision of the answer. This is determined by the value given to the special <strong>scale</strong>variable in the bc script. A full description of the bc scripting language is provided by the bc man page. While its mathematical notation is slightly different from that of the shell (bc more closely resembles C), most of it will be quite familiar, based on what we have learned so far.</p><p>若贷款 135,000 美金，年利率为 7.75%，借贷180个月（15年），这个例子计算出每月需要还贷的金额。 注意这个答案的精确度。这是由脚本中变量 scale 的值决定的。bc 的手册页提供了对 bc 脚本语言的详尽描述。 虽然 bc 的数学符号与 shell 的略有差异（bc 与 C 更相近），但是基于目前我们所学的内容， 大多数符号是我们相当熟悉的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>In this chapter, we have learned about many of the little things that can be used to get the “real work” done in scripts. As our experience with scripting grows, the ability to effectively manipulate strings and numbers will prove extremely valuable. Our loan-calc script demonstrates that even simple scripts can be created to do some really useful things.</p><p>在这一章中，我们学习了很多小东西，在脚本中这些小零碎可以完成“真正的工作”。随着我们编写脚本经验的增加， 能够有效地操作字符串和数字的能力将具有极为重要的价值。我们的 loan-calc 脚本表明， 甚至可以创建简单的脚本来完成一些真正有用的事情。</p><h3 id="额外加分"><a href="#额外加分" class="headerlink" title="额外加分"></a>额外加分</h3><p>While the basic functionality of the loan-calc script is in place, the script is far from complete. For extra credit, try improving the loan-calc script with the following features:</p><p>虽然该 loan-calc 脚本的基本功能已经很到位了，但脚本还远远不够完善。为了额外加分，试着 给脚本 loan-calc 添加以下功能：</p><ul><li>Full verification of the command line arguments</li><li>A command line option to implement an “interactive” mode that will prompt the user to input the principal, interest rate, and term of the loan.</li><li>A better format for the output.</li><li>完整的命令行参数验证</li><li>用一个命令行选项来实现“交互”模式，提示用户输入本金、利率和贷款期限</li><li>输出格式美化</li></ul><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Bash Hackers Wiki has a good discussion of parameter expansion:</p></li><li><p>《Bash Hackers Wiki》对参数展开有一个很好的论述：</p><p><a href="http://wiki.bash-hackers.org/syntax/pe" target="_blank" rel="noopener">http://wiki.bash-hackers.org/syntax/pe</a></p></li><li><p>The Bash Reference Manual covers this, too:</p></li><li><p>《Bash 参考手册》也介绍了这个：</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion</a></p></li><li><p>The Wikipedia has a good article describing bit operations:</p></li><li><p>Wikipedia 上面有一篇很好的文章描述了位运算：</p><p><a href="http://en.wikipedia.org/wiki/Bit_operation" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Bit_operation</a></p></li><li><p>and an article on ternary operations:</p></li><li><p>和一篇关于三元运算的文章：</p><p><a href="http://en.wikipedia.org/wiki/Ternary_operation" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ternary_operation</a></p></li><li><p>as well as a description of the formula for calculating loan payments used in our loan-calc script:</p></li><li><p>还有一个对计算还贷金额公式的描述，我们的 loan-calc 脚本中用到了这个公式：</p><p><a href="http://en.wikipedia.org/wiki/Amortization_calculator" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Amortization_calculator</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十四章 流程控制：for循环</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Afor%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Afor%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>In this final chapter on flow control, we will look at another of the shell’s looping constructs. The for loop differs from the while and until loops in that it provides a means of processing sequences during a loop. This turns out to be very useful when programming. Accordingly, the for loop is a very popular construct in bash scripting.</p><p>在这关于流程控制的最后一章中，我们将看看另一种 shell 循环构造。for 循环不同于 while 和 until 循环，因为 在循环中，它提供了一种处理序列的方式。这在编程时非常有用。因此在 bash 脚本中，for 循环是非常流行的构造。</p><p>A for loop is implemented, naturally enough, with the for command. In modern versions of bash, for is available in two forms.</p><p>实现一个 for 循环，很自然的，要用 for 命令。在现代版的 bash 中，有两种可用的 for 循环格式。</p><h3 id="for-传统-shell-格式"><a href="#for-传统-shell-格式" class="headerlink" title="for: 传统 shell 格式"></a>for: 传统 shell 格式</h3><p>The original for command’s syntax is:</p><p>for 命令语法是：</p><pre><code>for variable [in words]; do    commandsdone</code></pre><p>Where variable is the name of a variable that will increment during the execution of the loop, words is an optional list of items that will be sequentially assigned to variable, and commands are the commands that are to be executed on each iteration of the loop.</p><p>这里的 variable 是一个变量的名字，这个变量在循环执行期间会增加，words 是一个可选的条目列表， 其值会按顺序赋值给 variable，commands 是在每次循环迭代中要执行的命令。</p><p>The for command is useful on the command line. We can easily demonstrate how it works:</p><p>在命令行中 for 命令是很有用的。我们可以很容易的说明它是如何工作的：</p><pre><code>[me@linuxbox ~]$ for i in A B C D; do echo $i; doneABCD</code></pre><p>In this example, for is given a list of four words: “A”, “B”, “C”, and “D”. With a list of four words, the loop is executed four times. Each time the loop is executed, a word is as- signed to the variable i. Inside the loop, we have an echo command that displays the value of i to show the assignment. As with the while and until loops, the done keyword closes the loop.</p><p>在这个例子中，for 循环有一个四个单词的列表：“A”、“B”、“C”和 “D”。由于这四个单词的列表，for 循环会执行四次。 每次循环执行的时候，就会有一个单词赋值给变量 i。在循环体内，我们有一个 echo 命令会显示 i 变量的值，来演示赋值结果。 正如 while 和 until 循环，done 关键字会关闭循环。</p><p>The really powerful feature of for is the number of interesting ways we can create the list of words. For example, through brace expansion:</p><p>for 命令真正强大的功能是我们可以通过许多有趣的方式创建 words 列表。例如，通过花括号展开：</p><pre><code>[me@linuxbox ~]$ for i in {A..D}; do echo $i; doneABCD</code></pre><p>or pathname expansion:</p><p>或者路径名展开：</p><pre><code>[me@linuxbox ~]$ for i in distros*.txt; do echo $i; donedistros-by-date.txtdistros-dates.txtdistros-key-names.txtdistros-key-vernums.txtdistros-names.txtdistros.txtdistros-vernums.txtdistros-versions.txt</code></pre><p>or command substitution:</p><p>或者命令替换：</p><pre><code>#!/bin/bash# longest-word : find longest string in a filewhile [[ -n $1 ]]; do    if [[ -r $1 ]]; then        max_word=        max_len=0        for i in $(strings $1); do            len=$(echo $i | wc -c)            if (( len &gt; max_len )); then                max_len=$len                max_word=$i            fi        done        echo &quot;$1: &#39;$max_word&#39; ($max_len characters)&quot;    fi    shiftdone</code></pre><p>In this example, we look for the longest string found within a file. When given one or more filenames on the command line, this program uses the strings program (which is included in the GNU binutils package) to generate a list of readable text “words” in each file. The for loop processes each word in turn and determines if the current word is the longest found so far. When the loop concludes, the longest word is displayed.</p><p>在这个示例中，我们要在一个文件中查找最长的字符串。当在命令行中给出一个或多个文件名的时候， 该程序会使用 strings 程序（其包含在 GNU binutils 包中），为每一个文件产生一个可读的文本格式的 “words” 列表。 然后这个 for 循环依次处理每个单词，判断当前这个单词是否为目前为止找到的最长的一个。当循环结束的时候，显示出最长的单词。</p><p>If the optional in words portion of the for command is omitted, for defaults to pro- cessing the positional parameters. We will modify our longest-word script to use this method:</p><p>如果省略掉 for 命令的可选项 words 部分，for 命令会默认处理位置参数。 我们将修改 longest-word 脚本，来使用这种方式：</p><pre><code>#!/bin/bash# longest-word2 : find longest string in a filefor i; do    if [[ -r $i ]]; then        max_word=        max_len=0        for j in $(strings $i); do            len=$(echo $j | wc -c)            if (( len &gt; max_len )); then                max_len=$len                max_word=$j            fi        done        echo &quot;$i: &#39;$max_word&#39; ($max_len characters)&quot;    fidone</code></pre><p>As we can see, we have changed the outermost loop to use for in place of while. By omitting the list of words in the for command, the positional parameters are used instead. Inside the loop, previous instances of the variable i have been changed to the variable j. The use of shift has also been eliminated.</p><p>正如我们所看到的，我们已经更改了最外围的循环，用 for 循环来代替 while 循环。通过省略 for 命令的 words 列表， 用位置参数替而代之。在循环体内，之前的变量 i 已经改为变量 j。同时 shift 命令也被淘汰掉了。</p><blockquote><p><em>Why i?</em></p><p><em>为什么是 i？</em></p><p>You may have noticed that the variable i was chosen for each of the for loop examples above. Why? No specific reason actually, besides tradition. The variable used with for can be any valid variable, but i is the most common, followed by j and k.</p><p>你可能已经注意到上面所列举的 for 循环的实例都选择 i 作为变量。为什么呢？ 实际上没有具体原因，除了传统习惯。 for 循环使用的变量可以是任意有效的变量，但是 i 是最常用的一个，其次是 j 和 k。</p><p>The basis of this tradition comes from the Fortran programming language. In For- tran, undeclared variables starting with the letters I, J, K, L, and M are automati- cally typed as integers, while variables beginning with any other letter are typed as real (numbers with decimal fractions). This behavior led programmers to use the variables I, J, and K for loop variables, since it was less work to use them when a temporary variable (as loop variables often are) was needed. It also led to the following Fortran-based witticism:</p><p>“GOD is real, unless declared integer.”</p><p>这一传统的基础源于 Fortran 编程语言。在 Fortran 语言中，以字母 I、J、K、L 和 M 开头的未声明变量的类型 自动设为整形，而以其它字母开头的变量则为实数类型（带有小数的数字）。这种行为导致程序员使用变量 I、J和 K 作为循环变量， 因为当需要一个临时变量（正如循环变量）的时候，使用它们工作量比较少。这也引出了如下基于 Fortran 的俏皮话：</p><p>“神是实数，除非是声明的整数。”</p></blockquote><h3 id="for-C-语言格式"><a href="#for-C-语言格式" class="headerlink" title="for: C 语言格式"></a>for: C 语言格式</h3><p>Recent versions of bash have added a second form of for command syntax, one that resembles the form found in the C programming language. Many other languages support this form, as well:</p><p>最新版本的 bash 已经添加了第二种格式的 for 命令语法，该语法相似于 C 语言中的 for 语法格式。 其它许多编程语言也支持这种格式：</p><pre><code>for (( expression1; expression2; expression3 )); do    commandsdone</code></pre><p>where expression1, expression2, and expression3 are arithmetic expressions and com- mands are the commands to be performed during each iteration of the loop. In terms of behavior, this form is equivalent to the following construct:</p><p>这里的 expression1、expression2和 expression3 都是算术表达式，commands 是每次循环迭代时要执行的命令。 在行为方面，这相当于以下构造形式：</p><pre><code>(( expression1 ))while (( expression2 )); do    commands    (( expression3 ))done</code></pre><p>expression1 is used to initialize conditions for the loop, expression2 is used to determine when the loop is finished, and expression3 is carried out at the end of each iteration of the loop.</p><p>expression1 用来初始化循环条件，expression2 用来决定循环结束的时间，还有在每次循环迭代的末尾会执行 expression3。</p><p>Here is a typical application:</p><p>这里是一个典型应用：</p><pre><code>#!/bin/bash# simple_counter : demo of C style for commandfor (( i=0; i&lt;5; i=i+1 )); do    echo $idone</code></pre><p>When executed, it produces the following output:</p><p>脚本执行之后，产生如下输出：</p><pre><code>[me@linuxbox ~]$ simple_counter01234</code></pre><p>In this example, expression1 initializes the variable i with the value of zero, expression2 allows the loop to continue as long as the value of i remains less than 5, and expression3 increments the value of i by one each time the loop repeats.</p><p>在这个示例中，expression1 初始化变量 i 的值为0，expression2 允许循环继续执行只要变量 i 的值小于5， 还有每次循环迭代时，expression3 会把变量 i 的值加1。</p><p>The C language form of for is useful anytime a numeric sequence is needed. We will see several applications for this in the next two chapters.</p><p>C 语言格式的 for 循环对于需要一个数字序列的情况是很有用处的。我们将在接下来的两章中看到几个这样的应用实例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>With our knowledge of the for command, we will now apply the final improvements to our sys_info_page script. Currently, the report_home_space function looks like this:</p><p>学习了 for 命令的知识，现在我们将对我们的 sys_info_page 脚本做最后的改进。 目前，这个 report_home_space 函数看起来像这样：</p><pre><code>report_home_space () {    if [[ $(id -u) -eq 0 ]]; then        cat &lt;&lt;- _EOF_        &lt;H2&gt;Home Space Utilization (All Users)&lt;/H2&gt;        &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt;        _EOF_    else        cat &lt;&lt;- _EOF_        &lt;H2&gt;Home Space Utilization ($USER)&lt;/H2&gt;        &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt;        _EOF_    fi    return}</code></pre><p>Next, we will rewrite it to provide more detail for each user’s home directory, and include the total number of files and subdirectories in each:</p><p>下一步，我们将重写它，以便提供每个用户家目录的更详尽信息，并且包含用户家目录中文件和目录的总个数：</p><pre><code>report_home_space () {    local format=&quot;%8s%10s%10s\n&quot;    local i dir_list total_files total_dirs total_size user_name    if [[ $(id -u) -eq 0 ]]; then        dir_list=/home/*        user_name=&quot;All Users&quot;    else        dir_list=$HOME        user_name=$USER    fi    echo &quot;&lt;H2&gt;Home Space Utilization ($user_name)&lt;/H2&gt;&quot;    for i in $dir_list; do        total_files=$(find $i -type f | wc -l)        total_dirs=$(find $i -type d | wc -l)        total_size=$(du -sh $i | cut -f 1)        echo &quot;&lt;H3&gt;$i&lt;/H3&gt;&quot;        echo &quot;&lt;PRE&gt;&quot;        printf &quot;$format&quot; &quot;Dirs&quot; &quot;Files&quot; &quot;Size&quot;        printf &quot;$format&quot; &quot;----&quot; &quot;-----&quot; &quot;----&quot;        printf &quot;$format&quot; $total_dirs $total_files $total_size        echo &quot;&lt;/PRE&gt;&quot;    done    return}</code></pre><p>This rewrite applies much of what we have learned so far. We still test for the superuser, but instead of performing the complete set of actions as part of the if, we set some vari- ables used later in a for loop. We have added several local variables to the function and made use of printf to format some of the output.</p><p>这次重写应用了目前为止我们学过的许多知识。我们仍然测试超级用户（superuser），但是我们在 if 语句块内 设置了一些随后会在 for 循环中用到的变量，来取代在 if 语句块内执行完备的动作集合。我们给 函数添加了几个本地变量，并且使用 printf 来格式化输出。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Advanced Bash-Scripting Guide has a chapter on loops, with a variety of examples using for:</p></li><li><p>《高级 Bash 脚本指南》有一章关于循环的内容，其中列举了各种各样的 for 循环实例：</p><p><a href="http://tldp.org/LDP/abs/html/loops1.html" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/loops1.html</a></p></li><li><p>The Bash Reference Manual describes the looping compound commands, including for:</p></li><li><p>《Bash 参考手册》描述了循环复合命令，包括了 for 循环：</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Looping-Constructs" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Looping-Constructs</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十三章 位置参数</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>One feature that has been missing from our programs is the ability to accept and process command line options and arguments. In this chapter, we will examine the shell features that allow our programs to get access to the contents of the command line.</p><p>现在我们的程序还缺少一种本领，就是接收和处理命令行选项和参数的能力。在这一章中，我们将探究一些能 让程序访问命令行内容的 shell 性能。</p><h3 id="访问命令行"><a href="#访问命令行" class="headerlink" title="访问命令行"></a>访问命令行</h3><p>The shell provides a set of variables called positional parameters that contain the individ- ual words on the command line. The variables are named 0 through 9. They can be demonstrated this way:</p><p>shell 提供了一个称为位置参数的变量集合，这个集合包含了命令行中所有独立的单词。这些变量按照从0到9给予命名。 可以以这种方式讲明白：</p><pre><code>#!/bin/bash# posit-param: script to view command line parametersecho &quot;\$0 = $0\$1 = $1\$2 = $2\$3 = $3\$4 = $4\$5 = $5\$6 = $6\$7 = $7\$8 = $8\$9 = $9&quot;</code></pre><p>A very simple script that displays the values of the variables $0-$9. When executed with no command line arguments:</p><p>一个非常简单的脚本，显示从 $0 到 $9 所有变量的值。当不带命令行参数执行该脚本时，输出结果如下：</p><pre><code>[me@linuxbox ~]$ posit-param$0 = /home/me/bin/posit-param$1 =$2 =$3 =$4 =$5 =$6 =$7 =$8 =$9 =</code></pre><p>Even when no arguments are provided, $0 will always contain the first item appearing on the command line, which is the pathname of the program being executed. When argu- ments are provided, we see the results:</p><p>即使不带命令行参数，位置参数 $0 总会包含命令行中出现的第一个单词，也就是已执行程序的路径名。 当带参数执行脚本时，我们看看输出结果：</p><pre><code>[me@linuxbox ~]$ posit-param a b c d$0 = /home/me/bin/posit-param$1 = a$2 = b$3 = c$4 = d$5 =$6 =$7 =$8 =$9 =</code></pre><p>Note: You can actually access more than nine parameters using parameter expan- sion. To specify a number greater than nine, surround the number in braces. For ex- ample ${10}, ${55}, ${211}, and so on.</p><p>注意： 实际上通过参数展开方式你可以访问的参数个数多于9个。只要指定一个大于9的数字，用花括号把该数字括起来就可以。 例如 ${10}、 ${55}、 ${211}等等。</p><h4 id="确定参数个数"><a href="#确定参数个数" class="headerlink" title="确定参数个数"></a>确定参数个数</h4><p>The shell also provides a variable, $#, that yields the number of arguments on the com- mand line:</p><p>另外 shell 还提供了一个名为 $#，可以得到命令行参数个数的变量:</p><pre><code>#!/bin/bash# posit-param: script to view command line parametersecho &quot;Number of arguments: $#\$0 = $0\$1 = $1\$2 = $2\$3 = $3\$4 = $4\$5 = $5\$6 = $6\$7 = $7\$8 = $8\$9 = $9&quot;</code></pre><p>The result:</p><p>结果是：</p><pre><code>[me@linuxbox ~]$ posit-param a b c dNumber of arguments: 4$0 = /home/me/bin/posit-param$1 = a$2 = b$3 = c$4 = d$5 =$6 =$7 =$8 =$9 =</code></pre><h4 id="shift-访问多个参数的利器"><a href="#shift-访问多个参数的利器" class="headerlink" title="shift - 访问多个参数的利器"></a>shift - 访问多个参数的利器</h4><p>But what happens when we give the program a large number of arguments such as this:</p><p>但是如果我们给一个程序添加大量的命令行参数，会怎么样呢？ 正如下面的例子：</p><pre><code>[me@linuxbox ~]$ posit-param *Number of arguments: 82$0 = /home/me/bin/posit-param$1 = addresses.ldif$2 = bin$3 = bookmarks.html$4 = debian-500-i386-netinst.iso$5 = debian-500-i386-netinst.jigdo$6 = debian-500-i386-netinst.template$7 = debian-cd_info.tar.gz$8 = Desktop$9 = dirlist-bin.txt</code></pre><p>On this example system, the wildcard * expands into 82 arguments. How can we process that many? The shell provides a method, albeit a clumsy one, to do this. The shift command causes all the parameters to “move down one” each time it is executed. In fact, by using shift, it is possible to get by with only one parameter (in addition to $0, which never changes):</p><p>在这个例子运行的环境下，通配符 * 展开成82个参数。我们如何处理那么多的参数？ 为此，shell 提供了一种方法，尽管笨拙，但可以解决这个问题。执行一次 shift 命令， 就会导致所有的位置参数 “向下移动一个位置”。事实上，用 shift 命令也可以 处理只有一个参数的情况（除了其值永远不会改变的变量 $0）：</p><pre><code>#!/bin/bash# posit-param2: script to display all argumentscount=1while [[ $# -gt 0 ]]; do    echo &quot;Argument $count = $1&quot;    count=$((count + 1))    shiftdone</code></pre><p>Each time shift is executed, the value of $2 is moved to $1, the value of $3 is moved to $2 and so on. The value of $# is also reduced by one.</p><p>每次 shift 命令执行的时候，变量 $2 的值会移动到变量 $1 中，变量 $3 的值会移动到变量 $2 中，依次类推。 变量 $# 的值也会相应的减1。</p><p>In the posit-param2 program, we create a loop that evaluates the number of arguments remaining and continues as long as there is at least one. We display the current argument, increment the variable count with each iteration of the loop to provide a running count of the number of arguments processed and, finally, execute a shift to load $1 with the next argument. Here is the program at work:</p><p>在该 posit-param2 程序中，我们编写了一个计算剩余参数数量，只要参数个数不为零就会继续执行的 while 循环。 我们显示当前的位置参数，每次循环迭代变量 count 的值都会加1，用来计数处理的参数数量， 最后，执行 shift 命令加载 $1，其值为下一个位置参数的值。这里是程序运行后的输出结果:</p><pre><code>[me@linuxbox ~]$ posit-param2 a b c dArgument 1 = aArgument 2 = bArgument 3 = cArgument 4 = d</code></pre><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>Even without shift, it’s possible to write useful applications using positional parameters. By way of example, here is a simple file information program:</p><p>即使没有 shift 命令，也可以用位置参数编写一个有用的应用。举例说明，这里是一个简单的输出文件信息的程序：</p><pre><code>#!/bin/bash# file_info: simple file information programPROGNAME=$(basename $0)if [[ -e $1 ]]; then    echo -e &quot;\nFile Type:&quot;    file $1    echo -e &quot;\nFile Status:&quot;    stat $1else    echo &quot;$PROGNAME: usage: $PROGNAME file&quot; &gt;&amp;2    exit 1fi</code></pre><p>This program displays the file type (determined by the file command) and the file status (from the stat command) of a specified file. One interesting feature of this program is the <strong>PROGNAME</strong>variable. It is given the value that results from the <strong>basename $0</strong> command. The <strong>basename</strong>command removes the leading portion of a pathname, leaving only the base name of a file. In our example, <strong>basename</strong> removes the leading portion of the pathname contained in the $0 parameter, the full pathname of our example program. This value is useful when constructing messages such as the usage message at the end of the program. By coding it this way, the script can be renamed and the message automatically adjusts to contain the name of the program.</p><p>这个程序显示一个具体文件的文件类型（由 file 命令确定）和文件状态（来自 stat 命令）。该程序一个有意思 的特点是 PROGNAME 变量。它的值就是 basename $0 命令的执行结果。这个 basename 命令清除 一个路径名的开头部分，只留下一个文件的基本名称。在我们的程序中，basename 命令清除了包含在 $0 位置参数 中的路径名的开头部分，$0 中包含着我们示例程序的完整路径名。当构建提示信息正如程序结尾的使用信息的时候， basename $0 的执行结果就很有用处。按照这种方式编码，可以重命名该脚本，且程序信息会自动调整为 包含相应的程序名称。</p><h4 id="Shell-函数中使用位置参数"><a href="#Shell-函数中使用位置参数" class="headerlink" title="Shell 函数中使用位置参数"></a>Shell 函数中使用位置参数</h4><p>Just as positional parameters are used to pass arguments to shell scripts, they can also be used to pass arguments to shell functions. To demonstrate, we will convert the file_info script into a shell function:</p><p>正如位置参数被用来给 shell 脚本传递参数一样，它们也能够被用来给 shell 函数传递参数。为了说明这一点， 我们将把 file_info 脚本转变成一个 shell 函数：</p><pre><code>file_info () {  # file_info: function to display file information  if [[ -e $1 ]]; then      echo -e &quot;\nFile Type:&quot;      file $1      echo -e &quot;\nFile Status:&quot;      stat $1  else      echo &quot;$FUNCNAME: usage: $FUNCNAME file&quot; &gt;&amp;2      return 1  fi}</code></pre><p>Now, if a script that incorporates the file_info shell function calls the function with a filename argument, the argument will be passed to the function.</p><p>现在，如果一个包含 shell 函数 file_info 的脚本调用该函数，且带有一个文件名参数，那这个参数会传递给 file_info 函数。</p><p>With this capability, we can write many useful shell functions that can not only be used in scripts, but also within the .bashrc file.</p><p>通过此功能，我们可以写出许多有用的 shell 函数，这些函数不仅能在脚本中使用，也可以用在 .bashrc 文件中。</p><p>Notice that the PROGNAME variable was changed to the shell variable FUNCNAME. The shell automatically updates this variable to keep track of the currently executed shell function. Note that $0 always contains the full pathname of the first item on the command line (i.e., the name of the program) and does not contain the name of the shell function as we might expect.</p><p>注意那个 PROGNAME 变量已经改成 shell 变量 FUNCNAME 了。shell 会自动更新 FUNCNAME 变量，以便 跟踪当前执行的 shell 函数。注意位置参数 $0 总是包含命令行中第一项的完整路径名（例如，该程序的名字）， 但不会包含这个我们可能期望的 shell 函数的名字。</p><h3 id="处理集体位置参数"><a href="#处理集体位置参数" class="headerlink" title="处理集体位置参数"></a>处理集体位置参数</h3><p>It is sometimes useful to manage all the positional parameters as a group. For example, we might want to write a “wrapper” around another program. This means that we create a script or shell function that simplifies the execution of another program. The wrapper supplies a list of arcane command line options and then passes a list of arguments to the lower-level program.</p><p>有时候把所有的位置参数作为一个集体来管理是很有用的。例如，我们可能想为另一个程序编写一个 “包裹程序”。 这意味着我们会创建一个脚本或 shell 函数，来简化另一个程序的执行。包裹程序提供了一个神秘的命令行选项 列表，然后把这个参数列表传递给下一级的程序。</p><p>The shell provides two special parameters for this purpose. They both expand into the complete list of positional parameters, but differ in rather subtle ways. They are:</p><p>为此 shell 提供了两种特殊的参数。他们二者都能扩展成完整的位置参数列表，但以相当微妙的方式略有不同。它们是：</p><table><thead><tr><th align="left">Parameter</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">$*</td><td align="left">Expands into the list of positional parameters, starting with 1. When surrounded by double quotes, it expands into a double quoted string containing all of the positional parameters, each separated by the first character of the IFS shell variable (by default a space character).</td></tr><tr><td align="left">$@</td><td align="left">Expands into the list of positional parameters, starting with 1. When surrounded by double quotes, it expands each positional parameter into a separate word surrounded by double quotes.</td></tr></tbody></table><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$*</td><td align="left">展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候，展开成一个由双引号引起来 的字符串，包含了所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个字符（默认为一个空格）分隔开。</td></tr><tr><td align="left">$@</td><td align="left">展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候， 它把每一个位置参数展开成一个由双引号引起来的分开的字符串。</td></tr></tbody></table><p>Here is a script that shows these special paramaters in action:</p><p>下面这个脚本用程序中展示了这些特殊参数：</p><pre><code>#!/bin/bash# posit-params3 : script to demonstrate $* and $@print_params () {    echo &quot;\$1 = $1&quot;    echo &quot;\$2 = $2&quot;    echo &quot;\$3 = $3&quot;    echo &quot;\$4 = $4&quot;}pass_params () {    echo -e &quot;\n&quot; &#39;$* :&#39;;      print_params   $*    echo -e &quot;\n&quot; &#39;&quot;$*&quot; :&#39;;    print_params   &quot;$*&quot;    echo -e &quot;\n&quot; &#39;$@ :&#39;;      print_params   $@    echo -e &quot;\n&quot; &#39;&quot;$@&quot; :&#39;;    print_params   &quot;$@&quot;}pass_params &quot;word&quot; &quot;words with spaces&quot;</code></pre><p>In this rather convoluted program, we create two arguments: “word” and “words with spaces”, and pass them to the pass_params function. That function, in turn, passes them on to the print_params function, using each of the four methods available with the special parameters $* and $@. When executed, the script reveals the differences:</p><p>在这个相当复杂的程序中，我们创建了两个参数： “word” 和 “words with spaces”，然后把它们 传递给 pass_params 函数。这个函数，依次，再把两个参数传递给 print_params 函数， 使用了特殊参数 $* 和 $@ 提供的四种可用方法。脚本运行后，揭示了这两个特殊参数存在的差异：</p><pre><code>[me@linuxbox ~]$ posit-param3 $* :$1 = word$2 = words$3 = with$4 = spaces &quot;$*&quot; :$1 = word words with spaces$2 =$3 =$4 = $@ :$1 = word$2 = words$3 = with$4 = spaces &quot;$@&quot; :$1 = word$2 = words with spaces$3 =$4 =</code></pre><p>With our arguments, both $* and $@ produce a four word result:</p><p>通过我们的参数，$* 和 $@ 两个都产生了一个有四个词的结果：</p><pre><code>word words with spaces&quot;$*&quot; produces a one word result:    &quot;word words with spaces&quot;&quot;$@&quot; produces a two word result:    &quot;word&quot; &quot;words with spaces&quot;</code></pre><p>which matches our actual intent. The lesson to take from this is that even though the shell provides four different ways of getting the list of positional parameters, “$@” is by far the most useful for most situations, because it preserves the integrity of each positional parameter.</p><p>这个结果符合我们实际的期望。我们从中得到的教训是尽管 shell 提供了四种不同的得到位置参数列表的方法， 但到目前为止， “$@” 在大多数情况下是最有用的方法，因为它保留了每一个位置参数的完整性。</p><h3 id="一个更复杂的应用"><a href="#一个更复杂的应用" class="headerlink" title="一个更复杂的应用"></a>一个更复杂的应用</h3><p>After a long hiatus, we are going to resume work on our sys_info_page program. Our next addition will add several command line options to the program as follows:</p><p>经过长时间的间断，我们将恢复程序 sys_info_page 的工作。我们下一步要给程序添加如下几个命令行选项：</p><ul><li><strong>Output file</strong>. We will add an option to specify a name for a file to contain the pro- gram’s output. It will be specified as either <em>-f file</em> or <em>–file file</em>.</li><li><strong>输出文件</strong>。 我们将添加一个选项，以便指定一个文件名，来包含程序的输出结果。 选项格式要么是 -f file，要么是 –file file</li><li><strong>Interactive mode</strong>. This option will prompt the user for an output filename and will determine if the specified file already exists. If it does, the user will be prompted before the existing file is overwritten. This option will be specified by either -i or –interactive.</li><li><strong>交互模式</strong>。这个选项将提示用户输入一个输出文件名，然后判断指定的文件是否已经存在了。如果文件存在， 在覆盖这个存在的文件之前会提示用户。这个选项可以通过 -i 或者 –interactive 来指定。</li><li><strong>Help</strong>. Either <em>-h</em> or <em>–help</em> may be specified to cause the program to output an informative usage message.</li><li><strong>帮助</strong>。指定 -h 选项 或者是 –help 选项，可导致程序输出提示性的使用信息。</li></ul><p>Here is the code needed to implement the command line processing:</p><p>这里是处理命令行选项所需的代码：</p><pre><code>usage () {    echo &quot;$PROGNAME: usage: $PROGNAME [-f file | -i]&quot;    return}# process command line optionsinteractive=filename=while [[ -n $1 ]]; do    case $1 in    -f | --file)            shift                            filename=$1                            ;;    -i | --interactive)     interactive=1                            ;;    -h | --help)            usage                            exit                            ;;    *)                      usage &gt;&amp;2                            exit 1                            ;;    esac    shiftdone</code></pre><p>First, we add a shell function called usage to display a message when the help option is invoked or an unknown option is attempted.</p><p>首先，我们添加了一个叫做 usage 的 shell 函数，以便显示帮助信息，当启用帮助选项或敲写了一个未知选项的时候。</p><p>Next, we begin the processing loop. This loop continues while the positional parameter $1 is not empty. At the bottom of the loop, we have a shift command to advance the positional parameters to ensure that the loop will eventually terminate. Within the loop, we have a case statement that examines the current positional parameter to see if it matches any of the supported choices. If a supported parameter is found, it is acted upon. If not, the usage message is displayed and the script terminates with an error.</p><p>下一步，我们开始处理循环。当位置参数 $1 不为空的时候，这个循环会持续运行。在循环的底部，有一个 shift 命令， 用来提升位置参数，以便确保该循环最终会终止。在循环体内，我们使用了一个 case 语句来检查当前位置参数的值， 看看它是否匹配某个支持的选项。若找到了匹配项，就会执行与之对应的代码。若没有，就会打印出程序使用信息， 该脚本终止且执行错误。</p><p>The -f parameter is handled in an interesting way. When detected, it causes an additional shift to occur, which advances the positional parameter $1 to the filename argument supplied to the -f option.</p><p>处理 -f 参数的方式很有意思。当监测到 -f 参数的时候，会执行一次 shift 命令，从而提升位置参数 $1 为 伴随着 -f 选项的 filename 参数。</p><p>We next add the code to implement the interactive mode:</p><p>我们下一步添加代码来实现交互模式：</p><pre><code># interactive modeif [[ -n $interactive ]]; then    while true; do        read -p &quot;Enter name of output file: &quot; filename        if [[ -e $filename ]]; then            read -p &quot;&#39;$filename&#39; exists. Overwrite? [y/n/q] &gt; &quot;            case $REPLY in            Y|y)    break                    ;;            Q|q)    echo &quot;Program terminated.&quot;                    exit                    ;;            *)      continue                    ;;            esac        elif [[ -z $filename ]]; then            continue        else            break        fi    donefi</code></pre><p>If the interactive variable is not empty, an endless loop is started, which contains the filename prompt and subsequent existing file-handling code. If the desired output file already exists, the user is prompted to overwrite, choose another filename, or quit the program. If the user chooses to overwrite an existing file, a <em>break</em> is executed to terminate the loop. Notice how the case statement only detects if the user chooses to overwrite or quit. Any other choice causes the loop to continue and prompts the user again.</p><p>若 interactive 变量不为空，就会启动一个无休止的循环，该循环包含文件名提示和随后存在的文件处理代码。 如果所需要的输出文件已经存在，则提示用户覆盖，选择另一个文件名，或者退出程序。如果用户选择覆盖一个 已经存在的文件，则会执行 break 命令终止循环。注意 case 语句是怎样只检测用户选择了覆盖还是退出选项。 其它任何选择都会导致循环继续并提示用户再次选择。</p><p>In order to implement the output filename feature, we must first convert the existing page-writing code into a shell function, for reasons that will become clear in a moment:</p><p>为了实现这个输出文件名的功能，首先我们必须把现有的这个写页面（page-writing）的代码转变成一个 shell 函数， 一会儿就会明白这样做的原因：</p><pre><code>write_html_page () {    cat &lt;&lt;- _EOF_        &lt;HTML&gt;            &lt;HEAD&gt;                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;            &lt;/HEAD&gt;            &lt;BODY&gt;                &lt;H1&gt;$TITLE&lt;/H1&gt;                &lt;P&gt;$TIMESTAMP&lt;/P&gt;                $(report_uptime)                $(report_disk_space)                $(report_home_space)            &lt;/BODY&gt;        &lt;/HTML&gt;    _EOF_    return}# output html pageif [[ -n $filename ]]; then    if touch $filename &amp;&amp; [[ -f $filename ]]; then        write_html_page &gt; $filename    else        echo &quot;$PROGNAME: Cannot write file &#39;$filename&#39;&quot; &gt;&amp;2        exit 1    fielse    write_html_pagefi</code></pre><p>The code that handles the logic of the -f option appears at the end of the listing shown above. In it, we test for the existence of a filename and, if one is found, a test is performed to see if the file is indeed writable. To do this, a <em>touch</em> is performed, followed by a test to determine if the resulting file is a regular file. These two tests take care of situations where an invalid pathname is input (<em>touch</em> will fail), and, if the file already exists, that it’s a regular file.</p><p>解决 -f 选项逻辑的代码出现在以上程序片段的末尾。在这段代码中，我们测试一个文件名是否存在，若文件名存在， 则执行另一个测试看看该文件是不是可写文件。为此，会运行 touch 命令，紧随其后执行一个测试，来决定 touch 命令 创建的文件是否是个普通文件。这两个测试考虑到了输入是无效路径名（touch 命令执行失败），和一个普通文件已经存在的情况。</p><p>As we can see, the write_html_page function is called to perform the actual generation of the page. Its output is either directed to standard output (if the variable filename is empty) or redirected to the specified file.</p><p>正如我们所看到的，程序调用 write_html_page 函数来生成实际的网页。函数输出要么直接定向到 标准输出（若 filename 变量为空的话）要么重定向到具体的文件中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>With the addition of positional parameters, we can now write fairly functional scripts. For simple, repetitive tasks, positional parameters make it possible to write very useful shell functions that can be placed in a user’s .bashrc file.</p><p>伴随着位置参数的加入，现在我们能编写相当具有功能性的脚本。例如，重复性的任务，位置参数使得我们可以编写 非常有用的，可以放置在一个用户的 .bashrc 文件中的 shell 函数。</p><p>Our sys_info_page program has grown in complexity and sophistication. Here is a complete listing, with the most recent changes highlighted:</p><p>我们的 sys_info_page 程序日渐精进。这里是一个完整的程序清单，最新的更改用高亮显示：</p><pre><code>#!/bin/bash# sys_info_page: program to output a system information pagePROGNAME=$(basename $0)TITLE=&quot;System Information Report For $HOSTNAME&quot;CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)TIMESTAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;report_uptime () {    cat &lt;&lt;- _EOF_        &lt;H2&gt;System Uptime&lt;/H2&gt;        &lt;PRE&gt;$(uptime)&lt;/PRE&gt;    _EOF_    return}report_disk_space () {    cat &lt;&lt;- _EOF_        &lt;H2&gt;Disk Space Utilization&lt;/H2&gt;        &lt;PRE&gt;$(df -h)&lt;/PRE&gt;    _EOF_    return}report_home_space () {    if [[ $(id -u) -eq 0 ]]; then        cat &lt;&lt;- _EOF_            &lt;H2&gt;Home Space Utilization (All Users)&lt;/H2&gt;            &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt;        _EOF_    else        cat &lt;&lt;- _EOF_            &lt;H2&gt;Home Space Utilization ($USER)&lt;/H2&gt;            &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt;        _EOF_    fi    return}usage () {    echo &quot;$PROGNAME: usage: $PROGNAME [-f file | -i]&quot;    return}write_html_page () {    cat &lt;&lt;- _EOF_        &lt;HTML&gt;            &lt;HEAD&gt;                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;            &lt;/HEAD&gt;            &lt;BODY&gt;                &lt;H1&gt;$TITLE&lt;/H1&gt;                &lt;P&gt;$TIMESTAMP&lt;/P&gt;                $(report_uptime)                $(report_disk_space)                $(report_home_space)            &lt;/BODY&gt;        &lt;/HTML&gt;    _EOF_    return}# process command line optionsinteractive=filename=while [[ -n $1 ]]; do    case $1 in        -f | --file)          shift                              filename=$1                              ;;        -i | --interactive)   interactive=1                              ;;        -h | --help)          usage                              exit                              ;;        *)                    usage &gt;&amp;2                              exit 1                              ;;    esac    shiftdone# interactive modeif [[ -n $interactive ]]; then    while true; do        read -p &quot;Enter name of output file: &quot; filename        if [[ -e $filename ]]; then            read -p &quot;&#39;$filename&#39; exists. Overwrite? [y/n/q] &gt; &quot;            case $REPLY in                Y|y)    break                        ;;                Q|q)    echo &quot;Program terminated.&quot;                        exit                        ;;                *)      continue                        ;;            esac        fi    donefi# output html pageif [[ -n $filename ]]; then    if touch $filename &amp;&amp; [[ -f $filename ]]; then        write_html_page &gt; $filename    else        echo &quot;$PROGNAME: Cannot write file &#39;$filename&#39;&quot; &gt;&amp;2        exit 1    fielse    write_html_pagefi</code></pre><p>We’re not done yet. There are still more things we can do and improvements we can make.</p><p>我们还没有完成。仍然还有许多事情我们可以做，可以改进。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The <em>Bash Hackers Wiki</em> has a good article on positional parameters:</p></li><li><p><em>Bash Hackers Wiki</em> 上有一篇不错的关于位置参数的文章：</p><p><a href="http://wiki.bash-hackers.org/scripting/posparams" target="_blank" rel="noopener">http://wiki.bash-hackers.org/scripting/posparams</a></p></li><li><p>The <em>Bash Reference Manual</em> has an article on the special parameters, including $* and $@:</p></li><li><p>Bash 的参考手册有一篇关于特殊参数的文章，包括 $* 和 $@：</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters</a></p></li><li><p>In addition to the techniques discussed in this chapter, bash includes a builtin command called <em>getopts</em>, which can also be used for process command line arguments. It is described in the SHELL BUILTIN COMMANDS section of the bash man page and at the <em>Bash Hackers Wiki</em>:</p></li><li><p>除了本章讨论的技术之外，bash 还包含一个叫做 getopts 的内部命令，此命令也可以用来处理命令行参数。 bash 参考页面的 SHELL BUILTIN COMMANDS 一节介绍了这个命令，Bash Hackers Wiki 上也有对它的描述：</p><p><a href="http://wiki.bash-hackers.org/howto/getopts_tutorial" target="_blank" rel="noopener">http://wiki.bash-hackers.org/howto/getopts_tutorial</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十二章 流程控制：case分支</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Acase%E5%88%86%E6%94%AF/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Acase%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>In this chapter, we will continue to look at flow control. In Chapter 28, we constructed some simple menus and built the logic used to act on a user’s selection. To do this, we used a series of if commands to identify which of the possible choices has been selected. This type of construct appears frequently in programs, so much so that many programming languages (including the shell) provide a flow control mechanism for multiple-choice decisions.</p><p>在这一章中，我们将继续看一下程序的流程控制。在第28章中，我们构建了一些简单的菜单并创建了用来 应对各种用户选择的程序逻辑。为此，我们使用了一系列的 if 命令来识别哪一个可能的选项已经被选中。 这种类型的构造经常出现在程序中，出现频率如此之多，以至于许多编程语言（包括 shell） 专门为多选决策提供了一种流程控制机制。</p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>The bash multiple-choice compound command is called case. It has the following syntax:</p><p>Bash 的多选复合命令称为 case。它的语法规则如下所示：</p><pre><code>case word in    [pattern [| pattern]...) commands ;;]...esac</code></pre><p>If we look at the read-menu program from Chapter 28, we see the logic used to act on a user’s selection:</p><p>如果我们看一下第28章中的读菜单程序，我们就知道了用来应对一个用户选项的逻辑流程：</p><pre><code>#!/bin/bash# read-menu: a menu driven system information programclearecho &quot;Please Select:1. Display System Information2. Display Disk Space3. Display Home Space Utilization0. Quit&quot;read -p &quot;Enter selection [0-3] &gt; &quot;if [[ $REPLY =~ ^[0-3]$ ]]; then    if [[ $REPLY == 0 ]]; then        echo &quot;Program terminated.&quot;        exit    fi    if [[ $REPLY == 1 ]]; then        echo &quot;Hostname: $HOSTNAME&quot;        uptime        exit    fi    if [[ $REPLY == 2 ]]; then        df -h        exit    fi    if [[ $REPLY == 3 ]]; then        if [[ $(id -u) -eq 0 ]]; then            echo &quot;Home Space Utilization (All Users)&quot;            du -sh /home/*        else            echo &quot;Home Space Utilization ($USER)&quot;            du -sh $HOME        fi        exit    fielse    echo &quot;Invalid entry.&quot; &gt;&amp;2    exit 1fi</code></pre><p>Using case, we can replace this logic with something simpler:</p><p>使用 case 语句，我们可以用更简单的代码替换这种逻辑：</p><pre><code>#!/bin/bash# case-menu: a menu driven system information programclearecho &quot;Please Select:1. Display System Information2. Display Disk Space3. Display Home Space Utilization0. Quit&quot;read -p &quot;Enter selection [0-3] &gt; &quot;case $REPLY in    0)  echo &quot;Program terminated.&quot;        exit        ;;    1)  echo &quot;Hostname: $HOSTNAME&quot;        uptime        ;;    2)  df -h        ;;    3)  if [[ $(id -u) -eq 0 ]]; then            echo &quot;Home Space Utilization (All Users)&quot;            du -sh /home/*        else            echo &quot;Home Space Utilization ($USER)&quot;            du -sh $HOME        fi        ;;    *)  echo &quot;Invalid entry&quot; &gt;&amp;2        exit 1        ;;esac</code></pre><p>The case command looks at the value of word, in our example, the value of the REPLY variable, and then attempts to match it against one of the specified patterns. When a match is found, the commands associated with the specified pattern are executed. After a match is found, no further matches are attempted.</p><p>case 命令检查一个变量值，在我们这个例子中，就是 REPLY 变量的变量值，然后试图去匹配其中一个具体的模式。 当与之相匹配的模式找到之后，就会执行与该模式相关联的命令。若找到一个模式之后，就不会再继续寻找。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>The patterns used by case are the same as those used by pathname expansion. Patterns are terminated with a “)” character. Here are some valid patterns:</p><p>这里 case 语句使用的模式和路径展开中使用的那些是一样的。模式以一个 “)” 为终止符。这里是一些有效的模式。</p><table><thead><tr><th align="left">Pattern</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">a)</td><td align="left">Matches if word equals “a”.</td></tr><tr><td align="left">[[:alpha:]])</td><td align="left">Matches if word is a single alphabetic character.</td></tr><tr><td align="left">???)</td><td align="left">Matches if word is exactly three characters long.</td></tr><tr><td align="left">*.txt)</td><td align="left">Matches if word ends with the characters “.txt”.</td></tr><tr><td align="left">*)</td><td align="left">Matches any value of word. It is good practice to include this as the last pattern in a case command, to catch any values of word that did not match a previous pattern; that is, to catch any possible invalid values.</td></tr></tbody></table><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">a)</td><td align="left">若单词为 “a”，则匹配</td></tr><tr><td align="left">[[:alpha:]])</td><td align="left">若单词是一个字母字符，则匹配</td></tr><tr><td align="left">???)</td><td align="left">若单词只有3个字符，则匹配</td></tr><tr><td align="left">*.txt)</td><td align="left">若单词以 “.txt” 字符结尾，则匹配</td></tr><tr><td align="left">*)</td><td align="left">匹配任意单词。把这个模式做为 case 命令的最后一个模式，是一个很好的做法， 可以捕捉到任意一个与先前模式不匹配的数值；也就是说，捕捉到任何可能的无效值。</td></tr></tbody></table><p>Here is an example of patterns at work:</p><p>这里是一个模式使用实例：</p><pre><code>#!/bin/bashread -p &quot;enter word &gt; &quot;case $REPLY in    [[:alpha:]])        echo &quot;is a single alphabetic character.&quot; ;;    [ABC][0-9])         echo &quot;is A, B, or C followed by a digit.&quot; ;;    ???)                echo &quot;is three characters long.&quot; ;;    *.txt)              echo &quot;is a word ending in &#39;.txt&#39;&quot; ;;    *)                  echo &quot;is something else.&quot; ;;esac</code></pre><p>It is also possible to combine multiple patterns using the vertical bar character as a separator. This creates an “or” conditional pattern. This is useful for such things as handling both upper- and lowercase characters. For example:</p><p>还可以使用竖线字符作为分隔符，把多个模式结合起来。这就创建了一个 “或” 条件模式。这对于处理诸如大小写字符很有用处。例如：</p><pre><code>#!/bin/bash# case-menu: a menu driven system information programclearecho &quot;Please Select:A. Display System InformationB. Display Disk SpaceC. Display Home Space UtilizationQ. Quit&quot;read -p &quot;Enter selection [A, B, C or Q] &gt; &quot;case $REPLY inq|Q) echo &quot;Program terminated.&quot;     exit     ;;a|A) echo &quot;Hostname: $HOSTNAME&quot;     uptime     ;;b|B) df -h     ;;c|C) if [[ $(id -u) -eq 0 ]]; then         echo &quot;Home Space Utilization (All Users)&quot;         du -sh /home/*     else         echo &quot;Home Space Utilization ($USER)&quot;         du -sh $HOME     fi     ;;*)   echo &quot;Invalid entry&quot; &gt;&amp;2     exit 1     ;;esac</code></pre><p>Here, we modify the case-menu program to use letters instead of digits for menu selection. Notice how the new patterns allow for entry of both upper- and lowercase letters.</p><p>这里，我们更改了 case-menu 程序的代码，用字母来代替数字做为菜单选项。注意新模式如何使得大小写字母都是有效的输入选项。</p><h3 id="执行多个动作"><a href="#执行多个动作" class="headerlink" title="执行多个动作"></a>执行多个动作</h3><p>In versions of bash prior to 4.0, case allowed only one action to be performed on a successful match. After a successful match, the command would terminate. Here we see a script that tests a character:</p><p>早于版本号4.0的 bash，case 语法只允许执行与一个成功匹配的模式相关联的动作。 匹配成功之后，命令将会终止。这里我们看一个测试一个字符的脚本：</p><pre><code>#!/bin/bash# case4-1: test a characterread -n 1 -p &quot;Type a character &gt; &quot;echocase $REPLY in    [[:upper:]])    echo &quot;&#39;$REPLY&#39; is upper case.&quot; ;;    [[:lower:]])    echo &quot;&#39;$REPLY&#39; is lower case.&quot; ;;    [[:alpha:]])    echo &quot;&#39;$REPLY&#39; is alphabetic.&quot; ;;    [[:digit:]])    echo &quot;&#39;$REPLY&#39; is a digit.&quot; ;;    [[:graph:]])    echo &quot;&#39;$REPLY&#39; is a visible character.&quot; ;;    [[:punct:]])    echo &quot;&#39;$REPLY&#39; is a punctuation symbol.&quot; ;;    [[:space:]])    echo &quot;&#39;$REPLY&#39; is a whitespace character.&quot; ;;    [[:xdigit:]])   echo &quot;&#39;$REPLY&#39; is a hexadecimal digit.&quot; ;;esac</code></pre><p>Running this script produces this:</p><p>运行这个脚本，输出这些内容：</p><pre><code>[me@linuxbox ~]$ case4-1Type a character &gt; a&#39;a&#39; is lower case.</code></pre><p>The script works for the most part, but fails if a character matches more than one of the POSIX characters classes. For example, the character “a” is both lower case and alphabetic, as well as a hexadecimal digit. In bash prior to version 4.0 there was no way for case to match more than one test. Modern versions of bash, add the “;;&amp;” notation to terminate each action, so now we can do this:</p><p>大多数情况下这个脚本工作是正常的，但若输入的字符不止与一个 POSIX 字符集匹配的话，这时脚本就会出错。 例如，字符 “a” 既是小写字母，也是一个十六进制的数字。早于4.0的 bash，对于 case 语法绝不能匹配 多个测试条件。现在的 bash 版本，添加 “;;&amp;” 表达式来终止每个行动，所以现在我们可以做到这一点：</p><pre><code>#!/bin/bash# case4-2: test a characterread -n 1 -p &quot;Type a character &gt; &quot;echocase $REPLY in    [[:upper:]])    echo &quot;&#39;$REPLY&#39; is upper case.&quot; ;;&amp;    [[:lower:]])    echo &quot;&#39;$REPLY&#39; is lower case.&quot; ;;&amp;    [[:alpha:]])    echo &quot;&#39;$REPLY&#39; is alphabetic.&quot; ;;&amp;    [[:digit:]])    echo &quot;&#39;$REPLY&#39; is a digit.&quot; ;;&amp;    [[:graph:]])    echo &quot;&#39;$REPLY&#39; is a visible character.&quot; ;;&amp;    [[:punct:]])    echo &quot;&#39;$REPLY&#39; is a punctuation symbol.&quot; ;;&amp;    [[:space:]])    echo &quot;&#39;$REPLY&#39; is a whitespace character.&quot; ;;&amp;    [[:xdigit:]])   echo &quot;&#39;$REPLY&#39; is a hexadecimal digit.&quot; ;;&amp;esac</code></pre><p>When we run this script, we get this:</p><p>当我们运行这个脚本的时候，我们得到这些：</p><pre><code>[me@linuxbox ~]$ case4-2Type a character &gt; a&#39;a&#39; is lower case.&#39;a&#39; is alphabetic.&#39;a&#39; is a visible character.&#39;a&#39; is a hexadecimal digit.</code></pre><p>The addition of the “;;&amp;” syntax allows case to continue on to the next test rather than simply terminating.</p><p>添加的 “;;&amp;” 的语法允许 case 语句继续执行下一条测试，而不是简单地终止运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>The case command is a handy addition to our bag of programming tricks. As we will see in the next chapter, it’s the perfect tool for handling certain types of problems.</p><p>case 命令是我们编程技巧口袋中的一个便捷工具。在下一章中我们将看到， 对于处理某些类型的问题来说，case 命令是一个完美的工具。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Bash Reference Manual section on Conditional Constructs describes the case command in detail:</p></li><li><p>Bash 参考手册的条件构造一节详尽的介绍了 case 命令：</p><p><a href="http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21" target="_blank" rel="noopener">http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21</a></p></li><li><p>The Advanced Bash-Scripting Guide provides further examples of case applications:</p></li><li><p>高级 Bash 脚本指南提供了更深一层的 case 应用实例：</p><p><a href="http://tldp.org/LDP/abs/html/testbranch.html" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/testbranch.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十一章 疑难排解</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%96%91%E9%9A%BE%E6%8E%92%E8%A7%A3/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%96%91%E9%9A%BE%E6%8E%92%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>As our scripts become more complex, it’s time to take a look at what happens when things go wrong and they don’t do what we want. In this chapter, we’ll look at some of the common kinds of errors that occur in scripts, and describe a few useful techniques that can be used to track down and eradicate problems.</p><p>随着我们的脚本变得越来越复杂，当脚本运行错误，执行结果出人意料的时候, 我们就应该查看一下原因了。 在这一章中，我们将会看一些脚本中出现地常见错误类型，同时还会介绍几个可以跟踪和消除问题的有用技巧。</p><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>One general class of errors is syntactic. Syntactic errors involve mis-typing some element of shell syntax. In most cases, these kinds of errors will lead to the shell refusing to execute the script.</p><p>一个普通的错误类型是语法。语法错误涉及到一些 shell 语法元素的拼写错误。大多数情况下，这类错误 会导致 shell 拒绝执行此脚本。</p><p>In the following the discussions, we will use this script to demonstrate common types of errors:</p><p>在以下讨论中，我们将使用下面这个脚本，来说明常见的错误类型：</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=1if [ $number = 1 ]; then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fi</code></pre><p>As written, this script runs successfully:</p><p>参看脚本内容，我们知道这个脚本执行成功了：</p><pre><code>[me@linuxbox ~]$ troubleNumber is equal to 1.</code></pre><h4 id="丢失引号"><a href="#丢失引号" class="headerlink" title="丢失引号"></a>丢失引号</h4><p>If we edit our script and remove the trailing quote from the argument following the first echo command:</p><p>如果我们编辑我们的脚本，并从跟随第一个 echo 命令的参数中，删除其末尾的双引号：</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=1if [ $number = 1 ]; then    echo &quot;Number is equal to 1.else    echo &quot;Number is not equal to 1.&quot;fi</code></pre><p>watch what happens:</p><p>观察发生了什么：</p><pre><code>[me@linuxbox ~]$ trouble/home/me/bin/trouble: line 10: unexpected EOF while looking formatching `&quot;&#39;/home/me/bin/trouble: line 13: syntax error: unexpected end of file</code></pre><p>It generates two errors. Interestingly, the line numbers reported are not where the missing quote was removed, but rather much later in the program. We can see why, if we follow the program after the missing quote. bash will continue looking for the closing quote until it finds one, which it does immediately after the second echo command. bash becomes very confused after that, and the syntax of the if command is broken because the fi statement is now inside a quoted (but open) string.</p><p>这个脚本产生了两个错误。有趣地是，所报告的行号不是引号被删除的地方，而是程序中后面的文本行。 我们能知道为什么，如果我们跟随丢失引号文本行之后的程序。bash 会继续寻找右引号，直到它找到一个， 其就是这个紧随第二个 echo 命令之后的引号。找到这个引号之后，bash 变得很困惑，并且 if 命令的语法 被破坏了，因为现在这个 fi 语句在一个用引号引起来的（但是开放的）字符串里面。</p><p>In long scripts, this kind of error can be quite hard to find. Using an editor with syntax highlighting will help. If a complete version of vim is installed, syntax highlighting can be enabled by entering the command:</p><p>在冗长的脚本中，此类错误很难找到。使用带有语法高亮的编辑器将会帮助查找错误。如果安装了 vim 的完整版， 通过输入下面的命令，可以使语法高亮生效：</p><pre><code>:syntax on</code></pre><h4 id="丢失或意外的标记"><a href="#丢失或意外的标记" class="headerlink" title="丢失或意外的标记"></a>丢失或意外的标记</h4><p>Another common mistake is forgetting to complete a compound command, such as if or while. Let’s look at what happens if we remove the semicolon after the test in the if command:</p><p>另一个常见错误是忘记补全一个复合命令，比如说 if 或者是 while。让我们看一下，如果 我们删除 if 命令中测试之后的分号，会出现什么情况：</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=1if [ $number = 1 ] then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fi</code></pre><p>The result is this:</p><p>结果是这样的：</p><pre><code>[me@linuxbox ~]$ trouble/home/me/bin/trouble: line 9: syntax error near unexpected token`else&#39;/home/me/bin/trouble: line 9: `else&#39;</code></pre><p>Again, the error message points to a error that occurs later than the actual problem. What happens is really pretty interesting. As we recall, if accepts a list of commands and evaluates the exit code of the last command in the list. In our program, we intend this list to consist of a single command, [, a synonym for test. The [ command takes what follows it as a list of arguments. In our case, three arguments: $number, =, and ]. With the semicolon removed, the word then is added to the list of arguments, which is syntactically legal. The following echo command is legal, too. It’s interpreted as another command in the list of commands that if will evaluate for an exit code. The else is encountered next, but it’s out of place, since the shell recognizes it as a reserved word (a word that has special meaning to the shell) and not the name of a command, hence the error message.</p><p>再次，错误信息指向一个错误，其出现的位置在实际问题所在的文本行的后面。所发生的事情真是相当有意思。我们记得， if 能够接受一系列命令，并且会计算列表中最后一个命令的退出代码。在我们的程序中，我们打算这个列表由 单个命令组成，即 [，测试的同义词。这个 [ 命令把它后面的东西看作是一个参数列表。在我们这种情况下， 有三个参数： $number，=，和 ]。由于删除了分号，单词 then 被添加到参数列表中，从语法上讲， 这是合法的。随后的 echo 命令也是合法的。它被解释为命令列表中的另一个命令，if 将会计算命令的 退出代码。接下来遇到单词 else，但是它出局了，因为 shell 把它认定为一个 保留字（对于 shell 有特殊含义的单词），而不是一个命令名，因此报告错误信息。</p><h4 id="预料不到的展开"><a href="#预料不到的展开" class="headerlink" title="预料不到的展开"></a>预料不到的展开</h4><p>It’s possible to have errors that only occur intermittently in a script. Sometimes the script will run fine and other times it will fail because of results of an expansion. If we return our missing semicolon and change the value of number to an empty variable, we can demonstrate:</p><p>可能有这样的错误，它们仅会间歇性地出现在一个脚本中。有时候这个脚本执行正常，其它时间会失败， 这是因为展开结果造成的。如果我们归还我们丢掉的分号，并把 number 的数值更改为一个空变量，我们 可以示范一下：</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=if [ $number = 1 ]; then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fi</code></pre><p>Running the script with this change results in the output:</p><p>运行这个做了修改的脚本，得到以下输出：</p><pre><code>[me@linuxbox ~]$ trouble/home/me/bin/trouble: line 7: [: =: unary operator expectedNumber is not equal to 1.</code></pre><p>We get this rather cryptic error message, followed by the output of the second echo command. The problem is the expansion of the number variable within the test command. When the command:</p><p>我们得到一个相当神秘的错误信息，其后是第二个 echo 命令的输出结果。这问题是由于 test 命令中 number 变量的展开结果造成的。当此命令：</p><pre><code>[ $number = 1 ]</code></pre><p>undergoes expansion with number being empty, the result is this:</p><p>经过展开之后，number 变为空值，结果就是这样：</p><pre><code>[  = 1 ]</code></pre><p>which is invalid and the error is generated. The = operator is a binary operator (it requires a value on each side), but the first value is missing, so the test command expects a unary operator (such as -z) instead. Further, since the test failed (because of the error), the if command receives a non-zero exit code and acts accordingly, and the second echo command is executed.</p><p>这是无效的，所以就产生了错误。这个 = 操作符是一个二元操作符（它要求每边都有一个数值），但是第一个数值是缺失的， 这样 test 命令就期望用一个一元操作符（比如 -z）来代替。进一步说，因为 test 命令运行失败了（由于错误）， 这个 if 命令接收到一个非零退出代码，因此执行第二个 echo 命令。</p><p>This problem can be corrected by adding quotes around the first argument in the test command:</p><p>通过为 test 命令中的第一个参数添加双引号，可以更正这个问题：</p><pre><code>[ &quot;$number&quot; = 1 ]</code></pre><p>Then when expansion occurs, the result will be this:</p><p>然后当展开操作发生地时候，执行结果将会是这样：</p><pre><code>[ &quot;&quot; = 1 ]</code></pre><p>which yields the correct number of arguments. In addition to empty strings, quotes should be used in cases where a value could expand into multi-word strings, as with filenames containing embedded spaces.</p><p>其得到了正确的参数个数。除了代表空字符串之外，引号应该被用于这样的场合，一个要展开 成多单词字符串的数值，及其包含嵌入式空格的文件名。</p><h3 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h3><p>Unlike syntactic errors, logical errors do not prevent a script from running. The script will run, but it will not produce the desired result, due to a problem with its logic. There are countless numbers of possible logical errors, but here are a few of the most common kinds found in scripts:</p><p>不同于语法错误，逻辑错误不会阻止脚本执行。虽然脚本会正常运行，但是它不会产生期望的结果， 归咎于脚本的逻辑问题。虽然有不计其数的可能的逻辑错误，但下面是一些在脚本中找到的最常见的 逻辑错误类型：</p><ol><li>Incorrect conditional expressions. It’s easy to incorrectly code an if/then/else and have the wrong logic carried out. Sometimes the logic will be reversed or it will be incomplete.</li><li>“Off by one” errors. When coding loops that employ counters, it is possible to overlook that the loop may require the counting start with zero, rather than one, for the count to conclude at the correct point. These kinds of errors result in either a loop “going off the end” by counting too far, or else missing the last iteration of the loop by terminating one iteration too soon.</li><li>Unanticipated situations. Most logic errors result from a program encountering data or situations that were unforeseen by the programmer. This can also include unanticipated expansions, such as a filename that contains embedded spaces that expands into multiple command arguments rather than a single filename.</li><li>不正确的条件表达式。很容易编写一个错误的 if/then/else 语句，并且执行错误的逻辑。 有时候逻辑会被颠倒，或者是逻辑结构不完整。</li><li>“超出一个值”错误。当编写带有计数器的循环语句的时候，为了计数在恰当的点结束，循环语句 可能要求从 0 开始计数，而不是从 1 开始，这有可能会被忽视。这些类型的错误要不导致循环计数太多，而“超出范围”， 要不就是过早的结束了一次迭代，从而错过了最后一次迭代循环。</li><li>意外情况。大多数逻辑错误来自于程序碰到了程序员没有预见到的数据或者情况。这也 可以包括出乎意料的展开，比如说一个包含嵌入式空格的文件名展开成多个命令参数而不是单个的文件名。</li></ol><h4 id="防错编程"><a href="#防错编程" class="headerlink" title="防错编程"></a>防错编程</h4><p>It is important to verify assumptions when programming. This means a careful evaluation of the exit status of programs and commands that are used by a script. Here is an example, based on a true story. An unfortunate system administrator wrote a script to perform a maintenance task on an important server. The script contained the following two lines of code:</p><p>当编程的时候，验证假设非常重要。这意味着要仔细地计算脚本所使用的程序和命令的退出状态。 这里有个基于一个真实的故事的实例。为了在一台重要的服务器中执行维护任务，一位不幸的系统管理员写了一个脚本。 这个脚本包含下面两行代码：</p><pre><code>cd $dir_namerm *</code></pre><p>There is nothing intrinsically wrong with these two lines, as long as the directory named in the variable, dir_name, exists. But what happens if it does not? In that case, the cd command fails, the script continues to the next line and deletes the files in the current working directory. Not the desired outcome at all! The hapless administrator destroyed an important part of the server because of this design decision.</p><p>从本质上来说，这两行代码没有任何问题，只要是变量 dir_name 中存储的目录名字存在就可以。但是如果不是这样会发生什么事情呢？在那种情况下，cd 命令会运行失败， 脚本会继续执行下一行代码，将会删除当前工作目录中的所有文件。完成不是期望的结果！ 由于这种设计策略，这个倒霉的管理员销毁了服务器中的一个重要部分。</p><p>Let’s look at some ways this design could be improved. First, it might be wise to make the execution of rm contingent on the success of cd:</p><p>让我们看一些能够提高这个设计的方法。首先，在 cd 命令执行成功之后，再运行 rm 命令，可能是明智的选择。</p><pre><code>cd $dir_name &amp;&amp; rm *</code></pre><p>This way, if the cd command fails, the rm command is not carried out. This is better, but still leaves open the possibility that the variable, dir_name, is unset or empty, which would result in the files in the user’s home directory being deleted. This could also be avoided by checking to see that dir_name actually contains the name of an existing directory:</p><p>这样，如果 cd 命令运行失败后，rm 命令将不会执行。这样比较好，但是仍然有可能未设置变量 dir_name 或其变量值为空，从而导致删除了用户家目录下面的所有文件。这个问题也能够避免，通过检验变量 dir_name 中包含的目录名是否真正地存在：</p><pre><code>[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; rm *</code></pre><p>Often, it is best to terminate the script with an error when an situation such as the one above occurs:</p><p>通常，当某种情况（比如上述问题）发生的时候，最好是终止脚本执行，并对这种情况提示错误信息：</p><pre><code>if [[ -d $dir_name ]]; then    if cd $dir_name; then        rm *    else        echo &quot;cannot cd to &#39;$dir_name&#39;&quot; &gt;&amp;2        exit 1    fielse    echo &quot;no such directory: &#39;$dir_name&#39;&quot; &gt;&amp;2    exit 1fi</code></pre><p>Here, we check both the name, to see that it is that of an existing directory, and the success of the cd command. If either fails, a descriptive error message is sent to standard error and the script terminates with an exit status of one to indicate a failure.</p><p>这里，我们检验了两种情况，一个名字，看看它是否为一个真正存在的目录，另一个是 cd 命令是否执行成功。 如果任一种情况失败，就会发送一个错误说明信息到标准错误，然后脚本终止执行，并用退出状态 1 表明脚本执行失败。</p><h4 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入"></a>验证输入</h4><p>A general rule of good programming is that if a program accepts input, it must be able to deal with anything it receives. This usually means that input must be carefully screened, to ensure that only valid input is accepted for further processing. We saw an example of this in the previous chapter when we studied the read command. One script contained the following test to verify a menu selection:</p><p>一个良好的编程习惯是如果一个程序可以接受输入数据，那么这个程序必须能够应对它所接受的任意数据。这 通常意味着必须非常仔细地筛选输入数据，以确保只有有效的输入数据才能被程序用来做进一步地处理。在前面章节 中我们学习 read 命令的时候，我们遇到过一个这样的例子。一个脚本中包含了下面一条测试语句， 用来验证一个选择菜单：</p><pre><code>[[ $REPLY =~ ^[0-3]$ ]]</code></pre><p>This test is very specific. It will only return a zero exit status if the string returned by the user is a numeral in the range of zero to three. Nothing else will be accepted. Sometimes these sorts of tests can be very challenging to write, but the effort is necessary to produce a high quality script.</p><p>这条测试语句非常明确。只有当用户输入是一个位于 0 到 3 范围内（包括 0 和 3）的数字的时候， 这条语句才返回一个 0 退出状态。而其它任何输入概不接受。有时候编写这类测试条件非常具有挑战性， 但是为了能产出一个高质量的脚本，付出还是必要的。</p><blockquote><p>Design Is A Function Of Time</p><p><em>设计是时间的函数</em></p><p>When I was a college student studying industrial design, a wise professor stated that the degree of design on a project was determined by the amount of time given to the designer. If you were given five minutes to design a device “that kills flies,” you designed a flyswatter. If you were given five months, you might come up with a laser-guided “anti-fly system” instead.</p><p>当我还是一名大学生，在学习工业设计的时候，一位明智的教授说过一个项目的设计程度是由 给定设计师的时间量来决定的。如果给你五分钟来设计一款能够 “杀死苍蝇” 的产品，你会设计出一个苍蝇拍。如果给你五个月的时间，你可能会制作出激光制导的 “反苍蝇系统”。</p><p>The same principle applies to programming. Sometimes a “quick and dirty” script will do if it’s only going to be used once and only used by the programmer. That kind of script is common and should be developed quickly to make the effort economical. Such scripts don’t need a lot of comments and defensive checks. On the other hand, if a script is intended for production use, that is, a script that will be used over and over for an important task or by multiple users, it needs much more careful development.</p><p>同样的原理适用于编程。有时候一个 “快速但粗糙” 的脚本就可以解决问题， 但这个脚本只能被其作者使用一次。这类脚本很常见，为了节省气力也应该被快速地开发出来。 所以这些脚本不需要太多的注释和防错检查。相反，如果一个脚本打算用于生产使用，也就是说， 某个重要任务或者多个客户会不断地用到它，此时这个脚本就需要非常谨慎小心地开发了。</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>Testing is an important step in every kind of software development, including scripts. There is a saying in the open source world, “release early, release often,” which reflects this fact. By releasing early and often, software gets more exposure to use and testing. Experience has shown that bugs are much easier to find, and much less expensive to fix, if they are found early in the development cycle.</p><p>在各类软件开发中（包括脚本），测试是一个重要的环节。在开源世界中有一句谚语，“早发布，常发布”，这句谚语就反映出这个事实（测试的重要性）。 通过提早和经常发布，软件能够得到更多曝光去使用和测试。经验表明如果在开发周期的早期发现 bug，那么这些 bug 就越容易定位，而且越能低成本 的修复。</p><p>In a previous discussion, we saw how stubs can be used to verify program flow. From the earliest stages of script development, they are a valuable technique to check the progress of our work.</p><p>在之前的讨论中，我们知道了如何使用 stubs 来验证程序流程。在脚本开发的最初阶段，它们是一项有价值的技术 来检测我们的工作进度。</p><p>Let’s look at the file deletion problem above and see how this could be coded for easy testing. Testing the original fragment of code would be dangerous, since its purpose is to delete files, but we could modify the code to make the test safe:</p><p>让我们看一下上面的文件删除问题，为了轻松测试，看看如何修改这些代码。测试原本那个代码片段将是危险的，因为它的目的是要删除文件， 但是我们可以修改代码，让测试安全：</p><pre><code>if [[ -d $dir_name ]]; then    if cd $dir_name; then        echo rm * # TESTING    else        echo &quot;cannot cd to &#39;$dir_name&#39;&quot; &gt;&amp;2        exit 1    fielse    echo &quot;no such directory: &#39;$dir_name&#39;&quot; &gt;&amp;2    exit 1fiexit # TESTING</code></pre><p>Since the error conditions already output useful messages, we don’t have to add any. The most important change is placing an echo command just before the rm command to allow the command and its expanded argument list to be displayed, rather than the command actually being executed. This change allows safe execution of the code. At the end of the code fragment, we place an exit command to conclude the test and prevent any other part of the script from being carried out. The need for this will vary according to the design of the script.</p><p>因为在满足出错条件的情况下代码可以打印出有用信息，所以我们没有必要再添加任何额外信息了。 最重要的改动是仅在 rm 命令之前放置了一个 echo 命令， 为的是把 rm 命令及其展开的参数列表打印出来，而不是执行实际的 rm 命令语句。这个改动可以安全的执行代码。 在这段代码的末尾，我们放置了一个 exit 命令来结束测试，从而防止执行脚本其它部分的代码。 这个需求会因脚本的设计不同而变化。</p><p>We also include some comments that act as “markers” for our test-related changes. These can be used to help find and remove the changes when testing is complete.</p><p>我们也在代码中添加了一些注释，用来标记与测试相关的改动。当测试完成之后，这些注释可以帮助我们找到并删除所有的更改。</p><h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h4><p>To perform useful testing, it’s important to develop and apply good test cases. This is done by carefully choosing input data or operating conditions that reflect edge and corner cases. In our code fragment (which is very simple), we want to know how the code performs under three specific conditions:</p><p>为了执行有用的测试，开发和使用好的测试案例是很重要的。这个要求可以通过谨慎地选择输入数据或者运行边缘案例和极端案例来完成。 在我们的代码片段中（是非常简单的代码），我们想要知道在下面的三种具体情况下这段代码是怎样执行的：</p><ol><li>dir_name contains the name of an existing directory</li><li>dir_name contains the name of a non-existent directory</li><li>dir_name is empty</li><li>dir_name 包含一个已经存在的目录的名字</li><li>dir_name 包含一个不存在的目录的名字</li><li>dir_name 为空</li></ol><p>By performing the test with each of these conditions, good test coverage is achieved.</p><p>通过执行以上每一个测试条件，就达到了一个良好的测试覆盖率。</p><p>Just as with design, testing is a function of time, as well. Not every script feature needs to be extensively tested. It’s really a matter of determining what is most important. Since it could be so potentially destructive if it malfunctioned, our code fragment deserves careful consideration during both its design and testing.</p><p>正如设计，测试也是一个时间的函数。不是每一个脚本功能都需要做大量的测试。问题关键是确定什么功能是最重要的。因为 测试若发生故障会存在如此潜在的破坏性，所以我们的代码片在设计和测试段期间都应值得仔细推敲。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>If testing reveals a problem with a script, the next step is debugging. “A problem” usually means that the script is, in some way, not performing to the programmers expectations. If this is the case, we need to carefully determine exactly what the script is actually doing and why. Finding bugs can sometimes involve a lot of detective work. A well designed script will try to help. It should be programmed defensively, to detect abnormal conditions and provide useful feedback to the user. Sometimes, however, problems are quite strange and unexpected and more involved techniques are required.</p><p>如果测试暴露了脚本中的一个问题，那下一步就是调试了。“一个问题”通常意味着在某种情况下，这个脚本的执行 结果不是程序员所期望的结果。若是这种情况，我们需要仔细确认这个脚本实际到底要完成什么任务，和为什么要这样做。 有时候查找 bug 要牵涉到许多监测工作。一个设计良好的脚本会对查找错误有帮助。设计良好的脚本应该具备防卫能力， 能够监测异常条件，并能为用户提供有用的反馈信息。 然而有时候，出现的问题相当稀奇，出人意料，这时候就需要更多的调试技巧了。</p><h4 id="找到问题区域"><a href="#找到问题区域" class="headerlink" title="找到问题区域"></a>找到问题区域</h4><p>In some scripts, particularly long ones, it is sometimes useful to isolate the area of the script that is related to the problem. This won’t always be the actual error, but isolation will often provide insights into the actual cause. One technique that can be used to isolate code is “commenting out” sections a script. For example, our file deletion fragment could be modified to determine if the removed section was related to an error:</p><p>在一些脚本中，尤其是一些代码比较长的脚本，有时候隔离脚本中与出现的问题相关的代码区域对查找问题很有帮助。 隔离的代码区域并不总是真正的错误所在，但是隔离往往可以深入了解实际的错误原因。可以用来隔离代码的一项 技巧是“添加注释”。例如，我们的文件删除代码可以修改成这样，从而决定注释掉的这部分代码是否导致了一个错误：</p><pre><code>if [[ -d $dir_name ]]; then    if cd $dir_name; then        rm *    else        echo &quot;cannot cd to &#39;$dir_name&#39;&quot; &gt;&amp;2        exit 1    fi# else# echo &quot;no such directory: &#39;$dir_name&#39;&quot; &gt;&amp;2# exit 1fi</code></pre><p>By placing comment symbols at the beginning of each line in a logical section of a script, we prevent that section from being executed. Testing can then be performed again, to see if the removal of the code has any impact on the behavior of the bug.</p><p>通过给脚本中的一个逻辑区块内的每条语句的开头添加一个注释符号，我们就阻止了这部分代码的执行。然后可以再次执行测试， 来看看清除的代码是否影响了错误的行为。</p><h4 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h4><p>Bugs are often cases of unexpected logical flow within a script. That is, portions of the script are either never being executed, or are being executed in the wrong order or at the wrong time. To view the actual flow of the program, we use a technique called tracing.</p><p>在一个脚本中，错误往往是由意想不到的逻辑流导致的。也就是说，脚本中的一部分代码或者从未执行，或是以错误的顺序， 或在错误的时间给执行了。为了查看真实的程序流，我们使用一项叫做追踪（tracing）的技术。</p><p>One tracing method involves placing informative messages in a script that display the location of execution. We can add messages to our code fragment:</p><p>一种追踪方法涉及到在脚本中添加可以显示程序执行位置的提示性信息。我们可以添加提示信息到我们的代码片段中：</p><pre><code>echo &quot;preparing to delete files&quot; &gt;&amp;2if [[ -d $dir_name ]]; then    if cd $dir_name; thenecho &quot;deleting files&quot; &gt;&amp;2        rm *    else        echo &quot;cannot cd to &#39;$dir_name&#39;&quot; &gt;&amp;2        exit 1    fielse    echo &quot;no such directory: &#39;$dir_name&#39;&quot; &gt;&amp;2    exit 1fiecho &quot;file deletion complete&quot; &gt;&amp;2</code></pre><p>We send the messages to standard error to separate them from normal output. We also do not indent the lines containing the messages, so it is easier to find when it’s time to remove them.</p><p>我们把提示信息输出到标准错误输出，让其从标准输出中分离出来。我们也没有缩进包含提示信息的语句，这样 想要删除它们的时候，能比较容易找到它们。</p><p>Now when the script is executed, it’s possible to see that the file deletion has been performed:</p><p>当这个脚本执行的时候，就可能看到文件删除操作已经完成了：</p><pre><code>[me@linuxbox ~]$ deletion-scriptpreparing to delete filesdeleting filesfile deletion complete[me@linuxbox ~]$</code></pre><p>bash also provides a method of tracing, implemented by the -x option and the set command with the -x option. Using our earlier trouble script, we can activate tracing for the entire script by adding the -x option to the first line:</p><p>bash 还提供了一种名为追踪的方法，这种方法可通过 -x 选项和 set 命令加上 -x 选项两种途径实现。 拿我们之前的 trouble 脚本为例，给该脚本的第一行语句添加 -x 选项，我们就能追踪整个脚本。</p><pre><code>#!/bin/bash -x# trouble: script to demonstrate common errorsnumber=1if [ $number = 1 ]; then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fi</code></pre><p>When executed, the results look like this:</p><p>当脚本执行后，输出结果看起来像这样:</p><pre><code>[me@linuxbox ~]$ trouble+ number=1+ &#39;[&#39; 1 = 1 &#39;]&#39;+ echo &#39;Number is equal to 1.&#39;Number is equal to 1.</code></pre><p>With tracing enabled, we see the commands performed with expansions applied. The leading plus signs indicate the display of the trace to distinguish them from lines of regular output. The plus sign is the default character for trace output. It is contained in the PS4 (prompt string 4) shell variable. The contents of this variable can be adjusted to make the prompt more useful. Here, we modify the contents of the variable to include the current line number in the script where the trace is performed. Note that single quotes are required to prevent expansion until the prompt is actually used:</p><p>追踪生效后，我们看到脚本命令展开后才执行。行首的加号表明追踪的迹象，使其与常规输出结果区分开来。 加号是追踪输出的默认字符。它包含在 PS4（提示符4）shell 变量中。可以调整这个变量值让提示信息更有意义。 这里，我们修改该变量的内容，让其包含脚本中追踪执行到的当前行的行号。注意这里必须使用单引号是为了防止变量展开，直到 提示符真正使用的时候，就不需要了。</p><pre><code>[me@linuxbox ~]$ export PS4=&#39;$LINENO + &#39;[me@linuxbox ~]$ trouble5 + number=17 + &#39;[&#39; 1 = 1 &#39;]&#39;8 + echo &#39;Number is equal to 1.&#39;Number is equal to 1.</code></pre><p>To perform a trace on a selected portion of a script, rather than the entire script, we can use the set command with the -x option:</p><p>我们可以使用 set 命令加上 -x 选项，为脚本中的一块选择区域，而不是整个脚本启用追踪。</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=1set -x # Turn on tracingif [ $number = 1 ]; then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fiset +x # Turn off tracing</code></pre><p>We use the set command with the -x option to activate tracing and the +x option to deactivate tracing. This technique can be used to examine multiple portions of a troublesome script.</p><p>我们使用 set 命令加上 -x 选项来启动追踪，+x 选项关闭追踪。这种技术可以用来检查一个有错误的脚本的多个部分。</p><h4 id="执行时检查数值"><a href="#执行时检查数值" class="headerlink" title="执行时检查数值"></a>执行时检查数值</h4><p>It is often useful, along with tracing, to display the content of variables to see the internal workings of a script while it is being executed. Applying additional echo statements will usually do the trick:</p><p>伴随着追踪，在脚本执行的时候显示变量的内容，以此知道脚本内部的工作状态，往往是很用的。 使用额外的 echo 语句通常会奏效。</p><pre><code>#!/bin/bash# trouble: script to demonstrate common errorsnumber=1echo &quot;number=$number&quot; # DEBUGset -x # Turn on tracingif [ $number = 1 ]; then    echo &quot;Number is equal to 1.&quot;else    echo &quot;Number is not equal to 1.&quot;fiset +x # Turn off tracing</code></pre><p>In this trivial example, we simply display the value of the variable number and mark the added line with a comment to facilitate its later identification and removal. This technique is particularly useful when watching the behavior of loops and arithmetic within scripts.</p><p>在这个简单的示例中，我们只是显示变量 number 的数值，并为其添加注释，随后利于其识别和清除。 当查看脚本中的循环和算术语句的时候，这种技术特别有用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>In this chapter, we looked at just a few of the problems that can crop up during script de- velopment. Of course, there are many more. The techniques described here will enable finding most common bugs. Debugging is a fine art that can be developed through experience, both in knowing how to avoid bugs (testing constantly throughout development) and in finding bugs (effective use of tracing).</p><p>在这一章中，我们仅仅看了几个在脚本开发期间会出现的问题。当然，还有很多。这章中描述的技术对查找 大多数的常见错误是有效的。调试是一种艺术，可以通过开发经验，在知道如何避免错误(整个开发过程中不断测试) 以及在查找 bug（有效利用追踪）两方面都会得到提升。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Wikipedia has a couple of short articles on syntactic and logical errors:</p></li><li><p>Wikipedia 上面有两篇关于语法和逻辑错误的短文：</p><p><a href="http://en.wikipedia.org/wiki/Syntax_error" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Syntax_error</a></p><p><a href="http://en.wikipedia.org/wiki/logic_error" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/logic_error</a></p></li><li><p>There are many online resources for the technical aspects of bash programming:</p></li><li><p>网上有很多关于技术层面的 bash 编程的资源：</p><p><a href="http://mywiki.wooledge.org/BashPitfalls" target="_blank" rel="noopener">http://mywiki.wooledge.org/BashPitfalls</a></p><p><a href="http://tldp.org/LDP/abs/html/gotchas.html" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/gotchas.html</a></p><p><a href="http://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html</a></p></li><li><p>Eric Raymond’s <code>The Art of Unix Programming</code> is a great resource for learning the basic concepts found in well-written Unix programs. Many of these ideas apply to shell scripts:</p></li><li><p>想要学习从编写良好的 Unix 程序中得知的基本概念，可以参考 Eric Raymond 的《Unix 编程的艺术》这本 伟大的著作。书中的许多想法都能适用于 shell 脚本：</p><p><a href="http://www.faqs.org/docs/artu/" target="_blank" rel="noopener">http://www.faqs.org/docs/artu/</a></p><p><a href="http://www.faqs.org/docs/artu/ch01s06.html" target="_blank" rel="noopener">http://www.faqs.org/docs/artu/ch01s06.html</a></p></li><li><p>For really heavy-duty debugging, there is the Bash Debugger:</p></li><li><p>对于真正的高强度的调试，参考这个 Bash Debugger：</p><p><a href="http://bashdb.sourceforge.net/" target="_blank" rel="noopener">http://bashdb.sourceforge.net/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三十章 流程控制：while/until循环</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Awhile-until%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Awhile-until%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>In the previous chapter, we developed a menu-driven program to produce various kinds of system information. The program works, but it still has a significant usability problem. It only executes a single choice and then terminates. Even worse, if an invalid selection is made, the program terminates with an error, without giving the user an opportunity to try again. It would be better if we could somehow construct the program so that it could repeat the menu display and selection over and over, until the user chooses to exit the program.</p><p>在前面的章节中，我们开发了菜单驱动程序，来产生各种各样的系统信息。虽然程序能够运行， 但它仍然存在重大的可用性问题。它只能执行单一的选择，然后终止。更糟糕地是，如果做了一个 无效的选择，程序会以错误终止，而没有给用户提供再试一次的机会。如果我们能构建程序， 以致于程序能够重复显示菜单，而且能一次又一次的选择，直到用户选择退出程序，这样的程序会更好一些。</p><p>In this chapter, we will look at a programming concept called looping, which can be used to make portions of programs repeat. The shell provides three compound commands for looping. We will look at two of them in this chapter, and the third in a later one.</p><p>在这一章中，我们将看一个叫做循环的程序概念，其可用来使程序的某些部分重复。shell 为循环提供了三个复合命令。 本章我们将查看其中的两个命令，随后章节介绍第三个命令。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Daily life is full of repeated activities. Going to work each day, walking the dog, slicing a carrot are all tasks that involve repeating a series of steps. Let’s consider slicing a carrot. If we express this activity in pseudocode, it might look something like this:</p><p>日常生活中充满了重复性的活动。每天去散步，遛狗，切胡萝卜，所有任务都要重复一系列的步骤。 让我们以切胡萝卜为例。如果我们用伪码表达这种活动，它可能看起来像这样：</p><ol><li>get cutting board</li><li>get knife</li><li>place carrot on cutting board</li><li>lift knife</li><li>advance carrot</li><li>slice carrot</li><li>if entire carrot sliced, then quit, else go to step 4</li><li>准备切菜板</li><li>准备菜刀</li><li>把胡萝卜放到切菜板上</li><li>提起菜刀</li><li>向前推进胡萝卜</li><li>切胡萝卜</li><li>如果切完整个胡萝卜，就退出，要不然回到第四步继续执行</li></ol><p>Steps 4 through 7 form a loop. The actions within the loop are repeated until the condition, “entire carrot sliced,” is reached.</p><p>从第四步到第七步形成一个循环。重复执行循环内的动作直到满足条件“切完整个胡萝卜”。</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>bash can express a similar idea. Let’s say we wanted to display five numbers in sequential order from one to five. a bash script could be constructed as follows:</p><p>bash 能够表达相似的想法。比方说我们想要按照顺序从1到5显示五个数字。可如下构造一个 bash 脚本：</p><pre><code>#!/bin/bash# while-count: display a series of numberscount=1while [ $count -le 5 ]; do    echo $count    count=$((count + 1))doneecho &quot;Finished.&quot;</code></pre><p>When executed, this script displays the following:</p><p>当执行的时候，这个脚本显示如下信息：</p><pre><code>[me@linuxbox ~]$ while-count12345Finished.</code></pre><p>The syntax of the <code>while</code> command is:</p><p>while 命令的语法是：</p><pre><code>while commands; do commands; done</code></pre><p>Like <code>if</code>, <code>while</code> evaluates the exit status of a list of commands. As long as the exit status is zero, it performs the commands inside the loop. In the script above, the variable <code>count</code> is created and assigned an initial value of 1. The <code>while</code> command evaluates the exit status of the <code>test</code> command. As long as the <code>test</code> command returns an exit status of zero, the commands within the loop are executed. At the end of each cycle, the test command is repeated. After six iterations of the loop, the value of <code>count</code> has increased to six, the <code>test</code> command no longer returns an exit status of zero and the loop terminates. The program continues with the next statement following the loop.</p><p>和 if 一样， while 计算一系列命令的退出状态。只要退出状态为零，它就执行循环内的命令。 在上面的脚本中，创建了变量 count ，并初始化为1。 while 命令将会计算 test 命令的退出状态。 只要 test 命令返回退出状态零，循环内的所有命令就会执行。每次循环结束之后，会重复执行 test 命令。 第六次循环之后， count 的数值增加到6， test 命令不再返回退出状态零，且循环终止。 程序继续执行循环之后的语句。</p><p>We can use a <code>while</code> loop to improve the read-menu program from the previous chapter:</p><p>我们可以使用一个 while 循环，来提高前面章节的 read-menu 程序：</p><pre><code>#!/bin/bash# while-menu: a menu driven system information programDELAY=3 # Number of seconds to display resultswhile [[ $REPLY != 0 ]]; do    clear    cat &lt;&lt;- _EOF_        Please Select:        1. Display System Information        2. Display Disk Space        3. Display Home Space Utilization        0. Quit    _EOF_    read -p &quot;Enter selection [0-3] &gt; &quot;    if [[ $REPLY =~ ^[0-3]$ ]]; then        if [[ $REPLY == 1 ]]; then            echo &quot;Hostname: $HOSTNAME&quot;            uptime            sleep $DELAY        fi        if [[ $REPLY == 2 ]]; then            df -h            sleep $DELAY        fi        if [[ $REPLY == 3 ]]; then            if [[ $(id -u) -eq 0 ]]; then                echo &quot;Home Space Utilization (All Users)&quot;                du -sh /home/*            else                echo &quot;Home Space Utilization ($USER)&quot;                du -sh $HOME            fi            sleep $DELAY        fi    else        echo &quot;Invalid entry.&quot;        sleep $DELAY    fidoneecho &quot;Program terminated.&quot;</code></pre><p>By enclosing the menu in a <code>while</code> loop, we are able to have the program repeat the menu display after each selection. The loop continues as long as <code>REPLY</code> is not equal to “0” and the menu is displayed again, giving the user the opportunity to make another selection. At the end of each action, a <code>sleep</code> command is executed so the program will pause for a few seconds to allow the results of the selection to be seen before the screen is cleared and the menu is redisplayed. Once <code>REPLY</code> is equal to “0,” indicating the “quit” selection, the loop terminates and execution continues with the line following <code>done</code>.</p><p>通过把菜单包含在 while 循环中，每次用户选择之后，我们能够让程序重复显示菜单。只要 REPLY 不 等于”0”，循环就会继续，菜单就能显示，从而用户有机会重新选择。每次动作完成之后，会执行一个 sleep 命令，所以在清空屏幕和重新显示菜单之前，程序将会停顿几秒钟，为的是能够看到选项输出结果。 一旦 REPLY 等于“0”，则表示选择了“退出”选项，循环就会终止，程序继续执行 done 语句之后的代码。</p><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><p>bash provides two builtin commands that can be used to control program flow inside loops. The <code>break</code> command immediately terminates a loop, and program control resumes with the next statement following the loop. The <code>continue</code> command causes the remainder to the loop to be skipped, and program control resumes with the next iteration of the loop. Here we see a version of the while-menu program incorporating both <code>break</code> and <code>continue</code>:</p><p>bash 提供了两个内部命令，它们可以用来在循环内部控制程序流程。 break 命令立即终止一个循环， 且程序继续执行循环之后的语句。 continue 命令导致程序跳过循环中剩余的语句，且程序继续执行 下一次循环。这里我们看看采用了 break 和 continue 两个命令的 while-menu 程序版本：</p><pre><code>#!/bin/bash# while-menu2: a menu driven system information programDELAY=3 # Number of seconds to display resultswhile true; do    clear    cat &lt;&lt;- _EOF_        Please Select:        1. Display System Information        2. Display Disk Space        3. Display Home Space Utilization        0. Quit    _EOF_    read -p &quot;Enter selection [0-3] &gt; &quot;    if [[ $REPLY =~ ^[0-3]$ ]]; then        if [[ $REPLY == 1 ]]; then            echo &quot;Hostname: $HOSTNAME&quot;            uptime            sleep $DELAY            continue        fi        if [[ $REPLY == 2 ]]; then            df -h            sleep $DELAY            continue        fi        if [[ $REPLY == 3 ]]; then            if [[ $(id -u) -eq 0 ]]; then                echo &quot;Home Space Utilization (All Users)&quot;                du -sh /home/*            else                echo &quot;Home Space Utilization ($USER)&quot;                du -sh $HOME            fi            sleep $DELAY            continue        fi        if [[ $REPLY == 0 ]]; then            break        fi    else        echo &quot;Invalid entry.&quot;        sleep $DELAY    fidoneecho &quot;Program terminated.&quot;</code></pre><p>In this version of the script, we set up an endless loop (one that never terminates on its own) by using the true command to supply an exit status to while. Since true will always exit with a exit status of zero, the loop will never end. This is a surprisingly common scripting technique. Since the loop will never end on its own, it’s up to the programmer to provide some way to break out of the loop when the time is right. In this script, the <code>break</code> command is used to exit the loop when the “0” selection is chosen. The <code>continue</code> command has been included at the end of the other script choices to allow for more efficient execution. By using <code>continue</code>, the script will skip over code that is not needed when a selection is identified. For example, if the “1” selection is chosen and identified, there is no reason to test for the other selections.</p><p>在这个脚本版本中，我们设置了一个无限循环（就是自己永远不会终止的循环），通过使用 true 命令 为 while 提供一个退出状态。因为 true 的退出状态总是为零，所以循环永远不会终止。这是一个 令人惊讶的通用脚本编程技巧。因为循环自己永远不会结束，所以由程序员在恰当的时候提供某种方法来跳出循环。 此脚本，当选择”0”选项的时候，break 命令被用来退出循环。continue 命令被包含在其它选择动作的末尾， 来提高程序执行的效率。通过使用 continue 命令，当一个选项确定后，程序会跳过不需执行的其他代码。例如， 如果选择了选项”1”，则没有理由去测试其它选项。</p><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p>The <code>until</code> command is much like <code>while</code>, except instead of exiting a loop when a non- zero exit status is encountered, it does the opposite. An <code>until</code> loop continues until it receives a zero exit status. In our while-count script, we continued the loop as long as the value of the <code>count</code> variable was less than or equal to five. We could get the same result by coding the script with <code>until</code>:</p><p>until 命令与 while 非常相似，除了当遇到一个非零退出状态的时候， while 退出循环， 而 until 不退出。一个 until 循环会继续执行直到它接受了一个退出状态零。在我们的 while-count 脚本中， 我们继续执行循环直到 count 变量的数值小于或等于5。我们可以得到相同的结果，通过在脚本中使用 until 命令：</p><pre><code>#!/bin/bash# until-count: display a series of numberscount=1until [ $count -gt 5 ]; do    echo $count    count=$((count + 1))doneecho &quot;Finished.&quot;</code></pre><p>By changing the test expression to <code>$count -gt 5</code>, until will terminate the loop at the correct time. The decision of whether to use the <code>while</code> or <code>until</code> loop is usually a matter of choosing the one that allows the clearest <code>test</code> to be written.</p><p>通过把 test 表达式更改为 $count -gt 5 ， until 会在正确的时间终止循环。至于使用 while 循环 还是 until 循环，通常是选择其 test 判断条件最容易写的那种。</p><h3 id="使用循环读取文件"><a href="#使用循环读取文件" class="headerlink" title="使用循环读取文件"></a>使用循环读取文件</h3><p><code>while</code> and <code>until</code> can process standard input. This allows files to be processed with <code>while</code> and <code>until</code> loops. In the following example, we will display the contents of the distros.txt file used in earlier chapters:</p><p>while 和 until 能够处理标准输入。这就可以使用 while 和 until 处理文件。在下面的例子中， 我们将显示在前面章节中使用的 distros.txt 文件的内容：</p><pre><code>#!/bin/bash# while-read: read lines from a filewhile read distro version release; do    printf &quot;Distro: %s\tVersion: %s\tReleased: %s\n&quot; \        $distro \        $version \        $releasedone &lt; distros.txt</code></pre><p>To redirect a file to the loop, we place the redirection operator after the <code>done</code> statement. The loop will use <code>read</code> to input the fields from the redirected file. The <code>read</code> command will exit after each line is read, with a zero exit status until the end-of-file is reached. At that point, it will exit with a non-zero exit status, thereby terminating the loop. It is also possible to pipe standard input into a loop:</p><p>为了重定向文件到循环中，我们把重定向操作符放置到 done 语句之后。循环将使用 read 从重定向文件中读取 字段。这个 read 命令读取每个文本行之后，将会退出，其退出状态为零，直到到达文件末尾。到时候，它的 退出状态为非零数值，因此终止循环。也有可能把标准输入管道到循环中。</p><pre><code>#!/bin/bash# while-read2: read lines from a filesort -k 1,1 -k 2n distros.txt | while read distro version release; do    printf &quot;Distro: %s\tVersion: %s\tReleased: %s\n&quot; \        $distro \        $version \        $releasedone</code></pre><p>Here we take the output of the <code>sort</code> command and display the stream of text. However, it is important to remember that since a pipe will execute the loop in a subshell, any variables created or assigned within the loop will be lost when the loop terminates.</p><p>这里我们接受 sort 命令的标准输出，然后显示文本流。然而，因为管道将会在子 shell 中执行 循环，当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失，记住这一点很重要。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>With the introduction of loops, and our previous encounters with branching, subroutines and sequences, we have covered the major types of flow control used in programs. bash has some more tricks up its sleeve, but they are refinements on these basic concepts.</p><p>通过引入循环和我们之前遇到的分支、子例程和序列，我们已经介绍了程序流程控制的主要类型。 bash 还有一些锦囊妙计，但它们都是关于这些基本概念的完善。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Bash Guide for Beginners from the Linux Documentation Project has some more examples of while loops:</p></li><li><p>Linux 文档工程中的 Bash 初学者指南一书中介绍了更多的 while 循环实例：</p><p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html" target="_blank" rel="noopener">http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html</a></p></li><li><p>The Wikipedia has an article on loops, which is part of a larger article on flow control:</p></li><li><p>Wikipedia 中有一篇关于循环的文章，其是一篇比较长的关于流程控制的文章中的一部分：</p><p><a href="http://en.wikipedia.org/wiki/Control_flow#Loops" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Control_flow#Loops</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十九章 读取键盘输入</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AB%A0-%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AB%A0-%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>The scripts we have written so far lack a feature common in most computer programs — interactivity. That is, the ability of the program to interact with the user. While many programs don’t need to be interactive, some programs benefit from being able to accept input directly from the user. Take, for example, this script from the previous chapter:</p><p>到目前为止我们编写的脚本都缺乏一项在大多数计算机程序中都很常见的功能－交互性。也就是， 程序与用户进行交互的能力。虽然许多程序不必是可交互的，但一些程序却得到益处，能够直接 接受用户的输入。以这个前面章节中的脚本为例：</p><pre><code>#!/bin/bash# test-integer2: evaluate the value of an integer.INT=-5if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then    if [ $INT -eq 0 ]; then        echo &quot;INT is zero.&quot;    else        if [ $INT -lt 0 ]; then            echo &quot;INT is negative.&quot;        else            echo &quot;INT is positive.&quot;        fi        if [ $((INT % 2)) -eq 0 ]; then            echo &quot;INT is even.&quot;        else        echo &quot;INT is odd.&quot;        fi    fielse    echo &quot;INT is not an integer.&quot; &gt;&amp;2    exit 1fi</code></pre><p>Each time we want to change the value of <code>INT</code>, we have to edit the script. It would be much more useful if the script could ask the user for a value. In this chapter, we will begin to look at how we can add interactivity to our programs.</p><p>每次我们想要改变 INT 数值的时候，我们必须编辑这个脚本。如果脚本能请求用户输入数值，那 么它会更加有用处。在这个脚本中，我们将看一下我们怎样给程序增加交互性功能。</p><h3 id="read-从标准输入读取数值"><a href="#read-从标准输入读取数值" class="headerlink" title="read - 从标准输入读取数值"></a>read - 从标准输入读取数值</h3><p>The read builtin command is used to read a single line of standard input. This command can be used to read keyboard input or, when redirection is employed, a line of data from a file. The command has the following syntax:</p><p>这个 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用 重定向的时候，读取文件中的一行数据。这个命令有以下语法形式：</p><pre><code>read [-options] [variable...]</code></pre><p>where options is one or more of the available options listed below and variable is the name of one or more variables used to hold the input value. If no variable name is supplied, the shell variable REPLY contains the line of data.</p><p>这里的 options 是下面列出的可用选项中的一个或多个，且 variable 是用来存储输入数值的一个或多个变量名。 如果没有提供变量名，shell 变量 REPLY 会包含数据行。</p><p>Basically, <code>read</code> assigns fields from standard input to the specified variables. If we modify our integer evaluation script to use <code>read</code>, it might look like this:</p><p>基本上，read 会把来自标准输入的字段赋值给具体的变量。如果我们修改我们的整数求值脚本，让其使用 read ，它可能看起来像这样：</p><pre><code>#!/bin/bash# read-integer: evaluate the value of an integer.echo -n &quot;Please enter an integer -&gt; &quot;read intif [[ &quot;$int&quot; =~ ^-?[0-9]+$ ]]; then    if [ $int -eq 0 ]; then        echo &quot;$int is zero.&quot;    else        if [ $int -lt 0 ]; then            echo &quot;$int is negative.&quot;        else            echo &quot;$int is positive.&quot;        fi        if [ $((int % 2)) -eq 0 ]; then            echo &quot;$int is even.&quot;        else            echo &quot;$int is odd.&quot;        fi    fielse    echo &quot;Input value is not an integer.&quot; &gt;&amp;2    exit 1fi</code></pre><p>We use <code>echo</code> with the <code>-n</code> option (which suppresses the trailing newline on output) to display a prompt, then use <code>read</code> to input a value for the variable int. Running this script results in this:</p><p>我们使用带有 -n 选项（其会删除输出结果末尾的换行符）的 echo 命令，来显示提示信息， 然后使用 read 来读入变量 int 的数值。运行这个脚本得到以下输出：</p><pre><code>[me@linuxbox ~]$ read-integerPlease enter an integer -&gt; 55 is positive.5 is odd.</code></pre><p>read can assign input to multiple variables, as shown in this script:</p><p>read 可以给多个变量赋值，正如下面脚本中所示：</p><pre><code>#!/bin/bash# read-multiple: read multiple values from keyboardecho -n &quot;Enter one or more values &gt; &quot;read var1 var2 var3 var4 var5echo &quot;var1 = &#39;$var1&#39;&quot;echo &quot;var2 = &#39;$var2&#39;&quot;echo &quot;var3 = &#39;$var3&#39;&quot;echo &quot;var4 = &#39;$var4&#39;&quot;echo &quot;var5 = &#39;$var5&#39;&quot;</code></pre><p>In this script, we assign and display up to five values. Notice how <code>read</code> behaves when given different numbers of values:</p><p>在这个脚本中，我们给五个变量赋值并显示其结果。注意当给定不同个数的数值后，read 怎样操作：</p><pre><code>[me@linuxbox ~]$ read-multipleEnter one or more values &gt; a b c d evar1 = &#39;a&#39;var2 = &#39;b&#39;var3 = &#39;c&#39;var4 = &#39;d&#39;var5 = &#39;e&#39;[me@linuxbox ~]$ read-multipleEnter one or more values &gt; avar1 = &#39;a&#39;var2 = &#39;&#39;var3 = &#39;&#39;var4 = &#39;&#39;var5 = &#39;&#39;[me@linuxbox ~]$ read-multipleEnter one or more values &gt; a b c d e f gvar1 = &#39;a&#39;var2 = &#39;b&#39;var3 = &#39;c&#39;var4 = &#39;d&#39;var5 = &#39;e f g&#39;</code></pre><p>If <code>read</code> receives fewer than the expected number, the extra variables are empty, while an excessive amount of input results in the final variable containing all of the extra input. If no variables are listed after the read command, a shell variable, <code>REPLY</code>, will be assigned all the input:</p><p>如果 read 命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入数据则会 被包含到最后一个变量中。如果 read 命令之后没有列出变量名，则一个 shell 变量，REPLY，将会包含 所有的输入：</p><pre><code>#!/bin/bash# read-single: read multiple values into default variableecho -n &quot;Enter one or more values &gt; &quot;readecho &quot;REPLY = &#39;$REPLY&#39;&quot;</code></pre><p>Running this script results in this:</p><p>这个脚本的输出结果是：</p><pre><code>[me@linuxbox ~]$ read-singleEnter one or more values &gt; a b c dREPLY = &#39;a b c d&#39;</code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p><code>read</code> supports the following options:</p><p>read 支持以下选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-a array</td><td align="left">Assign the input to array, starting with index zero. We will cover arrays in Chapter 36.</td></tr><tr><td align="left">-d delimiter</td><td align="left">The first character in the string delimiter is used to indicate end of input, rather than a newline character.</td></tr><tr><td align="left">-e</td><td align="left">Use Readline to handle input. This permits input editing in the same manner as the command line.</td></tr><tr><td align="left">-n num</td><td align="left">Read num characters of input, rather than an entire line.</td></tr><tr><td align="left">-p prompt</td><td align="left">Display a prompt for input using the string prompt.</td></tr><tr><td align="left">-r</td><td align="left">Raw mode. Do not interpret backslash characters as escapes.</td></tr><tr><td align="left">-s</td><td align="left">Silent mode. Do not echo characters to the display as they are typed. This is useful when inputting passwords and other confidential information.</td></tr><tr><td align="left">-t seconds</td><td align="left">Timeout. Terminate input after seconds. read returns a non-zero exit status if an input times out.</td></tr><tr><td align="left">-u fd</td><td align="left">Use input from file descriptor fd, rather than standard input.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-a array</td><td align="left">把输入赋值到数组 array 中，从索引号零开始。我们 将在第36章中讨论数组问题。</td></tr><tr><td align="left">-d delimiter</td><td align="left">用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。</td></tr><tr><td align="left">-e</td><td align="left">使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。</td></tr><tr><td align="left">-n num</td><td align="left">读取 num 个输入字符，而不是整行。</td></tr><tr><td align="left">-p prompt</td><td align="left">为输入显示提示信息，使用字符串 prompt。</td></tr><tr><td align="left">-r</td><td align="left">Raw mode. 不把反斜杠字符解释为转义字符。</td></tr><tr><td align="left">-s</td><td align="left">Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。</td></tr><tr><td align="left">-t seconds</td><td align="left">超时. 几秒钟后终止输入。若输入超时，read 会返回一个非零退出状态。</td></tr><tr><td align="left">-u fd</td><td align="left">使用文件描述符 fd 中的输入，而不是标准输入。</td></tr></tbody></table><p>Using the various options, we can do interesting things with read. For example, with the -p option, we can provide a prompt string:</p><p>使用各种各样的选项，我们能用 read 完成有趣的事情。例如，通过-p 选项，我们能够提供提示信息：</p><pre><code>#!/bin/bash# read-single: read multiple values into default variableread -p &quot;Enter one or more values &gt; &quot;echo &quot;REPLY = &#39;$REPLY&#39;&quot;</code></pre><p>With the -t and -s options we can write a script that reads “secret” input and times out if the input is not completed in a specified time:</p><p>通过 -t 和 -s 选项，我们可以编写一个这样的脚本，读取“秘密”输入，并且如果在特定的时间内 输入没有完成，就终止输入。</p><pre><code>#!/bin/bash# read-secret: input a secret pass phraseif read -t 10 -sp &quot;Enter secret pass phrase &gt; &quot; secret_pass; then    echo &quot;\nSecret pass phrase = &#39;$secret_pass&#39;&quot;else    echo &quot;\nInput timed out&quot; &gt;&amp;2    exit 1fi</code></pre><p>The script prompts the user for a secret pass phrase and waits ten seconds for input. If the entry is not completed within the specified time, the script exits with an error. Since the -s option is included, the characters of the pass phrase are not echoed to the display as they are typed.</p><p>这个脚本提示用户输入一个密码，并等待输入10秒钟。如果在特定的时间内没有完成输入， 则脚本会退出并返回一个错误。因为包含了一个 -s 选项，所以输入的密码不会出现在屏幕上。</p><h3 id="IFS"><a href="#IFS" class="headerlink" title="IFS"></a>IFS</h3><p>Normally, the shell performs word splitting on the input provided to <code>read</code>. As we have seen, this means that multiple words separated by one or more spaces become separate items on the input line, and are assigned to separate variables by read. This behavior is configured by a shell variable named <em>IFS</em> (for Internal Field Separator). The default value of <strong>IFS</strong> contains a space, a tab, and a newline character, each of which will separate items from one another.</p><p>通常，shell 对提供给 read 的输入按照单词进行分离。正如我们所见到的，这意味着多个由一个或几个空格 分离开的单词在输入行中变成独立的个体，并被 read 赋值给单独的变量。这种行为由 shell 变量<strong>IFS</strong> （内部字符分隔符）配置。<em>IFS</em> 的默认值包含一个空格，一个 tab，和一个换行符，每一个都会把 字段分割开。</p><p>We can adjust the value of <em>IFS</em> to control the separation of fields input to <code>read</code>. For example, the /etc/passwd file contains lines of data that use the colon character as a field separator. By changing the value of <em>IFS</em> to a single colon, we can use read to input the contents of /etc/passwd and successfully separate fields into different variables. Here we have a script that does just that:</p><p>我们可以调整 <em>IFS</em> 的值来控制输入字段的分离。例如，这个 /etc/passwd 文件包含的数据行 使用冒号作为字段分隔符。通过把 <em>IFS</em> 的值更改为单个冒号，我们可以使用 read 读取 /etc/passwd 中的内容，并成功地把字段分给不同的变量。这个就是做这样的事情：</p><pre><code>#!/bin/bash# read-ifs: read fields from a fileFILE=/etc/passwdread -p &quot;Enter a user name &gt; &quot; user_namefile_info=$(grep &quot;^$user_name:&quot; $FILE)if [ -n &quot;$file_info&quot; ]; then    IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;    echo &quot;User = &#39;$user&#39;&quot;    echo &quot;UID = &#39;$uid&#39;&quot;    echo &quot;GID = &#39;$gid&#39;&quot;    echo &quot;Full Name = &#39;$name&#39;&quot;    echo &quot;Home Dir. = &#39;$home&#39;&quot;    echo &quot;Shell = &#39;$shell&#39;&quot;else    echo &quot;No such user &#39;$user_name&#39;&quot; &gt;&amp;2    exit 1fi</code></pre><p>This script prompts the user to enter the user name of an account on the system, then displays the different fields found in the user’s record in the /etc/passwd file. The script contains two interesting lines. The first is:</p><p>这个脚本提示用户输入系统中一个帐户的用户名，然后显示在文件 /etc/passwd/ 文件中关于用户记录的 不同字段。这个脚本包含有趣的两行。 第一个是：</p><pre><code>file_info=$(grep &quot;^$user_name:&quot; $FILE)</code></pre><p>This line assigns the results of a grep command to the variable file_info. The regular expression used by grep assures that the user name will only match a single line in the /etc/passwd file.</p><p>这一行把 grep 命令的输入结果赋值给变量 file_info。grep 命令使用的正则表达式 确保用户名只会在 /etc/passwd 文件中匹配一行。</p><p>The second interesting line is this one:</p><p>第二个有意思的一行是：</p><pre><code>IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;</code></pre><p>The line consists of three parts: a variable assignment, a <code>read</code> command with a list of variable names as arguments, and a strange new redirection operator. We’ll look at the variable assignment first.</p><p>这一行由三部分组成：对一个变量的赋值操作，一个带有一串参数的 read 命令，和一个奇怪的新的重定向操作符。 我们首先看一下变量赋值。</p><p>The shell allows one or more variable assignments to take place immediately before a command. These assignments alter the environment for the command that follows. The effect of the assignment is temporary; only changing the environment for the duration of the command. In our case, the value of IFS is changed to a colon character. Alternately, we could have coded it this way:</p><p>Shell 允许在一个命令之前给一个或多个变量赋值。这些赋值会暂时改变之后的命令的环境变量。 在这种情况下，IFS 的值被改成一个冒号。等效的，我们也可以这样写：</p><pre><code>OLD_IFS=&quot;$IFS&quot;IFS=&quot;:&quot;read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;IFS=&quot;$OLD_IFS&quot;</code></pre><p>where we store the value of IFS, assign a new value, perform the read command, then restore IFS to its original value. Clearly, placing the variable assignment in front of the command is a more concise way of doing the same thing.</p><p>我们先存储 IFS 的值，然后赋给一个新值，再执行 read 命令，最后把 IFS 恢复原值。显然，完成相同的任务， 在命令之前放置变量名赋值是一种更简明的方式。</p><p>The <code>&lt;&lt;&lt;</code> operator indicates a here string. A here string is like a here document, only shorter, consisting of a single string. In our example, the line of data from the /etc/passwd file is fed to the standard input of the read command. We might wonder why this rather oblique method was chosen rather than:</p><p>这个 <code>&lt;&lt;&lt;</code> 操作符指示一个 here 字符串。一个 here 字符串就像一个 here 文档，只是比较简短，由 单个字符串组成。在这个例子中，来自 /etc/passwd 文件的数据发送给 read 命令的标准输入。 我们可能想知道为什么选择这种相当晦涩的方法而不是：</p><pre><code>echo &quot;$file_info&quot; | IFS=&quot;:&quot; read user pw uid gid name home shell</code></pre><blockquote><p>You Can’t Pipe read</p><p>你不能把 管道用在 read 上</p><p>While the read command normally takes input from standard input, you cannot do this:</p><p>虽然通常 read 命令接受标准输入，但是你不能这样做：</p><p><em>echo “foo” | read</em></p><p>We would expect this to work, but it does not. The command will appear to succeed but the REPLY variable will always be empty. Why is this?</p><p>我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY 变量 总是为空。为什么会这样？</p><p>The explanation has to do with the way the shell handles pipelines. In bash (and other shells such as sh), pipelines create subshells. These are copies of the shell and its environment which are used to execute the command in the pipeline. In our example above, read is executed in a subshell.</p><p>答案与 shell 处理管道线的方式有关系。在 bash（和其它 shells，例如 sh）中，管道线 会创建子 shell。这个子 shell 是为了执行执行管线中的命令而创建的shell和它的环境的副本。 上面示例中，read 命令将在子 shell 中执行。</p><p>Subshells in Unix-like systems create copies of the environment for the processes to use while they execute. When the processes finishes the copy of the environment is destroyed. This means that a subshell can never alter the environment of its parent process. read assigns variables, which then become part of the environment. In the example above, read assigns the value “foo” to the variable REPLY in its subshell’s environment, but when the command exits, the subshell and its environment are destroyed, and the effect of the assignment is lost.</p><p>在类 Unix 的系统中，子 shell 执行的时候，会为进程创建父环境的副本。当进程结束 之后，该副本就会被破坏掉。这意味着一个子 shell 永远不能改变父进程的环境。read 赋值变量， 然后会变为环境的一部分。在上面的例子中，read 在它的子 shell 环境中，把 foo 赋值给变量 REPLY， 但是当命令退出后，子 shell 和它的环境将被破坏掉，这样赋值的影响就会消失。</p><p>Using here strings is one way to work around this behavior. Another method is discussed in Chapter 37.</p><p>使用 here 字符串是解决此问题的一种方法。另一种方法将在37章中讨论。</p></blockquote><h3 id="校正输入"><a href="#校正输入" class="headerlink" title="校正输入"></a>校正输入</h3><p>With our new ability to have keyboard input comes an additional programming challenge, validating input. Very often the difference between a well-written program and a poorly written one is in the program’s ability to deal with the unexpected. Frequently, the unexpected appears in the form of bad input. We’ve done a little of this with our evaluation programs in the previous chapter, where we checked the value of integers and screened out empty values and non-numeric characters. It is important to perform these kinds of programming checks every time a program receives input, to guard against invalid data. This is especially important for programs that are shared by multiple users. Omitting these safeguards in the interests of economy might be excused if a program is to be used once and only by the author to perform some special task. Even then, if the program performs dangerous tasks such as deleting files, it would be wise to include data validation, just in case.</p><p>从键盘输入这种新技能，带来了额外的编程挑战，校正输入。很多时候，一个良好编写的程序与 一个拙劣程序之间的区别就是程序处理意外的能力。通常，意外会以错误输入的形式出现。在前面 章节中的计算程序，我们已经这样做了一点儿，我们检查整数值，甄别空值和非数字字符。每次 程序接受输入的时候，执行这类的程序检查非常重要，为的是避免无效数据。对于 由多个用户共享的程序，这个尤为重要。如果一个程序只使用一次且只被作者用来执行一些特殊任务， 那么为了经济利益而忽略这些保护措施，可能会被原谅。即使这样，如果程序执行危险任务，比如说 删除文件，所以最好包含数据校正，以防万一。</p><p>Here we have an example program that validates various kinds of input:</p><p>这里我们有一个校正各种输入的示例程序：</p><pre><code>#!/bin/bash# read-validate: validate inputinvalid_input () {    echo &quot;Invalid input &#39;$REPLY&#39;&quot; &gt;&amp;2    exit 1}read -p &quot;Enter a single item &gt; &quot;# input is empty (invalid)[[ -z $REPLY ]] &amp;&amp; invalid_input# input is multiple items (invalid)(( $(echo $REPLY | wc -w) &gt; 1 )) &amp;&amp; invalid_input# is input a valid filename?if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then    echo &quot;&#39;$REPLY&#39; is a valid filename.&quot;    if [[ -e $REPLY ]]; then        echo &quot;And file &#39;$REPLY&#39; exists.&quot;    else        echo &quot;However, file &#39;$REPLY&#39; does not exist.&quot;    fi    # is input a floating point number?    if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then        echo &quot;&#39;$REPLY&#39; is a floating point number.&quot;    else        echo &quot;&#39;$REPLY&#39; is not a floating point number.&quot;    fi    # is input an integer?    if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then        echo &quot;&#39;$REPLY&#39; is an integer.&quot;    else        echo &quot;&#39;$REPLY&#39; is not an integer.&quot;    fielse    echo &quot;The string &#39;$REPLY&#39; is not a valid filename.&quot;fi</code></pre><p>This script prompts the user to enter an item. The item is subsequently analyzed to determine its contents. As we can see, the script makes use of many of the concepts that we have covered thus far, including shell functions, <code>[[ ]]</code>, <code>(( ))</code>, the control operator <code>&amp;&amp;</code>, and if, as well as a healthy dose of regular expressions.</p><p>这个脚本提示用户输入一个数字。随后，分析这个数字来决定它的内容。正如我们所看到的，这个脚本 使用了许多我们已经讨论过的概念，包括 shell 函数，<code>[[ ]]</code>，<code>(( ))</code>，控制操作符 <code>&amp;&amp;</code>，以及 <code>if</code> 和 一些正则表达式。</p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>A common type of interactivity is called menu-driven. In menu-driven programs, the user is presented with a list of choices and is asked to choose one. For example, we could imagine a program that presented the following:</p><p>一种常见的交互类型称为菜单驱动。在菜单驱动程序中，呈现给用户一系列选择，并要求用户选择一项。 例如，我们可以想象一个展示以下信息的程序：</p><pre><code>Please Select:1.Display System Information2.Display Disk Space3.Display Home Space Utilization0.QuitEnter selection [0-3] &gt;</code></pre><p>Using what we learned from writing our sys_info_page program, we can construct a menu-driven program to perform the tasks on the above menu:</p><p>使用我们从编写 sys_info_page 程序中所学到的知识，我们能够构建一个菜单驱动程序来执行 上述菜单中的任务：</p><pre><code>#!/bin/bash# read-menu: a menu driven system information programclearecho &quot;Please Select:    1. Display System Information    2. Display Disk Space    3. Display Home Space Utilization    0. Quit&quot;read -p &quot;Enter selection [0-3] &gt; &quot;if [[ $REPLY =~ ^[0-3]$ ]]; then    if [[ $REPLY == 0 ]]; then        echo &quot;Program terminated.&quot;        exit    fi    if [[ $REPLY == 1 ]]; then        echo &quot;Hostname: $HOSTNAME&quot;        uptime        exit    fi    if [[ $REPLY == 2 ]]; then        df -h        exit    fi    if [[ $REPLY == 3 ]]; then        if [[ $(id -u) -eq 0 ]]; then            echo &quot;Home Space Utilization (All Users)&quot;            du -sh /home/*        else            echo &quot;Home Space Utilization ($USER)&quot;            du -sh $HOME        fi        exit    fielse    echo &quot;Invalid entry.&quot; &gt;&amp;2    exit 1fi</code></pre><p>This script is logically divided into two parts. The first part displays the menu and inputs the response from the user. The second part identifies the response and carries out the selected action. Notice the use of the <code>exit</code> command in this script. It is used here to prevent the script from executing unnecessary code after an action has been carried out. The presence of multiple ｀exit｀ points in a program is generally a bad idea (it makes program logic harder to understand), but it works in this script.</p><p>从逻辑上讲，这个脚本被分为两部分。第一部分显示菜单和用户输入。第二部分确认用户反馈，并执行 选择的行动。注意脚本中使用的 exit 命令。在这里，在一个行动执行之后， exit 被用来阻止脚本执行不必要的代码。 通常在程序中出现多个 exit 代码不是一个好主意（它使程序逻辑较难理解），但是它在这个脚本中可以使用。</p><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this chapter, we took our first steps toward interactivity; allowing users to input data into our programs via the keyboard. Using the techniques presented thus far, it is possible to write many useful programs, such as specialized calculation programs and easy-to-use front ends for arcane command line tools. In the next chapter, we will build on the menu-driven program concept to make it even better.</p><p>在这一章中，我们向着程序交互性迈出了第一步；允许用户通过键盘向程序输入数据。使用目前 已经学过的技巧，有可能编写许多有用的程序，比如说特定的计算程序和容易使用的命令行工具 前端。在下一章中，我们将继续建立菜单驱动程序概念，让它更完善。</p><h4 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h4><p>It is important to study the programs in this chapter carefully and have a complete understanding of the way they are logically structured, as the programs to come will be increasingly complex. As an exercise, rewrite the programs in this chapter using the test command rather than the <code>[[ ]]</code>compound command. Hint: use <code>grep</code> to evaluate the regular expressions and evaluate its exit status. This will be good practice.</p><p>仔细研究本章中的程序，并对程序的逻辑结构有一个完整的理解，这是非常重要的，因为即将到来的 程序会日益复杂。作为练习，用 test 命令而不是<code>[[ ]]</code>复合命令来重新编写本章中的程序。 提示：使用 grep 命令来计算正则表达式及其退出状态。这会是一个不错的练习。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Bash Reference Manual contains a chapter on builtins, which includes the read command:</p></li><li><p>Bash 参考手册有一章关于内部命令的内容，其包括了<code>read</code>命令：</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Bash-Builtins" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Bash-Builtins</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十八章 流程控制：if分支结构</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Aif%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Aif%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>In the last chapter, we were presented with a problem. How can we make our report generator script adapt to the privileges of the user running the script? The solution to this problem will require us to find a way to “change directions” within our script, based on a the results of a test. In programming terms, we need the program to branch. Let’s consider a simple example of logic expressed in pseudocode, a simulation of a computer language intended for human consumption:</p><p>在上一章中，我们遇到一个问题。怎样使我们的报告生成器脚本能适应运行此脚本的用户的权限？ 这个问题的解决方案要求我们能找到一种方法，在脚本中基于测试条件结果，来“改变方向”。 用编程术语表达，就是我们需要程序可以分支。让我们考虑一个简单的用伪码表示的逻辑实例， 伪码是一种模拟的计算机语言，为的是便于人们理解：</p><pre><code>X=5If X = 5, then:Say “X equals 5.”Otherwise:Say “X is not equal to 5.”</code></pre><p>This is an example of a branch. Based on the condition, “Does X = 5?” do one thing, “Say X equals 5,” otherwise do another thing, “Say X is not equal to 5.”</p><p>这就是一个分支的例子。根据条件，“Does X = 5?” 做一件事情，“Say X equals 5,” 否则，做另一件事情，“Say X is not equal to 5.”</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>Using the shell, we can code the logic above as follows:</p><p>使用 shell，我们可以编码上面的逻辑，如下所示：</p><pre class=" language-shell"><code class="language-shell">x=5if [ $x = 5 ]; then    echo "x equals 5."else    echo "x does not equal 5."fi</code></pre><p>or we can enter it directly at the command line (slightly shortened):</p><p>或者我们可以直接在命令行中输入以上代码（略有缩短）：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ x=5[me@linuxbox ~]$ if [ $x = 5 ]; then echo "equals 5"; else echo "doesnot equal 5"; fiequals 5[me@linuxbox ~]$ x=0[me@linuxbox ~]$ if [ $x = 5 ]; then echo "equals 5"; else echo "doesnot equal 5"; fidoes not equal 5</code></pre><p>In this example, we execute the command twice. Once, with the value of x set to 5, which results in the string “equals 5” being output, and the second time with the value of x set to 0, which results in the string “does not equal 5” being output.</p><p>在这个例子中，我们执行了两次这个命令。第一次是，把 x 的值设置为5，从而导致输出字符串“equals 5”, 第二次是，把 x 的值设置为0，从而导致输出字符串“does not equal 5”。</p><p>The if statement has the following syntax:</p><p>这个 if 语句语法如下：</p><pre class=" language-shell"><code class="language-shell">if commands; then     commands[elif commands; then     commands...][else     commands]fi</code></pre><p>where commands is a list of commands. This is a little confusing at first glance. But before we can clear this up, we have to look at how the shell evaluates the success or failure of a command.</p><p>这里的 commands 是指一系列命令。第一眼看到会有点儿困惑。但是在我们弄清楚这些语句之前，我们 必须看一下 shell 是如何评判一个命令的成功与失败的。</p><h3 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h3><p>Commands (including the scripts and shell functions we write) issue a value to the system when they terminate, called an exit status. This value, which is an integer in the range of 0 to 255, indicates the success or failure of the command’s execution. By convention, a value of zero indicates success and any other value indicates failure. The shell provides a parameter that we can use to examine the exit status. Here we see it in action:</p><p>当命令执行完毕后，命令（包括我们编写的脚本和 shell 函数）会给系统发送一个值，叫做退出状态。 这个值是一个 0 到 255 之间的整数，说明命令执行成功或是失败。按照惯例，一个零值说明成功，其它所有值说明失败。 Shell 提供了一个参数，我们可以用它检查退出状态。用具体实例看一下：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ ls -d /usr/bin/usr/bin[me@linuxbox ~]$ echo $?0[me@linuxbox ~]$ ls -d /bin/usrls: cannot access /bin/usr: No such file or directory[me@linuxbox ~]$ echo $?2</code></pre><p>In this example, we execute the ls command twice. The first time, the command executes successfully. If we display the value of the parameter <code>$?</code>, we see that it is zero. We execute the ls command a second time, producing an error and examine the parameter <code>$?</code> again. This time it contains a 2, indicating that the command encountered an error. Some commands use different exit status values to provide diagnostics for errors, while many commands simply exit with a value of one when they fail. Man pages often include a section entitled “Exit Status,” describing what codes are used. However, a zero always indicates success.</p><p>在这个例子中，我们执行了两次 ls 命令。第一次，命令执行成功。如果我们显示参数<code>$?</code>的值，我们 看到它是零。我们第二次执行 ls 命令的时候，产生了一个错误，并再次查看参数<code>$?</code>。这次它包含一个 数字 2，表明这个命令遇到了一个错误。有些命令使用不同的退出值，来诊断错误，而许多命令当 它们执行失败的时候，会简单地退出并发送一个数字1。手册页中经常会包含一章标题为“退出状态”的内容， 描述了使用的代码。然而，一个零总是表明成功。</p><p>The shell provides two extremely simple builtin commands that do nothing except terminate with either a zero or one exit status. The true command always executes successfully and the false command always executes unsuccessfully:</p><p>shell 提供了两个极其简单的内部命令，它们不做任何事情，除了以一个0或1退出状态来终止执行。 True 命令总是执行成功，而 false 命令总是执行失败：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox~]$ true[me@linuxbox~]$ echo $?0[me@linuxbox~]$ false[me@linuxbox~]$ echo $?1</code></pre><p>We can use these commands to see how the if statement works. What the if statement really does is evaluate the success or failure of commands:</p><p>我们能够使用这些命令，来看一下 if 语句是怎样工作的。If 语句真正做的事情是计算命令执行成功或失败：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ if true; then echo "It's true."; fiIt's true.[me@linuxbox ~]$ if false; then echo "It's true."; fi[me@linuxbox ~]$</code></pre><p>The command echo “It’s true.” is executed when the command following if executes successfully, and is not executed when the command following if does not execute successfully. If a list of commands follows if, the last command in the list is evaluated:</p><p>当 if 之后的命令执行成功的时候，命令 echo “It’s true.” 将会执行，否则此命令不执行。 如果 if 之后跟随一系列命令，则将计算列表中的最后一个命令：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ if false; true; then echo "It's true."; fiIt's true.[me@linuxbox ~]$ if true; false; then echo "It's true."; fi[me@linuxbox ~]$</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>By far, the command used most frequently with if is test. The test command performs a variety of checks and comparisons. It has two equivalent forms:</p><p>到目前为止，经常与 if 一块使用的命令是 test。这个 test 命令执行各种各样的检查与比较。 它有两种等价模式：</p><pre><code>test expression</code></pre><p>and the more popular:</p><p>比较流行的格式是：</p><pre><code>[ expression ]</code></pre><p>where expression is an expression that is evaluated as either true or false. The test command returns an exit status of zero when the expression is true and a status of one when the expression is false.</p><p>这里的 expression 是一个表达式，其执行结果是 true 或者是 false。当表达式为真时，这个 test 命令返回一个零 退出状态，当表达式为假时，test 命令退出状态为1。</p><h4 id="文件表达式"><a href="#文件表达式" class="headerlink" title="文件表达式"></a>文件表达式</h4><p>The following expressions are used to evaluate the status of files:</p><p>以下表达式被用来计算文件状态：</p><table><thead><tr><th align="left">Expression</th><th align="left">Is Ture If</th></tr></thead><tbody><tr><td align="left">file1 -ef file2</td><td align="left">file1 and file2 have the same inode numbers (the two filenames refer to the same file by hard linking).</td></tr><tr><td align="left">file1 -nt file2</td><td align="left">file 1 is newer than file2.</td></tr><tr><td align="left">file1 -ot file2</td><td align="left">file1 is older than file2.</td></tr><tr><td align="left">-b file</td><td align="left">file exists and is a block special (device) file.</td></tr><tr><td align="left">-c file</td><td align="left">file exists and is a character special (device) file.</td></tr><tr><td align="left">-d file</td><td align="left">file exists and is a directory.</td></tr><tr><td align="left">-e file</td><td align="left">file exists.</td></tr><tr><td align="left">-f file</td><td align="left">file exists and is a regular file.</td></tr><tr><td align="left">-g file</td><td align="left">file exists and is set-group-ID.</td></tr><tr><td align="left">-G file</td><td align="left">file exists and is owned by the effective group ID.</td></tr><tr><td align="left">-k file</td><td align="left">file exists and has its “sticky bit” set.</td></tr><tr><td align="left">-L file</td><td align="left">file exists and is a symbolic link.</td></tr><tr><td align="left">-O file</td><td align="left">file exists and is owned by the effective user ID.</td></tr><tr><td align="left">-p file</td><td align="left">file exists and is a named pipe.</td></tr><tr><td align="left">-r file</td><td align="left">file exists and is readable (has readable permission for the effective user).</td></tr><tr><td align="left">-s file</td><td align="left">file exists and has a length greater than zero.</td></tr><tr><td align="left">-S file</td><td align="left">file exists and is a network socket.</td></tr><tr><td align="left">-t fd</td><td align="left">fd is a file descriptor directed to/from the terminal. This can be used to determine whether standard input/output/ error is being redirected.</td></tr><tr><td align="left">-u file</td><td align="left">file exists and is setuid.</td></tr><tr><td align="left">-w file</td><td align="left">file exists and is writable (has write permission for the effective user).</td></tr><tr><td align="left">-x file</td><td align="left">file exists and is executable (has execute/search permission for the effective user).</td></tr></tbody></table><table><thead><tr><th align="left">表达式</th><th align="left">如果下列条件为真则返回True</th></tr></thead><tbody><tr><td align="left">file1 -ef file2</td><td align="left">file1 和 file2 拥有相同的索引号（通过硬链接两个文件名指向相同的文件）。</td></tr><tr><td align="left">file1 -nt file2</td><td align="left">file1新于 file2。</td></tr><tr><td align="left">file1 -ot file2</td><td align="left">file1早于 file2。</td></tr><tr><td align="left">-b file</td><td align="left">file 存在并且是一个块（设备）文件。</td></tr><tr><td align="left">-c file</td><td align="left">file 存在并且是一个字符（设备）文件。</td></tr><tr><td align="left">-d file</td><td align="left">file 存在并且是一个目录。</td></tr><tr><td align="left">-e file</td><td align="left">file 存在。</td></tr><tr><td align="left">-f file</td><td align="left">file 存在并且是一个普通文件。</td></tr><tr><td align="left">-g file</td><td align="left">file 存在并且设置了组 ID。</td></tr><tr><td align="left">-G file</td><td align="left">file 存在并且由有效组 ID 拥有。</td></tr><tr><td align="left">-k file</td><td align="left">file 存在并且设置了它的“sticky bit”。</td></tr><tr><td align="left">-L file</td><td align="left">file 存在并且是一个符号链接。</td></tr><tr><td align="left">-O file</td><td align="left">file 存在并且由有效用户 ID 拥有。</td></tr><tr><td align="left">-p file</td><td align="left">file 存在并且是一个命名管道。</td></tr><tr><td align="left">-r file</td><td align="left">file 存在并且可读（有效用户有可读权限）。</td></tr><tr><td align="left">-s file</td><td align="left">file 存在且其长度大于零。</td></tr><tr><td align="left">-S file</td><td align="left">file 存在且是一个网络 socket。</td></tr><tr><td align="left">-t fd</td><td align="left">fd 是一个定向到终端／从终端定向的文件描述符 。 这可以被用来决定是否重定向了标准输入／输出错误。</td></tr><tr><td align="left">-u file</td><td align="left">file 存在并且设置了 setuid 位。</td></tr><tr><td align="left">-w file</td><td align="left">file 存在并且可写（有效用户拥有可写权限）。</td></tr><tr><td align="left">-x file</td><td align="left">file 存在并且可执行（有效用户有执行／搜索权限）。</td></tr></tbody></table><p>Here we have a script that demonstrates some of the file expressions:</p><p>这里我们有一个脚本说明了一些文件表达式：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# test-file: Evaluate the status of a fileFILE=~/.bashrcif [ -e "$FILE" ]; then    if [ -f "$FILE" ]; then        echo "$FILE is a regular file."    fi    if [ -d "$FILE" ]; then        echo "$FILE is a directory."    fi    if [ -r "$FILE" ]; then        echo "$FILE is readable."    fi    if [ -w "$FILE" ]; then        echo "$FILE is writable."    fi    if [ -x "$FILE" ]; then        echo "$FILE is executable/searchable."    fielse    echo "$FILE does not exist"    exit 1fiexit</code></pre><p>The script evaluates the file assigned to the constant FILE and displays its results as the evaluation is performed. There are two interesting things to note about this script. First, notice how the parameter <code>$FILE</code> is quoted within the expressions. This is not required, but is a defense against the parameter being empty. If the parameter expansion of <code>$FILE</code> were to result in an empty value, it would cause an error (the operators would be interpreted as non-null strings rather than operators). Using the quotes around the parameter insures that the operator is always followed by a string, even if the string is empty. Second, notice the presence of the exit commands near the end of the script. The exit command accepts a single, optional argument, which becomes the script’s exit status. When no argument is passed, the exit status defaults to zero. Using exit in this way allows the script to indicate failure if <code>$FILE</code> expands to the name of a nonexistent file. The exit command appearing on the last line of the script is there as a formality. When a script “runs off the end” (reaches end of file), it terminates with an exit status of zero by default, anyway.</p><p>这个脚本会计算赋值给常量 FILE 的文件，并显示计算结果。对于此脚本有两点需要注意。第一个， 在表达式中参数<code>$FILE</code>是怎样被引用的。引号并不是必需的，但这是为了防范空参数。如果<code>$FILE</code>的参数展开 是一个空值，就会导致一个错误（操作符将会被解释为非空的字符串而不是操作符）。用引号把参数引起来就 确保了操作符之后总是跟随着一个字符串，即使字符串为空。第二个，注意脚本末尾的 exit 命令。 这个 exit 命令接受一个单独的，可选的参数，其成为脚本的退出状态。当不传递参数时，退出状态默认为零。 以这种方式使用 exit 命令，则允许此脚本提示失败如果 <code>$FILE</code> 展开成一个不存在的文件名。这个 exit 命令 出现在脚本中的最后一行，是一个当一个脚本“运行到最后”（到达文件末尾），不管怎样， 默认情况下它以退出状态零终止。</p><p>Similarly, shell functions can return an exit status by including an integer argument to the return command. If we were to convert the script above to a shell function to include it in a larger program, we could replace the exit commands with return statements and get the desired behavior:</p><p>类似地，通过带有一个整数参数的 return 命令，shell 函数可以返回一个退出状态。如果我们打算把 上面的脚本转变为一个 shell 函数，为了在更大的程序中包含此函数，我们用 return 语句来代替 exit 命令， 则得到期望的行为：</p><pre class=" language-shell"><code class="language-shell">test_file () {    # test-file: Evaluate the status of a file    FILE=~/.bashrc    if [ -e "$FILE" ]; then        if [ -f "$FILE" ]; then            echo "$FILE is a regular file."        fi        if [ -d "$FILE" ]; then            echo "$FILE is a directory."        fi        if [ -r "$FILE" ]; then            echo "$FILE is readable."        fi        if [ -w "$FILE" ]; then            echo "$FILE is writable."        fi        if [ -x "$FILE" ]; then            echo "$FILE is executable/searchable."        fi    else        echo "$FILE does not exist"        return 1    fi}</code></pre><h4 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h4><p>The following expressions are used to evaluate strings:</p><p>以下表达式用来计算字符串：</p><table><thead><tr><th align="left">Expression</th><th align="left">Is Ture If…</th></tr></thead><tbody><tr><td align="left">string</td><td align="left">string is not null.</td></tr><tr><td align="left">-n string</td><td align="left">The length of string is greater than zero.</td></tr><tr><td align="left">-z string</td><td align="left">The length of string is zero.</td></tr><tr><td align="left">string1 = string2string1 == string2</td><td align="left">string1 and string2 are equal. Single or double equal signs may be used, but the use of double equal signs is greatly preferred.</td></tr><tr><td align="left">string1 != string2</td><td align="left">string1 and string2 are not equal.</td></tr><tr><td align="left">string1 &gt; string2</td><td align="left">sting1 sorts after string2.</td></tr><tr><td align="left">string1 &lt; string2</td><td align="left">string1 sorts before string2.</td></tr></tbody></table><table><thead><tr><th align="left">表达式</th><th align="left">如果下列条件为真则返回True</th></tr></thead><tbody><tr><td align="left">string</td><td align="left">string 不为 null。</td></tr><tr><td align="left">-n string</td><td align="left">字符串 string 的长度大于零。</td></tr><tr><td align="left">-z string</td><td align="left">字符串 string 的长度为零。</td></tr><tr><td align="left">string1 = string2string1 == string2</td><td align="left">string1 和 string2 相同。 单或双等号都可以，不过双等号更受欢迎。</td></tr><tr><td align="left">string1 != string2</td><td align="left">string1 和 string2 不相同。</td></tr><tr><td align="left">string1 &gt; string2</td><td align="left">sting1 排列在 string2 之后。</td></tr><tr><td align="left">string1 &lt; string2</td><td align="left">string1 排列在 string2 之前。</td></tr></tbody></table><hr><p>Warning: the <code>&gt;</code> and <code>&lt;</code> expression operators must be quoted (or escaped with a backslash) when used with test. If they are not, they will be interpreted by the shell as redirection operators, with potentially destructive results. Also note that while the bash documentation states that the sorting order conforms to the collation order of the current locale, it does not. ASCII (POSIX) order is used in versions of bash up to and including 4.0.</p><p>警告：当与 test 一块使用的时候， &gt; 和 &lt; 表达式操作符必须用引号引起来（或者是用反斜杠转义）。 如果不这样，它们会被 shell 解释为重定向操作符，造成潜在的破坏结果。 同时也要注意虽然 bash 文档声明排序遵从当前语系的排列规则，但并不这样。将来的 bash 版本，包含 4.0， 使用 ASCII（POSIX）排序规则。</p><hr><p>Here is a script that demonstrates them:</p><p>这是一个演示这些问题的脚本：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# test-string: evaluate the value of a stringANSWER=maybeif [ -z "$ANSWER" ]; then    echo "There is no answer." >&2    exit 1fiif [ "$ANSWER" = "yes" ]; then    echo "The answer is YES."elif [ "$ANSWER" = "no" ]; then    echo "The answer is NO."elif [ "$ANSWER" = "maybe" ]; then    echo "The answer is MAYBE."else    echo "The answer is UNKNOWN."fi</code></pre><p>In this script, we evaluate the constant ANSWER. We first determine if the string is empty. If it is, we terminate the script and set the exit status to one. Notice the redirection that is applied to the echo command. This redirects the error message “There is no answer.” to standard error, which is the “proper” thing to do with error messages. If the string is not empty, we evaluate the value of the string to see if it is equal to either “yes,” “no,” or “maybe.” We do this by using elif, which is short for “else if.” By using elif, we are able to construct a more complex logical test.</p><p>在这个脚本中，我们计算常量 ANSWER。我们首先确定是否此字符串为空。如果为空，我们就终止 脚本，并把退出状态设为零。注意这个应用于 echo 命令的重定向操作。其把错误信息 “There is no answer.” 重定向到标准错误，这是处理错误信息的“正确”方法。如果字符串不为空，我们就计算 字符串的值，看看它是否等于“yes,” “no,” 或者“maybe”。为此使用了 elif，它是 “else if” 的简写。 通过使用 elif，我们能够构建更复杂的逻辑测试。</p><h4 id="整型表达式"><a href="#整型表达式" class="headerlink" title="整型表达式"></a>整型表达式</h4><p>The following expressions are used with integers:</p><p>下面的表达式用于整数：</p><table><thead><tr><th align="left">Expression</th><th align="left">Is True If…</th></tr></thead><tbody><tr><td align="left">integer1 -eq integer2</td><td align="left">integer1 is equal to integer2.</td></tr><tr><td align="left">integer1 -ne integer2</td><td align="left">integer1 is not equal to integer2.</td></tr><tr><td align="left">integer1 -le integer2</td><td align="left">integer1 is less than or equal to integer2.</td></tr><tr><td align="left">integer1 -lt integer2</td><td align="left">integer1 is less than integer2.</td></tr><tr><td align="left">integer1 -ge integer2</td><td align="left">integer1 is greater than or equal to integer2.</td></tr><tr><td align="left">integer1 -gt integer2</td><td align="left">integer1 is greater than integer2.</td></tr></tbody></table><table><thead><tr><th align="left">表达式</th><th align="left">如果为真…</th></tr></thead><tbody><tr><td align="left">integer1 -eq integer2</td><td align="left">integer1 等于 integer2。</td></tr><tr><td align="left">integer1 -ne integer2</td><td align="left">integer1 不等于 integer2。</td></tr><tr><td align="left">integer1 -le integer2</td><td align="left">integer1 小于或等于 integer2。</td></tr><tr><td align="left">integer1 -lt integer2</td><td align="left">integer1 小于 integer2。</td></tr><tr><td align="left">integer1 -ge integer2</td><td align="left">integer1 大于或等于 integer2。</td></tr><tr><td align="left">integer1 -gt integer2</td><td align="left">integer1 大于 integer2。</td></tr></tbody></table><p>Here is a script that demonstrates them:</p><p>这里是一个演示以上表达式用法的脚本：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# test-integer: evaluate the value of an integer.INT=-5if [ -z "$INT" ]; then    echo "INT is empty." >&2    exit 1fiif [ $INT -eq 0 ]; then    echo "INT is zero."else    if [ $INT -lt 0 ]; then        echo "INT is negative."    else        echo "INT is positive."    fi    if [ $((INT % 2)) -eq 0 ]; then        echo "INT is even."    else        echo "INT is odd."    fifi</code></pre><p>The interesting part of the script is how it determines whether an integer is even or odd. By performing a modulo 2 operation on the number, which divides the number by two and returns the remainder, it can tell if the number is odd or even.</p><p>这个脚本中有趣的地方是怎样来确定一个整数是偶数还是奇数。通过用模数2对数字执行求模操作， 就是用数字来除以2，并返回余数，从而知道数字是偶数还是奇数。</p><h3 id="更现代的测试版本"><a href="#更现代的测试版本" class="headerlink" title="更现代的测试版本"></a>更现代的测试版本</h3><p>Recent versions of bash include a compound command that acts as an enhanced replacement for test. It uses the following syntax:</p><p>目前的 bash 版本包括一个复合命令，作为加强的 test 命令替代物。它使用以下语法：</p><pre><code>[[ expression ]]</code></pre><p>where, like test, expression is an expression that evaluates to either a true or false result. The <code>[[ ]]</code>command is very similar to test (it supports all of its expressions), but adds an important new string expression:</p><p>这里，类似于 test，expression 是一个表达式，其计算结果为真或假。这个<code>[[ ]]</code>命令非常 相似于 test 命令（它支持所有的表达式），但是增加了一个重要的新的字符串表达式：</p><pre><code>string1 =~ regex</code></pre><p>which returns true if string1 is matched by the extended regular expression regex. This opens up a lot of possibilities for performing such tasks as data validation. In our earlier example of the integer expressions, the script would fail if the constant INT contained anything except an integer. The script needs a way to verify that the constant contains an integer. Using <code>[[ ]]</code> with the <code>=~</code> string expression operator, we could improve the script this way:</p><p>其返回值为真，如果 string1匹配扩展的正则表达式 regex。这就为执行比如数据验证等任务提供了许多可能性。 在我们前面的整数表达式示例中，如果常量 INT 包含除了整数之外的任何数据，脚本就会运行失败。这个脚本 需要一种方法来证明此常量包含一个整数。使用 <code>[[ ]]</code> 和 <code>=~</code> 字符串表达式操作符，我们能够这样来改进脚本：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># test-integer2: evaluate the value of an integer.</span>INT<span class="token operator">=</span>-5<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INT</span>"</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$INT</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token keyword">echo</span> <span class="token string">"INT is zero."</span>    <span class="token keyword">else</span>        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$INT</span> -lt 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>            <span class="token keyword">echo</span> <span class="token string">"INT is negative."</span>        <span class="token keyword">else</span>            <span class="token keyword">echo</span> <span class="token string">"INT is positive."</span>        <span class="token keyword">fi</span>        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$((</span>INT <span class="token operator">%</span> <span class="token number">2</span><span class="token variable">))</span></span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>            <span class="token keyword">echo</span> <span class="token string">"INT is even."</span>        <span class="token keyword">else</span>            <span class="token keyword">echo</span> <span class="token string">"INT is odd."</span>        <span class="token keyword">fi</span>    <span class="token keyword">fi</span><span class="token keyword">else</span>    <span class="token keyword">echo</span> <span class="token string">"INT is not an integer."</span> <span class="token operator">></span><span class="token operator">&amp;</span>2    <span class="token keyword">exit</span> 1<span class="token keyword">fi</span></code></pre><p>By applying the regular expression, we are able to limit the value of INT to only strings that begin with an optional minus sign, followed by one or more numerals. This expression also eliminates the possibility of empty values.</p><p>通过应用正则表达式，我们能够限制 INT 的值只是字符串，其开始于一个可选的减号，随后是一个或多个数字。 这个表达式也消除了空值的可能性。</p><p>Another added feature of <code>[[ ]]</code> is that the <code>==</code> operator supports pattern matching the same way pathname expansion does. For example:</p><p><code>[[ ]]</code>添加的另一个功能是<code>==</code>操作符支持类型匹配，正如路径名展开所做的那样。例如：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ FILE=foo.bar[me@linuxbox ~]$ if [[ $FILE == foo.* ]]; then> echo "$FILE matches pattern 'foo.*'"> fifoo.bar matches pattern 'foo.*'</code></pre><p>This makes <code>[[ ]]</code> useful for evaluating file and path names.</p><p>这就使<code>[[ ]]</code>有助于计算文件和路径名。</p><h3 id="为整数设计"><a href="#为整数设计" class="headerlink" title="(( )) - 为整数设计"></a>(( )) - 为整数设计</h3><p>In addition to the <code>[[ ]]</code> compound command, bash also provides the <code>(( ))</code> compound command, which is useful for operating on integers. It supports a full set of arithmetic evaluations, a subject we will cover fully in Chapter 35.</p><p>除了 <code>[[ ]]</code> 复合命令之外，bash 也提供了 <code>(( ))</code> 复合命令，其有利于操作整数。它支持一套 完整的算术计算，我们将在第35章中讨论这个主题。</p><p><code>(( ))</code> is used to perform arithmetic truth tests. An arithmetic truth test results in true if the result of the arithmetic evaluation is non-zero.</p><p><code>(( ))</code>被用来执行算术真测试。如果算术计算的结果是非零值，则其测试值为真。</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ if ((1)); then echo "It is true."; fiIt is true.[me@linuxbox ~]$ if ((0)); then echo "It is true."; fi[me@linuxbox ~]$</code></pre><p>Using <code>(( ))</code>, we can slightly simplify the test-integer2 script like this:</p><p>使用<code>(( ))</code>，我们能够略微简化 test-integer2脚本，像这样：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# test-integer2a: evaluate the value of an integer.INT=-5if [[ "$INT" =~ ^-?[0-9]+$ ]]; then    if ((INT == 0)); then        echo "INT is zero."    else        if ((INT < 0)); then            echo "INT is negative."        else            echo "INT is positive."        fi        if (( ((INT % 2)) == 0)); then            echo "INT is even."        else            echo "INT is odd."        fi    fielse    echo "INT is not an integer." >&2    exit 1fi</code></pre><p>Notice that we use less than and greater than signs and that == is used to test for equivalence. This is a more natural looking syntax for working with integers. Notice too, that because the compound command <code>(( ))</code> is part of the shell syntax rather than an ordinary command, and it deals only with integers, it is able to recognize variables by name and does not require expansion to be performed. We’ll discuss <code>(( ))</code> and the related arithmetic expansion further in Chapter 35.</p><p>注意我们使用小于和大于符号，以及==用来测试是否相等。这是使用整数较为自然的语法了。也要 注意，因为复合命令 <code>(( ))</code> 是 shell 语法的一部分，而不是一个普通的命令，而且它只处理整数， 所以它能够通过名字识别出变量，而不需要执行展开操作。我们将在第35中进一步讨论 <code>(( ))</code> 命令 和相关的算术展开操作。</p><h3 id="结合表达式"><a href="#结合表达式" class="headerlink" title="结合表达式"></a>结合表达式</h3><p>It’s also possible to combine expressions to create more complex evaluations. Expressions are combined by using logical operators. We saw these in Chapter 18, when we learned about the find command. There are three logical operations for test and <code>[[ ]]</code>. They are AND, OR and NOT. test and <code>[[ ]]</code> use different operators to represent these operations :</p><p>也有可能把表达式结合起来创建更复杂的计算。通过使用逻辑操作符来结合表达式。我们 在第18章中学习 find 命令的时候已经知道了这些。有三个用于 test 和 <code>[[ ]]</code> 的逻辑操作。 它们是 AND、OR 和 NOT。test 和 <code>[[ ]]</code> 使用不同的操作符来表示这些操作：</p><table><thead><tr><th align="left">Operation</th><th align="left">test</th><th align="left">[[ ]] and (( ))</th></tr></thead><tbody><tr><td align="left">AND</td><td align="left">-a</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">OR</td><td align="left">-o</td><td align="left">||</td></tr><tr><td align="left">NOT</td><td align="left">!</td><td align="left">!</td></tr></tbody></table><table><thead><tr><th align="left">操作符</th><th align="left">测试</th><th align="left">[[ ]] and (( ))</th></tr></thead><tbody><tr><td align="left">AND</td><td align="left">-a</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">OR</td><td align="left">-o</td><td align="left">||</td></tr><tr><td align="left">NOT</td><td align="left">!</td><td align="left">!</td></tr></tbody></table><p>Here’s an example of an AND operation. The following script determines if an integer is within a range of values:</p><p>这里有一个 AND 操作的示例。下面的脚本决定了一个整数是否属于某个范围内的值：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# test-integer3: determine if an integer is within a# specified range of values.MIN_VAL=1MAX_VAL=100INT=50if [[ "$INT" =~ ^-?[0-9]+$ ]]; then    if [[ INT -ge MIN_VAL && INT -le MAX_VAL ]]; then        echo "$INT is within $MIN_VAL to $MAX_VAL."    else        echo "$INT is out of range."    fielse    echo "INT is not an integer." >&2    exit 1fi</code></pre><p>We also include parentheses around the expression, for grouping. If these were not included, the negation would only apply to the first expression and not the combination of the two. Coding this with test would be done this way:</p><p>我们也可以对表达式使用圆括号，为的是分组。如果不使用括号，那么否定只应用于第一个 表达式，而不是两个组合的表达式。用 test 可以这样来编码：</p><pre class=" language-shell"><code class="language-shell">if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then    echo "$INT is outside $MIN_VAL to $MAX_VAL."else    echo "$INT is in range."fi</code></pre><p>Since all expressions and operators used by test are treated as command arguments by the shell (unlike <code>[[ ]]</code> and <code>(( ))</code> ), characters which have special meaning to bash, such as &lt;, &gt;, (, and ), must be quoted or escaped.</p><p>因为 test 使用的所有的表达式和操作符都被 shell 看作是命令参数（不像 <code>[[ ]]</code> 和 <code>(( ))</code> ）， 对于 bash 有特殊含义的字符，比如说 &lt;，&gt;，(，和 )，必须引起来或者是转义。</p><p>Seeing that test and <code>[[ ]]</code> do roughly the same thing, which is preferable? test is traditional (and part of POSIX), whereas <code>[[ ]]</code> is specific to bash. It’s important to know how to use test, since it is very widely used, but <code>[[ ]]</code> is clearly more useful and is easier to code.</p><p>知道了 test 和 <code>[[ ]]</code> 基本上完成相同的事情，哪一个更好呢？test 更传统（是 POSIX 的一部分）， 然而 <code>[[ ]]</code> 特定于 bash。知道怎样使用 test 很重要，因为它被非常广泛地应用，但是显然 <code>[[ ]]</code> 更 有用，并更易于编码。</p><blockquote><p>Portability Is The Hobgoblin Of Little Minds</p><p>可移植性是头脑狭隘人士的心魔</p><p>If you talk to “real” Unix people, you quickly discover that many of them don’t like Linux very much. They regard it as impure and unclean. One tenet of Unix followers is that everything should be “portable.” This means that any script you write should be able to run, unchanged, on any Unix-like system.</p><p>如果你和“真正的”Unix 用户交谈，你很快就会发现他们大多数人不是非常喜欢 Linux。他们 认为 Linux 肮脏且不干净。Unix 追随者的一个宗旨是，一切都应“可移植的”。这意味着你编写 的任意一个脚本都应当无需修改，就能运行在任何一个类 Unix 的系统中。</p><p>Unix people have good reason to believe this. Having seen what proprietary extensions to commands and shells did to the Unix world before POSIX, they are naturally wary of the effect of Linux on their beloved OS.</p><p>Unix 用户有充分的理由相信这一点。在 POSIX 之前，Unix 用户已经看到了命令的专有扩展以及 shell 对 Unix 世界的所做所为，他们自然会警惕 Linux 对他们心爱系统的影响。</p><p>But portability has a serious downside. It prevents progress. It requires that things are always done using “lowest common denominator” techniques. In the case of shell programming, it means making everything compatible with sh, the original Bourne shell.</p><p>但是可移植性有一个严重的缺点。它防碍了进步。它要求做事情要遵循“最低常见标准”。 在 shell 编程这种情况下，它意味着一切要与 sh 兼容，最初的 Bourne shell。</p><p>This downside is the excuse that proprietary vendors use to justify their proprietary extensions, only they call them “innovations.” But they are really just lock-in devices for their customers.</p><p>这个缺点是一个专有软件供应商用来为他们专有的扩展做辩解的借口，只有他们称他们为“创新”。 但是他们只是为他们的客户锁定设备。</p><p>The GNU tools, such as bash, have no such restrictions. They encourage portability by supporting standards and by being universally available. You can install bash and the other GNU tools on almost any kind of system, even Windows, without cost. So feel free to use all the features of bash. It’s really portable.</p><p>GNU 工具，比如说 bash，就没有这些限制。他们通过支持标准和普遍地可用性来鼓励可移植性。你几乎可以 在所有类型的系统中安装 bash 和其它的 GNU 工具，甚至是 Windows，而没有损失。所以就 感觉可以自由的使用 bash 的所有功能。它是真正的可移植。</p></blockquote><h3 id="控制操作符：分支的另一种方法"><a href="#控制操作符：分支的另一种方法" class="headerlink" title="控制操作符：分支的另一种方法"></a>控制操作符：分支的另一种方法</h3><p>bash provides two control operators that can perform branching. The <code>&amp;&amp; (AND)</code> and <code>|| (OR)</code>operators work like the logical operators in the <code>[[ ]]</code> compound command. This is the syntax:</p><p>bash 支持两种可以执行分支任务的控制操作符。 <code>&amp;&amp;（AND）</code>和<code>||（OR）</code>操作符作用如同 复合命令<code>[[ ]]</code>中的逻辑操作符。这是语法：</p><pre><code>command1 &amp;&amp; command2</code></pre><p>and</p><p>和</p><pre><code>command1 || command2</code></pre><p>It is important to understand the behavior of these. With the &amp;&amp; operator, command1 is executed and command2 is executed if, and only if, command1 is successful. With the <code>||</code> operator, command1 is executed and command2 is executed if, and only if, command1 is unsuccessful.</p><p>理解这些操作很重要。对于 &amp;&amp; 操作符，先执行 command1，如果并且只有如果 command1 执行成功后， 才会执行 command2。对于 || 操作符，先执行 command1，如果并且只有如果 command1 执行失败后， 才会执行 command2。</p><p>In practical terms, it means that we can do something like this:</p><p>在实际中，它意味着我们可以做这样的事情：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ mkdir temp && cd temp</code></pre><p>This will create a directory named temp, and if it succeeds, the current working directory will be changed to temp. The second command is attempted only if the mkdir command is successful. Likewise, a command like this:</p><p>这会创建一个名为 temp 的目录，并且若它执行成功后，当前目录会更改为 temp。第二个命令会尝试 执行只有当 mkdir 命令执行成功之后。同样地，一个像这样的命令：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ [ -d temp ] || mkdir temp</code></pre><p>will test for the existence of the directory temp, and only if the test fails, will the directory be created. This type of construct is very handy for handling errors in scripts, a subject we will discuss more in later chapters. For example, we could do this in a script:</p><p>会测试目录 temp 是否存在，并且只有测试失败之后，才会创建这个目录。这种构造类型非常有助于在 脚本中处理错误，这个主题我们将会在随后的章节中讨论更多。例如，我们在脚本中可以这样做：</p><pre class=" language-shell"><code class="language-shell">[ -d temp ] || exit 1</code></pre><p>If the script requires the directory temp, and it does not exist, then the script will terminate with an exit status of one.</p><p>如果这个脚本要求目录 temp，且目录不存在，然后脚本会终止，并返回退出状态1。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>We started this chapter with a question. How could we make our <code>sys_info_page</code> script detect if the user had permission to read all the home directories? With our knowledge of if, we can solve the problem by adding this code to the <code>report_home_space</code> function:</p><p>这一章开始于一个问题。我们怎样使 <code>sys_info_page</code> 脚本来检测是否用户拥有权限来读取所有的 家目录？根据我们的 if 知识，我们可以解决这个问题，通过把这些代码添加到 <code>report_home_space</code> 函数中：</p><pre class=" language-shell"><code class="language-shell">report_home_space () {    if [[ $(id -u) -eq 0 ]]; then        cat <<- _EOF_        <H2>Home Space Utilization (All Users)</H2>        <PRE>$(du -sh /home/*)</PRE>_EOF_    else        cat <<- _EOF_        <H2>Home Space Utilization ($USER)</H2>        <PRE>$(du -sh $HOME)</PRE>_EOF_    fi    return}</code></pre><p>We evaluate the output of the id command. With the -u option, id outputs the numeric user ID number of the effective user. The superuser is always zero and every other user is a number greater than zero. Knowing this, we can construct two different here documents, one taking advantage of superuser privileges, and the other, restricted to the user’s own home directory.</p><p>我们计算 id 命令的输出结果。通过带有 -u 选项的 id 命令，输出有效用户的数字用户 ID 号。 超级用户总是零，其它每个用户是一个大于零的数字。知道了这点，我们能够构建两种不同的 here 文档， 一个利用超级用户权限，另一个限制于用户拥有的家目录。</p><p>We are going to take a break from the sys_info_page program, but don’t worry. It will be back. In the meantime, we’ll cover some topics that we’ll need when we resume our work.</p><p>我们将暂别 <code>sys_info_page</code> 程序，但不要着急。它还会回来。同时，当我们继续工作的时候， 将会讨论一些我们需要的话题。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>There are several sections of the bash man page that provide further detail on the topics covered in this chapter:</p><p>bash 手册页中有几部分对本章中涵盖的主题提供了更详细的内容：</p><ul><li>Lists ( 讨论控制操作符 <code>||</code> 和 <code>&amp;&amp;</code> )</li><li>Compound Commands ( 讨论 <code>[[ ]]</code>, <code>(( ))</code> 和 if )</li><li>CONDITIONAL EXPRESSIONS （条件表达式）</li><li>SHELL BUILTIN COMMANDS ( 讨论 test )</li></ul><p>Further, the Wikipedia has a good article on the concept of pseudocode:</p><p>进一步，Wikipedia 中有一篇关于伪代码概念的好文章：</p><p><a href="http://en.wikipedia.org/wiki/Pseudocode" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Pseudocode</a></p>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十七章 自顶向下设计</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AB%A0-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AB%A0-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十六章 启动一个项目</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>Starting with this chapter, we will begin to build a program. The purpose of this project is to see how various shell features are used to create programs and, more importantly, create good programs.</p><p>从这一章开始，我们将建设一个项目。这个项目的目的是为了了解怎样使用各种各样的 shell 功能来 创建程序，更重要的是，创建好程序。</p><p>The program we will write is a report generator. It will present various statistics about our system and its status, and will produce this report in HTML format, so we can view it with a web browser such as Firefox or Konqueror.</p><p>我们将要编写的程序是一个报告生成器。它会显示系统的各种统计数据和它的状态，并将产生 HTML 格式的报告， 所以我们能通过网络浏览器，比如说 Firefox 或者 Konqueror，来查看这个报告。</p><p>Programs are usually built up in a series of stages, with each stage adding features and capabilities. The first stage of our program will produce a very minimal HTML page that contains no system information. That will come later.</p><p>通常，创建程序要经过一系列阶段，每个阶段会添加新的特性和功能。我们程序的第一个阶段将会 产生一个非常小的 HTML 网页，其不包含系统信息。随后我们会添加这些信息。</p><h3 id="第一阶段：最小的文档"><a href="#第一阶段：最小的文档" class="headerlink" title="第一阶段：最小的文档"></a>第一阶段：最小的文档</h3><p>The first thing we need to know is the format of a well-formed HTML document. It looks like this:</p><p>首先我们需要知道的事是一个规则的 HTML 文档的格式。它看起来像这样：</p><pre><code>&lt;HTML&gt;      &lt;HEAD&gt;            &lt;TITLE&gt;Page Title&lt;/TITLE&gt;      &lt;/HEAD&gt;      &lt;BODY&gt;            Page body.      &lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>If we enter this into our text editor and save the file as foo.html, we can use the following URL in Firefox to view the file:</p><p>如果我们将这些内容输入到文本编辑器中，并把文件保存为 foo.html，然后我们就能在 Firefox 中 使用下面的 URL 来查看文件内容：</p><pre><code>file:///home/username/foo.html</code></pre><p>The first stage of our program will be able to output this HTML file to standard output. We can write a program to do this pretty easily. Let’s start our text editor and create a new file named ~/bin/sys_info_page:</p><p>程序的第一个阶段将这个 HTML 文件输出到标准输出。我们可以编写一个程序，相当容易地完成这个任务。 启动我们的文本编辑器，然后创建一个名为 ~/bin/sys_info_page 的新文件：</p><pre><code>[me@linuxbox ~]$ vim ~/bin/sys_info_page</code></pre><p>and enter the following program:</p><p>随后输入下面的程序：</p><pre><code>#!/bin/bash# Program to output a system information pageecho &quot;&lt;HTML&gt;&quot;echo &quot;      &lt;HEAD&gt;&quot;echo &quot;            &lt;TITLE&gt;Page Title&lt;/TITLE&gt;&quot;echo &quot;      &lt;/HEAD&gt;&quot;echo &quot;      &lt;BODY&gt;&quot;echo &quot;            Page body.&quot;echo &quot;      &lt;/BODY&gt;&quot;echo &quot;&lt;/HTML&gt;&quot;</code></pre><p>Our first attempt at this problem contains a shebang, a comment (always a good idea) and a sequence of echo commands, one for each line of output. After saving the file, we’ll make it executable and attempt to run it:</p><p>我们第一次尝试解决这个问题，程序包含了一个 shebang，一条注释（总是一个好主意）和一系列的 echo 命令，每个命令负责输出一行文本。保存文件之后，我们将让它成为可执行文件，再尝试运行它：</p><pre><code>[me@linuxbox ~]$ chmod 755 ~/bin/sys_info_page[me@linuxbox ~]$ sys_info_page</code></pre><p>When the program runs, we should see the text of the HTML document displayed on the screen, since the echo commands in the script send their output to standard output. We’ll run the program again and redirect the output of the program to the file sys_info_page.html, so that we can view the result with a web browser:</p><p>当程序运行的时候，我们应该看到 HTML 文本在屏幕上显示出来，因为脚本中的 echo 命令会将输出 发送到标准输出。我们再次运行这个程序，把程序的输出重定向到文件 sys_info_page.html 中， 从而我们可以通过网络浏览器来查看输出结果：</p><pre><code>[me@linuxbox ~]$ sys_info_page &gt; sys_info_page.html[me@linuxbox ~]$ firefox sys_info_page.html</code></pre><p>So far, so good.</p><p>到目前为止，一切顺利。</p><p>When writing programs, it’s always a good idea to strive for simplicity and clarity. Maintenance is easier when a program is easy to read and understand, not to mention, it can make the program easier to write by reducing the amount of typing. Our current version of the program works fine, but it could be simpler. We could actually combine all the echo commands into one, which will certainly make it easier to add more lines to the program’s output. So, let’s change our program to this:</p><p>在编写程序的时候，尽量做到简单明了，这总是一个好主意。当一个程序易于阅读和理解的时候， 维护它也就更容易，更不用说，通过减少键入量，可以使程序更容易书写了。我们当前的程序版本 工作正常，但是它可以更简单些。实际上，我们可以把所有的 echo 命令结合成一个 echo 命令，当然 这样能更容易地添加更多的文本行到程序的输出中。那么，把我们的程序修改为：</p><pre><code>#!/bin/bash# Program to output a system information pageecho &quot;&lt;HTML&gt;    &lt;HEAD&gt;          &lt;TITLE&gt;Page Title&lt;/TITLE&gt;    &lt;/HEAD&gt;    &lt;BODY&gt;          Page body.    &lt;/BODY&gt;&lt;/HTML&gt;&quot;</code></pre><p>A quoted string may include newlines, and therefore contain multiple lines of text. The shell will keep reading the text until it encounters the closing quotation mark. It works this way on the command line, too:</p><p>一个带引号的字符串可能包含换行符，因此可以包含多个文本行。Shell 会持续读取文本直到它遇到 右引号。它在命令行中也是这样工作的：</p><pre><code>[me@linuxbox ~]$ echo &quot;&lt;HTML&gt;&gt;         &lt;HEAD&gt;                &lt;TITLE&gt;Page Title&lt;/TITLE&gt;&gt;         &lt;/HEAD&gt;&gt;         &lt;BODY&gt;&gt;               Page body.&gt;         &lt;/BODY&gt;&gt;&lt;/HTML&gt;&quot;</code></pre><p>The leading “&gt;” character is the shell prompt contained in the PS2 shell variable. It appears whenever we type a multi-line statement into the shell. This feature is a little obscure right now, but later, when we cover multi-line programming statements, it will turn out to be quite handy.</p><p>开头的 “&gt;” 字符是包含在 PS2shell 变量中的 shell 提示符。每当我们在 shell 中键入多行语句的时候， 这个提示符就会出现。现在这个功能有点儿晦涩，但随后，当我们介绍多行编程语句时，它会派上大用场。</p><h3 id="第二阶段：添加一点儿数据"><a href="#第二阶段：添加一点儿数据" class="headerlink" title="第二阶段：添加一点儿数据"></a>第二阶段：添加一点儿数据</h3><p>Now that our program can generate a minimal document, let’s put some data in the report. To do this, we will make the following changes:</p><p>现在我们的程序能生成一个最小的文档，让我们给报告添加些数据吧。为此，我们将做 以下修改：</p><pre><code>#!/bin/bash# Program to output a system information pageecho &quot;&lt;HTML&gt;    &lt;HEAD&gt;          &lt;TITLE&gt;System Information Report&lt;/TITLE&gt;    &lt;/HEAD&gt;    &lt;BODY&gt;          &lt;H1&gt;System Information Report&lt;/H1&gt;    &lt;/BODY&gt;&lt;/HTML&gt;&quot;</code></pre><p>We added a page title and a heading to the body of the report.</p><p>我们增加了一个网页标题，并且在报告正文部分加了一个标题。</p><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>There is an issue with our script, however. Notice how the string “System Information Report” is repeated? With our tiny script it’s not a problem, but let’s imagine that our script was really long and we had multiple instances of this string. If we wanted to change the title to something else, we would have to change it in multiple places, which could be a lot of work. What if we could arrange the script so that the string only appeared once and not multiple times? That would make future maintenance of the script much easier. Here’s how we could do that:</p><p>然而，我们的脚本存在一个问题。请注意字符串 “System Information Report” 是怎样被重复使用的？对于这个微小的脚本而言，它不是一个问题，但是让我们设想一下， 我们的脚本非常冗长，并且我们有许多这个字符串的实例。如果我们想要更换一个标题，我们必须 对脚本中的许多地方做修改，这会是很大的工作量。如果我们能整理一下脚本，让这个字符串只 出现一次而不是多次，会怎样呢？这样会使今后的脚本维护工作更加轻松。我们可以这样做：</p><pre><code>#!/bin/bash# Program to output a system information pagetitle=&quot;System Information Report&quot;echo &quot;&lt;HTML&gt;        &lt;HEAD&gt;                &lt;TITLE&gt;$title&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;                &lt;H1&gt;$title&lt;/H1&gt;        &lt;/BODY&gt;&lt;/HTML&gt;&quot;</code></pre><p>By creating a variable named title and assigning it the value “System Information Report,” we can take advantage of parameter expansion and place the string in multiple locations.</p><p>通过创建一个名为 title 的变量，并把 “System Information Report” 字符串赋值给它，我们就可以利用参数展开功能，把这个字符串放到文件中的多个位置。</p><p>So, how do we create a variable? Simple, we just use it. When the shell encounters a variable, it automatically creates it. This differs from many programming languages in which variables must be explicitly declared or defined before use. The shell is very lax about this, which can lead to some problems. For example, consider this scenario played out on the command line:</p><p>那么，我们怎样来创建一个变量呢？很简单，我们只管使用它。当 shell 碰到一个变量的时候，它会 自动地创建它。这不同于许多编程语言，它们中的变量在使用之前，必须显式的声明或是定义。关于 这个问题，shell 要求非常宽松，这可能会导致一些问题。例如，考虑一下在命令行中发生的这种情形：</p><pre><code>[me@linuxbox ~]$ foo=&quot;yes&quot;[me@linuxbox ~]$ echo $fooyes[me@linuxbox ~]$ echo $fool[me@linuxbox ~]$</code></pre><p>We first assign the value “yes” to the variable foo, then display its value with echo. Next we display the value of the variable name misspelled as “fool” and get a blank result. This is because the shell happily created the variable fool when it encountered it, and gave it the default value of nothing, or empty. From this, we learn that we must pay close attention to our spelling! It’s also important to understand what really happened in this example. From our previous look at how the shell performs expansions, we know that the command:</p><p>首先我们把 “yes” 赋给变量 foo，然后用 echo 命令来显示变量值。接下来，我们显示拼写错误的变量名 “fool” 的变量值，然后得到一个空值。这是因为 当 shell 遇到 fool 的时候, 它很高兴地创建了变量 fool 并且赋给 fool 一个空的默认值。因此，我们必须小心谨慎地拼写！同样理解实例中究竟发生了什么事情也 很重要。从我们以前学习 shell 执行展开操作，我们知道这个命令：</p><pre><code>[me@linuxbox ~]$ echo $foo</code></pre><p>undergoes parameter expansion and results in:</p><p>经历了参数展开操作，然后得到：</p><pre><code>[me@linuxbox ~]$ echo yes</code></pre><p>Whereas the command:</p><p>然而这个命令：</p><pre><code>[me@linuxbox ~]$ echo $fool</code></pre><p>expands into:</p><p>展开为：</p><pre><code>[me@linuxbox ~]$ echo</code></pre><p>The empty variable expands into nothing! This can play havoc with commands that require arguments. Here’s an example:</p><p>这个空变量展开值为空！对于需要参数的命令来说，这会引起混乱。下面是一个例子：</p><pre><code>[me@linuxbox ~]$ foo=foo.txt[me@linuxbox ~]$ foo1=foo1.txt[me@linuxbox ~]$ cp $foo $foolcp: missing destination file operand after `foo.txt&#39;Try `cp --help&#39; for more information.</code></pre><p>We assign values to two variables, foo and foo1. We then perform a cp, but misspell the name of the second argument. After expansion, the cp command is only sent one argument, though it requires two.</p><p>我们给两个变量赋值，foo 和 foo1。然后我们执行 cp 操作，但是拼写错了第二个参数的名字。 参数展开之后，这个 cp 命令只接受到一个参数，虽然它需要两个。</p><p>There are some rules about variable names:</p><p>有一些关于变量名的规则：</p><ol><li>Variable names may consist of alphanumeric characters (letters and numbers) and underscore characters.</li><li>The first character of a variable name must be either a letter or an underscore.</li><li>Spaces and punctuation symbols are not allowed.</li><li>变量名可由字母数字字符（字母和数字）和下划线字符组成。</li><li>变量名的第一个字符必须是一个字母或一个下划线。</li><li>变量名中不允许出现空格和标点符号。</li></ol><p>The word “variable” implies a value that changes, and in many applications, variables are used this way. However, the variable in our application, title, is used as a constant. A constant is just like a variable in that it has a name and contains a value. The difference is that the value of a constant does not change. In an application that performs geometric calculations, we might define PI as a constant, and assign it the value of 3.1415, instead of using the number literally throughout our program. The shell makes no distinction between variables and constants; they are mostly for the programmer’s convenience. A common convention is to use upper case letters to designate constants and lower case letters for true variables. We will modify our script to comply with this convention:</p><p>单词 “variable” 意味着可变的值，并且在许多应用程序当中，都是以这种方式来使用变量的。然而， 我们应用程序中的变量，title，被用作一个常量。常量有一个名字且包含一个值，在这方面就 像是变量。不同之处是常量的值是不能改变的。在执行几何运算的应用程序中，我们可以把 PI 定义为 一个常量，并把 3.1415 赋值给它，用它来代替数字字面值。shell 不能辨别变量和常量；它们大多数情况下 是为了方便程序员。一个常用惯例是指定大写字母来表示常量，小写字母表示真正的变量。我们 将修改我们的脚本来遵从这个惯例：</p><pre><code>#!/bin/bash# Program to output a system information pageTITLE=&quot;System Information Report For $HOSTNAME&quot;echo &quot;&lt;HTML&gt;        &lt;HEAD&gt;                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;                &lt;H1&gt;$TITLE&lt;/H1&gt;        &lt;/BODY&gt;&lt;/HTML&gt;&quot;</code></pre><p>We also took the opportunity to jazz up our title by adding the value of the shell variable HOSTNAME. This is the network name of the machine.</p><p>我们亦借此机会，通过在标题中添加 shell 变量名 HOSTNAME，让标题变得活泼有趣些。 这个变量名是这台机器的网络名称。</p><hr><p>Note: The shell actually does provide a way to enforce the immutability of constants, through the use of the declare builtin command with the -r (read- only) option. Had we assigned TITLE this way:</p><p>注意：实际上，shell 确实提供了一种方法，通过使用带有-r（只读）选项的内部命令 declare， 来强制常量的不变性。如果我们给 TITLE 这样赋值：</p><p>declare -r TITLE=”Page Title”</p><p>the shell would prevent any subsequent assignment to TITLE. This feature is rarely used, but it exists for very formal scripts.</p><p>那么随后所有给 TITLE 的赋值都会被 shell 阻止。这个功能极少被使用，但为了很早之前的脚本， 它仍然存在。</p><hr><h4 id="给变量和常量赋值"><a href="#给变量和常量赋值" class="headerlink" title="给变量和常量赋值"></a>给变量和常量赋值</h4><p>Here is where our knowledge of expansion really starts to pay off. As we have seen, variables are assigned values this way:</p><p>这里是我们真正开始使用参数扩展知识的地方。正如我们所知道的，这样给变量赋值：</p><pre><code>variable=value</code></pre><p>where variable is the name of the variable and value is a string. Unlike some other programming languages, the shell does not care about the type of data assigned to a variable; it treats them all as strings. You can force the shell to restrict the assignment to integers by using the declare command with the -i option, but, like setting variables as read-only, this is rarely done.</p><p>这里的<em>variable</em>是变量的名字，<em>value</em>是一个字符串。不同于一些其它的编程语言，shell 不会 在乎变量值的类型；它把它们都看作是字符串。通过使用带有-i 选项的 declare 命令，你可以强制 shell 把 赋值限制为整数，但是，正如像设置变量为只读一样，极少这样做。</p><p>Note that in an assignment, there must be no spaces between the variable name, the equals sign, and the value. So what can the value consist of? Anything that we can expand into a string:</p><p>注意在赋值过程中，变量名、等号和变量值之间必须没有空格。那么，这些值由什么组成呢？ 可以展开成字符串的任意值：</p><pre><code>a=z                     # Assign the string &quot;z&quot; to variable a.b=&quot;a string&quot;            # Embedded spaces must be within quotes.c=&quot;a string and $b&quot;     # Other expansions such as variables can be                        # expanded into the assignment.d=$(ls -l foo.txt)      # Results of a command.e=$((5 * 7))            # Arithmetic expansion.f=&quot;\t\ta string\n&quot;      # Escape sequences such as tabs and newlines.</code></pre><p>Multiple variable assignments may be done on a single line:</p><p>可以在同一行中对多个变量赋值：</p><pre><code>a=5 b=&quot;a string&quot;</code></pre><p>During expansion, variable names may be surrounded by optional curly braces “{}”. This is useful in cases where a variable name becomes ambiguous due to its surrounding context. Here, we try to change the name of a file from myfile to myfile1, using a variable:</p><p>在参数展开过程中，变量名可能被花括号 “{}” 包围着。由于变量名周围的上下文，其变得不明确的情况下， 这会很有帮助。这里，我们试图把一个文件名从 myfile 改为 myfile1，使用一个变量：</p><pre><code>[me@linuxbox ~]$ filename=&quot;myfile&quot;[me@linuxbox ~]$ touch $filename[me@linuxbox ~]$ mv $filename $filename1mv: missing destination file operand after `myfile&#39;Try `mv --help&#39; for more information.</code></pre><p>This attempt fails because the shell interprets the second argument of the mv command as a new (and empty) variable. The problem can be overcome this way:</p><p>这种尝试失败了，因为 shell 把 mv 命令的第二个参数解释为一个新的（并且空的）变量。通过这种方法 可以解决这个问题：</p><pre><code>[me@linuxbox ~]$ mv $filename ${filename}1</code></pre><p>By adding the surrounding braces, the shell no longer interprets the trailing 1 as part of the variable name.</p><p>通过添加花括号，shell 不再把末尾的1解释为变量名的一部分。</p><p>We’ll take this opportunity to add some data to our report, namely the date and time the report was created and the user name of the creator:</p><p>我们将利用这个机会来添加一些数据到我们的报告中，即创建包括的日期和时间，以及创建者的用户名：</p><pre><code>#!/bin/bash# Program to output a system information pageTITLE=&quot;System Information Report For $HOSTNAME&quot;CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;echo &quot;&lt;HTML&gt;        &lt;HEAD&gt;                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;                &lt;H1&gt;$TITLE&lt;/H1&gt;                &lt;P&gt;$TIME_STAMP&lt;/P&gt;        &lt;/BODY&gt;&lt;/HTML&gt;&quot;</code></pre><h3 id="Here-Documents"><a href="#Here-Documents" class="headerlink" title="Here Documents"></a>Here Documents</h3><p>We’ve looked at two different methods of outputting our text, both using the echo command. There is a third way called a <em>here document</em> or <em>here script</em>. A here document is an additional form of I/O redirection in which we embed a body of text into our script and feed it into the standard input of a command. It works like this:</p><p>我们已经知道了两种不同的文本输出方法，两种方法都使用了 echo 命令。还有第三种方法，叫做 here document 或者 here script。一个 here document 是另外一种 I/O 重定向形式，我们 在脚本文件中嵌入正文文本，然后把它发送给一个命令的标准输入。它这样工作：</p><pre><code>command &lt;&lt; tokentexttoken</code></pre><p>where <em>command</em> is the name of command that accepts standard input and <em>token</em> is a string used to indicate the end of the embedded text. We’ll modify our script to use a here document:</p><p>这里的 command 是一个可以接受标准输入的命令名，token 是一个用来指示嵌入文本结束的字符串。 我们将修改我们的脚本，来使用一个 here document:</p><pre><code>#!/bin/bash# Program to output a system information pageTITLE=&quot;System Information Report For $HOSTNAME&quot;CURRENT_TIME=$(date +&quot;%x %r %Z&quot;)TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot;cat &lt;&lt; _EOF_&lt;HTML&gt;         &lt;HEAD&gt;                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;         &lt;/HEAD&gt;         &lt;BODY&gt;                &lt;H1&gt;$TITLE&lt;/H1&gt;                &lt;P&gt;$TIME_STAMP&lt;/P&gt;         &lt;/BODY&gt;&lt;/HTML&gt;_EOF_</code></pre><p>Instead of using echo, our script now uses cat and a here document. The string <em>EOF</em> (meaning “End Of File,” a common convention) was selected as the token, and marks the end of the embedded text. Note that the token must appear alone and that there must not be trailing spaces on the line.</p><p>取代 echo 命令，现在我们的脚本使用 cat 命令和一个 here document。这个字符串_EOF_（意思是“文件结尾”， 一个常见用法）被选作为 token，并标志着嵌入文本的结尾。注意这个 token 必须在一行中单独出现，并且文本行中 没有末尾的空格。</p><p>So what’s the advantage of using a here document? It’s mostly the same as echo, except that, by default, single and double quotes within here documents lose their special meaning to the shell. Here is a command line example:</p><p>那么使用一个 here document 的优点是什么呢？它很大程度上和 echo 一样，除了默认情况下，here documents 中的单引号和双引号会失去它们在 shell 中的特殊含义。这里有一个命令中的例子：</p><pre><code>[me@linuxbox ~]$ foo=&quot;some text&quot;[me@linuxbox ~]$ cat &lt;&lt; _EOF_&gt; $foo&gt; &quot;$foo&quot;&gt; &#39;$foo&#39;&gt; \$foo&gt; _EOF_some text&quot;some text&quot;&#39;some text&#39;$foo</code></pre><p>As we can see, the shell pays no attention to the quotation marks. It treats them as ordinary characters. This allows us to embed quotes freely within a here document. This could turn out to be handy for our report program.</p><p>正如我们所见到的，shell 根本没有注意到引号。它把它们看作是普通的字符。这就允许我们 在一个 here document 中可以随意的嵌入引号。对于我们的报告程序来说，这将是非常方便的。</p><p>Here documents can be used with any command that accepts standard input. In this example, we use a here document to pass a series of commands to the ftp program in order to retrieve a file from a remote FTP server:</p><p>Here documents 可以和任意能接受标准输入的命令一块使用。在这个例子中，我们使用了 一个 here document 将一系列的命令传递到这个 ftp 程序中，为的是从一个远端 FTP 服务器中得到一个文件：</p><pre><code>#!/bin/bash# Script to retrieve a file via FTPFTP_SERVER=ftp.nl.debian.orgFTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdromREMOTE_FILE=debian-cd_info.tar.gzftp -n &lt;&lt; _EOF_open $FTP_SERVERuser anonymous me@linuxboxcd $FTP_PATHhashget $REMOTE_FILEbye_EOF_ls -l $REMOTE_FILE</code></pre><p>If we change the redirection operator from “&lt;&lt;” to “&lt;&lt;-“, the shell will ignore leading tab characters in the here document. This allows a here document to be indented, which can improve readability:</p><p>如果我们把重定向操作符从 “&lt;&lt;” 改为 “&lt;&lt;-”，shell 会忽略在此 here document 中开头的 tab 字符。 这就能缩进一个 here document，从而提高脚本的可读性：</p><pre><code>#!/bin/bash# Script to retrieve a file via FTPFTP_SERVER=ftp.nl.debian.orgFTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdromREMOTE_FILE=debian-cd_info.tar.gzftp -n &lt;&lt;- _EOF_    open $FTP_SERVER    user anonymous me@linuxbox    cd $FTP_PATH    hash    get $REMOTE_FILE    bye_EOF_ls -l $REMOTE_FILE</code></pre><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this chapter, we started a project that will carry us through the process of building a successful script. We introduced the concept of variables and constants and how they can be employed. They are the first of many applications we will find for parameter expansion. We also looked at how to produce output from our script, and various methods for embedding blocks of text.</p><p>在这一章中，我们启动了一个项目，其带领我们领略了创建一个成功脚本的整个过程。 同时我们介绍了变量和常量的概念，以及怎样使用它们。它们是我们将找到的众多参数展开应用程序中的第一批实例。 我们也知道了怎样从我们的脚本文件中产生输出，及其各种各样嵌入文本块的方法。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>For more information about HTML, see the following articles and tutorials:</p></li><li><p>关于 HTML 的更多信息，查看下面的文章和教材：</p><p><a href="http://en.wikipedia.org/wiki/Html" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Html</a></p><p><a href="http://en.wikibooks.org/wiki/HTML_Programming" target="_blank" rel="noopener">http://en.wikibooks.org/wiki/HTML_Programming</a></p><p><a href="http://html.net/tutorials/html/" target="_blank" rel="noopener">http://html.net/tutorials/html/</a></p></li><li><p>The bash man page includes a section entitled “HERE DOCUMENTS,” which has a full description of this feature.</p></li><li><p>Bash 手册包括一节“HERE DOCUMENTS”的内容，其详细的讲述了这个功能。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十五章 编写第一个Shell脚本</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShell%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>In the preceding chapters, we have assembled an arsenal of command line tools. While these tools can solve many kinds of computing problems, we are still limited to manually using them one by one on the command line. Wouldn’t it be great if we could get the shell to do more of the work? We can. By joining our tools together into programs of our own design, the shell can carry out complex sequences of tasks all by itself. We can enable it to do this by writing shell scripts.</p><p>在前面的章节中，我们已经装备了一个命令行工具的武器库。虽然这些工具能够解决许多种计算问题， 但是我们仍然局限于在命令行中手动地一个一个使用它们。如果我们能够让 shell 来完成更多的工作, 岂不是更好？ 我们可以的。通过把我们的工具一起放置到我们自己设计的程序中, shell 就会自己来执行这些复杂的任务序列。 通过编写 shell 脚本，我们可以让 shell 来做这些事情。</p><h3 id="什么是-Shell-脚本？"><a href="#什么是-Shell-脚本？" class="headerlink" title="什么是 Shell 脚本？"></a>什么是 Shell 脚本？</h3><p>In the simplest terms, a shell script is a file containing a series of commands. The shell reads this file and carries out the commands as though they have been entered directly on the command line.</p><p>最简单的解释，一个 shell 脚本就是一个包含一系列命令的文件。shell 读取这个文件，然后执行 文件中的所有命令，就好像这些命令已经直接被输入到了命令行中一样。</p><p>The shell is somewhat unique, in that it is both a powerful command line interface to the system and a scripting language interpreter. As we will see, most of the things that can be done on the command line can be done in scripts, and most of the things that can be done in scripts can be done on the command line.</p><p>Shell 有些独特，因为它不仅是一个功能强大的命令行接口,也是一个脚本语言解释器。我们将会看到， 大多数能够在命令行中完成的任务也能够用脚本来实现，同样地，大多数能用脚本实现的操作也能够 在命令行中完成。</p><p>We have covered many shell features, but we have focused on those features most often used directly on the command line. The shell also provides a set of features usually (but not always) used when writing programs.</p><p>虽然我们已经介绍了许多 shell 功能，但只是集中于那些经常直接在命令行中使用的功能。 Shell 也提供了一些通常（但不总是）在编写程序时才使用的功能。</p><h3 id="怎样编写一个-Shell-脚本"><a href="#怎样编写一个-Shell-脚本" class="headerlink" title="怎样编写一个 Shell 脚本"></a>怎样编写一个 Shell 脚本</h3><p>To successfully create and run a shell script, we need to do three things:</p><p>为了成功地创建和运行一个 shell 脚本，我们需要做三件事情：</p><ol><li><strong>Write a script.</strong> Shell scripts are ordinary text files. So we need a text editor to write them. The best text editors will provide syntax highlighting, allowing us to see a color-coded view of the elements of the script. Syntax highlighting will help us spot certain kinds of common errors. vim, gedit, kate, and many other editors are good candidates for writing scripts.</li><li><strong>Make the script executable.</strong> The system is rather fussy about not letting any old text file be treated as a program, and for good reason! We need to set the script file’s permissions to allow execution.</li><li><strong>Put the script somewhere the shell can find it.</strong> The shell automatically searches certain directories for executable files when no explicit pathname is specified. For maximum convenience, we will place our scripts in these directories.</li><li><em>编写一个脚本。</em> Shell 脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它们。最好的文本 编辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编码视图。语法高亮会帮助我们查看某种常见 错误。为了编写脚本文件，vim，gedit，kate，和许多其它编辑器都是不错的候选者。</li><li><em>使脚本文件可执行。</em> 系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且有充分的理由! 所以我们需要设置脚本文件的权限来允许其可执行。</li><li><em>把脚本放置到 shell 能够找到的地方。</em> 当没有指定可执行文件明确的路径名时，shell 会自动地搜索某些目录， 来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些目录当中。</li></ol><h3 id="脚本文件格式"><a href="#脚本文件格式" class="headerlink" title="脚本文件格式"></a>脚本文件格式</h3><p>In keeping with programming tradition, we’ll create a “hello world” program to demonstrate an extremely simple script. So let’s fire up our text editors and enter the following script:</p><p>为了保持编程传统，我们将创建一个 “hello world” 程序来说明一个极端简单的脚本。所以让我们启动 我们的文本编辑器，然后输入以下脚本：</p><pre><code>#!/bin/bash# This is our first script.echo &#39;Hello World!&#39;</code></pre><p>The last line of our script is pretty familiar, just an echo command with a string argument. The second line is also familiar. It looks like a comment that we have seen used in many of the configuration files we have examined and edited. One thing about comments in shell scripts is that they may also appear at the end of lines, like so:</p><p>对于脚本中的最后一行，我们应该是相当的熟悉，仅仅是一个带有一个字符串参数的 echo 命令。 对于第二行也很熟悉。它看起来像一个注释，我们已经在许多我们检查和编辑过的配置文件中 看到过。关于 shell 脚本中的注释，它们也可以出现在文本行的末尾，像这样：</p><pre><code>echo &#39;Hello World!&#39; # This is a comment too</code></pre><p>Everything from the # symbol onward on the line is ignored.</p><p>文本行中，# 符号之后的所有字符都会被忽略。</p><p>Like many things, this works on the command line, too:</p><p>类似于许多命令，这也在命令行中起作用：</p><pre><code>[me@linuxbox ~]$ echo &#39;Hello World!&#39; # This is a comment tooHello World!</code></pre><p>Though comments are of little use on the command line, they will work.</p><p>虽然很少在命令行中使用注释，但它们也能起作用。</p><p>The first line of our script is a little mysterious. It looks like it should be a comment, since it starts with #, but it looks too purposeful to be just that. The #! character sequence is, in fact, a special construct called a shebang. The shebang is used to tell the system the name of the interpreter that should be used to execute the script that follows. Every shell script should include this as its first line.</p><p>我们脚本中的第一行文本有点儿神秘。它看起来它应该是一条注释，因为它起始于一个#符号，但是 它看起来太有意义，以至于不仅仅是注释。事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行 作为它的第一行。</p><p>Let’s save our script file as hello_world.</p><p>让我们把此脚本文件保存为 hello_world。</p><h3 id="可执行权限"><a href="#可执行权限" class="headerlink" title="可执行权限"></a>可执行权限</h3><p>The next thing we have to do is make our script executable. This is easily done using chmod:</p><p>下一步我们要做的事情是让我们的脚本可执行。使用 chmod 命令，这很容易做到：</p><pre><code>[me@linuxbox ~]$ ls -l hello_world-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world[me@linuxbox ~]$ chmod 755 hello_world[me@linuxbox ~]$ ls -l hello_world-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world</code></pre><p>There are two common permission settings for scripts; 755 for scripts that everyone can execute, and 700 for scripts that only the owner can execute. Note that scripts must be readable in order to be executed.</p><p>对于脚本文件，有两个常见的权限设置；权限为755的脚本，则每个人都能执行，和权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p><h3 id="脚本文件位置"><a href="#脚本文件位置" class="headerlink" title="脚本文件位置"></a>脚本文件位置</h3><p>With the permissions set, we can now execute our script:</p><p>当设置了脚本权限之后，我们就能执行我们的脚本了：</p><pre><code>[me@linuxbox ~]$ ./hello_worldHello World!</code></pre><p>In order for the script to run, we must precede the script name with an explicit path. If we don’t, we get this:</p><p>为了能够运行此脚本，我们必须指定脚本文件明确的路径。如果我们没有那样做，我们会得到这样的提示：</p><pre><code>[me@linuxbox ~]$ hello_worldbash: hello_world: command not found</code></pre><p>Why is this? What makes our script different from other programs? As it turns out, nothing. Our script is fine. Its location is the problem. Back in Chapter 12, we discussed the PATH environment variable and its effect on how the system searches for executable programs. To recap, the system searches a list of directories each time it needs to find an executable program, if no explicit path is specified. This is how the system knows to execute /bin/ls when we type ls at the command line. The /bin directory is one of the directories that the system automatically searches. The list of directories is held within an environment variable named PATH. The PATH variable contains a colon- separated list of directories to be searched. We can view the contents of PATH:</p><p>为什么会这样呢？什么使我们的脚本不同于其它的程序？结果证明，什么也没有。我们的 脚本没有问题。是脚本存储位置的问题。回到第12章，我们讨论了 PATH 环境变量及其在系统 查找可执行程序方面的作用。回顾一下，如果没有给出可执行程序的明确路径名，那么系统每次都会 搜索一系列的目录，来查找此可执行程序。这个/bin 目录就是其中一个系统会自动搜索的目录。 这个目录列表被存储在一个名为 PATH 的环境变量中。这个 PATH 变量包含一个由冒号分隔开的目录列表。 我们可以查看 PATH 的内容：</p><pre><code>[me@linuxbox ~]$ echo $PATH/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</code></pre><p>Here we see our list of directories. If our script were located in any of the directories in the list, our problem would be solved. Notice the first directory in the list, /home/me/bin. Most Linux distributions configure the PATH variable to contain a bin directory in the user’s home directory, to allow users to execute their own programs. So if we create the bin directory and place our script within it, it should start to work like other programs:</p><p>这里我们看到了我们的目录列表。如果我们的脚本位于此列表中任意目录下，那么我们的问题将 会被解决。注意列表中的第一个目录/home/me/bin。大多数的 Linux 发行版会配置 PATH 变量，让其包含 一个位于用户家目录下的 bin 目录，从而允许用户能够执行他们自己的程序。所以如果我们创建了 一个 bin 目录，并把我们的脚本放在这个目录下，那么这个脚本就应该像其它程序一样开始工作了：</p><pre><code>[me@linuxbox ~]$ mkdir bin[me@linuxbox ~]$ mv hello_world bin[me@linuxbox ~]$ hello_worldHello World!</code></pre><p>And so it does.</p><p>它的确工作了。</p><p>If the PATH variable does not contain the directory, we can easily add it by including this line in our .bashrc file:</p><p>如果这个 PATH 变量不包含这个目录，我们能够轻松地添加它，通过在我们的.bashrc 文件中包含下面 这一行文本：</p><pre><code>export PATH=~/bin:&quot;$PATH&quot;</code></pre><p>After this change is made, it will take effect in each new terminal session. To apply the change to the current terminal session, we must have the shell re-read the .bashrc file. This can be done by “sourcing” it:</p><p>当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中， 我们必须让 shell 重新读取这个 .bashrc 文件。这可以通过 “sourcing”.bashrc 文件来完成：</p><pre><code>[me@linuxbox ~]$ . .bashrc</code></pre><p>The dot (.) command is a synonym for the source command, a shell builtin which reads a specified file of shell commands and treats it like input from the keyboard.</p><p>这个点（.）命令是 source 命令的同义词，一个 shell 内建命令，用来读取一个指定的 shell 命令文件， 并把它看作是从键盘中输入的一样。</p><hr><p>Note: Ubuntu automatically adds the ~/bin directory to the PATH variable if the ~/bin directory exists when the user’s .bashrc file is executed. So, on Ubuntu systems, if we create the ~/bin directory and then log out and log in again, everything works.</p><p>注意：在 Ubuntu 系统中，如果存在 ~/bin 目录，当执行用户的 .bashrc 文件时， Ubuntu 会自动地添加这个 ~/bin 目录到 PATH 变量中。所以在 Ubuntu 系统中，如果我们创建 了这个 ~/bin 目录，随后退出，然后再登录，一切会正常运行。</p><hr><h4 id="脚本文件的好去处"><a href="#脚本文件的好去处" class="headerlink" title="脚本文件的好去处"></a>脚本文件的好去处</h4><p>The ~/bin directory is a good place to put scripts intended for personal use. If we write a script that everyone on a system is allowed to use, the traditional location is /usr/local/bin. Scripts intended for use by the system administrator are often located in /usr/local/sbin. In most cases, locally supplied software, whether scripts or compiled programs, should be placed in the /usr/local hierarchy and not in /bin or /usr/bin. These directories are specified by the Linux Filesystem Hierarchy Standard to contain only files supplied and maintained by the Linux distributor.</p><p>这个 ~/bin 目录是存放为个人所用脚本的好地方。如果我们编写了一个脚本，系统中的每个用户都可以使用它， 那么这个脚本的传统位置是 /usr/local/bin。系统管理员使用的脚本经常放到 /usr/local/sbin 目录下。 大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，都应该放到 /usr/local 目录下， 而不是在 /bin 或 /usr/bin 目录下。这些目录都是由 Linux 文件系统层次结构标准指定，只包含由 Linux 发行商 所提供和维护的文件。</p><h3 id="更多的格式技巧"><a href="#更多的格式技巧" class="headerlink" title="更多的格式技巧"></a>更多的格式技巧</h3><p>One of the key goals of serious script writing is ease of maintenance; that is, the ease with which a script may be modified by its author or others to adapt it to changing needs. Making a script easy to read and understand is one way to facilitate easy maintenance.</p><p>严肃认真的脚本书写的关键目标之一是为了易于维护；也就是说，一个脚本可以轻松地被作者或其它 用户修改，使它适应变化的需求。使脚本容易阅读和理解是一种方便维护的方法。</p><h4 id="长选项名称"><a href="#长选项名称" class="headerlink" title="长选项名称"></a>长选项名称</h4><p>Many of the commands we have studied feature both short and long option names. For instance, the ls command has many options that can be expressed in either short or long form. For example:</p><p>我们学过的许多命令都以长短两种选项名称为特征。例如，这个 ls 命令有许多选项既可以用短形式也 可以用长形式来表示。例如：</p><pre><code>[me@linuxbox ~]$ ls -ad</code></pre><p>and:</p><p>和：</p><pre><code>[me@linuxbox ~]$ ls --all --directory</code></pre><p>are equivalent commands. In the interests of reduced typing, short options are preferred when entering options on the command line, but when writing scripts, long options can provide improved readability.</p><p>是等价的命令。为了减少输入，当在命令行中输入选项的时候，短选项更受欢迎，但是当书写脚本的时候， 长选项能提供可读性。</p><h4 id="缩进和行继续符"><a href="#缩进和行继续符" class="headerlink" title="缩进和行继续符"></a>缩进和行继续符</h4><p>When employing long commands, readability can be enhanced by spreading the command over several lines. In Chapter 18, we looked at a particularly long example of the find command:</p><p>当使用长命令的时候，通过把命令在几个文本行中展开，可以提高命令的可读性。 在第十八章中，我们看到了一个特别长的 find 命令实例：</p><pre><code>[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -execchmod 0600 ‘{}’ ‘;’ \) -or \( -type d -not -perm 0711 -exec chmod0711 ‘{}’ ‘;’ \)</code></pre><p>Obviously, this command is a little hard to figure out at first glance. In a script, this command might be easier to understand if written this way:</p><p>显然，这个命令有点儿难理解，当第一眼看到它的时候。在脚本中，这个命令可能会比较容易 理解，如果这样书写它：</p><pre><code>find playground \    \( \        -type f \        -not -perm 0600 \        -exec chmod 0600 ‘{}’ ‘;’ \    \) \    -or \    \( \        -type d \        -not -perm 0711 \        -exec chmod 0711 ‘{}’ ‘;’ \    \)</code></pre><p>By using line continuations (backslash-linefeed sequences) and indentation, the logic of this complex command is more clearly described to the reader. This technique works on the command line, too, though it is seldom used, as it is very awkward to type and edit. One difference between a script and the command line is that the script may employ tab characters to achieve indentation, whereas the command line cannot, since tabs are used to activate completion.</p><p>通过使用行继续符（反斜杠-回车符序列）和缩进，这个复杂命令的逻辑会被更清楚地描述给读者。 这个技巧在命令行中同样有效，虽然很少使用它，因为输入和编辑这个命令非常麻烦。脚本和 命令行的一个区别是，脚本可能使用 tab 字符来实现缩进，然而命令行却不能，因为 tab 字符被用来 激活自动补全功能。</p><blockquote><p>Configuring vim For Script Writing</p><p>为书写脚本配置 vim</p><p>The vim text editor has many, many configuration settings. There are several common options that can facilitate script writing:</p><p>这个 vim 文本编辑器有许多许多的配置设置。有几个常见的选项能够有助于脚本书写：</p><p><em>:syntax on</em></p><p>turns on syntax highlighting. With this setting, different elements of shell syntax will be displayed in different colors when viewing a script. This is helpful for identifying certain kinds of programming errors. It looks cool, too. Note that for this feature to work, you must have a complete version of vim installed, and the file you are editing must have a shebang indicating the file is a shell script. If you have difficulty with the command above, try <em>:set syntax=sh</em> instead.</p><p>打开语法高亮。通过这个设置，当查看脚本的时候，不同的 shell 语法元素会以不同的颜色 显示。这对于识别某些编程错误很有帮助。并且它看起来也很酷。注意为了这个功能起作用，你 必须安装了一个完整的 vim 版本，并且你编辑的文件必须有一个 shebang，来说明这个文件是 一个 shell 脚本。如果对于上面的命令，你遇到了困难，试试 <em>:set syntax=sh</em>。</p><p><em>:set hlsearch</em></p><p>turns on the option to highlight search results. Say we search for the word “echo.” With this option on, each instance of the word will be highlighted.</p><p>打开这个选项是为了高亮查找结果。比如说我们查找单词“echo”。通过设置这个选项，这个 单词的每个实例会高亮显示。</p><p><em>:set tabstop=4</em></p><p>sets the number of columns occupied by a tab character. The default is eight columns. Setting the value to four (which is a common practice) allows long lines to fit more easily on the screen.</p><blockquote><p>设置一个 tab 字符所占据的列数。默认是8列。把这个值设置为4（一种常见做法）， 从而让长文本行更容易适应屏幕。</p></blockquote><p><em>:set autoindent</em></p><p>turns on the “auto indent” feature. This causes vim to indent a new line the same amount as the line just typed. This speeds up typing on many kinds of programming constructs. To stop indentation, type Ctrl-d.</p><p>打开 “auto indent” 功能。这导致 vim 能对新的文本行缩进与刚输入的文本行相同的列数。 对于许多编程结构来说，这就加速了输入。停止缩进，输入 Ctrl-d。</p><p>These changes can be made permanent by adding these commands (without the leading colon characters) to your ~/.vimrc file.</p><p>通过把这些命令（没有开头的冒号字符）添加到你的 ~/.vimrc 文件中，这些改动会永久生效。</p></blockquote><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this first chapter of scripting, we have looked at how scripts are written and made to easily execute on our system. We also saw how we may use various formatting techniques to improve the readability (and thus, the maintainability) of our scripts. In future chapters, ease of maintenance will come up again and again as a central principle in good script writing.</p><p>在这脚本编写的第一章中，我们已经看过怎样编写脚本，怎样让它们在我们的系统中轻松地执行。 我们也知道了怎样使用各种格式技巧来提高脚本的可读性（可维护性）。在以后的各章中，轻松维护 会作为编写好脚本的中心法则一次又一次地出现。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>For “Hello World” programs and examples in various programming languages, see:</p></li><li><p>查看各种各样编程语言的“Hello World”程序和实例：</p><p><a href="http://en.wikipedia.org/wiki/Hello_world" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Hello_world</a></p></li><li><p>This Wikipedia article talks more about the shebang mechanism:</p></li><li><p>这篇 Wikipedia 文章讨论了更多关于 shebang 机制的内容：</p><p><a href="http://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Shebang_(Unix)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十四章 编译程序</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>In this chapter, we will look at how to build programs by compiling source code. The availability of source code is the essential freedom that makes Linux possible. The entire ecosystem of Linux development relies on free exchange between developers. For many desktop users, compiling is a lost art. It used to be quite common, but today, distribution providers maintain huge repositories of precompiled binaries, ready to download and use. At the time of this writing, the Debian repository (one of the largest of any of the distributions) contains almost 23,000 packages.</p><p>在这一章中，我们将看一下如何通过编译源代码来创建程序。源代码的可用性是至关重要的自由，从而使得 Linux 成为可能。 整个 Linux 开发生态圈就是依赖于开发者之间的自由交流。对于许多桌面用户来说，编译是一种失传的艺术。以前很常见， 但现在，由系统发行版提供商维护巨大的预编译的二进制仓库，准备供用户下载和使用。在写这篇文章的时候， Debian 仓库（最大的发行版之一）包含了几乎23,000个预编译的包。</p><p>So why compile software? There are two reasons:</p><p>那么为什么要编译软件呢？ 有两个原因：</p><ol><li>Availability. Despite the number of precompiled programs in distribution repositories, some distributions may not include all the desired applications. In this case, the only way to get the desired program is to compile it from source.</li><li>Timeliness. While some distributions specialize in cutting edge versions of programs, many do not. This means that in order to have the very latest version of a program, compiling is necessary.</li><li>可用性。尽管系统发行版仓库中已经包含了大量的预编译程序，但是一些发行版本不可能包含所有期望的应用。 在这种情况下，得到所期望程序的唯一方式是编译程序源码。</li><li>及时性。虽然一些系统发行版专门打包前沿版本的应用程序，但是很多不是。这意味着， 为了拥有一个最新版本的程序，编译是必需的。</li></ol><p>Compiling software from source code can become very complex and technical; well beyond the reach of many users. However, many compiling tasks are quite easy and involve only a few steps. It all depends on the package. We will look at a very simple case in order to provide an overview of the process and as a starting point for those who wish to undertake further study.</p><p>从源码编译软件可以变得非常复杂且具有技术性；许多用户难以企及。然而，许多编译任务是 相当简单的，只涉及到几个步骤。这都取决于程序包。我们将看一个非常简单的案例， 为的是给大家提供一个对编译过程的整体认识，并为那些愿意进一步学习的人们构筑一个起点。</p><p>We will introduce one new command:</p><p>我们将介绍一个新命令：</p><ul><li>make – Utility to maintain programs</li><li>make - 维护程序的工具</li></ul><h3 id="什么是编译？"><a href="#什么是编译？" class="headerlink" title="什么是编译？"></a>什么是编译？</h3><p>Simply put, compiling is the process of translating source code (the human-readable description of a program written by a programmer) into the native language of the computer’s processor.</p><p>简而言之，编译就是把源码（一个由程序员编写的人类可读的程序的说明）翻译成计算机处理器的语言的过程。</p><p>The computer’s processor (or CPU) works at a very elemental level, executing programs in what is called machine language. This is a numeric code that describes very small operations, such as “add this byte,” “point to this location in memory,” or “copy this byte.”</p><p>计算机处理器（或 CPU）工作在一个非常基本的水平，执行用机器语言编写的程序。这是一种数值编码，描述非常小的操作， 比如“加这个字节”、“指向内存中的这个位置”或者“复制这个字节”。</p><p>Each of these instructions is expressed in binary (ones and zeros). The earliest computer programs were written using this numeric code, which may explain why programmers who wrote it were said to smoke a lot, drink gallons of coffee, and wear thick glasses.This problem was overcome by the advent of assembly language, which replaced the numeric codes with (slightly) easier to use character mnemonics such as CPY (for copy) and MOV (for move). Programs written in assembly language are processed into machine language by a program called an assembler. Assembly language is still used today for certain specialized programming tasks, such as device drivers and embedded systems.</p><p>这些指令中的每一条都是用二进制表示的（1和0）。最早的计算机程序就是用这种数值编码写成的，这可能就 解释了为什么编写它们的程序员据说吸很多烟，喝大量咖啡，并带着厚厚的眼镜。随着汇编语言的出现，这个问题得到克服。 汇编语言使用诸如CPY（复制）和 MOV（移动）之类（略微）易用的字符助记符代替了数值编码 。用汇编语言编写的程序通过 汇编器处理为机器语言。今天为了完成某些特定的程序任务，汇编语言仍在被使用，例如设备驱动和嵌入式系统。</p><p>We next come to what are called high-level programming languages. They are called this because they allow the programmer to be less concerned with the details of what the processor is doing and more with solving the problem at hand. The early ones (developed during the 1950s) included FORTRAN (designed for scientific and technical tasks) and COBOL (designed for business applications). Both are still in limited use today.</p><p>下一步我们谈论一下什么是所谓的高级编程语言。之所以这样称呼它们，是因为它们可以让程序员少操心处理器的 一举一动，而更多关心如何解决手头的问题。早期的高级语言（二十世纪50年代期间研发的）包括 FORTRAN（为科学和技术任务而设计）和 COBOL（为商业应用而设计）。今天这两种语言仍在有限的使用。</p><p>While there are many popular programming languages, two predominate. Most programs written for modern systems are written in either C or C++. In the examples to follow, we will be compiling a C program.</p><p>虽然有许多流行的编程语言，两个占主导地位。大多数为现代系统编写的程序，要么用 C 编写，要么是用 C++ 编写。 在随后的例子中，我们将编写一个 C 程序。</p><p>Programs written in high-level programming languages are converted into machine language by processing them with another program, called a compiler. Some compilers translate high-level instructions into assembly language and then use an assembler to perform the final stage of translation into machine language.</p><p>用高级语言编写的程序，经过另一个称为编译器的程序的处理，会转换成机器语言。一些编译器把 高级指令翻译成汇编语言，然后使用一个汇编器完成翻译成机器语言的最后阶段。</p><p>A process often used in conjunction with compiling is called linking. There are many common tasks performed by programs. Take, for instance, opening a file. Many programs perform this task, but it would be wasteful to have each program implement its own routine to open files. It makes more sense to have a single piece of programming that knows how to open files and to allow all programs that need it to share it. Providing support for common tasks is accomplished by what are called libraries. They contain multiple routines, each performing some common task that multiple programs can share. If we look in the /lib and /usr/lib directories, we can see where many of them live. A program called a linker is used to form the connections between the output of the compiler and the libraries that the compiled program requires. The final result of this process is the executable program file, ready for use.</p><p>一个称为链接的过程经常与编译结合在一起。有许多常见的由程序执行的任务。以打开文件为例。许多程序执行这个任务， 但是让每个程序实现它自己的打开文件功能，是很浪费资源的。更有意义的是，拥有单独的一段知道如何打开文件的程序， 并允许所有需要它的程序共享它。对常见任务提供支持由所谓的库完成。这些库包含多个程序，每个程序执行 一些可以由多个程序共享的常见任务。如果我们看一下 /lib 和 /usr/lib 目录，我们可以看到许多库定居在那里。 一个叫做链接器的程序用来在编译器的输出结果和要编译的程序所需的库之间建立连接。这个过程的最终结果是 一个可执行程序文件，准备使用。</p><h4 id="所有的程序都是可编译的吗？"><a href="#所有的程序都是可编译的吗？" class="headerlink" title="所有的程序都是可编译的吗？"></a>所有的程序都是可编译的吗？</h4><p>No. As we have seen, there are programs such as shell scripts that do not require compiling. They are executed directly. These are written in what are known as scripting or interpreted languages. These languages have grown in popularity in recent years and include Perl, Python, PHP, Ruby, and many others.</p><p>不是。正如我们所看到的，有些程序比如 shell 脚本就不需要编译。它们直接执行。 这些程序是用所谓的脚本或解释型语言编写的。近年来，这些语言变得越来越流行，包括 Perl、 Python、PHP、Ruby和许多其它语言。</p><p>Scripted languages are executed by a special program called an interpreter. An interpreter inputs the program file and reads and executes each instruction contained within it. Ingeneral, interpreted programs execute much more slowly than compiled programs. This is because that each source code instruction in an interpreted program is translated every time it is carried out, whereas with a compiled program, a source code instruction is only translated once, and this translation is permanently recorded in the final executable file.</p><p>脚本语言由一个叫做解释器的特殊程序执行。一个解释器输入程序文件，读取并执行程序中包含的每一条指令。 通常来说，解释型程序执行起来要比编译程序慢很多。这是因为每次解释型程序执行时，程序中每一条源码指令都需要翻译， 而一个已经编译好的程序，一条源码指令只翻译了一次，翻译后的指令会永久地记录到最终的执行文件中。</p><p>So why are interpreted languages so popular? For many programming chores, the results are “fast enough,” but the real advantage is that it is generally faster and easier to develop interpreted programs than compiled programs. Programs are usually developed in a repeating cycle of code, compile, test. As a program grows in size, the compilation phase of the cycle can become quite long. Interpreted languages remove the compilation step and thus speed up program development.</p><p>那么为什么解释型程序这样流行呢？对于许多编程任务来说，原因是“足够快”，但是真正的优势是一般来说开发解释型程序 要比编译程序快速且容易。通常程序开发需要经历一个不断重复的写码、编译和测试周期。随着程序变得越来越大， 编译阶段会变得相当耗时。解释型语言删除了编译步骤，这样就加快了程序开发。</p><h3 id="编译一个-C-语言"><a href="#编译一个-C-语言" class="headerlink" title="编译一个 C 语言"></a>编译一个 C 语言</h3><p>Let’s compile something. Before we do that however, we’re going to need some tools like the compiler, the linker, and make. The C compiler used almost universally in the Linux environment is called gcc (GNU C Compiler), originally written by Richard Stallman. Most distributions do not install gcc by default. We can check to see if the compiler is present like this:</p><p>让我们编译一些东西。在我们编译之前，然而我们需要一些工具，像编译器、链接器以及 make。 在 Linux 环境中，普遍使用的 C 编译器叫做 gcc（GNU C 编译器），最初由 Richard Stallman 写出来的。 大多数 Linux 系统发行版默认不安装 gcc。我们可以这样查看该编译器是否存在：</p><pre><code>[me@linuxbox ~]$ which gcc/usr/bin/gcc</code></pre><p>The results in this example indicate that the compiler is installed.</p><p>在这个例子中的输出结果表明安装了 gcc 编译器。</p><hr><p>Tip: Your distribution may have a meta-package (a collection of packages) for soft- ware development. If so, consider installing it if you intend to compile programs on your system. If your system does not provide a meta-package, try installing the gcc and make packages. On many distributions, this is sufficient to carry out the exercise below.</p><p>小提示： 你的系统发行版可能有一个用于软件开发的 meta-package（软件包的集合）。如果是这样的话， 若你打算在你的系统中编译程序就考虑安装它。若你的系统没有提供一个 meta-package，试着安装 gcc 和 make 工具包。 在许多发行版中，这就足够完成下面的练习了。 —</p><h4 id="得到源码"><a href="#得到源码" class="headerlink" title="得到源码"></a>得到源码</h4><p>For our compiling exercise, we are going to compile a program from the GNU Project called diction. This is a handy little program that checks text files for writing quality and style. As programs go, it is fairly small and easy to build.</p><p>为了我们的编译练习，我们将编译一个叫做 diction 的程序，来自 GNU 项目。这是一个小巧方便的程序， 检查文本文件的书写质量和样式。就程序而言，它相当小，且容易创建。</p><p>Following convention, we’re first going to create a directory for our source code named src and then download the source code into it using ftp:</p><p>遵照惯例，首先我们要创建一个名为 src 的目录来存放我们的源码，然后使用 ftp 协议把源码下载下来。</p><pre><code>[me@linuxbox ~]$ mkdir src[me@linuxbox ~]$ cd src[me@linuxbox src]$ ftp ftp.gnu.orgConnected to ftp.gnu.org.220 GNU FTP server ready.Name (ftp.gnu.org:me): anonymous230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; cd gnu/diction250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 1003 65534 68940 Aug 28 1998 diction-0.7.tar.gz-rw-r--r-- 1 1003 65534 90957 Mar 04 2002 diction-1.02.tar.gz-rw-r--r-- 1 1003 65534 141062 Sep 17 2007 diction-1.11.tar.gz226 Directory send OK.ftp&gt; get diction-1.11.tar.gzlocal: diction-1.11.tar.gz remote: diction-1.11.tar.gz200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for diction-1.11.tar.gz(141062 bytes).226 File send OK.141062 bytes received in 0.16 secs (847.4 kB/s)ftp&gt; bye221 Goodbye.[me@linuxbox src]$ lsdiction-1.11.tar.gz</code></pre><hr><p>Note: Since we are the “maintainer” of this source code while we compile it, we will keep it in ~/src. Source code installed by your distribution will be installed in /usr/src, while source code intended for use by multiple users is usually installed in /usr/local/src.</p><p>注意：因为我们是这个源码的“维护者”，当我们编译它的时候，我们把它保存在 ~/src 目录下。 由你的系统发行版源码会把源码安装在 /usr/src 目录下，而供多个用户使用的源码，通常安装在 /usr/local/src 目录下。</p><hr><p>As we can see, source code is usually supplied in the form of a compressed tar file. Sometimes called a tarball, this file contains the source tree, or hierarchy of directories and files that comprise the source code. After arriving at the ftp site, we examine the list of tar files available and select the newest version for download. Using the get command within ftp, we copy the file from the ftp server to the local machine.</p><p>正如我们所看到的，通常提供的源码形式是一个压缩的 tar 文件。有时候称为 tarball，这个文件包含源码树， 或者是组成源码的目录和文件的层次结构。当到达 ftp 站点之后，我们检查可用的 tar 文件列表，然后选择最新版本，下载。 使用 ftp 中的 get 命令，我们把文件从 ftp 服务器复制到本地机器。</p><p>Once the tar file is downloaded, it must be unpacked. This is done with the tar program:</p><p>一旦 tar 文件下载下来之后，必须解包。通过 tar 程序可以完成：</p><pre><code>[me@linuxbox src]$ tar xzf diction-1.11.tar.gz[me@linuxbox src]$ lsdiction-1.11diction-1.11.tar.gz</code></pre><hr><p>Tip: The diction program, like all GNU Project software, follows certain stan- dards for source code packaging. Most other source code available in the Linux ecosystem also follows this standard. One element of the standard is that when the source code tar file is unpacked, a directory will be created which contains the source tree, and that this directory will be named project-x.xx, thus containing both the project’s name and its version number. This scheme allows easy installation of multiple versions of the same program. However, it is often a good idea to examine the layout of the tree before unpacking it. Some projects will not create the directory, but instead will deliver the files directly into the current directory. This will make a mess in your otherwise well-organized src directory. To avoid this, use the following command to examine the contents of the tar file:</p><p>小提示：该 diction 程序，像所有的 GNU 项目软件，遵循着一定的源码打包标准。其它大多数在 Linux 生态系统中 可用的源码也遵循这个标准。该标准的一个条目是，当源码 tar 文件打开的时候，会创建一个目录，该目录包含了源码树， 并且这个目录将会命名为 project-x.xx，其包含了项目名称和它的版本号两项内容。这种方案能在系统中方便安装同一程序的多个版本。 然而，通常在打开 tarball 之前检验源码树的布局是个不错的主意。一些项目不会创建该目录，反而，会把文件直接传递给当前目录。 这会把你的（除非组织良好的）src 目录弄得一片狼藉。为了避免这个，使用下面的命令，检查 tar 文件的内容：</p><pre><code>tar tzvf tarfile | head ---</code></pre><h3 id="检查源码树"><a href="#检查源码树" class="headerlink" title="检查源码树"></a>检查源码树</h3><p>Unpacking the tar file results in the creation of a new directory, named diction-1.11. This directory contains the source tree. Let’s look inside:</p><p>打开该 tar 文件，会创建一个新的目录，名为 diction-1.11。这个目录包含了源码树。让我们看一下里面的内容：</p><pre><code>[me@linuxbox src]$ cd diction-1.11[me@linuxbox diction-1.11]$ lsconfig.guess     diction.c          getopt.c      nlconfig.h.in      diction.pot        getopt.h      nl.poconfig.sub       diction.spec       getopt_int.h  READMEconfigure        diction.spec.in    INSTALL       sentence.cconfigure.in     diction.texi.in    install-sh    sentence.hCOPYING en       Makefile.in        style.1.inde               en_GB              misc.c        style.cde.po            en_GB.po           misc.h        testdiction.1.in     getopt1.c          NEWS</code></pre><p>In it, we see a number of files. Programs belonging to the GNU Project, as well as many others, will supply the documentation files README, INSTALL, NEWS, and COPYING.</p><p>在源码树中，我们看到大量的文件。属于 GNU 项目的程序，还有其它许多程序都会，提供文档文件 README，INSTALL，NEWS，和 COPYING。</p><p>These files contain the description of the program, information on how to build and in- stall it, and its licensing terms. It is always a good idea to carefully read the README and INSTALL files before attempting to build the program.</p><p>这些文件包含了程序描述，如何建立和安装它的信息，还有其它许可条款。在试图建立程序之前，仔细阅读 README 和 INSTALL 文件，总是一个不错的主意。</p><p>The other interesting files in this directory are the ones ending with .c and .h:</p><p>在这个目录中，其它有趣的文件是那些以 .c 和 .h 为后缀的文件：</p><pre><code>[me@linuxbox diction-1.11]$ ls *.cdiction.c getopt1.c getopt.c misc.c sentence.c style.c[me@linuxbox diction-1.11]$ ls *.hgetopt.h getopt_int.h misc.h sentence.h</code></pre><p>The .c files contain the two C programs supplied by the package (style and diction), divided into modules. It is common practice for large programs to be broken into smaller, easier to manage pieces. The source code files are ordinary text and can be examined with less:</p><p>这些 .c 文件包含了由该软件包提供的两个 C 程序（style 和 diction），被分割成模块。这是一种常见做法，把大型程序 分解成更小，更容易管理的代码块。源码文件都是普通文本，可以用 less 命令查看：</p><pre><code>[me@linuxbox diction-1.11]$ less diction.c</code></pre><p>The .h files are known as header files. These, too, are ordinary text. Header files contain descriptions of the routines included in a source code file or library. In order for the com- piler to connect the modules, it must receive a description of all the modules needed to complete the entire program. Near the beginning of the diction.c file, we see this line:</p><p>这些 .h 文件被称为头文件。它们也是普通文件。头文件包含了程序的描述，这些程序被包括在源码文件或库中。 为了让编译器链接到模块，编译器必须接受所需的所有模块的描述，来完成整个程序。在 diction.c 文件的开头附近， 我们看到这行代码：</p><pre><code>#include &quot;getopt.h&quot;</code></pre><p>This instructs the compiler to read the file getopt.h as it reads the source code in diction.c in order to “know” what’s in getopt.c. The getopt.c file supplies routines that are shared by both the style and diction programs.</p><p>当它读取 diction.c 中的源码的时候，这行代码指示编译器去读取文件 getopt.h， 为的是“知道” getopt.c 中的内容。 getopt.c 文件提供由 style 和 diction 两个程序共享的例行程序。</p><p>Above the include statement for getopt.h, we see some other include statements such as these:</p><p>在 getopt.h 的 include 语句上面，我们看到一些其它的 include 语句，比如这些：</p><pre><code>#include &lt;regex.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;</code></pre><p>These also refer to header files, but they refer to header files that live outside the current source tree. They are supplied by the system to support the compilation of every program. If we look in /usr/include, we can see them:</p><p>这些文件也是头文件，但是这些头文件在当前源码树的外面。它们由操作系统供给，来支持每个程序的编译。 如果我们看一下 /usr/include 目录，能看到它们：</p><pre><code>[me@linuxbox diction-1.11]$ ls /usr/include</code></pre><p>The header files in this directory were installed when we installed the compiler.</p><p>当我们安装编译器的时候，这个目录中的头文件会被安装。</p><h4 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h4><p>Most programs build with a simple, two-command sequence:</p><p>大多数程序通过一个简单的，两个命令的序列构建：</p><pre><code>./configuremake</code></pre><p>The configure program is a shell script which is supplied with the source tree. Its job is to analyze the build environment. Most source code is designed to be portable. That is, it is designed to build on more than one kind of Unix-like system. But in order to do that, the source code may need to undergo slight adjustments during the build to accommodate differences between systems. configure also checks to see that necessary external tools and components are installed. Let’s run configure. Since configure is not located where the shell normally expects programs to be located, we must explicitly tell the shell its location by prefixing the command with ./ to indicate that the program is located in the current working directory:</p><p>这个 configure 程序是一个 shell 脚本，由源码树提供。它的工作是分析程序构建环境。大多数源码会设计为可移植的。 也就是说，它被设计成能够在不止一种类 Unix 系统中进行构建。但是为了做到这一点，在建立程序期间，为了适应系统之间的差异， 源码可能需要经过轻微的调整。configure 也会检查是否安装了必要的外部工具和组件。让我们运行 configure 命令。 因为 configure 命令所在的位置不是位于 shell 通常期望程序所呆的地方，我们必须明确地告诉 shell 它的位置，通过 在命令之前加上 ./ 字符，来表明程序位于当前工作目录：</p><pre><code>[me@linuxbox diction-1.11]$ ./configure</code></pre><p>configure will output a lot of messages as it tests and configures the build. When it finishes, it will look something like this:</p><p>configure 将会输出许多信息，随着它测试和配置整个构建过程。当结束后，输出结果看起来像这样：</p><pre><code>checking libintl.h presence... yeschecking for libintl.h... yeschecking for library containing gettext... none requiredconfigure: creating ./config.statusconfig.status: creating Makefileconfig.status: creating diction.1config.status: creating diction.texiconfig.status: creating diction.specconfig.status: creating style.1config.status: creating test/rundictionconfig.status: creating config.h[me@linuxbox diction-1.11]$</code></pre><p>What’s important here is that there are no error messages. If there were, the configuration failed, and the program will not build until the errors are corrected.</p><p>这里最重要的事情是没有错误信息。如果有错误信息，整个配置过程失败，然后程序不能构建直到修正了错误。</p><p>We see configure created several new files in our source directory. The most impor- tant one is Makefile. Makefile is a configuration file that instructs the make pro- gram exactly how to build the program. Without it, make will refuse to run. Makefile is an ordinary text file, so we can view it:</p><p>我们看到在我们的源码目录中 configure 命令创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。没有它，make 程序就不能运行。Makefile 是一个普通文本文件，所以我们能查看它：</p><pre><code>[me@linuxbox diction-1.11]$ less Makefile</code></pre><p>The make program takes as input a makefile (which is normally named Makefile), that describes the relationships and dependencies among the components that comprise the finished program.</p><p>这个 make 程序把一个 makefile 文件作为输入（通常命名为 Makefile），makefile 文件 描述了包括最终完成的程序的各组件之间的关系和依赖性。</p><p>The first part of the makefile defines variables that are substituted in later sections of the makefile. For example we see the line:</p><p>makefile 文件的第一部分定义了变量，这些变量在该 makefile 后续章节中会被替换掉。例如我们看看这一行代码：</p><pre><code>CC=                 gcc</code></pre><p>which defines the C compiler to be gcc. Later in the makefile, we see one instance where it gets used:</p><p>其定义了所用的 C 编译器是 gcc。文件后面部分，我们看到一个使用该变量的实例：</p><pre><code>diction:        diction.o sentence.o misc.o getopt.o getopt1.o                $(CC) -o $@ $(LDFLAGS) diction.o sentence.o misc.o \                getopt.o getopt1.o $(LIBS)</code></pre><p>A substitution is performed here, and the value $(CC) is replaced by gcc at run time. Most of the makefile consists of lines, which define a target, in this case the executable file diction, and the files on which it is dependent. The remaining lines describe the command(s) needed to create the target from its components. We see in this example that the executable file diction (one of the final end products) depends on the existence of diction.o, sentence.o, misc.o, getopt.o, and getopt1.o. Later on, in the makefile, we see definitions of each of these as targets:</p><p>这里完成了一个替换操作，在程序运行时，$(CC) 的值会被替换成 gcc。大多数 makefile 文件由行组成，每行定义一个目标文件， 在这种情况下，目标文件是指可执行文件 diction，还有目标文件所依赖的文件。剩下的行描述了从目标文件的依赖组件中 创建目标文件所需的命令。在这个例子中，我们看到可执行文件 diction（最终的成品之一）依赖于文件 diction.o，sentence.o，misc.o，getopt.o，和 getopt1.o都存在。在 makefile 文件后面部分，我们看到 diction 文件所依赖的每一个文件做为目标文件的定义：</p><pre><code>diction.o:       diction.c config.h getopt.h misc.h sentence.hgetopt.o:        getopt.c getopt.h getopt_int.hgetopt1.o:       getopt1.c getopt.h getopt_int.hmisc.o:          misc.c config.h misc.hsentence.o:      sentence.c config.h misc.h sentence.hstyle.o:         style.c config.h getopt.h misc.h sentence.h</code></pre><p>However, we don’t see any command specified for them. This is handled by a general target, earlier in the file, that describes the command used to compile any .c file into a .o file:</p><p>然而，我们不会看到针对它们的任何命令。这个由一个通用目标解决，在文件的前面，描述了这个命令，用来把任意的 .c 文件编译成 .o 文件：</p><pre><code>.c.o:            $(CC) -c $(CPPFLAGS) $(CFLAGS) $&lt;</code></pre><p>This all seems very complicated. Why not simply list all the steps to compile the parts and be done with it? The answer to this will become clear in a moment. In the meantime, let’s run make and build our programs:</p><p>这些看起来非常复杂。为什么不简单地列出编译每个部分的步骤，那样不就行了？一会儿就知道答案了。同时， 让我们运行 make 命令并构建我们的程序：</p><pre><code>[me@linuxbox diction-1.11]$ make</code></pre><p>The make program will run, using the contents of Makefile to guide its actions. It will produce a lot of messages.</p><p>这个 make 程序将会运行，使用 Makefile 文件的内容来指导它的行为。它会产生很多信息。</p><p>When it finishes, we will see that all the targets are now present in our directory:</p><p>当 make 程序运行结束后，现在我们将看到所有的目标文件出现在我们的目录中。</p><pre><code>[me@linuxbox diction-1.11]$ lsconfig.guess  de.po             en              en_GB           sentence.cconfig.h      diction           en_GB.mo        en_GB.po        sentence.hconfig.h.in   diction.1         getopt1.c       getopt1.o       sentence.oconfig.log    diction.1.in      getopt.c        getopt.h        styleconfig.status diction.c         getopt_int.h    getopt.o        style.1config.sub    diction.o         INSTALL         install-sh      style.1.inconfigure     diction.pot       Makefile        Makefile.in     style.cconfigure.in  diction.spec      misc.c          misc.h          style.oCOPYING       diction.spec.in   misc.o          NEWS            testde            diction.texi      nl              nl.mode.mo         diction.texi.i    nl.po           README</code></pre><p>Among the files, we see diction and style, the programs that we set out to build. Congratulations are in order! We just compiled our first programs from source code! But just out of curiosity, let’s run make again:</p><p>在这些文件之中，我们看到 diction 和 style，我们开始要构建的程序。恭喜一切正常！我们刚才源码编译了 我们的第一个程序。但是出于好奇，让我们再运行一次 make 程序：</p><pre><code>[me@linuxbox diction-1.11]$ makemake: Nothing to be done for `all&#39;.</code></pre><p>It only produces this strange message. What’s going on? Why didn’t it build the program again? Ah, this is the magic of make. Rather than simply building everything again, make only builds what needs building. With all of the targets present, make determined that there was nothing to do. We can demonstrate this by deleting one of the targets and running make again to see what it does. Let’s get rid of one of the intermediate targets:</p><p>它只是产生这样一条奇怪的信息。怎么了？为什么它没有重新构建程序呢？啊，这就是 make 奇妙之处了。make 只是构建 需要构建的部分，而不是简单地重新构建所有的内容。由于所有的目标文件都存在，make 确定没有任何事情需要做。 我们可以证明这一点，通过删除一个目标文件，然后再次运行 make 程序，看看它做些什么。让我们去掉一个中间目标文件：</p><pre><code>[me@linuxbox diction-1.11]$ rm getopt.o[me@linuxbox diction-1.11]$ make</code></pre><p>We see that make rebuilds it and re-links the diction and style programs, since they depend on the missing module. This behavior also points out another important feature of make: it keeps targets up to date. make insists that targets be newer than their dependencies. This makes perfect sense, as a programmer will often update a bit of source code and then use make to build a new version of the finished product. make ensures that everything that needs building based on the updated code is built. If we use the touch program to “update” one of the source code files, we can see this happen:</p><p>我们看到 make 重新构建了 getopt.o 文件，并重新链接了 diction 和 style 程序，因为它们依赖于丢失的模块。 这种行为也指出了 make 程序的另一个重要特征：它保持目标文件是最新的。make 坚持目标文件要新于它们的依赖文件。 这个非常有意义，做为一名程序员，经常会更新一点儿源码，然后使用 make 来构建一个新版本的成品。make 确保 基于更新的代码构建了需要构建的内容。如果我们使用 touch 程序，来“更新”其中一个源码文件，我们看到发生了这样的事情：</p><pre><code>[me@linuxboxdiction-1.11]$ ls -l diction getopt.c-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction-rw-r--r-- 1 me me 33125 2007-03-30 17:45 getopt.c[me@linuxboxdiction-1.11]$ touch getopt.c[me@linuxboxdiction-1.11]$ ls -l diction getopt.c-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c[me@linuxbox diction-1.11]$ make</code></pre><p>After make runs, we see that it has restored the target to being newer than the dependency:</p><p>运行 make 之后，我们看到目标文件已经更新于它的依赖文件：</p><pre><code>[me@linuxbox diction-1.11]$ ls -l diction getopt.c-rwxr-xr-x 1 me me 37164 2009-03-05 06:24 diction-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c</code></pre><p>The ability of make to intelligently build only what needs building is a great benefit to programmers. While the time savings may not be very apparent with our small project, it is very significant with larger projects. Remember, the Linux kernel (a program that undergoes continuous modification and improvement) contains several million lines of code.</p><p>make 程序这种智能地只构建所需要构建的内容的特性，对程序来说，是巨大的福利。虽然在我们的小项目中，节省的时间可能 不是非常明显，在庞大的工程中，它具有非常重大的意义。记住，Linux 内核（一个经历着不断修改和改进的程序）包含了几百万行代码。</p><h4 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h4><p>Well-packaged source code will often include a special make target called install. This target will install the final product in a system directory for use. Usually, this directory is /usr/local/bin, the traditional location for locally built software. However, this directory is not normally writable by ordinary users, so we must become the superuser to perform the installation:</p><p>打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户， 来执行安装操作：</p><pre><code>[me@linuxbox diction-1.11]$ sudo make install</code></pre><p>After we perform the installation, we can check that the program is ready to go:</p><p>执行了安装后，我们可以检查下程序是否已经可用：</p><pre><code>[me@linuxbox diction-1.11]$ which diction/usr/local/bin/diction[me@linuxbox diction-1.11]$ man diction</code></pre><p>And there we have it!</p><p>完美！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>In this chapter, we have seen how three simple commands:</p><p>在这一章中，我们已经知道了三个简单命令：</p><pre><code>./configuremakemake install</code></pre><p>can be used to build many source code packages. We have also seen the important role that make plays in the maintenance of programs. The make program can be used for any task that needs to maintain a target/dependency relationship, not just for compiling source code.</p><p>可以用来构建许多源码包。我们也知道了在程序维护过程中，make 程序起到了举足轻重的作用。make 程序可以用到 任何需要维护一个目标/依赖关系的任务中，不仅仅为了编译源代码。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Wikipedia has good articles on compilers and the make program:</p></li><li><p>Wikipedia 上面有关于编译器和 make 程序的好文章：</p><p><a href="http://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Compiler</a></p><p><a href="http://en.wikipedia.org/wiki/Make_(software)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Make_(software)</a></p></li><li><p>The GNU Make Manual:</p></li><li><p>GNU Make 手册</p><p><a href="http://www.gnu.org/software/make/manual/html_node/index.html" target="_blank" rel="noopener">http://www.gnu.org/software/make/manual/html_node/index.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十三章 打印</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%89%93%E5%8D%B0/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>After spending the last couple of chapters manipulating text, it’s time to put that text on paper. In this chapter, we’ll look at the command-line tools that are used to print files and control printer operation. We won’t be looking at how to configure printing, as that varies from distribution to distribution and is usually set up automatically during installation. Note that we will need a working printer configuration to perform the exercises in this chapter.</p><p>前几章我们学习了如何操控文本，下面要做的是将文本呈于纸上。在这章中，我们将会着手用于打印文件和控制打印选项的命令行工具。通常不同发行版的打印配置各有不同且都会在其安装时自动完成，因此这里我们不讨论打印的配置过程。本章的练习需要一台正确配置的打印机来完成。</p><p>We will discuss the following commands:</p><p>我们将讨论一下命令：</p><ul><li>pr——Convert text files for printing.</li><li>pr —— 转换需要打印的文本文件</li><li>lpr——Print files.</li><li>lpr —— 打印文件</li><li>lp——Print files (System V).</li><li>lp —— 打印文件（System V）</li><li>a2ps——Format files for printing on a PostScript printer.</li><li>a2ps —— 为 PostScript 打印机格式化文件</li><li>lpstat——Show printer status information.</li><li>lpstat —— 显示打印机状态信息</li><li>lpq——Show printer queue status.</li><li>lpq —— 显示打印机队列状态</li><li>lprm——Cancel print jobs.</li><li>lprm —— 取消打印任务</li><li>cancel——Cancel print jobs (System V).</li><li>cancel —— 取消打印任务（System V）</li></ul><h3 id="打印简史"><a href="#打印简史" class="headerlink" title="打印简史"></a>打印简史</h3><p>To fully understand the printing features found in Unix-like operating systems, we must first learn some history. Printing on Unix-like systems goes way back to the beginning of the operating system itself. In those days, printers and how they were used were much different from how they are today.</p><p>为了较好的理解类 Unix 操作系统中的打印功能，我们必须先了解一些历史。类 Unix 系统中的打印可追溯到操作系统本身的起源，那时候打印机和它的用法与今天截然不同。</p><h4 id="早期的打印"><a href="#早期的打印" class="headerlink" title="早期的打印"></a>早期的打印</h4><p>Like the computers themselves, printers in the pre-PC era tended to be large, expensive, and centralized. The typical computer user of 1980 worked at a terminal connected to a computer some distance away. The printer was located near the computer and was under the watchful eyes of the computer’s operators.</p><p>和计算机一样，前 PC 时代的打印机都很大、很贵，并且很集中。1980年的计算机用户都是在离电脑很远的地方用一个连接电脑的终端来工作的，而打印机就放在电脑旁并受到计算机管理员的全方位监视。</p><p>When printers were expensive and centralized, as they often were in the early days of Unix, it was common practice for many users to share a printer. To identify print jobs belonging to a particular user, a banner page displaying the name of the user was often printed at the beginning of each print job. The computer support staff would then load up a cart containing the day’s print jobs and deliver them to the individual users.</p><p>由于当时打印机既昂贵又集中，而且都工作在早期的 Unix 环境下，人们从实际考虑通常都会多人共享一台打印机。为了区别不同用户的打印任务，每个打印任务的开头都会打印一张写着用户名字的标题页，然后计算机工作人员会用推车装好当天的打印任务并分发给每个用户。</p><h4 id="基于字符的打印机"><a href="#基于字符的打印机" class="headerlink" title="基于字符的打印机"></a>基于字符的打印机</h4><p>The printer technology of the ’80s was very different in two respects. First, printers of that period were almost always impact printers. Impact printers use a mechanical mechanism that strikes a ribbon against the paper to form character impressions on the page. Two of the popular technologies of that time were daisy-wheel printing and dot-matrix printing.</p><p>80年代的打印机技术有两方面的不同。首先，那时的打印机基本上都是打击式打印机。打击式打印机使用撞针打击色带的机械结构在纸上形成字符。这种流行的技术造就了当时的菊轮式打印和点阵式打印。</p><p>The second, and more important, characteristic of early printers was that they used a fixed set of characters that were intrinsic to the device itself. For example, a daisy-wheel printer could print only the characters actually molded into the petals of the daisy wheel. This made the printers much like high-speed typewriters. As with most typewriters, they printed using monospaced (fixed-width) fonts. This means that each character has the same width. Printing was done at fixed positions on the page, and the printable area of a page contained a fixed number of characters. Most printers printed 10 characters per inch (CPI) horizontally and 6 lines per inch (LPI) vertically. Using this scheme, a US-letter sheet of paper is 85 characters wide and 66 lines high. Taking into account a small margin on each side, 80 characters was considered the maximum width of a print line. This explains why terminal displays (and our terminal emulators) are normally 80 characters wide. It provides a WYSIWYG (What You See Is What You Get) view of printed output, using a monospaced font.</p><p>其次，更重要的是，早期打印机的特点是它使用设备内部固定的一组字符集。比如，一台菊轮式打印机只能打印固定在其菊花轮花瓣上的字符，就这点而言打印机更像是高速打字机。大部分打字机都使用等宽字体，意思是说每个字符的宽度相等，页面上只有固定的区域可供打印，而这些区域只能容纳固定的字符数。大部分打印机采用横向10字符每英寸（CPI）和纵向6行每英寸（LPI）的规格打印，这样一张美式信片纸就有横向85字符宽纵向66行高，加上两侧的页边距，一行的最大宽度可达80字符。据此，使用等宽字体就能提供所见即所得（WYSIWYG，What You See Is What You Get）的打印预览。</p><p>Data is sent to a typewriter-like printer in a simple stream of bytes containing the characters to be printed. For example, to print an a, the ASCII character code 97 is sent. In addition, the low-numbered ASCII control codes provided a means of moving the printer’s carriage and paper, using codes 286 Chapter 22 for carriage return, line feed, form feed, and so on. Using the control codes, it’s possible to achieve some limited font effects, such as boldface, by having the printer print a character, backspace, and print the character again to get a darker print impression on the page. We can actually witness this if we use nroff to render a man page and examine the output using cat -A:</p><p>接着，一台类打字机的打印机会收到以简单字节流的形式传送来的数据，其中就包含要打印的字符。例如要打印一个字母a，计算机就会发送 ASCII 码97，如果要移动打印机的滑动架和纸张，就需要使用回车、换行、换页等的小编号 ASCII 控制码。使用控制码，还能实现一些之前受限制的字体效果，比如粗体，就是让打印机先打印一个字符，然后退格再打印一遍来得到颜色较深的效果的。用 nroff 来产生一个手册页然后用 cat -A 检查输出，我们就能亲眼看看这种效果了：</p><pre><code>[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | nroff -man | cat -A | headLS(1) User Commands LS(1)$$$N^HNA^HAM^HME^HE$ls - list directory contents$$S^HSY^HYN^HNO^HOP^HPS^HSI^HIS^HS$l^Hls^Hs [_^HO_^HP_^HT_^HI_^HO_^HN]... [_^HF_^HI_^HL_^HE]...$</code></pre><p>^H (CTRL-H) characters are the backspaces used to create the boldface effect. Likewise, we can also see a backspace/underscore sequence used to produce underlining.</p><p>^H（ctrl-H）字符是用于打印粗体效果的退格符。同样，我们还可以看到用于打印下划线效果的[退格/下划线]序列。</p><h4 id="图形化打印机"><a href="#图形化打印机" class="headerlink" title="图形化打印机"></a>图形化打印机</h4><p>The development of GUIs led to major changes in printer technology. As computers moved to more picture-based displays, printing moved from character-based to graphical techniques. This was facilitated by the advent of the low-cost laser printer, which, instead of printing fixed characters, could print tiny dots anywhere in the printable area of the page. This made printing proportional fonts (like those used by typesetters), and even photographs and high-quality diagrams, possible.</p><p>图形用户界面（GUI）的发展催生了打印机技术中主要的变革。随着计算机的展现步入更多以图形为基础的方式，打印技术也从基于字符走向图形化技术，这一切都是源于激光打印机的到来，它不仅廉价，还可以在打印区域的任意位置打印微小的墨点，而不是使用固定的字符集。这让打印机能够打印成比例的字体（像用排字机那样），甚至是图片和高质量图表。</p><p>However, moving from a character-based scheme to a graphical scheme presented a formidable technical challenge. Here’s why: The number of bytes needed to fill a page using a character-based printer can be calculated this way (assuming 60 lines per page, each containing 80 characters): 60 x 80 = 4,800 bytes.</p><p>然而，从基于字符的方式到转移到图形化的方式提出了一个严峻的技术挑战。原因如下：使用基于字符的打印机时，填满一张纸所用的字节数可以这样计算出来（假设一张纸有60行，每行80个字符)：60 × 80 = 4800字节。</p><p>In comparison, a 300-dot-per-inch (DPI) laser printer (assuming an 8-by-10-inch print area per page) requires (8 x 300) x (10 x 300) / 8 = 900,000 bytes.</p><p>相比之下，用一台300点每英寸（DPI）分辨率的激光打印机（假设一张纸有8乘10英寸的打印区域）打印则需要 (8 × 300) × (10 × 300) / 8 = 900,000字节。</p><p>Many of the slow PC networks simply could not handle the nearly 1 megabyte of data required to print a full page on a laser printer, so it was clear that a clever invention was needed.</p><p>当时许多慢速的个人电脑网络无法接受激光打印机打印一页需要传输将近1兆的数据这一点，因此，很有必要发明一种更聪明的方法。</p><p>That invention turned out to be the page-description language. A page-description language (PDL) is a programming language that describes the contents of a page. Basically it says, “Go to this position, draw the character a in 10-point Helvetica, go to this position….” until everything on the page is described. The first major PDL was PostScript from Adobe Systems, which is still in wide use today. The PostScript language is a complete programming language tailored for typography and other kinds of graphics and imaging. It includes built-in support for 35 standard, high-quality fonts, plus the ability Printing 287 to accept additional font definitions at runtime. At first, support for Post- Script was built into the printers themselves. This solved the data transmission problem. While the typical PostScript program was verbose in comparison to the simple byte stream of character-based printers, it was much smaller than the number of bytes required to represent the entire printed page.</p><p>这种发明便是页面描述语言（PDL）。PDL 是一种描述页面内容的编程语言。简单的说就是，“到这个地方，印一个10点大小的黑体字符 a ，到这个地方。。。” 这样直到页面上的所有内容都描述完了。第一种主要的 PDL 是 Adobe 系统开发的 PostScript，直到今天，这种语言仍被广泛使用。PostScript 是专为印刷各类图形和图像设计的完整的编程语言，它内建支持35种标准的高质量字体，在工作时还能够接受其他的字体定义。最早，对 PostScript 的支持是打印机本身内建的。这样传输数据的问题就解决了。相比基于字符打印机的简单字节流，典型的 PostScript 程序更为详细，而且比表示整个页面的字节数要小很多。</p><p>A PostScript printer accepted a PostScript program as input. The printer contained its own processor and memory (oftentimes making the printer a more powerful computer than the computer to which it was attached) and executed a special program called a PostScript interpreter, which read the incoming PostScript program and rendered the results into the printer’s internal memory, thus forming the pattern of bits (dots) that would be transferred to the paper. The generic name for this process of rendering something into a large bit pattern (called a bitmap) is raster image processor, or RIP.</p><p>一台 PostScript 打印机接受 PostScript 程序作为输入。打印机有自己的处理器和内存（通常这让打印机比连接它的计算机更为强大），能执行一种叫做 PostScript 解析器的特殊程序用于读取输入的 PostScript 程序并生成结果导入打印机的内存，这样就形成了要转移到纸上的位（点）图。这种将页面渲染成大型位图（bitmap）的过程有个通用名称作光栅图像处理器（raster image processor），又叫 RIP。</p><p>As the years went by, both computers and networks became much faster. This allowed the RIP to move from the printer to the host computer, which, in turn, permitted high-quality printers to be much less expensive.</p><p>多年之后，电脑和网络都变得更快了。这使得 RIP 技术从打印机转移到了主机上，还让高品质打印机变得更便宜了。</p><p>Many printers today still accept character-based streams, but many low-cost printers do not. They rely on the host computer’s RIP to provide a stream of bits to print as dots. There are still some PostScript printers, too.</p><p>现在的许多打印机仍能接受基于字符的字节流，但很多廉价的打印机却不支持，因为它们依赖于主机的 RIP 提供的比特流来作为点阵打印。当然也有不少仍旧是 PostScript 打印机。</p><h3 id="在-Linux-下打印"><a href="#在-Linux-下打印" class="headerlink" title="在 Linux 下打印"></a>在 Linux 下打印</h3><p>Modern Linux systems employ two software suites to perform and manage printing. The first, CUPS (Common Unix Printing System), provides print drivers and print-job management; the second, Ghostscript, a PostScript interpreter, acts as a RIP.</p><p>当前 Linux 系统采用两套软件配合显示和管理打印。第一，CUPS（Common Unix Printing System，一般 Unix 打印系统），用于提供打印驱动和打印任务管理；第二，Ghostscript，一种 PostScript 解析器，作为 RIP 使用。</p><p>CUPS manages printers by creating and maintaining print queues. As we discussed in our brief history lesson, Unix printing was originally designed to manage a centralized printer shared by multiple users. Since printers are slow by nature, compared to the computers that are feeding them, printing systems need a way to schedule multiple print jobs and keep things organized. CUPS also has the ability to recognize different types of data (within reason) and can convert files to a printable form.</p><p>CUPS 通过创建并维护打印队列来管理打印机。如前所述，Unix 下的打印原本是设计成多用户共享中央打印机的管理模式的。由于打印机本身比连接到它的电脑要慢，打印系统就需要对打印任务进行调度使其保持顺序。CUPS 还能识别出不同类型的数据（在合理范围内）并转换文件为可打印的格式。</p><h3 id="为打印准备文件"><a href="#为打印准备文件" class="headerlink" title="为打印准备文件"></a>为打印准备文件</h3><p>As command line users, we are mostly interested in printing text, though it is certainly possible to print other data formats as well.</p><p>作为命令行用户，尽管打印各种格式的文本都能实现，不过打印最多的，还是文本。</p><h4 id="pr-转换需要打印的文本文件"><a href="#pr-转换需要打印的文本文件" class="headerlink" title="pr - 转换需要打印的文本文件"></a>pr - 转换需要打印的文本文件</h4><p>We looked at pr a little in the previous chapter. Now we will examine some of its many options used in conjunction with printing. In our history of printing, we saw that character-based printers use monospaced fonts, resulting in 288 Chapter 22 fixed numbers of characters per line and lines per page. pr is used to adjust text to fit on a specific page size, with optional page headers and margins. Table 23-1 summarizes the most commonly used options.</p><p>前面的章节我们也有提到过 pr 命令，现在我们来探讨一下这条命令结合打印使用的一些选项。我们知道，在打印的历史上，基于字符的打印机曾经用过等宽字体，致使每页只能打印固定的行数和字符数，而 pr 命令则能够根据不同的页眉和页边距排列文本使其适应指定的纸张。表23-1总结了最常用的选项。</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">+first[:last]</td><td align="left">Output a range of pages starting with first and, optionally, ending with last.</td></tr><tr><td align="left">-columns</td><td align="left">Organize the content of the page into the number of columns specified by columns.</td></tr><tr><td align="left">-a</td><td align="left">By default, multicolumn output is listed vertically. By adding the -a (across) option, content is listed horizontally.</td></tr><tr><td align="left">-d</td><td align="left">Double-space output.</td></tr><tr><td align="left">-D format</td><td align="left">Format the date displayed in page headers using format. See the man page for the date command for a description of the format string.</td></tr><tr><td align="left">-f</td><td align="left">Use form feeds rather than carriage returns to separate pages.</td></tr><tr><td align="left">-h header</td><td align="left">In the center portion of the page header, use header rather the name of the file being processed.</td></tr><tr><td align="left">-l length</td><td align="left">Set page length to length. Default is 66 lines (US letter at 6 lines per inch).</td></tr><tr><td align="left">-n</td><td align="left">Number lines.</td></tr><tr><td align="left">-o offset</td><td align="left">Create a left margin offset characters wide.</td></tr><tr><td align="left">-w width</td><td align="left">Set page width to width. Default is 72 characters.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+first[:last]</td><td align="left">输出从 first 到 last（默认为最后）范围内的页面。</td></tr><tr><td align="left">-columns</td><td align="left">根据 columns 指定的列数排版页面内容。</td></tr><tr><td align="left">-a</td><td align="left">默认多列输出为垂直，用 -a (across)可使其水平输出。</td></tr><tr><td align="left">-d</td><td align="left">双空格输出。</td></tr><tr><td align="left">-D format</td><td align="left">用 format 指定的格式修改页眉中显示的日期，日期命令中 format 字符串的描述详见参考手册。</td></tr><tr><td align="left">-f</td><td align="left">改用换页替换默认的回车来分割页面。</td></tr><tr><td align="left">-h header</td><td align="left">在页眉中部用 header 参数替换打印文件的名字。</td></tr><tr><td align="left">-l length</td><td align="left">设置页长为 length，默认为66行（每英寸6行的美国信纸）。</td></tr><tr><td align="left">-n</td><td align="left">输出行号。</td></tr><tr><td align="left">-o offset</td><td align="left">创建一个宽 offset 字符的左页边。</td></tr><tr><td align="left">-w width</td><td align="left">设置页宽为 width，默认为72字符。</td></tr></tbody></table><p>pr is often used in pipelines as a filter. In this example, we will produce a directory listing of /usr/bin and format it into paginated, three-column output using pr:</p><p>我们通常用管道配合 pr 命令来做筛选。下面的例子中我们会列出目录 /usr/bin 并用 pr 将其格式化为3列输出的标题页：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | pr -3 -w 65 | head2012-02-18 14:00                    Page 1[                   apturl          bsd-write411toppm            ar              bsha2p                 arecord         btcflasha2ps                arecordmidi     bug-buddya2ps-lpr-wrapper    ark             buildhash</code></pre><h3 id="将打印任务送至打印机"><a href="#将打印任务送至打印机" class="headerlink" title="将打印任务送至打印机"></a>将打印任务送至打印机</h3><p>The CUPS printing suite supports two methods of printing historically used on Unix-like systems. One method, called Berkeley or LPD (used in the Berkeley Software Distribution version of Unix), uses the lpr program; the other method, called SysV (from the System V version of Unix), uses the lp program. Both programs do roughly the same thing. Choosing one over the other is a matter of personal taste.</p><p>CUPS 打印体系支持两种曾用于类 Unix 系统的打印方式。一种，叫 Berkeley 或 LPD（用于 Unix 的 Berkeley 软件发行版），使用 lpr 程序；另一种，叫 SysV（源自 System V 版本的 Unix），使用 lp 程序。这两个程序的功能大致相同。具体使用哪个完全根据个人喜好。</p><h4 id="lpr-打印文件（Berkeley-风格）"><a href="#lpr-打印文件（Berkeley-风格）" class="headerlink" title="lpr - 打印文件（Berkeley 风格）"></a>lpr - 打印文件（Berkeley 风格）</h4><p>The lpr program can be used to send files to the printer. It may also be used in pipelines, as it accepts standard input. For example, to print the results of our multicolumn directory listing above, we could do this:</p><p>lpr 程序可以用来把文件传送给打印机。由于它能接收标准输入，所以能用管道来协同工作。例如，要打印刚才多列目录列表的结果，我们只需这样：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | pr -3 | lpr</code></pre><p>The report would be sent to the system’s default printer. To send the file to a different printer, the -P option can used like this: lpr -P printer_name where printer_name is the name of the desired printer. To see a list of printers known to the system:</p><p>报告会送到系统默认的打印机，如果要送到别的打印机，可以使用 -P 参数：</p><pre><code>lpr -P printer_name</code></pre><p>printer_name 表示这台打印机的名称。若要查看系统已知的打印机列表：</p><pre><code>[me@linuxbox ~]$ lpstat -a</code></pre><p>Note: Many Linux distributions allow you to define a “printer” that outputs files in PDF, rather than printing on the physical printer. This is very handy for experimenting with printing commands. Check your printer configuration program to see if it supports this configuration. On some distributions, you may need to install additional packages (such as cups-pdf) to enable this capability.</p><p>注意：许多 Linux 发行版允许你定义一个输出 PDF 文件但不执行实体打印的“打印机”，这可以用来很方便的检验你的打印命令。看看你的打印机配置程序是否支持这项配置。在某些发行版中，你可能要自己安装额外的软件包（如 cups-pdf）来使用这项功能。</p><p>Table 23-2 shows some of the common options for lpr.</p><p>表23-2显示了 lpr 的一些常用选项</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-# number</td><td align="left">Set number of copies to number.</td></tr><tr><td align="left">-p</td><td align="left">Print each page with a shaded header with the date, time, job name, and page number. This so-called “pretty print” option can be used when printing text files.</td></tr><tr><td align="left">-P printer</td><td align="left">Specify the name of the printer used for output. If no printer is specified, the system’s default printer is used.</td></tr><tr><td align="left">-r</td><td align="left">Delete files after printing. This would be useful for programs that produce temporary printer-output files.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-# number</td><td align="left">设定打印份数为 number。</td></tr><tr><td align="left">-p</td><td align="left">使每页页眉标题中带有日期、时间、工作名称和页码。这种所谓的“美化打印”选项可用于打印文本文件。</td></tr><tr><td align="left">-P printer</td><td align="left">指定输出打印机的名称。未指定则使用系统默认打印机。</td></tr><tr><td align="left">-r</td><td align="left">打印后删除文件。对程序产生的临时打印文件较为有用。</td></tr></tbody></table><h4 id="lp-打印文件（System-V-风格）"><a href="#lp-打印文件（System-V-风格）" class="headerlink" title="lp - 打印文件（System V 风格）"></a>lp - 打印文件（System V 风格）</h4><p>Like lpr, lp accepts either files or standard input for printing. It differs from lpr in that it supports a different (and slightly more sophisticated) option set. Table 23-3 lists the common options.</p><p>和 lpr 一样，lp 可以接收文件或标准输入为打印内容。与 lpr 不同的是 lp 支持不同的选项（略为复杂），表23-3列出了其常用选项。</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-d printer</td><td align="left">Set the destination (printer) to printer. If no d option is specified, the system default printer is used.</td></tr><tr><td align="left">-n number</td><td align="left">Set the number of copies to number.</td></tr><tr><td align="left">-o landscape</td><td align="left">Set output to landscape orientation.</td></tr><tr><td align="left">-o fitplot</td><td align="left">Scale the file to fit the page. This is useful when printing images, such as JPEG files.</td></tr><tr><td align="left">-o scaling=number</td><td align="left">Scale file to number. The value of 100 fills the page. Values less than 100 are reduced, while values greater than 100 cause the file to be printed across multiple pages.</td></tr><tr><td align="left">-o cpi=number</td><td align="left">Set the output characters per inch to number. Default is 10.</td></tr><tr><td align="left">-o lpi=number</td><td align="left">Set the output lines per inch to number. Default is 6.</td></tr><tr><td align="left">-o page-bottom=points -o page-left=points -o page-right=points -o page-top=points</td><td align="left">Set the page margins. Values are expressed in points, a unit of typographic measurement. There are 72 points to an inch.</td></tr><tr><td align="left">-P pages</td><td align="left">Specify the list of pages. pages may be expressed as a comma-separated list and/or a range—for example 1,3,5,7-10.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d printer</td><td align="left">设定目标（打印机）为 printer。若d 选项未指定，则使用系统默认打印机。</td></tr><tr><td align="left">-n number</td><td align="left">设定的打印份数为 number。</td></tr><tr><td align="left">-o landscape</td><td align="left">设置输出为横向。</td></tr><tr><td align="left">-o fitplot</td><td align="left">缩放文件以适应页面。打印图像时较为有用，如 JPEG 文件。</td></tr><tr><td align="left">-o scaling=number</td><td align="left">缩放文件至 number。100表示填满页面，小于100表示缩小，大于100则会打印在多页上。</td></tr><tr><td align="left">-o cpi=number</td><td align="left">设定输出为 number 字符每英寸。默认为10。</td></tr><tr><td align="left">-o lpi=number</td><td align="left">设定输出为 number 行每英寸，默认为6。</td></tr><tr><td align="left">-o page-bottom=points -o page-left=points -o page-right=points -o page-top=points</td><td align="left">设置页边距，单位为点，一种印刷上的单位。一英寸 =72点。</td></tr><tr><td align="left">-P pages</td><td align="left">指定打印的页面。pages 可以是逗号分隔的列表或范围——例如 1,3,5,7-10。</td></tr></tbody></table><p>We’ll produce our directory listing again, this time printing 12 CPI and 8 LPI with a left margin of one-half inch. Note that we have to adjust the pr options to account for the new page size:</p><p>再次打印我们的目录列表，这次我们设置12 CPI、8 LPI 和一个半英寸的左边距。注意这里我必须调整 pr 选项来适应新的页面大小：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | pr -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8</code></pre><p>This pipeline produces a four-column listing using smaller type than the default. The increased number of characters per inch allows us to fit more columns on the page.</p><p>这条命令用小于默认的格式产生了一个四列的列表。增加 CPI 可以让我们在页面上打印更多列。</p><h4 id="另一种选择：a2ps"><a href="#另一种选择：a2ps" class="headerlink" title="另一种选择：a2ps"></a>另一种选择：a2ps</h4><p>The a2ps program is interesting. As we can surmise from its name, it’s a format conversion program, but it’s also much more. Its name originally meant ASCII to PostScript, and it was used to prepare text files for printing on PostScript printers. Over the years, however, the capabilities of the program have grown, and now its name means Anything to PostScript. While its name suggests a format-conversion program, it is actually a printing program. It sends its default output, rather than standard output, to the system’s default printer. The program’s default behavior is that of a “pretty printer,” meaning that it improves the appearance of output. We can use the program to create a PostScript file on our desktop:</p><p>a2ps 程序很有趣。单从名字上看，这是个格式转换程序，但它的功能不止于此。程序名字的本意为 ASCII to PostScript，它是用来为 PostScript 打印机准备要打印的文本文件的。多年后，程序的功能得到了提升，名字的含义也变成了 Anything to PostScript。尽管名为格式转换程序，但它实际的功能却是打印。它的默认输出不是标准输出，而是系统的默认打印机。程序的默认行为被称为“漂亮的打印机”，这意味着它可以改善输出的外观。我们能用程序在桌面上创建一个 PostScript 文件：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | pr -3 -t | a2ps -o ~/Desktop/ls.ps -L 66[stdin (plain): 11 pages on 6 sheets][Total: 11 pages on 6 sheets] saved into the file `/home/me/Desktop/ls.ps&#39;</code></pre><p>Here we filter the stream with pr, using the -t option (omit headers and footers) and then, with a2ps, specifying an output file (-o option) and 66 lines per page (-L option) to match the output pagination of pr. If we view the resulting file with a suitable file viewer, we will see the output shown in Figure 23-1.</p><p>这里我们用带 -t 参数（忽略页眉和页脚）的 pr 命令过滤数据流，然后用 a2ps 指定一个输出文件（-o 参数），并设定每页66行（-L 参数）来匹配 pr 的输出分页。用合适的文件查看器查看我们的输出文件，我们就会看到图23-1中显示的结果。</p><p><img src="https://billie66.github.io/TLCL/book/images/23-1.png" alt="img"><br>图 23-1: 浏览 a2ps 的输出结果</p><p>As we can see, the default output layout is “two up” format. This causes the contents of two pages to be printed on each sheet of paper. a2ps applies nice page headers and footers, too.</p><p>可以看到，默认的输出布局是一面两页的，这将导致两页的内容被打印到一张纸上。a2ps 还能利用页眉和页脚。</p><p>a2ps has a lot of options. Table 23-4 summarizes them.</p><p>a2ps 有很多选项，总结在表23-4中。</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">–center-title text</td><td align="left">Set center page title to text.</td></tr><tr><td align="left">–columns number</td><td align="left">Arrange pages into number columns. Default is 2.</td></tr><tr><td align="left">–footer text</td><td align="left">Set page footer to text.</td></tr><tr><td align="left">–guess</td><td align="left">Report the types of files given as arguments. Since a2ps tries to convert and format all types of data, this option can be useful for predicting what a2ps will do when given a particular file.</td></tr><tr><td align="left">–left-footer text</td><td align="left">Set left-page footer to text.</td></tr><tr><td align="left">–left-title text</td><td align="left">Set left-page title to text.</td></tr><tr><td align="left">–line-numbers=interval</td><td align="left">Number lines of output every interval lines.</td></tr><tr><td align="left">–list=defauls</td><td align="left">Display default settings.</td></tr><tr><td align="left">–list=topic</td><td align="left">Display settings for topic, where topic is one of the following: delegations (external programs that will be used to convert data), encodings, features, variables, media (paper sizes and the like), ppd (PostScript printer descriptions), printers, prologues (portions of code that are prefixed to normal output), stylesheets, or user options.</td></tr><tr><td align="left">–pages range</td><td align="left">Print pages in range.</td></tr><tr><td align="left">–right-footer text</td><td align="left">Set right-page footer to text.</td></tr><tr><td align="left">–right-title text</td><td align="left">Set right-page title to text.</td></tr><tr><td align="left">–rows number</td><td align="left">Arrange pages into number rows. Default is 1.</td></tr><tr><td align="left">-B</td><td align="left">No page headers.</td></tr><tr><td align="left">-b text</td><td align="left">Set page header to text.</td></tr><tr><td align="left">-f size</td><td align="left">Use size point font.</td></tr><tr><td align="left">-l number</td><td align="left">Set characters per line to number. This and the -L option (below) can be used to make files paginated with other programs, such as pr, fit correctly on the page.</td></tr><tr><td align="left">-L number</td><td align="left">Set lines per page to number.</td></tr><tr><td align="left">-M name</td><td align="left">Use media name—for example, A4.</td></tr><tr><td align="left">-n number</td><td align="left">Output number copies of each page.</td></tr><tr><td align="left">-o file</td><td align="left">Send output to file. If file is specified as -, use standard output.</td></tr><tr><td align="left">-P printer</td><td align="left">Use printer. If a printer is not specified, the system default printer is used.</td></tr><tr><td align="left">-R</td><td align="left">Portrait orientation</td></tr><tr><td align="left">-r</td><td align="left">Landscape orientation</td></tr><tr><td align="left">-T number</td><td align="left">Set tab stops to every number characters.</td></tr><tr><td align="left">-u text</td><td align="left">Underlay (watermark) pages with text.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">–center-title text</td><td align="left">设置中心页标题为 text。</td></tr><tr><td align="left">–columns number</td><td align="left">将所有页面排列成 number 列。默认为2。</td></tr><tr><td align="left">–footer text</td><td align="left">设置页脚为 text。</td></tr><tr><td align="left">–guess</td><td align="left">报告参数中文件的类型。由于 a2ps 会转换并格式化所有类型的数据，所以当给定文件类型后，这个选项可以很好的用来判断 a2ps 应该做什么。</td></tr><tr><td align="left">–left-footer text</td><td align="left">设置左页脚为 text。</td></tr><tr><td align="left">–left-title text</td><td align="left">设置页面左标题为 text。</td></tr><tr><td align="left">–line-numbers=interval</td><td align="left">每隔 interval 行输出行号。</td></tr><tr><td align="left">–list=defauls</td><td align="left">显示默认设置。</td></tr><tr><td align="left">–list=topic</td><td align="left">显示 topic 设置，topic 表示下列之一：代理程序（用来转换数据的外部程序），编码，特征，变量，媒介（页面大小等），ppd（PostScript 打印机描述信息），打印机，起始程序（为常规输出添加前缀的代码部分），样式表，或用户选项。</td></tr><tr><td align="left">–pages range</td><td align="left">打印 range 范围内的页面。</td></tr><tr><td align="left">–right-footer text</td><td align="left">设置右页脚为 text。</td></tr><tr><td align="left">–right-title text</td><td align="left">设置页面右标题为 text。</td></tr><tr><td align="left">–rows number</td><td align="left">将所有页面排列成 number 排。默认为1。</td></tr><tr><td align="left">-B</td><td align="left">没有页眉。</td></tr><tr><td align="left">-b text</td><td align="left">设置页眉为 text。</td></tr><tr><td align="left">-f size</td><td align="left">使用字体大小为 size 号。</td></tr><tr><td align="left">-l number</td><td align="left">设置每行字符数为 number。此项和 -L 选项（见下方）可以给文件用其他程序来更准确的分页，如 pr。</td></tr><tr><td align="left">-L number</td><td align="left">设置每页行数为 number。</td></tr><tr><td align="left">-M name</td><td align="left">使用打印媒介的名称——例如，A4。</td></tr><tr><td align="left">-n number</td><td align="left">每页输出 number 份。</td></tr><tr><td align="left">-o file</td><td align="left">输出到文件 file。如果指定为 - ，则输出到标准输出。</td></tr><tr><td align="left">-P printer</td><td align="left">使用打印机 printer。如果未指定，则使用系统默认打印机。</td></tr><tr><td align="left">-R</td><td align="left">纵向打印。</td></tr><tr><td align="left">-r</td><td align="left">横向打印。</td></tr><tr><td align="left">-T number</td><td align="left">设置制表位为每 number 字符。</td></tr><tr><td align="left">-u text</td><td align="left">用 text 作为页面底图（水印）。</td></tr></tbody></table><p>This is just a summary. a2ps has several more options.</p><p>以上只是对 a2ps 的总结，更多的选项尚未列出。</p><p>Note: a2ps is still in active development. During my testing, I noticed different behavior on various distributions. On CentOS 4, output always went to standard output by default. On CentOS 4 and Fedora 10, output defaulted to A4 media, despite the program being configured to use letter-size media by default. I could overcome these issues by explicitly specifying the desired option. On Ubuntu 8.04, a2ps performed as documented. Also note that there is another output formatter that is useful for converting text into PostScript. Called enscript, it can perform many of the same kinds of formatting and printing tricks, but unlike a2ps, it accepts only text input.</p><p>注意：a2ps 目前仍在不断的开发中。就我的测试而言，不同版本之间都多少有所变化。CentOS 4 中输出总是默认为标准输出。在 CentOS 4 和 Fedora 10 中，尽管程序配置信纸为默认媒介，输出还是默认为 A4纸。我可以明确的指定需要的选项来解决这些问题。Ubuntu 8.04 中，a2ps 表现的正如参考文档中所述。 另外，我们也要注意到另一个转换文本为 PostScript 的输出格式化工具，名叫 enscript。它具有许多相同的格式化和打印功能，但和 a2ps 唯一的不同在于，它只能处理纯文本的输入。</p><h3 id="监视和控制打印任务"><a href="#监视和控制打印任务" class="headerlink" title="监视和控制打印任务"></a>监视和控制打印任务</h3><p>As Unix printing systems are designed to handle multiple print jobs from multiple users, CUPS is designed to do the same. Each printer is given a print queue, where jobs are parked until they can be spooled to the printer. CUPS supplies several command-line programs that are used to manage printer status and print queues. Like the lpr and lp programs, these management programs are modeled after the corresponding programs from the Berkeley and System V printing systems.</p><p>由于 Unix 打印系统的设计是能够处理多用户的多重打印任务，CUPS 也是如此设计的。每台打印机都有一个打印队列，其中的任务直到传送到打印机才停下并进行打印。CUPS 支持一些命令行程序来管理打印机状态和打印队列。想 lpr 和 lp 这样的管理程序都是以 Berkeley 和 System V 打印系统的相应程序为依据进行排列的。</p><h4 id="lpstat-显示打印系统状态"><a href="#lpstat-显示打印系统状态" class="headerlink" title="lpstat - 显示打印系统状态"></a>lpstat - 显示打印系统状态</h4><p>The lpstat program is useful for determining the names and availability of printers on the system. For example, if we had a system with both a physical printer (named printer) and a PDF virtual printer (named PDF ), we could check their status like this:</p><p>lpstat 程序可用于确定系统中打印机的名字和有效性。例如，我们系统中有一台实体打印机（名叫 printer）和一台 PDF 虚拟打印机（名叫 PDF），我们可以像这样查看打印机状态：</p><pre><code>[me@linuxbox ~]$ lpstat -aPDF accepting requests since Mon 05 Dec 2011 03:05:59 PM ESTprinter accepting requests since Tue 21 Feb 2012 08:43:22 AM EST</code></pre><p>Further, we could determine a more detailed description of the print system configuration this way:</p><p>接着，我们可以查看打印系统更具体的配置信息：</p><pre><code>[me@linuxbox ~]$ lpstat -ssystem default destination: printerdevice for PDF: cups-pdf:/device for printer: ipp://print-server:631/printers/printer</code></pre><p>In this example, we see that printer is the system’s default printer and that it is a network printer using Internet Printing Protocol (ipp:// ) attached to a system named print-server.</p><p>上例中，我们看到 printer 是系统默认的打印机，其本身是一台网络打印机，使用网络打印协议（ipp://）通过网络连接到名为 print-server 的系统。</p><p>The commonly used options are described in Table 23-5.</p><p>lpstat 的常用选项列于表23-5。</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-a [printer…]</td><td align="left">Display the state of the printer queue for printer. Note that this is the status of the printer queue’s ability to accept jobs, not the status of the physical printers. If no printers are specified, all print queues are shown.</td></tr><tr><td align="left">-d</td><td align="left">Display the name of the system’s default printer.</td></tr><tr><td align="left">-p [printer…]</td><td align="left">Display the status of the specified printer. If no printers are specified, all printers are shown.</td></tr><tr><td align="left">-r</td><td align="left">Display the status of the print server.</td></tr><tr><td align="left">-s</td><td align="left">Display a status summary.</td></tr><tr><td align="left">-t</td><td align="left">Display a complete status report.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-a [printer…]</td><td align="left">显示 printer 打印机的队列。这里显示的状态是打印机队列承受任务的能力，而不是实体打印机的状态。若未指定打印机，则显示所有打印队列。</td></tr><tr><td align="left">-d</td><td align="left">显示系统默认打印机的名称。</td></tr><tr><td align="left">-p [printer…]</td><td align="left">显示 printer 指定的打印机的状态。若未指定打印机，则显示所有打印机状态。</td></tr><tr><td align="left">-r</td><td align="left">显示打印系统的状态。</td></tr><tr><td align="left">-s</td><td align="left">显示汇总状态。</td></tr><tr><td align="left">-t</td><td align="left">显示完整状态报告。</td></tr></tbody></table><h4 id="lpq-显示打印机队列状态"><a href="#lpq-显示打印机队列状态" class="headerlink" title="lpq - 显示打印机队列状态"></a>lpq - 显示打印机队列状态</h4><p>To see the status of a printer queue, the lpq program is used. This allows us to view the status of the queue and the print jobs it contains. Here is an example of an empty queue for a system default printer named printer :</p><p>使用 lpq 程序可以查看打印机队列的状态，从中我们可以看到队列的状态和所包含的打印任务。下面的例子显示了一台名叫 printer 的系统默认打印机包含一个空队列的情况：</p><pre><code>[me@linuxbox ~]$ lpqprinter is readyno entries</code></pre><p>If we do not specify a printer (using the -P option), the system’s default printer is shown. If we send a job to the printer and then look at the queue, we will see it listed:</p><p>如果我们不指定打印机（用 -P 参数），就会显示系统默认打印机。如果给打印机添加一项任务再查看队列，我们就会看到下列结果：</p><pre><code>[me@linuxbox ~]$ ls *.txt | pr -3 | lprequest id is printer-603 (1 file(s))[me@linuxbox ~]$ lpqprinter is ready and printingRank      Owner   Job     File(s)           Total Sizeactive    me      603     (stdin)           1024 bytes</code></pre><h4 id="lprm-和-cancel-取消打印任务"><a href="#lprm-和-cancel-取消打印任务" class="headerlink" title="lprm 和 cancel - 取消打印任务"></a>lprm 和 cancel - 取消打印任务</h4><p>CUPS supplies two programs used to terminate print jobs and remove them from the print queue. One is Berkeley style (lprm), and the other is System V (cancel). They differ slightly in the options they support but do basically the same thing. Using our print job above as an example, we could stop the job and remove it this way:</p><p>CUPS 提供两个程序来从打印队列中终止并移除打印任务。一个是 Berkeley 风格的（lprm），另一个是 System V 的（cancel）。在支持的选项上两者有较小的区别但是功能却几乎相同。以上面的打印任务为例，我们可以像这样终止并移除任务：</p><pre><code>[me@linuxbox ~]$ cancel 603[me@linuxbox ~]$ lpqprinter is readyno entries</code></pre><p>Each command has options for removing all the jobs belonging to a particular user, particular printer, and multiple job numbers. Their respective man pages have all the details.</p><p>每个命令都有选项可用于移除某用户、某打印机或多个任务号的所有任务，相应的参考手册中都有详细的介绍。</p>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十二章 格式化输出</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>In this chapter, we continue our look at text related tools, focusing on programs that are used to format text output, rather than changing the text itself. These tools are often used to prepare text for eventual printing, a subject that we will cover in the next chapter. The programs that we will cover in this chapter include:</p><p>在这章中，我们继续着手于文本相关的工具，关注那些用来格式化输出的程序，而不是改变文本自身。 这些工具通常让文本准备就绪打印，这是我们在下一章会提到的。我们在这章中会提到的工具有以下这些：</p><ul><li>nl – Number lines</li><li>nl – 添加行号</li><li>fold – Wrap each line to a specified length</li><li>fold – 限制文件列宽</li><li>fmt – A simple text formatter</li><li>fmt – 一个简单的文本格式转换器</li><li>pr – Prepare text for printing</li><li>pr – 让文本为打印做好准备</li><li>printf – Format and print data</li><li>printf – 格式化数据并打印出来</li><li>groff – A document formatting system</li><li>groff – 一个文件格式化系统</li></ul><h3 id="简单的格式化工具"><a href="#简单的格式化工具" class="headerlink" title="简单的格式化工具"></a>简单的格式化工具</h3><p>We’ll look at some of the simple formatting tools first. These are mostly single purpose programs, and a bit unsophisticated in what they do, but they can be used for small tasks and as parts of pipelines and scripts.</p><p>我们将先着眼于一些简单的格式工具。他们都是功能单一的程序，并且做法有一点单纯， 但是他们能被用于小任务并且作为脚本和管道的一部分 。</p><h4 id="nl-添加行号"><a href="#nl-添加行号" class="headerlink" title="nl - 添加行号"></a>nl - 添加行号</h4><p>The nl program is a rather arcane tool used to perform a simple task. It numbers lines. In its simplest use, it resembles cat -n:</p><p>nl 程序是一个相当神秘的工具，用作一个简单的任务。它添加文件的行数。在它最简单的用途中，它相当于 cat -n:</p><pre><code>[me@linuxbox ~]$ nl distros.txt | head</code></pre><p>Like cat, nl can accept either multiple files as command line arguments, or standard input. However, nl has a number of options and supports a primitive form of markup to allow more complex kinds of numbering.</p><p>像 cat，nl 既能接受多个文件作为命令行参数，也能接受标准输入。然而，nl 有一个相当数量的选项并支持一个简单的标记方式去允许更多复杂的方式的计算。</p><p>nl supports a concept called “logical pages” when numbering. This allows nl to reset (start over) the numerical sequence when numbering. Using options, it is possible to set the starting number to a specific value and, to a limited extent, its format. A logical page is further broken down into a header, body, and footer. Within each of these sections, line numbering may be reset and/or be assigned a different style. If nl is given multiple files, it treats them as a single stream of text. Sections in the text stream are indicated by the presence of some rather odd-looking markup added to the text:</p><p>nl 在计算文件行数的时候支持一个叫“逻辑页面”的概念 。这允许nl在计算的时候去重设（再一次开始）可数的序列。用到那些选项 的时候，可以设置一个特殊的开始值，并且在某个可限定的程度上还能设置它的格式。一个逻辑页面被进一步分为 header,body 和 footer 这样的元素。在每一个部分中，数行数可以被重设，并且/或被设置成另外一个格式。如果nl同时处理多个文件，它会把他们当成一个单一的 文本流。文本流中的部分被一些相当古怪的标记的存在加进了文本：</p><table><thead><tr><th align="left">MarkUp</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">:::</td><td align="left">Start of logical page header</td></tr><tr><td align="left">::</td><td align="left">Start of logical page body</td></tr><tr><td align="left">:</td><td align="left">Start of logical page footer</td></tr></tbody></table><table><thead><tr><th align="left">标记</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">:::</td><td align="left">逻辑页页眉开始处</td></tr><tr><td align="left">::</td><td align="left">逻辑页主体开始处</td></tr><tr><td align="left">:</td><td align="left">逻辑页页脚开始处</td></tr></tbody></table><p>Each of the above markup elements must appear alone on its own line. After processing a markup element, nl deletes it from the text stream.</p><p>每一个上述的标记元素肯定在自己的行中独自出现。在处理完一个标记元素之后，nl 把它从文本流中删除。</p><p>Here are the common options for nl:</p><p>这里有一些常用的 nl 选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-b style</td><td align="left">Set body numbering to style, where style is one of the following:a = number all linest = number only non-blank lines. This is the default.n = nonepregexp = number only lines matching basic regular expression regexp.</td></tr><tr><td align="left">-f style</td><td align="left">Set footer numbering to style. Default is n (none).</td></tr><tr><td align="left">-h style</td><td align="left">Set header numbering to style. Default is n (none).</td></tr><tr><td align="left">-i number</td><td align="left">Set page numbering increment to number. Default is one.</td></tr><tr><td align="left">-n format</td><td align="left">Sets numbering format to format, where format is:ln = left justified, without leading zeros.rn = right justified, without leading zeros. This is the default.rz = right justified, with leading zeros.</td></tr><tr><td align="left">-p</td><td align="left">Do not reset page numbering at the beginning of each logical page.</td></tr><tr><td align="left">-s string</td><td align="left">Add string to the end of each line number to create a separator.Default is a single tab character.</td></tr><tr><td align="left">-v number</td><td align="left">Set first line number of each logical page to number. Default is one.</td></tr><tr><td align="left">-w width</td><td align="left">Set width of the line number field to width. Default is six.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-b style</td><td align="left">把 body 按被要求方式数行，可以是以下方式：a = 数所有行t = 数非空行。这是默认设置。n = 无pregexp = 只数那些匹配了正则表达式的行</td></tr><tr><td align="left">-f style</td><td align="left">将 footer 按被要求设置数。默认是无</td></tr><tr><td align="left">-h style</td><td align="left">将 header 按被要求设置数。默认是</td></tr><tr><td align="left">-i number</td><td align="left">将页面增加量设置为数字。默认是一。</td></tr><tr><td align="left">-n format</td><td align="left">设置数数的格式，格式可以是：ln = 左偏，没有前导零。rn = 右偏，没有前导零。rz = 右偏，有前导零。</td></tr><tr><td align="left">-p</td><td align="left">不要在没一个逻辑页面的开始重设页面数。</td></tr><tr><td align="left">-s string</td><td align="left">在没一个行的末尾加字符作分割符号。默认是单个的 tab。</td></tr><tr><td align="left">-v number</td><td align="left">将每一个逻辑页面的第一行设置成数字。默认是一。</td></tr><tr><td align="left">-w width</td><td align="left">将行数的宽度设置，默认是六。</td></tr></tbody></table><p>Admittedly, we probably won’t be numbering lines that often, but we can use nl to look at how we can combine multiple tools to perform more complex tasks. We will build on our work in the previous chapter to produce a Linux distributions report. Since we will be using nl, it will be useful to include its header/body/footer markup. To do this, we will add it to the sed script from the last chapter. Using our text editor, we will change the script as follows and save it as distros-nl.sed:</p><p>坦诚的说，我们大概不会那么频繁地去数行数，但是我们能用 nl 去查看我们怎么将多个工具结合在一个去完成更复杂的任务。 我们将在之前章节的基础上做一个 Linux 发行版的报告。因为我们将使用 nl，包含它的 header/body/footer 标记将会十分有用。 我们将把它加到上一章的 sed 脚本来做这个。使用我们的文本编辑器，我们将脚本改成一下并且把它保存成 distros-nl.sed:</p><pre><code># sed script to produce Linux distributions report1 i\\\:\\:\\:\\Linux Distributions Report\\NameVer. Released\-------- --------\\\:\\:s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/$ i\\\:\\End Of Report</code></pre><p>The script now inserts the nl logical page markup and adds a footer at the end of the report. Note that we had to double up the backslashes in our markup, because they are normally interpreted as an escape character by sed.</p><p>这个脚本现在加入了 nl 的逻辑页面标记并且在报告的最后加了一个 footer。记得我们在我们的标记中必须两次使用反斜杠， 因为他们通常被 sed 解释成一个转义字符。</p><p>Next, we’ll produce our enhanced report by combining sort, sed, and nl:</p><p>下一步，我们将结合 sort, sed, nl 来生成我们改进的报告：</p><pre><code>[me@linuxbox ~]$ sort -k 1,1 -k 2n distros.txt | sed -f distros-nl.sed | nl        Linux Distributions Report        Name    Ver.    Released        ----    ----    --------    1   Fedora  5       2006-03-20    2   Fedora  6       2006-10-24    3   Fedora  7       2007-05-31    4   Fedora  8       2007-11-08    5   Fedora  9       2008-05-13    6   Fedora  10      2008-11-25    7   SUSE    10.1    2006-05-11    8   SUSE    10.2    2006-12-07    9   SUSE    10.3    2007-10-04    10  SUSE    11.0    2008-06-19    11  Ubuntu  6.06    2006-06-01    12  Ubuntu  6.10    2006-10-26    13  Ubuntu  7.04    2007-04-19    14  Ubuntu  7.10    2007-10-18    15  Ubuntu  8.04    2008-04-24        End Of Report</code></pre><p>Our report is the result of our pipeline of commands. First, we sort the list by distribution name and version (fields one and two), then we process the results with sed, adding the report header (including the logical page markup for nl) and footer. Finally, we process the result with nl, which, by default, only numbers the lines of the text stream that belong to the body section of the logical page.</p><p>我们的报告是一串命令的结果，首先，我们给名单按发行版本和版本号（表格1和2处）进行排序，然后我们用 sed 生产结果， 增加了 header（包括了为 nl 增加的逻辑页面标记）和 footer。最后，我们按默认用 nl 生成了结果，只数了属于逻辑页面的 body 部分的 文本流的行数。</p><p>We can repeat the command and experiment with different options for nl. Some interesting ones are:</p><p>我们能够重复命令并且实验不同的 nl 选项。一些有趣的方式：</p><pre><code>nl -n rz</code></pre><p>and</p><p>和</p><pre><code>nl -w 3 -s &#39; &#39;</code></pre><h4 id="fold-限制文件行宽"><a href="#fold-限制文件行宽" class="headerlink" title="fold - 限制文件行宽"></a>fold - 限制文件行宽</h4><p>Folding is the process of breaking lines of text at a specified width. Like our other commands, fold accepts either one or more text files or standard input. If we send fold a simple stream of text, we can see how it works:</p><p>折叠是将文本的行限制到特定的宽的过程。像我们的其他命令，fold 接受一个或多个文件及标准输入。如果我们将 一个简单的文本流 fold，我们可以看到它工作的方式：</p><pre><code>[me@linuxbox ~]$ echo &quot;The quick brown fox jumped over the lazy dog.&quot; | fold -w 12The quick brown fox jumped over thelazy dog.</code></pre><p>Here we see fold in action. The text sent by the echo command is broken into segments specified by the -w option. In this example, we specify a line width of twelve characters. If no width is specified, the default is eighty characters. Notice how the lines are broken regardless of word boundaries. The addition of the -s option will cause fold to break the line at the last available space before the line width is reached:</p><p>这里我们看到了 fold 的行为。这个用 echo 命令发送的文本用 -w 选项分解成块。在这个例子中，我们设定了行宽为12个字符。 如果没有字符设置，默认是80。注意到文本行不会因为单词边界而不会被分解。增加的 -s 选项将让 fold 分解到最后可用的空白 字符，即会考虑单词边界。</p><pre><code>[me@linuxbox ~]$ echo &quot;The quick brown fox jumped over the lazy dog.&quot;| fold -w 12 -sThe quickbrown foxjumped overthe lazydog.</code></pre><h4 id="fmt-一个简单的文本格式器"><a href="#fmt-一个简单的文本格式器" class="headerlink" title="fmt - 一个简单的文本格式器"></a>fmt - 一个简单的文本格式器</h4><p>The fmt program also folds text, plus a lot more. It accepts either files or standard input and performs paragraph formatting on the text stream. Basically, it fills and joins lines in text while preserving blank lines and indentation.</p><p>fmt 程序同样折叠文本，外加很多功能。它接受文本或标准输入并且在文本流上呈现照片转换。它主要是填充和连接文本行，同时保留空白符和缩进。</p><p>To demonstrate, we’ll need some text. Let’s lift some from the fmt info page:</p><p>为了解释，我们将需要一些文本。让我们抄一些 fmt 主页上的东西吧：</p><pre><code>‘fmt’ reads from the specified FILE arguments (or standard input ifnone are given), and writes to standard output.   By default, blank lines, spaces between words, and indentation arepreserved in the output; successive input lines with differentindentation are not joined; tabs are expanded on input and introduced onoutput.   ‘fmt’ prefers breaking lines at the end of a sentence, and tries toavoid line breaks after the first word of a sentence or before the lastword of a sentence.  A &quot;sentence break&quot; is defined as either the end ofa paragraph or a word ending in any of ‘.?!’, followed by two spaces orend of line, ignoring any intervening parentheses or quotes.  Like TeX,‘fmt’ reads entire “paragraphs” before choosing line breaks; thealgorithm is a variant of that given by Donald E. Knuth and Michael F.Plass in “Breaking Paragraphs Into Lines”, ‘Software—Practice &amp;Experience’ 11, 11 (November 1981), 1119–1184.</code></pre><p>We’ll copy this text into our text editor and save the file as fmt-info.txt. Now, let’s say we wanted to reformat this text to fit a fifty character wide column. We could do this by processing the file with fmt and the -w option:</p><p>我们将把这段文本复制进我们的文本编辑器并且保存文件名为 fmt-info.txt。现在，让我们重新格式这个文本并且让它成为一个50 个字符宽的项目。我们能用 -w 选项对文件进行处理：</p><pre><code>[me@linuxbox ~]$ fmt -w 50 fmt-info.txt | head&#39;fmt&#39; reads from the specified FILE arguments(or standard input ifnone are given), and writes to standard output.By default, blank lines, spaces between words,and indentation arepreserved in the output; successive input lineswith different indentation are not joined; tabsare expanded on input and introduced on output.</code></pre><p>Well, that’s an awkward result. Perhaps we should actually read this text, since it explains what’s going on:</p><p>好，这真是一个奇怪的结果。大概我们应该认真的阅读这段文本，因为它恰好解释了发生了什么：</p><p>“By default, blank lines, spaces between words, and indentation are preserved in the output; successive input lines with different indentation are not joined; tabs are expanded on input and introduced on output.”</p><p>默认情况下，输出会保留空行，单词之间的空格，和缩进；持续输入的具有不同缩进的文本行不会连接在一起；tab 字符在输入时会展开，输出时复原 。</p><p>So, fmt is preserving the indentation of the first line. Fortunately, fmt provides an option to correct this:</p><p>所以，fmt 会保留第一行的缩进。幸运的是，fmt 提供了一个选项来更正这种行为：</p><p>Much better. By adding the -c option, we now have the desired result.</p><p>好多了。通过添加 -c 选项，现在我们得到了所期望的结果。</p><p>fmt has some interesting options:</p><p>fmt 有一些有意思的选项：</p><p>The -p option is particularly interesting. With it, we can format selected portions of a file, provided that the lines to be formatted all begin with the same sequence of characters. Many programming languages use the pound sign (#) to indicate the beginning of a comment and thus can be formatted using this option. Let’s create a file that simulates a program that uses comments:</p><p>这个 -p 选项尤为有趣。通过它，我们可以格式文件选中的部分，通过在开头使用一样的符号。 很多编程语言使用锚标记（#）去提醒注释的开始，而且它可以通过这个选项来被格式。让我们创建一个有用到注释的程序。</p><pre><code>[me@linuxbox ~]$ cat &gt; fmt-code.txt# This file contains code with comments.# This line is a comment.# Followed by another comment line.# And another.This, on the other hand, is a line of code.And another line of code.And another.</code></pre><p>Our sample file contains comments which begin the string “# “ (a # followed by a space) and lines of “code” which do not. Now, using fmt, we can format the comments and leave the code untouched:</p><p>我们的示例文件包含了用 “#” 开始的注释（一个 # 后跟着一个空白符）和代码。现在，使用 fmt，我们能格式注释并且 不让代码被触及。</p><pre><code>[me@linuxbox ~]$ fmt -w 50 -p &#39;# &#39; fmt-code.txt# This file contains code with comments.# This line is a comment. Followed by another# comment line. And another.This, on the other hand, is a line of code.And another line of code.And another.</code></pre><p>Notice that the adjoining comment lines are joined, while the blank lines and the lines that do not begin with the specified prefix are preserved.</p><p>注意相邻的注释行被合并了，空行和非注释行被保留了。</p><h4 id="pr-–-格式化打印文本"><a href="#pr-–-格式化打印文本" class="headerlink" title="pr – 格式化打印文本"></a>pr – 格式化打印文本</h4><p>The pr program is used to paginate text. When printing text, it is often desirable to separate the pages of output with several lines of whitespace, to provide a top and bottom margin for each page. Further, this whitespace can be used to insert a header and footer on each page.</p><p>pr 程序用来把文本分页。当打印文本的时候，经常希望用几个空行在输出的页面的顶部或底部添加空白。此外，这些空行能够用来插入到每个页面的页眉或页脚。</p><p>We’ll demonstrate pr by formatting our distros.txt file into a series of very short pages (only the first two pages are shown):</p><p>下面我们将演示 pr 的用法。我们准备将 distros.txt 这个文件分成若干张很短的页面（仅展示前两张页面）：</p><pre><code>[me@linuxbox ~]$ pr -l 15 -w 65 distros.txt2008-12-11 18:27        distros.txt         Page 1SUSE        10.2     12/07/2006Fedora      10       11/25/2008SUSE        11.0     06/19/2008Ubuntu      8.04     04/24/2008Fedora      8        11/08/20072008-12-11 18:27        distros.txt         Page 2SUSE        10.3     10/04/2007Ubuntu      6.10     10/26/2006Fedora      7        05/31/2007Ubuntu      7.10     10/18/2007Ubuntu      7.04     04/19/2007</code></pre><p>In this example, we employ the -l option (for page length) and the -w option (page width) to define a “page” that is 65 columns wide and 15 lines long. pr paginates the contents of the distros.txt file, separates each page with several lines of whitespace and creates a default header containing the file modification time, filename, and page number. The pr program provides many options to control page layout. We’ll take a look at more of them in the next chapter.</p><p>在上面的例子中，我们用 -l 选项（页长）和 -w 选项（页宽）定义了宽65列，长15行的一个“页面”。 pr 为 distros.txt 中的内容编订页码，用空行分开各页面，生成了包含文件修改时间、文件名、页码的默认页眉。 pr 指令拥有很多调整页面布局的选项，我们将在下一章中进一步探讨。</p><h4 id="printf-–-Format-And-Print-Data"><a href="#printf-–-Format-And-Print-Data" class="headerlink" title="printf – Format And Print Data"></a>printf – Format And Print Data</h4><p>Unlike the other commands in this chapter, the printf command is not used for pipelines (it does not accept standard input) nor does it find frequent application directly on the command line (it’s mostly used in scripts). So why is it important? Because it is so widely used.</p><p>与本章中的其他指令不同， printf 并不用于流水线执行（不接受标准输入）。在命令行中，它也鲜有运用（它通常被用于自动执行指令中）。所以为什么它如此重要？因为它被广泛使用。</p><p>printf (from the phrase “print formatted”) was originally developed for the C programming language and has been implemented in many programming languages including the shell. In fact, in bash, printf is a builtin. printf works like this:</p><p>printf (来自短语“格式化打印” “print formatted”) 最初为 C 语言设计，后来在包括 shell 的多种语言中运用。事实上，在 bash 中, printf 是内置的。 printf 这样工作:</p><pre><code>printf “format” arguments</code></pre><p>The command is given a string containing a format description which is then applied to a list of arguments. The formatted result is sent to standard output. Here is a trivial example:</p><p>首先，发送包含有格式化描述的字符串的指令，接着，这些描述被应用于参数列表上。格式化的结果在标准输出中显示。下面是一个小例子：</p><pre><code>[me@linuxbox ~]$ printf &quot;I formatted the string: %s\n&quot; fooI formatted the string: foo</code></pre><p>The format string may contain literal text (like “I formatted the string:”), escape sequences (such as \n, a newline character), and sequences beginning with the % character, which are called conversion specifications. In the example above, the conversion specification %s is used to format the string “foo” and place it in the command’s output. Here it is again:</p><p>格式字符串可能包含文字文本（如“我格式化了这个字符串：” “I formatted the string:”），转义序列（例如\n，换行符）和以％字符开头的序列，这被称为转换规范。在上面的例子中，转换规范 ％s 用于格式化字符串 “foo” 并将其输出在命令行中。我们再来看一遍：</p><pre><code>[me@linuxbox ~]$ printf &quot;I formatted &#39;%s&#39; as a string.\n&quot; fooI formatted &#39;foo&#39; as a string.</code></pre><p>As we can see, the %s conversion specification is replaced by the string “foo” in the command’s output. The s conversion is used to format string data. There are other specifiers for other kinds of data. This table lists the commonly used data types:</p><p>我们可以看到，在命令行输出中，转换规范 ％s 被字符串 “foo” 所替代。s 转换用于格式化字符串数据。还有其他转换符用于其他类型的数据。此表列出了常用的数据类型：</p><table><thead><tr><th align="left">Component</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">d</td><td align="left">Format a number as a signed decimal integer.</td></tr><tr><td align="left">f</td><td align="left">Format and output a floating point number.</td></tr><tr><td align="left">o</td><td align="left">Format an integer as an octal number.</td></tr><tr><td align="left">s</td><td align="left">Format a string.</td></tr><tr><td align="left">x</td><td align="left">Format an integer as a hexadecimal number using lowercase a-f where needed.</td></tr><tr><td align="left">X</td><td align="left">Same as x but use uppercase letters.</td></tr><tr><td align="left">%</td><td align="left">Print a literal % symbol (i.e., specify “%%”)</td></tr></tbody></table><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">d</td><td align="left">将数字格式化为带符号的十进制整数</td></tr><tr><td align="left">f</td><td align="left">格式化并输出浮点数</td></tr><tr><td align="left">o</td><td align="left">将整数格式化为八进制数</td></tr><tr><td align="left">s</td><td align="left">将字符串格式化</td></tr><tr><td align="left">x</td><td align="left">将整数格式化为十六进制数，必要时使用小写a-f</td></tr><tr><td align="left">X</td><td align="left">与 x 相同，但变为大写</td></tr><tr><td align="left">%</td><td align="left">打印 % 符号 (比如，指定 “%%”)</td></tr></tbody></table><p>We’ll demonstrate the effect each of the conversion specifiers on the string “380”:</p><p>下面我们以字符串 “380” 为例，展示每种转换符的效果。</p><pre><code>[me@linuxbox ~]$ printf &quot;%d, %f, %o, %s, %x, %X\n&quot; 380 380 380 380 380 380380, 380.000000, 574, 380, 17c, 17C</code></pre><p>Since we specified six conversion specifiers, we must also supply six arguments for printf to process. The six results show the effect of each specifier. Several optional components may be added to the conversion specifier to adjust its output. A complete conversion specification may consist of the following:</p><p>由于我们指定了六个转换符，我们还必须为 printf 提供六个参数进行处理。下面六个结果展示了每个转换符的效果。 可将可选组件添加到转换符以调整输出。 完整的转换规范包含以下内容：</p><pre><code>%[flags][width][.precision]conversion_specification</code></pre><p>Multiple optional components, when used, must appear in the order specified above to be properly interpreted. Here is a description of each:</p><p>使用多个可选组件时，必须按照上面指定的顺序，以便准确编译。以下是每个可选组件的描述：</p><table><thead><tr><th align="left">Component</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">flags</td><td align="left">There are five different flags:# – Use the “alternate format” for output. This varies by data type. For o (octal number) conversion, the output is prefixed with 0. For x and X (hexadecimal number) conversions, the output is prefixed with 0x or 0X respectively.0–(zero) Pad the output with zeros. This means that the field will be filled with leading zeros, as in “000380”.- – (dash) Left-align the output. By default, printf right-aligns output.‘ ’ – (space) Produce a leading space for positive numbers.+ – (plus sign) Sign positive numbers. By default, printf only signs negative numbers.</td></tr><tr><td align="left">width</td><td align="left">A number specifying the minimum field width.</td></tr><tr><td align="left">.precision</td><td align="left">For floating point numbers, specify the number of digits of precision to be output after the decimal point. For string conversion, precision specifies the number of characters to output.</td></tr></tbody></table><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">flags</td><td align="left">有5种不同的标志:# – 使用“备用格式”输出。这取决于数据类型。对于o（八进制数）转换，输出以0为前缀.对于x和X（十六进制数）转换，输出分别以0x或0X为前缀。0–(零) 用零填充输出。这意味着该字段将填充前导零，比如“000380”。- – (破折号) 左对齐输出。默认情况下，printf右对齐输出。‘ ’ – (空格) 在正数前空一格。+ – (加号) 在正数前添加加号。默认情况下，printf 只在负数前添加符号。</td></tr><tr><td align="left">width</td><td align="left">指定最小字段宽度的数。</td></tr><tr><td align="left">.precision</td><td align="left">对于浮点数，指定小数点后的精度位数。对于字符串转换，指定要输出的字符数。</td></tr></tbody></table><p>Here are some examples of different formats in action:</p><p>以下是不同格式的一些示例：</p><table><thead><tr><th align="left">Argument</th><th align="left">Format</th><th align="left">Result</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">380</td><td align="left">“%d”</td><td align="left">380</td><td align="left">Simple formatting of an integer.</td></tr><tr><td align="left">380</td><td align="left">“%#x”</td><td align="left">0x17c</td><td align="left">Integer formatted as a hexadecimal number using the “alternate format” flag.</td></tr><tr><td align="left">380</td><td align="left">“%05d”</td><td align="left">00380</td><td align="left">Integer formatted with leading zeros (padding) and a minimum field width of five characters.</td></tr><tr><td align="left">380</td><td align="left">“%05.5f”</td><td align="left">380.00000</td><td align="left">Number formatted as a floating point number with padding and five decimal places of precision. Since the specified minimum field width (5) is less than the actual width of the formatted number, the padding has no effect.</td></tr><tr><td align="left">380</td><td align="left">“%010.5f”</td><td align="left">0380.00000</td><td align="left">By increasing the minimum field width to 10 the padding is now visible.</td></tr><tr><td align="left">380</td><td align="left">“%+d”</td><td align="left">+380</td><td align="left">The + flag signs a positive number.</td></tr><tr><td align="left">380</td><td align="left">“%-d”</td><td align="left">380</td><td align="left">The - flag left aligns the formatting.</td></tr><tr><td align="left">abcdefghijk</td><td align="left">“%5s”</td><td align="left">abcedfghijk</td><td align="left">A string formatted with a minimum field width.</td></tr><tr><td align="left">abcdefghijk</td><td align="left">“%d”</td><td align="left">abcde</td><td align="left">By applying precision to a string, it is truncated.</td></tr></tbody></table><table><thead><tr><th align="left">自变量</th><th align="left">格式</th><th align="left">结果</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">380</td><td align="left">“%d”</td><td align="left">380</td><td align="left">简单格式化整数。</td></tr><tr><td align="left">380</td><td align="left">“%#x”</td><td align="left">0x17c</td><td align="left">使用“替代格式”标志将整数格式化为十六进制数。</td></tr><tr><td align="left">380</td><td align="left">“%05d”</td><td align="left">00380</td><td align="left">用前导零（padding）格式化整数，且最小字段宽度为五个字符。</td></tr><tr><td align="left">380</td><td align="left">“%05.5f”</td><td align="left">380.00000</td><td align="left">使用前导零和五位小数位精度格式化数字为浮点数。由于指定的最小字段宽度（5）小于格式化后数字的实际宽度，因此前导零这一命令实际上没有起到作用。</td></tr><tr><td align="left">380</td><td align="left">“%010.5f”</td><td align="left">0380.00000</td><td align="left">将最小字段宽度增加到10，前导零现在变得可见。</td></tr><tr><td align="left">380</td><td align="left">“%+d”</td><td align="left">+380</td><td align="left">使用+标志标记正数。</td></tr><tr><td align="left">380</td><td align="left">“%-d”</td><td align="left">380</td><td align="left">使用-标志左对齐</td></tr><tr><td align="left">abcdefghijk</td><td align="left">“%5s”</td><td align="left">abcedfghijk</td><td align="left">用最小字段宽度格式化字符串。</td></tr><tr><td align="left">abcdefghijk</td><td align="left">“%d”</td><td align="left">abcde</td><td align="left">对字符串应用精度，它被从中截断。</td></tr></tbody></table><p>Again, printf is used mostly in scripts where it is employed to format tabular data, rather than on the command line directly. But we can still show how it can be used to solve various formatting problems. First, let’s output some fields separated by tab characters:</p><p>再次强调，printf 主要用在脚本中，用于格式化表格数据，而不是直接用于命令行。但是我们仍然可以展示如何使用它来解决各种格式化问题。 首先，我们输出一些由制表符分隔的字段：</p><pre><code>[me@linuxbox ~]$ printf &quot;%s\t%s\t%s\n&quot; str1 str2 str3str1 str2 str3</code></pre><p>By inserting \t (the escape sequence for a tab), we achieve the desired effect. Next, some numbers with neat formatting:</p><p>通过插入\t（tab 的转义序列），我们实现了所需的效果。接下来，我们让一些数字的格式变得整齐：</p><pre><code>[me@linuxbox ~]$ printf &quot;Line: %05d %15.3f Result: %+15d\n&quot; 10713.14156295 32589Line: 01071 3.142 Result: +32589</code></pre><p>This shows the effect of minimum field width on the spacing of the fields. Or how about formatting a tiny web page:</p><p>这显示了最小字符宽度对字符间距的影响。或者，让我们看看如何格式化一个小网页：</p><pre><code>[me@linuxbox ~]$ printf &quot;&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;title&gt;%s&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;p&gt;%s&lt;/p&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;\n&quot; &quot;Page Title&quot; &quot;Page Content&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Page Content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Document-Formatting-Systems"><a href="#Document-Formatting-Systems" class="headerlink" title="Document Formatting Systems"></a>Document Formatting Systems</h3><h3 id="文件格式化系统"><a href="#文件格式化系统" class="headerlink" title="文件格式化系统"></a>文件格式化系统</h3><p>So far, we have examined the simple text-formatting tools. These are good for small, simple tasks, but what about larger jobs? One of the reasons that Unix became a popular operating system among technical and scientific users (aside from providing a powerful multitasking, multiuser environment for all kinds of software development) is that it offered tools that could be used to produce many types of documents, particularly scientific and academic publications. In fact, as the GNU documentation describes, document preparation was instrumental to the development of Unix:</p><p>到目前为止，我们已经查看了简单的文本格式化工具。这些对于小而简单的任务是有好处的，但更大的工作呢？ Unix在技术和科学用户中流行的原因之一（除了为各种软件开发提供强大的多任务多用户环境之外）， 是它提供了可用于生成许多类型文档的工具，特别是科学和学术出版物。事实上，正如GNU文档所描述的那样，文档准备对于Unix的开发起到了促进作用：</p><p>The first version of UNIX was developed on a PDP-7 which was sitting around Bell Labs. In 1971 the developers wanted to get a PDP-11 for further work on the operating system. In order to justify the cost for this system, they proposed that they would implement a document formatting system for the AT&amp;T patents division. This first formatting program was a reimplementation of McIllroy’s `roff’, written by J. F. Ossanna.</p><p>UNIX 的第一个版本是在位于贝尔实验室的 PDP-7 上开发的。在1971年，开发人员想要获得 PDP-11 进一步开发操作系统。 为了证明这个系统的成本是合理的，他们建议为 AT＆T 专利部门创建文件格式化系统。 第一个格式化程序是由 J. F. Ossanna 撰写的，重新实现了 McIllroy 的 “roff” 的。</p><p>Two main families of document formatters dominate the field: those descended from the original roff program, including nroff and troff, and those based on Donald Knuth’s TEX (pronounced “tek”) typesetting system. And yes, the dropped “E” in the middle is part of its name.</p><p>两个文件格式化程序的主要家族占据了该领域：继承自原始 roff 程序的，包括 nroff 和 troff；以及 基于 Donald Knuth 的 TEX（发音“tek”）排版系统。是的，中间那个掉下来的“E”是其名称的一部分。</p><p>The name “roff” is derived from the term “run off” as in, “I’ll run off a copy for you.” The nroff program is used to format documents for output to devices that use monospaced fonts, such as character terminals and typewriter-style printers. At the time of its introduction, this included nearly all printing devices attached to computers. The later troff program formats documents for output on typesetters, devices used to produce “camera-ready” type for commercial printing. Most computer printers today are able to simulate the output of typesetters. The roff family also includes some other programs that are used to prepare portions of documents. These include eqn (for mathematical equations) and tbl (for tables).</p><p>名称 “roff” 源于术语 “run off” ，如“I’ll run off a copy for you.”（“我将为您运行副本”）。 nroff 程序用于格式化文档以输出到使用等宽字体的设备，如字符终端和打字机式打印机。 在它刚面世时，这几乎包括了所有连接在计算机上的打印设备。 稍后的 troff 程序格式化用于排版机输出的文档，也就是“camera-ready”（可供拍摄成印刷版的）类型的用于商业打印的设备。 今天的大多数电脑打印机都能够模拟排版机的输出。roff 家族还包括一些用于准备文档部分的程序。这些包括 eqn（用于数学方程）和 tbl（用于表）。</p><p>The TEX system (in stable form) first appeared in 1989 and has, to some degree, displaced troff as the tool of choice for typesetter output. We won’t be covering TEX here, due both to its complexity (there are entire books about it) and to the fact that it is not installed by default on most modern Linux systems.</p><p>TEX 系统（稳定形式）首先在1989年出现，并在某种程度上取代了 troff 作为排版机输出的首选工具。 由于其复杂性（整本书都讲不完）以及在大多数现代 Linux 系统上默认情况下不安装的事实，我们不会在此讨论 TEX。</p><hr><p>Tip: For those interested in installing TEX, check out the texlive package which can be found in most distribution repositories, and the LyX graphical content editor.</p><p>提示：对于有兴趣安装 TEX 的用户，请查看大多数分发版本中可以找到的 texlive 软件包，以及 LyX 图形内容编辑器。</p><hr><h4 id="groff"><a href="#groff" class="headerlink" title="groff"></a>groff</h4><p>groff is a suite of programs containing the GNU implementation of troff. It also includes a script that is used to emulate nroff and the rest of the roff family as well.</p><p>groff 是一套用GNU实现 troff 的程序。它还包括一个脚本，用来模仿 nroff 和其他 roff 家族。</p><p>While roff and its descendants are used to make formatted documents, they do it in a way that is rather foreign to modern users. Most documents today are produced using word processors that are able to perform both the composition and layout of a document in a single step. Prior to the advent of the graphical word processor, documents were often produced in a two-step process involving the use of a text editor to perform composition, and a processor, such as troff, to apply the formatting. Instructions for the formatting program were embedded into the composed text through the use of a markup language. The modern analog for such a process is the web page, which is composed using a text editor of some kind and then rendered by a web browser using HTML as the markup language to describe the final page layout.</p><p>roff 及其后继制作格式化文档的方式对现代用户来说是相当陌生的。今天的大部分文件都是由能够一次性完成排字和布局的文字处理器生成的。 在图形文字处理器出现之前，需要两步来生成文档。首先用文本编辑器排字，接着用诸如 troff 之类的处理器来格式化。 格式化程序的说明通过标记语言的形式插入到已排好字的文本当中。 类似这种过程的现代例子是网页。它首先由某种文本编辑器排好字，然后由使用 HTML 作为标记语言的 Web 浏览器渲染出最终的页面布局。</p><p>We’re not going to cover groff in its entirety, as many elements of its markup language deal with rather arcane details of typography. Instead we will concentrate on one of its macro packages that remains in wide use. These macro packages condense many of its low-level commands into a smaller set of high-level commands that make using groff much easier.</p><p>我们不会讲解 groff 的全部内容，因为它的标记语言被用来处理少有人懂的排字细节。我们将专注于其中的一个仍然广泛使用的宏包。这些宏包将 低级命令转换少量高级命令，从而简化 groff 的使用。</p><p>For a moment, let’s consider the humble man page. It lives in the /usr/share/man directory as a gzip compressed text file. If we were to examine its uncompressed contents, we would see the following (the man page for ls in section 1 is shown):</p><p>现在，我们来看一下这个简单的手册页。它位于/usr/share/man目录，是一个gzip压缩文本文件。解压后，我们将看到以下内容（显示了 ls 手册的第1节）：</p><pre><code>[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | head.\&quot; DO NOT MODIFY THIS FILE! It was generated by help2man 1.35..TH LS &quot;1&quot; &quot;April 2008&quot; &quot;GNU coreutils 6.10&quot; &quot;User Commands&quot;.SH NAMEls \- list directory contents.SH SYNOPSIS.B ls[\fIOPTION\fR]... [\fIFILE\fR]....SH DESCRIPTION.\&quot; Add any additional description here.PP</code></pre><p>Compared to the man page in its normal presentation, we can begin to see a correlation between the markup language and its results:</p><p>与默认手册页进行比较，我们可以开始看到标记语言与其结果之间的相关性：</p><pre><code>[me@linuxbox ~]$ man ls | headLS(1) User Commands LS(1)NAMEls - list directory contentsSYNOPSISls [OPTION]... [FILE]...</code></pre><p>The reason this is of interest is that man pages are rendered by groff, using the mandoc macro package. In fact, we can simulate the man command with the following pipeline:</p><p>令人感兴趣的原因是手册页由 groff 渲染，使用 mandoc 宏包。事实上，我们可以用以下流水线来模拟 man 命令：</p><pre><code>[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc -Tascii | headLS(1) User Commands LS(1)NAMEls - list directory contentsSYNOPSISls [OPTION]... [FILE]...</code></pre><p>Here we use the groff program with the options set to specify the mandoc macro package and the output driver for ASCII. groff can produce output in several formats. If no format is specified, PostScript is output by default:</p><p>在这里，我们使用 groff 程序和选项集来指定 mandoc 宏程序包和 ASCII 的输出驱动程序。groff 可以产生多种格式的输出。 如果没有指定格式，默认情况下会输出 PostScript格式：</p><pre><code>[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc |head%!PS-Adobe-3.0%%Creator: groff version 1.18.1%%CreationDate: Thu Feb 5 13:44:37 2009%%DocumentNeededResources: font Times-Roman%%+ font Times-Bold%%+ font Times-Italic%%DocumentSuppliedResources: procset grops 1.18 1%%Pages: 4%%PageOrder: Ascend%%Orientation: Portrait</code></pre><p>We briefly mentioned PostScript in the previous chapter, and will again in the next chapter. PostScript is a page description language that is used to describe the contents of a printed page to a typesetter-like device. If we take the output of our command and store it to a file (assuming that we are using a graphical desktop with a Desktop directory):</p><p>我们在前一章中简要介绍了PostScript，并将在下一章中再次介绍。 PostScript 是一种页面描述语言，用于将打印页面的内容描述给类似排字机的设备。 如果我们输出命令并将其存储到一个文件中（假设我们正在使用带有 Desktop 目录的图形桌面）：</p><pre><code>[me@linuxbox ~]$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt;~/Desktop/foo.ps</code></pre><p>An icon for the output file should appear on the desktop. By double-clicking the icon, a page viewer should start up and reveal the file in its rendered form:</p><p>输出文件的图标应该出现在桌面上。双击图标，页面查看器将启动，并显示渲染后的文件：</p><p>Figure 4: Viewing PostScript Output With A Page Viewer In GNOME</p><p>图4：在GNOME中使用页面查看器查看 PostScript 输出</p><p>What we see is a nicely typeset man page for ls! In fact, it’s possible to convert the Post- Script file into a PDF (Portable Document Format) file with this command:</p><p>我们看到的是一个排版很好的 ls 手册页面！事实上，可以使用以下命令将 PostScript 输出的文件转换为PDF（便携式文档格式）文件：</p><pre><code>[me@linuxbox ~]$ ps2pdf ~/Desktop/foo.ps ~/Desktop/ls.pdf</code></pre><p>The ps2pdf program is part of the ghostscript package, which is installed on most Linux systems that support printing.</p><p>ps2pdf 程序是 ghostscript 包的一部分，它安装在大多数支持打印的 Linux 系统上。</p><hr><p>Tip: Linux systems often include many command line programs for file format conversion. They are often named using the convention of format2format. Try using the command 提示：Linux 系统通常包含许多用于文件格式转换的命令行程序。它们通常以 format2format 命名。尝试使用该命令</p><pre><code>ls /usr/bin/*[[:alpha:]]2[[:alpha:]]*</code></pre><p>to identify them. Also try searching for programs named formattoformat.</p><p>去识别它们。同样也可以尝试搜索 formattoformat 程序。</p><hr><p>For our last exercise with groff, we will revisit our old friend distros.txt once more. This time, we will use the tbl program which is used to format tables to typeset our list of Linux distributions. To do this, we are going to use our earlier sed script to add markup to a text stream that we will feed to groff.</p><p>groff 的最后一个练习，将再次访问我们的老朋友 distros.txt。这一次，我们将使用能够将表格格式化的 tbl 程序，来输出 Linux 发行版本列表。为此，我们将使用早期的 sed 脚本添加一个文本流的标记，提供给 groff。</p><p>First, we need to modify our sed script to add the necessary requests that tbl requires. Using a text editor, we will change distros.sed to the following:</p><p>首先，我们需要修改我们的 sed 脚本来添加 tbl 所需的请求。 使用文本编辑器，我们将将 distros.sed 更改为以下内容：</p><pre><code># sed script to produce Linux distributions report1 i\.TS\center box;\cb s s\cb cb cb\l n c.\Linux Distributions Report\=\Name Version Released\_s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/$ a\.TE</code></pre><p>Note that for the script to work properly, care must been taken to see that the words “Name Version Released” are separated by tabs, not spaces. We’ll save the resulting file as distros-tbl.sed. tbl uses the .TS and .TE requests to start and end the table. The rows following the .TS request define global properties of the table which, for our example, are centered horizontally on the page and surrounded by a box. The remaining lines of the definition describe the layout of each table row. Now, if we run our reportgenerating pipeline again with the new sed script, we’ll get the following :</p><p>请注意，为使脚本正常工作，必须注意单词“Name Version Released”由 tab 分隔，而不是空格。 我们将生成的文件保存为 distros-tbl.sed. tbl 使用 .TS 和 .TE 请求来启动和结束表格。 .TS 请求后面的行定义了表格的全局属性，就我们的示例而言，它在页面上水平居中并含外边框。 定义的其余行描述每行的布局。现在，如果我们再次使用新的 sed 脚本运行我们新的报告生成流水线，我们将得到以下内容：</p><pre><code>[me@linuxbox ~]$ sort -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t -T ascii 2&gt;/dev/null+------------------------------+| Linux Distributions Report |+------------------------------+| Name Version Released |+------------------------------+|Fedora 5 2006-03-20 ||Fedora 6 2006-10-24 ||Fedora 7 2007-05-31 ||Fedora 8 2007-11-08 ||Fedora 9 2008-05-13 ||Fedora 10 2008-11-25 ||SUSE 10.1 2006-05-11 ||SUSE 10.2 2006-12-07 ||SUSE 10.3 2007-10-04 ||SUSE 11.0 2008-06-19 ||Ubuntu 6.06 2006-06-01 ||Ubuntu 6.10 2006-10-26 ||Ubuntu 7.04 2007-04-19 ||Ubuntu 7.10 2007-10-18 ||Ubuntu 8.04 2008-04-24 ||Ubuntu 8.10 2008-10-30 |+------------------------------+</code></pre><p>Adding the -t option to groff instructs it to pre-process the text stream with tbl. Likewise, the -T option is used to output to ASCII rather than the default output medium, PostScript.</p><p>将 -t 选项添加到 groff 指示它用 tbl 预处理文本流。同样地，-T 选项用于输出到 ASCII ，而不是默认的输出介质 PostScript。</p><p>The format of the output is the best we can expect if we are limited to the capabilities of a terminal screen or typewriter-style printer. If we specify PostScript output and graphically view the resulting output, we get a much more satisfying result:</p><p>如果仅限于终端屏幕或打字机式打印机，这样的输出格式是我们能期望的最好的。 如果我们指定 PostScript 输出并以图形方式查看生成的输出，我们将得到一个更加满意的结果：</p><pre><code>[me@linuxbox ~]$ sort -k 1,1 -k 2n distros.txt | sed -f distros-tbl.sed | groff -t &gt; ~/Desktop/foo.ps</code></pre><p>Figure 5: Viewing The Finished Table 图5：查看生成的表格</p><h3 id="Summing-Up"><a href="#Summing-Up" class="headerlink" title="Summing Up"></a>Summing Up</h3><p>Given that text is so central to the character of Unix-like operating systems, it makes sense that there would be many tools that are used to manipulate and format text. As we have seen, there are! The simple formatting tools like fmt and pr will find many uses in scripts that produce short documents, while groff (and friends) can be used to write books. We may never write a technical paper using command line tools (though there are many people who do!), but it’s good to know that we could.</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>文本是 类 Unix 系统的核心特性，一定会有许多修改和格式化文本的工具。正如我们所看到的那样，的确很多！像 fmt 和 pr 这种比较简单的格式化工具会在 生成比较短的文件时发挥很多用途，而 groff 和其他工具则会在写书的时候用上。我们也许永远不会用命令行工具来写一篇技术文章（尽管有很多人在这么做！）， 但是知道我们可以这么做也是极好的。</p><h3 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h3><ul><li><p>groff User’s Guide</p><p><a href="http://www.gnu.org/software/groff/manual/" target="_blank" rel="noopener">http://www.gnu.org/software/groff/manual/</a></p></li><li><p>Writing Papers With nroff Using -me:</p><p><a href="http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf" target="_blank" rel="noopener">http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf</a></p></li><li><p>-me Reference Manual:</p><p><a href="http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf" target="_blank" rel="noopener">http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf</a></p></li><li><p>Tbl – A Program To Format Tables:</p><p><a href="http://plan9.bell-labs.com/10thEdMan/tbl.pdf" target="_blank" rel="noopener">http://plan9.bell-labs.com/10thEdMan/tbl.pdf</a></p></li><li><p>And, of course, try the following articles at Wikipedia:</p><p><a href="http://en.wikipedia.org/wiki/TeX" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/TeX</a></p><p><a href="http://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Donald_Knuth</a></p><p><a href="http://en.wikipedia.org/wiki/Typesetting" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Typesetting</a></p></li></ul><h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><ul><li><p>groff 用户指南</p><p><a href="http://www.gnu.org/software/groff/manual/" target="_blank" rel="noopener">http://www.gnu.org/software/groff/manual/</a></p></li><li><p>运用 nroff 指令中的 -me 选项写论文:</p><p><a href="http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf" target="_blank" rel="noopener">http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf</a></p></li><li><p>-me 参考手册:</p><p><a href="http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf" target="_blank" rel="noopener">http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf</a></p></li><li><p>Tbl – 一个格式化表格的指令:</p><p><a href="http://plan9.bell-labs.com/10thEdMan/tbl.pdf" target="_blank" rel="noopener">http://plan9.bell-labs.com/10thEdMan/tbl.pdf</a></p></li><li><p>当然，你也可以试试下面列出的维基百科中的内容:</p><p><a href="http://en.wikipedia.org/wiki/TeX" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/TeX</a></p><p><a href="http://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Donald_Knuth</a></p><p><a href="http://en.wikipedia.org/wiki/Typesetting" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Typesetting</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十一章 文本处理</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>All Unix-like operating systems rely heavily on text files for several types of data storage. So it makes sense that there are many tools for manipulating text. In this chapter, we will look at programs that are used to “slice and dice” text. In the next chapter, we will look at more text processing, focusing on programs that are used to format text for printing and other kinds of human consumption.</p><p>所有类 Unix 的操作系统都严重依赖于几种数据存储类型的文本文件。所以， 有许多用于处理文本的工具就说的通了。在这一章中，我们将看一些被用来“切割”文本的程序。在下一章中， 我们将查看更多的文本处理程序，但主要集中于文本格式化输出程序和其它一些人们需要的工具。</p><p>This chapter will revisit some old friends and introduce us to some new ones:</p><p>这一章会重新拜访一些老朋友，并且会给我们介绍一些新朋友：</p><ul><li>cat – Concatenate files and print on the standard output</li><li>cat – 连接文件并且打印到标准输出</li><li>sort – Sort lines of text files</li><li>sort – 给文本行排序</li><li>uniq – Report or omit repeated lines</li><li>uniq – 报告或者省略重复行</li><li>cut – Remove sections from each line of files</li><li>cut – 从每行中删除文本区域</li><li>paste – Merge lines of files</li><li>paste – 合并文件文本行</li><li>join – Join lines of two files on a common field</li><li>join – 基于某个共享字段来联合两个文件的文本行</li><li>comm – Compare two sorted files line by line</li><li>comm – 逐行比较两个有序的文件</li><li>diff – Compare files line by line</li><li>diff – 逐行比较文件</li><li>patch – Apply a diff file to an original</li><li>patch – 给原始文件打补丁</li><li>tr – Translate or delete characters</li><li>tr – 翻译或删除字符</li><li>sed – Stream editor for filtering and transforming text</li><li>sed – 用于筛选和转换文本的流编辑器</li><li>aspell – Interactive spell checker</li><li>aspell – 交互式拼写检查器</li></ul><h3 id="文本应用程序"><a href="#文本应用程序" class="headerlink" title="文本应用程序"></a>文本应用程序</h3><p>So far, we have learned a couple of text editors (nano and vim), looked a bunch of configuration files, and have witnessed the output of dozens of commands, all in text. But what else is text used for? For many things, it turns out.</p><p>到目前为止，我们已经知道了一对文本编辑器（nano 和 vim），看过一堆配置文件，并且目睹了 许多命令的输出都是文本格式。但是文本还被用来做什么？ 它可以做很多事情。</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>Many people write documents using plain text formats. While it is easy to see how a small text file could be useful for keeping simple notes, it is also possible to write large documents in text format, as well. One popular approach is to write a large document in a text format and then use a <code>markup language</code> to describe the formatting of the finished document. Many scientific papers are written using this method, as Unix-based text processing systems were among the first systems that supported the advanced typographical layout needed by writers in technical disciplines.</p><p>许多人使用纯文本格式来编写文档。虽然很容易看到一个小的文本文件对于保存简单的笔记会 很有帮助，但是也有可能用文本格式来编写大的文档。一个流行的方法是先用文本格式来编写一个 大的文档，然后使用一种标记语言来描述已完成文档的格式。许多科学论文就是用这种方法编写的， 因为基于 Unix 的文本处理系统位于支持技术学科作家所需要的高级排版布局的一流系统之列。</p><h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h4><p>The world’s most popular type of electronic document is probably the web page. Web pages are text documents that use either HTML (Hypertext Markup Language) or XML (Extensible Markup Language) as markup languages to describe the document’s visual format.</p><p>世界上最流行的电子文档类型可能就是网页了。网页是文本文档，它们使用 HTML（超文本标记语言）或者是 XML （可扩展的标记语言）作为标记语言来描述文档的可视格式。</p><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>Email is an intrinsically text-based medium. Even non-text attachments are converted into a text representation for transmission. We can see this for ourselves by downloading an email message and then viewing it in less. We will see that the message begins with a header that describes the source of the message and the processing it received during its journey, followed by the body of the message with its content.</p><p>从本质上来说，email 是一个基于文本的媒介。为了传输，甚至非文本的附件也被转换成文本表示形式。 我们能看到这些，通过下载一个 email 信息，然后用 less 来浏览它。我们将会看到这条信息开始于一个标题， 其描述了信息的来源以及在传输过程中它接受到的处理，然后是信息的正文内容。</p><h4 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h4><p>On Unix-like systems, output destined for a printer is sent as plain text or, if the page contains graphics, is converted into a text format page description language known as PostScript, which is then sent to a program that generates the graphic dots to be printed.</p><p>在类 Unix 的系统中，输出会以纯文本格式发送到打印机，或者如果页面包含图形，其会被转换成 一种文本格式的页面描述语言，以 PostScript 著称，然后再被发送给一款能产生图形点阵的程序， 最后被打印出来。</p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><p>Many of the command line programs found on Unix-like systems were created to support system administration and software development, and text processing programs are no exception. Many of them are designed to solve software development problems. The reason text processing is important to software developers is that all software starts out as text. Source code, the part of the program the programmer actually writes, is always in text format.</p><p>在类 Unix 系统中会发现许多命令行程序被用来支持系统管理和软件开发，并且文本处理程序也不例外。 许多文本处理程序被设计用来解决软件开发问题。文本处理对于软件开发者而言至关重要是因为所有的软件 都起始于文本格式。源代码，程序员实际编写的一部分程序，总是文本格式。</p><h3 id="回顾一些老朋友"><a href="#回顾一些老朋友" class="headerlink" title="回顾一些老朋友"></a>回顾一些老朋友</h3><p>Back in Chapter 7 (Redirection), we learned about some commands that are able to accept standard input in addition to command line arguments. We only touched on them briefly then, but now we will take a closer look at how they can be used to perform text processing.</p><p>回到第7章（重定向），我们已经知道一些命令除了接受命令行参数之外，还能够接受标准输入。 那时候我们只是简单地介绍了它们，但是现在我们将仔细地看一下它们是怎样被用来执行文本处理的。</p><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>The cat program has a number of interesting options. Many of them are used to help better visualize text content. One example is the -A option, which is used to display non- printing characters in the text. There are times when we want to know if control characters are embedded in our otherwise visible text. The most common of these are tab characters (as opposed to spaces) and carriage returns, often present as end-of-line characters in MS-DOS style text files. Another common situation is a file containing lines of text with trailing spaces.</p><p>这个 cat 程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子是-A 选项， 其用来在文本中显示非打印字符。有些时候我们想知道是否控制字符嵌入到了我们的可见文本中。 最常用的控制字符是 tab 字符（而不是空格）和回车字符，在 MS-DOS 风格的文本文件中回车符经常作为 结束符出现。另一种常见情况是文件中包含末尾带有空格的文本行。</p><p>Let’s create a test file using cat as a primitive word processor. To do this, we’ll just enter the command cat (along with specifying a file for redirected output) and type our text, followed by Enter to properly end the line, then Ctrl-d, to indicate to cat that we have reached end-of-file. In this example, we enter a leading tab character and follow the line with some trailing spaces:</p><p>让我们创建一个测试文件，用 cat 程序作为一个简单的文字处理器。为此，我们将键入 cat 命令（随后指定了 用于重定向输出的文件），然后输入我们的文本，最后按下 Enter 键来结束这一行，然后按下组合键 Ctrl-d， 来指示 cat 程序，我们已经到达文件末尾了。在这个例子中，我们文本行的开头和末尾分别键入了一个 tab 字符以及一些空格。</p><pre><code>[me@linuxbox ~]$ cat &gt; foo.txt    The quick brown fox jumped over the lazy dog.[me@linuxbox ~]$</code></pre><p>Next, we will use cat with the -A option to display the text:</p><p>下一步，我们将使用带有-A 选项的 cat 命令来显示这个文本：</p><pre><code>[me@linuxbox ~]$ cat -A foo.txt^IThe quick brown fox jumped over the lazy dog.       $[me@linuxbox ~]$</code></pre><p>As we can see in the results, the tab character in our text is represented by ^I. This is a common notation that means “Control-I” which, as it turns out, is the same as a tab character. We also see that a $ appears at the true end of the line, indicating that our text contains trailing spaces.</p><p>在输出结果中我们看到，这个 tab 字符在我们的文本中由^I 字符来表示。这是一种常见的表示方法，意思是 “Control-I”，结果证明，它和 tab 字符是一样的。我们也看到一个$字符出现在文本行真正的结尾处， 表明我们的文本包含末尾的空格。</p><blockquote><p>MS-DOS Text Vs. Unix Text</p><p>MS-DOS 文本 Vs. Unix 文本</p><p>One of the reasons you may want to use cat to look for non-printing characters in text is to spot hidden carriage returns. Where do hidden carriage returns come from? DOS and Windows! Unix and DOS don’t define the end of a line the same way in text files. Unix ends a line with a linefeed character (ASCII 10) while MS-DOS and its derivatives use the sequence carriage return (ASCII 13) and linefeed to terminate each line of text.</p><p>可能你想用 cat 程序在文本中查看非打印字符的一个原因是发现隐藏的回车符。那么 隐藏的回车符来自于哪里呢？它们来自于 DOS 和 Windows！Unix 和 DOS 在文本文件中定义每行 结束的方式不相同。Unix 通过一个换行符（ASCII 10）来结束一行，然而 MS-DOS 和它的 衍生品使用回车（ASCII 13）和换行字符序列来终止每个文本行。</p><p>There are a several ways to convert files from DOS to Unix format. On many Linux systems, there are programs called dos2unix and unix2dos, which can convert text files to and from DOS format. However, if you don’t have dos2unix on your system, don’t worry. The process of converting text from DOS to Unix format is very simple; it simply involves the removal of the offending carriage returns. That is easily accomplished by a couple of the programs discussed later in this chapter.</p><p>有几种方法能够把文件从 DOS 格式转变为 Unix 格式。在许多 Linux 系统中，有两个 程序叫做 dos2unix 和 unix2dos，它们能在两种格式之间转变文本文件。然而，如果你 的系统中没有安装 dos2unix 程序，也不要担心。文件从 DOS 格式转变为 Unix 格式的过程非常 简单；它只简单地涉及到删除违规的回车符。通过随后本章中讨论的一些程序，这个工作很容易 完成。</p></blockquote><p>cat also has options that are used to modify text. The two most prominent are -n, which numbers lines, and -s, which suppresses the output of multiple blank lines. We can demonstrate thusly:</p><p>cat 程序也包含用来修改文本的选项。最著名的两个选项是-n，其给文本行添加行号和-s， 禁止输出多个空白行。我们这样来说明：</p><pre><code>[me@linuxbox ~]$ cat &gt; foo.txtThe quick brown foxjumped over the lazy dog.[me@linuxbox ~]$ cat -ns foo.txt1   The quick brown fox23   jumped over the lazy dog.[me@linuxbox ~]$</code></pre><p>In this example, we create a new version of our foo.txt test file, which contains two lines of text separated by two blank lines. After processing by cat with the -ns options, the extra blank line is removed and the remaining lines are numbered. While this is not much of a process to perform on text, it is a process.</p><p>在这个例子里，我们创建了一个测试文件 foo.txt 的新版本，其包含两行文本，由两个空白行分开。 经由带有-ns 选项的 cat 程序处理之后，多余的空白行被删除，并且对保留的文本行进行编号。 然而这并不是多个进程在操作这个文本，只有一个进程。</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>The sort program sorts the contents of standard input, or one or more files specified on the command line, and sends the results to standard output. Using the same technique that we used with cat, we can demonstrate processing of standard input directly from the keyboard:</p><p>这个 sort 程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序 结果发送到标准输出。使用与 cat 命令相同的技巧，我们能够演示如何用 sort 程序来处理标准输入：</p><pre><code>[me@linuxbox ~]$ sort &gt; foo.txtcba[me@linuxbox ~]$ cat foo.txtabc</code></pre><p>After entering the command, we type the letters “c”, “b”, and “a”, followed once again by Ctrl-d to indicate end-of-file. We then view the resulting file and see that the lines now appear in sorted order.</p><p>输入命令之后，我们键入字母“c”，“b”，和“a”，然后再按下 Ctrl-d 组合键来表示文件的结尾。 随后我们查看生成的文件，看到文本行有序地显示。</p><p>Since sort can accept multiple files on the command line as arguments, it is possible to merge multiple files into a single sorted whole. For example, if we had three text files and wanted to combine them into a single sorted file, we could do something like this:</p><p>因为 sort 程序能接受命令行中的多个文件作为参数，所以有可能把多个文件合并成一个有序的文件。例如， 如果我们有三个文本文件，想要把它们合并为一个有序的文件，我们可以这样做：</p><pre><code>sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt</code></pre><p>sort has several interesting options. Here is a partial list:</p><p>sort 程序有几个有趣的选项。这里只是一部分列表：</p><table><thead><tr><th align="left">Option</th><th align="left">Long Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">–ignore-leading-blanks</td><td align="left">By default, sorting is performed on the entire line, starting with the first character in the line. This option causes sort to ignore leading spaces in lines and calculates sorting based on the first non-whitespace character on the line.</td></tr><tr><td align="left">-f</td><td align="left">–ignore-case</td><td align="left">Makes sorting case insensitive.</td></tr><tr><td align="left">-n</td><td align="left">–numeric-sort</td><td align="left">Performs sorting based on the numeric evaluation of a string. Using this option allows sorting to be performed on numeric values rather than alphabetic values.</td></tr><tr><td align="left">-r</td><td align="left">–reverse</td><td align="left">Sort in reverse order. Results are in descending rather than ascending order.</td></tr><tr><td align="left">-k</td><td align="left">–key=field1[,field2]</td><td align="left">Sort based on a key field located from field1 to field2 rather than the entire line. See discussion below.</td></tr><tr><td align="left">-m</td><td align="left">–merge</td><td align="left">Treat each argument as the name of a presorted file. Merge multiple files into a single sorted result without performing any additional sorting.</td></tr><tr><td align="left">-o</td><td align="left">–output=file</td><td align="left">Send sorted output to file rather than standard output.</td></tr><tr><td align="left">-t</td><td align="left">–field-separator=char</td><td align="left">Define the field separator character. By default fields are separated by spaces or tabs.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">长选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">–ignore-leading-blanks</td><td align="left">默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排序。</td></tr><tr><td align="left">-f</td><td align="left">–ignore-case</td><td align="left">让排序不区分大小写。</td></tr><tr><td align="left">-n</td><td align="left">–numeric-sort</td><td align="left">基于字符串的数值来排序。使用此选项允许根据数字值执行排序，而不是字母值。</td></tr><tr><td align="left">-r</td><td align="left">–reverse</td><td align="left">按相反顺序排序。结果按照降序排列，而不是升序。</td></tr><tr><td align="left">-k</td><td align="left">–key=field1[,field2]</td><td align="left">对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的讨论。</td></tr><tr><td align="left">-m</td><td align="left">–merge</td><td align="left">把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</td></tr><tr><td align="left">-o</td><td align="left">–output=file</td><td align="left">把排好序的输出结果发送到文件，而不是标准输出。</td></tr><tr><td align="left">-t</td><td align="left">–field-separator=char</td><td align="left">定义域分隔字符。默认情况下，域由空格或制表符分隔。</td></tr></tbody></table><p>Although most of the options above are pretty self-explanatory, some are not. First, let’s look at the -n option, used for numeric sorting. With this option, it is possible to sort values based on numeric values. We can demonstrate this by sorting the results of the du command to determine the largest users of disk space. Normally, the du command lists the results of a summary in pathname order:</p><p>虽然以上大多数选项的含义是不言自喻的，但是有些也不是。首先，让我们看一下 -n 选项，被用做数值排序。 通过这个选项，有可能基于数值进行排序。我们通过对 du 命令的输出结果排序来说明这个选项，du 命令可以 确定最大的磁盘空间用户。通常，这个 du 命令列出的输出结果按照路径名来排序：</p><pre><code>[me@linuxbox ~]$ du -s /usr/share/* | head252     /usr/share/aclocal96      /usr/share/acpi-support8       /usr/share/adduser196     /usr/share/alacarte344     /usr/share/alsa8       /usr/share/alsa-base12488   /usr/share/anthy8       /usr/share/apmd21440   /usr/share/app-install48      /usr/share/application-registry</code></pre><p>In this example, we pipe the results into head to limit the results to the first ten lines. We can produce a numerically sorted list to show the ten largest consumers of space this way:</p><p>在这个例子里面，我们把结果管道到 head 命令，把输出结果限制为前 10 行。我们能够产生一个按数值排序的 列表，来显示 10 个最大的空间消费者：</p><pre><code>[me@linuxbox ~]$ du -s /usr/share/* | sort -nr | head509940         /usr/share/locale-langpack242660         /usr/share/doc197560         /usr/share/fonts179144         /usr/share/gnome146764         /usr/share/myspell144304         /usr/share/gimp135880         /usr/share/dict76508          /usr/share/icons68072          /usr/share/apps62844          /usr/share/foomatic</code></pre><p>By using the -nr options, we produce a reverse numerical sort, with the largest values appearing first in the results. This sort works because the numerical values occur at the beginning of each line. But what if we want to sort a list based on some value found within the line? For example, the results of an ls -l:</p><p>通过使用此 -nr 选项，我们产生了一个反向的数值排序，最大数值排列在第一位。这种排序起作用是 因为数值出现在每行的开头。但是如果我们想要基于文件行中的某个数值排序，又会怎样呢？ 例如，命令 ls -l 的输出结果：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin | headtotal 152948-rwxr-xr-x 1 root   root     34824  2008-04-04  02:42 [-rwxr-xr-x 1 root   root    101556  2007-11-27  06:08 a2p...</code></pre><p>Ignoring, for the moment, that ls can sort its results by size, we could use sort to sort this list by file size, as well:</p><p>此刻，忽略 ls 程序能按照文件大小对输出结果进行排序，我们也能够使用 sort 程序来完成此任务：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin | sort -nr -k 5 | head-rwxr-xr-x 1 root   root   8234216  2008-04-0717:42 inkscape-rwxr-xr-x 1 root   root   8222692  2008-04-07 17:42 inkview...</code></pre><p>Many uses of sort involve the processing of tabular data, such as the results of the ls command above. If we apply database terminology to the table above, we would say that each row is a record and that each record consists of multiple fields, such as the file attributes, link count, filename, file size and so on. sort is able to process individual fields. In database terms, we are able to specify one or more key fields to use as sort keys. In the example above, we specify the n and r options to perform a reverse numerical sort and specify -k 5 to make sort use the fifth field as the key for sorting.</p><p>sort 程序的许多用法都涉及到处理表格数据，例如上面 ls 命令的输出结果。如果我们 把数据库这个术语应用到上面的表格中，我们会说每行是一条记录，并且每条记录由多个字段组成， 例如文件属性，链接数，文件名，文件大小等等。sort 程序能够处理独立的字段。在数据库术语中， 我们能够指定一个或者多个关键字段，来作为排序的关键值。在上面的例子中，我们指定 n 和 r 选项来执行相反的数值排序，并且指定 -k 5，让 sort 程序使用第五字段作为排序的关键值。</p><p>The k option is very interesting and has many features, but first we need to talk about how sort defines fields. Let’s consider a very simple text file consisting of a single line containing the author’s name:</p><p>这个 k 选项非常有趣，而且还有很多特点，但是首先我们需要讲讲 sort 程序怎样来定义字段。 让我们考虑一个非常简单的文本文件，只有一行包含作者名字的文本。</p><pre><code>William      Shotts</code></pre><p>By default, sort sees this line as having two fields. The first field contains the characters:</p><p>默认情况下，sort 程序把此行看作有两个字段。第一个字段包含字符：</p><p>“William”</p><p>and the second field contains the characters:</p><p>和第二个字段包含字符：</p><p>“ Shotts”</p><p>meaning that whitespace characters (spaces and tabs) are used as delimiters between fields and that the delimiters are included in the field when sorting is performed. Looking again at a line from our ls output, we can see that a line contains eight fields and that the fifth field is the file size:</p><p>意味着空白字符（空格和制表符）被当作是字段间的界定符，当执行排序时，界定符会被 包含在字段当中。再看一下 ls 命令的输出，我们看到每行包含八个字段，并且第五个字段是文件大小：</p><pre><code>-rwxr-xr-x 1 root root 8234216 2008-04-07 17:42 inkscape</code></pre><p>For our next series of experiments, let’s consider the following file containing the history of three popular Linux distributions released from 2006 to 2008. Each line in the file has three fields: the distribution name, version number, and date of release in MM/DD/YYYY format:</p><p>让我们考虑用下面的文件，其包含从 2006 年到 2008 年三款流行的 Linux 发行版的发行历史，来做一系列实验。 文件中的每一行都有三个字段：发行版的名称，版本号，和 MM/DD/YYYY 格式的发行日期：</p><pre><code>SUSE        10.2   12/07/2006Fedora          10     11/25/2008SUSE            11.04  06/19/2008Ubuntu          8.04   04/24/2008Fedora          8      11/08/2007SUSE            10.3   10/04/2007...</code></pre><p>Using a text editor (perhaps vim), we’ll enter this data and name the resulting file distros.txt.</p><p>使用一个文本编辑器（可能是 vim），我们将输入这些数据，并把产生的文件命名为 distros.txt。</p><p>Next, we’ll try sorting the file and observe the results:</p><p>下一步，我们将试着对这个文件进行排序，并观察输出结果：</p><pre><code>[me@linuxbox ~]$ sort distros.txtFedora          10     11/25/2008Fedora          5     03/20/2006Fedora          6     10/24/2006Fedora          7     05/31/2007Fedora          8     11/08/2007...</code></pre><p>Well, it mostly worked. The problem occurs in the sorting of the Fedora version numbers. Since a “1” comes before a “5” in the character set, version “10” ends up at the top while version “9” falls to the bottom.</p><p>恩，大部分正确。问题出现在 Fedora 的版本号上。因为在字符集中 “1” 出现在 “5” 之前，版本号 “10” 在 最顶端，然而版本号 “9” 却掉到底端。</p><p>To fix this problem we are going to have to sort on multiple keys. We want to perform an alphabetic sort on the first field and then a numeric sort on the third field. sort allows multiple instances of the -k option so that multiple sort keys can be specified. In fact, a key may include a range of fields. If no range is specified (as has been the case with our previous examples), sort uses a key that begins with the specified field and extends to the end of the line. Here is the syntax for our multi-key sort:</p><p>为了解决这个问题，我们必须依赖多个键值来排序。我们想要对第一个字段执行字母排序，然后对 第三个字段执行数值排序。sort 程序允许多个 -k 选项的实例，所以可以指定多个排序关键值。事实上， 一个关键值可能包括一个字段区域。如果没有指定区域（如同之前的例子），sort 程序会使用一个键值， 其始于指定的字段，一直扩展到行尾。下面是多键值排序的语法：</p><pre><code>[me@linuxbox ~]$ sort --key=1,1 --key=2n distros.txtFedora         5     03/20/2006Fedora         6     10/24/2006Fedora         7     05/31/2007...</code></pre><p>Though we used the long form of the option for clarity, -k 1,1 -k 2n would be exactly equivalent. In the first instance of the key option, we specified a range of fields to include in the first key. Since we wanted to limit the sort to just the first field, we specified 1,1 which means “start at field one and end at field one.” In the second instance, we specified 2n, which means that field two is the sort key and that the sort should be numeric. An option letter may be included at the end of a key specifier to indicate the type of sort to be performed. These option letters are the same as the global options for the sort program: b (ignore leading blanks), n (numeric sort), r (reverse sort), and so on.</p><p>虽然为了清晰，我们使用了选项的长格式，但是 -k 1,1 -k 2n 格式是等价的。在第一个 key 选项的实例中， 我们指定了一个字段区域。因为我们只想对第一个字段排序，我们指定了 1,1， 意味着“始于并且结束于第一个字段。”在第二个实例中，我们指定了 2n，意味着第二个字段是排序的键值， 并且按照数值排序。一个选项字母可能被包含在一个键值说明符的末尾，其用来指定排序的种类。这些 选项字母和 sort 程序的全局选项一样：b（忽略开头的空格），n（数值排序），r（逆向排序），等等。</p><p>The third field in our list contains a date in an inconvenient format for sorting. On computers, dates are usually formatted in YYYY-MM-DD order to make chronological sorting easy, but ours are in the American format of MM/DD/YYYY. How can we sort this list in chronological order?</p><p>我们列表中第三个字段包含的日期格式不利于排序。在计算机中，日期通常设置为 YYYY-MM-DD 格式， 这样使按时间顺序排序变得容易，但是我们的日期为美国格式 MM/DD/YYYY。那么我们怎样能按照 时间顺序来排列这个列表呢？</p><p>Fortunately, sort provides a way. The key option allows specification of offsets within fields, so we can define keys within fields:</p><p>幸运地是，sort 程序提供了一种方式。这个 key 选项允许在字段中指定偏移量，所以我们能在字段中 定义键值。</p><pre><code>[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txtFedora         10    11/25/2008Ubuntu         8.10  10/30/2008SUSE           11.0  06/19/2008...</code></pre><p>By specifying -k 3.7 we instruct sort to use a sort key that begins at the seventh character within the third field, which corresponds to the start of the year. Likewise, we specify -k 3.1 and -k 3.4 to isolate the month and day portions of the date. We also add the n and r options to achieve a reverse numeric sort. The b option is included to suppress the leading spaces (whose numbers vary from line to line, thereby affecting the outcome of the sort) in the date field.</p><p>通过指定 -k 3.7，我们指示 sort 程序使用一个排序键值，其始于第三个字段中的第七个字符，对应于 年的开头。同样地，我们指定 -k 3.1和 -k 3.4来分离日期中的月和日。 我们也添加了 n 和 r 选项来实现一个逆向的数值排序。这个 b 选项用来删除日期字段中开头的空格（ 行与行之间的空格数迥异，因此会影响 sort 程序的输出结果）。</p><p>Some files don’t use tabs and spaces as field delimiters; for example, the /etc/passwd file:</p><p>一些文件不会使用 tabs 和空格做为字段界定符；例如，这个 /etc/passwd 文件：</p><pre><code>[me@linuxbox ~]$ head /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/sh</code></pre><p>The fields in this file are delimited with colons (:), so how would we sort this file using a key field? sort provides the -t option to define the field separator character. To sort the passwd file on the seventh field (the account’s default shell), we could do this:</p><p>这个文件的字段之间通过冒号分隔开，所以我们怎样使用一个 key 字段来排序这个文件？sort 程序提供 了一个 -t 选项来定义分隔符。按照第七个字段（帐户的默认 shell）来排序此 passwd 文件，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ sort -t &#39;:&#39; -k 7 /etc/passwd | headme:x:1001:1001:Myself,,,:/home/me:/bin/bashroot:x:0:0:root:/root:/bin/bashdhcp:x:101:102::/nonexistent:/bin/falsegdm:x:106:114:Gnome Display Manager:/var/lib/gdm:/bin/falsehplip:x:104:7:HPLIP system user,,,:/var/run/hplip:/bin/falseklog:x:103:104::/home/klog:/bin/falsemessagebus:x:108:119::/var/run/dbus:/bin/falsepolkituser:x:110:122:PolicyKit,,,:/var/run/PolicyKit:/bin/falsepulse:x:107:116:PulseAudio daemon,,,:/var/run/pulse:/bin/false</code></pre><p>By specifying the colon character as the field separator, we can sort on the seventh field.</p><p>通过指定冒号字符做为字段分隔符，我们能按照第七个字段来排序。</p><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>Compared to sort, the uniq program is a lightweight. uniq performs a seemingly trivial task. When given a sorted file (including standard input), it removes any duplicate lines and sends the results to standard output. It is often used in conjunction with sort to clean the output of duplicates.</p><p>与 sort 程序相比，这个 uniq 程序是个轻量级程序。uniq 执行一个看似琐碎的行为。当给定一个 排好序的文件（包括标准输出），uniq 会删除任意重复行，并且把结果发送到标准输出。 它常常和 sort 程序一块使用，来清理重复的输出。</p><hr><p>Tip: While uniq is a traditional Unix tool often used with sort, the GNU version of sort supports a -u option, which removes duplicates from the sorted output.</p><p>uniq 程序是一个传统的 Unix 工具，经常与 sort 程序一块使用，但是这个 GNU 版本的 sort 程序支持一个 -u 选项，其可以从排好序的输出结果中删除重复行。</p><hr><p>Let’s make a text file to try this out:</p><p>让我们创建一个文本文件，来实验一下：</p><pre><code>[me@linuxbox ~]$ cat &gt; foo.txtabcabc</code></pre><p>Remember to type Ctrl-d to terminate standard input. Now, if we run uniq on our text file:</p><p>记住输入 Ctrl-d 来终止标准输入。现在，如果我们对文本文件执行 uniq 命令：</p><pre><code>[me@linuxbox ~]$ uniq foo.txtabcabc</code></pre><p>the results are no different from our original file; the duplicates were not removed. For uniq to actually do its job, the input must be sorted first:</p><p>输出结果与原始文件没有差异；重复行没有被删除。实际上，uniq 程序能完成任务，其输入必须是排好序的数据，</p><pre><code>[me@linuxbox ~]$ sort foo.txt | uniqabc</code></pre><p>This is because uniq only removes duplicate lines which are adjacent to each other. uniq has several options. Here are the common ones:</p><p>这是因为 uniq 只会删除相邻的重复行。uniq 程序有几个选项。这里是一些常用选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">Output a list of duplicate lines preceded by the number of times the line occurs.</td></tr><tr><td align="left">-d</td><td align="left">Only output repeated lines, rather than unique lines.</td></tr><tr><td align="left">-f n</td><td align="left">Ignore n leading fields in each line. Fields are separated by whitespace as they are in sort; however, unlike sort, uniq has no option for setting an alternate field separator.</td></tr><tr><td align="left">-i</td><td align="left">Ignore case during the line comparisons.</td></tr><tr><td align="left">-s n</td><td align="left">Skip (ignore) the leading n characters of each line.</td></tr><tr><td align="left">-u</td><td align="left">Only output unique lines. This is the default.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">输出所有的重复行，并且每行开头显示重复的次数。</td></tr><tr><td align="left">-d</td><td align="left">只输出重复行，而不是特有的文本行。</td></tr><tr><td align="left">-f n</td><td align="left">忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。</td></tr><tr><td align="left">-i</td><td align="left">在比较文本行的时候忽略大小写。</td></tr><tr><td align="left">-s n</td><td align="left">跳过（忽略）每行开头的 n 个字符。</td></tr><tr><td align="left">-u</td><td align="left">只输出独有的文本行。这是默认的。</td></tr></tbody></table><p>Here we see uniq used to report the number of duplicates found in our text file, using the -c option:</p><p>这里我们看到 uniq 被用来报告文本文件中重复行的次数，使用这个-c 选项：</p><pre><code>[me@linuxbox ~]$ sort foo.txt | uniq -c        2 a        2 b        2 c</code></pre><h3 id="切片和切块"><a href="#切片和切块" class="headerlink" title="切片和切块"></a>切片和切块</h3><p>The next three programs we will discuss are used to peel columns of text out of files and recombine them in useful ways.</p><p>下面我们将要讨论的三个程序用来从文件中获得文本列，并且以有用的方式重组它们。</p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>The cut program is used to extract a section of text from a line and output the extracted section to standard output. It can accept multiple file arguments or input from standard input.</p><p>这个 cut 程序被用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者 标准输入。</p><p>Specifying the section of the line to be extracted is somewhat awkward and is specified using the following options:</p><p>从文本行中指定要抽取的文本有些麻烦，使用以下选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-c char_list</td><td align="left">Extract the portion of the line defined by char_list. The list may consist of one or more comma-separated numerical ranges.</td></tr><tr><td align="left">-f field_list</td><td align="left">Extract one or more fields from the line as defined by field_list. The list may contain one or more fields or field ranges separated by commas.</td></tr><tr><td align="left">-d delim_char</td><td align="left">When -f is specified, use delim_char as the field delimiting character. By default, fields must be separated by a single tab character.</td></tr><tr><td align="left">–complement</td><td align="left">Extract the entire line of text, except for those portions specified by -c and/or -f.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c char_list</td><td align="left">从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号 分隔开的数值区间组成。</td></tr><tr><td align="left">-f field_list</td><td align="left">从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能 包括一个或多个字段，或由逗号分隔开的字段区间。</td></tr><tr><td align="left">-d delim_char</td><td align="left">当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必须由单个 tab 字符分隔开。</td></tr><tr><td align="left">–complement</td><td align="left">抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</td></tr></tbody></table><p>As we can see, the way cut extracts text is rather inflexible. cut is best used to extract text from files that are produced by other programs, rather than text directly typed by humans. We’ll take a look at our distros.txt file to see if it is “clean” enough to be a good specimen for our cut examples. If we use cat with the -A option, we can see if the file meets our requirements of tab separated fields:</p><p>正如我们所看到的，cut 程序抽取文本的方式相当不灵活。cut 命令最好用来从其它程序产生的文件中 抽取文本，而不是从人们直接输入的文本中抽取。我们将会看一下我们的 distros.txt 文件，看看 是否它足够 “整齐” 成为 cut 实例的一个好样本。如果我们使用带有 -A 选项的 cat 命令，我们能查看是否这个 文件符号由 tab 字符分离字段的要求。</p><pre><code>[me@linuxbox ~]$ cat -A distros.txtSUSE^I10.2^I12/07/2006$Fedora^I10^I11/25/2008$SUSE^I11.0^I06/19/2008$Ubuntu^I8.04^I04/24/2008$Fedora^I8^I11/08/2007$SUSE^I10.3^I10/04/2007$Ubuntu^I6.10^I10/26/2006$Fedora^I7^I05/31/2007$Ubuntu^I7.10^I10/18/2007$Ubuntu^I7.04^I04/19/2007$SUSE^I10.1^I05/11/2006$Fedora^I6^I10/24/2006$Fedora^I9^I05/13/2008$Ubuntu^I6.06^I06/01/2006$Ubuntu^I8.10^I10/30/2008$Fedora^I5^I03/20/2006$</code></pre><p>It looks good. No embedded spaces, just single tab characters between the fields. Since the file uses tabs rather than spaces, we’ll use the -f option to extract a field:</p><p>看起来不错。字段之间仅仅是单个 tab 字符，没有嵌入空格。因为这个文件使用了 tab 而不是空格， 我们将使用 -f 选项来抽取一个字段：</p><pre><code>[me@linuxbox ~]$ cut -f 3 distros.txt12/07/200611/25/200806/19/200804/24/200811/08/200710/04/200710/26/200605/31/200710/18/200704/19/200705/11/200610/24/200605/13/200806/01/200610/30/200803/20/2006</code></pre><p>Because our distros file is tab-delimited, it is best to use cut to extract fields rather than characters. This is because when a file is tab-delimited, it is unlikely that each line will contain the same number of characters, which makes calculating character positions within the line difficult or impossible. In our example above, however, we now have extracted a field that luckily contains data of identical length, so we can show how character extraction works by extracting the year from each line:</p><p>因为我们的 distros 文件是由 tab 分隔开的，最好用 cut 来抽取字段而不是字符。这是因为一个由 tab 分离的文件， 每行不太可能包含相同的字符数，这就使计算每行中字符的位置变得困难或者是不可能。在以上事例中，然而， 我们已经抽取了一个字段，幸运地是其包含地日期长度相同，所以通过从每行中抽取年份，我们能展示怎样 来抽取字符：</p><pre><code>[me@linuxbox ~]$ cut -f 3 distros.txt | cut -c 7-102006200820082008200720072006200720072007200620062008200620082006</code></pre><p>By running cut a second time on our list, we are able to extract character positions 7 through 10, which corresponds to the year in our date field. The 7-10 notation is an example of a range. The cut man page contains a complete description of how ranges can be specified.</p><p>通过对我们的列表再次运行 cut 命令，我们能够抽取从位置7到10的字符，其对应于日期字段的年份。 这个 7-10 表示法是一个区间的例子。cut 命令手册包含了一个如何指定区间的完整描述。</p><blockquote><p>Expanding Tabs</p><p>展开 Tabs</p><p>Our distros.txt file is ideally formatted for extracting fields using cut. But what if we wanted a file that could be fully manipulated with cut by characters, rather than fields? This would require us to replace the tab characters within the file with the corresponding number of spaces. Fortunately, the GNU Coreutils package includes a tool for that. Named expand, this program accepts either one or more file arguments or standard input, and outputs the modified text to standard output.</p><p>distros.txt 的文件格式很适合使用 cut 程序来抽取字段。但是如果我们想要 cut 程序 按照字符，而不是字段来操作一个文件，那又怎样呢？这要求我们用相应数目的空格来 代替 tab 字符。幸运地是，GNU 的 Coreutils 软件包有一个工具来解决这个问题。这个 程序名为 expand，它既可以接受一个或多个文件参数，也可以接受标准输入，并且把 修改过的文本送到标准输出。</p><p>If we process our distros.txt file with expand, we can use the cut -c to extract any range of characters from the file. For example, we could use the following command to extract the year of release from our list, by expanding the file and using cut to extract every character from the twenty-third position to the end of the line:</p><p>如果我们通过 expand 来处理 distros.txt 文件，我们能够使用 cut -c 命令来从文件中抽取 任意区间内的字符。例如，我们能够使用以下命令来从列表中抽取发行年份，通过展开 此文件，再使用 cut 命令，来抽取从位置 23 开始到行尾的每一个字符：</p><p><em>[me@linuxbox ~]$ expand distros.txt | cut -c 23-</em></p><p>Coreutils also provides the unexpand program to substitute tabs for spaces.</p><p>Coreutils 软件包也提供了 unexpand 程序，用 tab 来代替空格。</p></blockquote><p>When working with fields, it is possible to specify a different field delimiter rather than the tab character. Here we will extract the first field from the /etc/passwd file:</p><p>当操作字段的时候，有可能指定不同的字段分隔符，而不是 tab 字符。这里我们将会从/etc/passwd 文件中 抽取第一个字段：</p><pre><code>[me@linuxbox ~]$ cut -d &#39;:&#39; -f 1 /etc/passwd | headrootdaemonbinsyssyncgamesmanlpmailnews</code></pre><p>Using the -d option, we are able to specify the colon character as the field delimiter.</p><p>使用-d 选项，我们能够指定冒号做为字段分隔符。</p><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>The paste command does the opposite of cut. Rather than extracting a column of text from a file, it adds one or more columns of text to a file. It does this by reading multiple files and combining the fields found in each file into a single stream on standard output. Like cut, paste accepts multiple file arguments and/or standard input. To demonstrate how paste operates, we will perform some surgery on our distros.txt file to produce a chronological list of releases.</p><p>这个 paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。 它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。类似于 cut 命令， paste 接受多个文件参数和 ／ 或标准输入。为了说明 paste 是怎样工作的，我们将会对 distros.txt 文件 动手术，来产生发行版的年代表。</p><p>From our earlier work with sort, we will first produce a list of distros sorted by date and store the result in a file called distros-by-date.txt:</p><p>从我们之前使用 sort 的工作中，首先我们将产生一个按照日期排序的发行版列表，并把结果 存储在一个叫做 distros-by-date.txt 的文件中：</p><pre><code>[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt &gt; distros-by-date.txt</code></pre><p>Next, we will use cut to extract the first two fields from the file (the distro name and version), and store that result in a file named distro-versions.txt:</p><p>下一步，我们将会使用 cut 命令从文件中抽取前两个字段（发行版名字和版本号），并把结果存储到 一个名为 distro-versions.txt 的文件中：</p><pre><code>[me@linuxbox ~]$ cut -f 1,2 distros-by-date.txt &gt; distros-versions.txt[me@linuxbox ~]$ head distros-versions.txtFedora     10Ubuntu     8.10SUSE       11.0Fedora     9Ubuntu     8.04Fedora     8Ubuntu     7.10SUSE       10.3Fedora     7Ubuntu     7.04</code></pre><p>The final piece of preparation is to extract the release dates and store them a file named distro-dates.txt:</p><p>最后的准备步骤是抽取发行日期，并把它们存储到一个名为 distro-dates.txt 文件中：</p><pre><code>[me@linuxbox ~]$ cut -f 3 distros-by-date.txt &gt; distros-dates.txt[me@linuxbox ~]$ head distros-dates.txt11/25/200810/30/200806/19/200805/13/200804/24/200811/08/200710/18/200710/04/200705/31/200704/19/2007</code></pre><p>We now have the parts we need. To complete the process, use paste to put the column of dates ahead of the distro names and versions, thus creating a chronological list. This is done simply by using paste and ordering its arguments in the desired arrangement:</p><p>现在我们拥有了我们所需要的文本了。为了完成这个过程，使用 paste 命令来把日期列放到发行版名字 和版本号的前面，这样就创建了一个年代列表。通过使用 paste 命令，然后按照期望的顺序来安排它的 参数，就能很容易完成这个任务。</p><pre><code>[me@linuxbox ~]$ paste distros-dates.txt distros-versions.txt11/25/2008    Fedora     1010/30/2008    Ubuntu     8.1006/19/2008    SUSE       11.005/13/2008    Fedora     904/24/2008    Ubuntu     8.0411/08/2007    Fedora     810/18/2007    Ubuntu     7.1010/04/2007    SUSE       10.305/31/2007    Fedora     704/19/2007    Ubuntu     7.04</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>In some ways, join is like paste in that it adds columns to a file, but it uses a unique way to do it. A join is an operation usually associated with relational databases where data from multiple tables with a shared key field is combined to form a desired result. The join program performs the same operation. It joins data from multiple files based on a shared key field.</p><p>在某些方面，join 命令类似于 paste，它会往文件中添加列，但是它使用了独特的方法来完成。 一个 join 操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的 数据结合起来，得到一个期望的结果。这个 join 程序执行相同的操作。它把来自于多个基于共享 关键域的文件的数据结合起来。</p><p>To see how a join operation is used in a relational database, let’s imagine a very small database consisting of two tables each containing a single record. The first table, called CUSTOMERS, has three fields: a customer number (CUSTNUM), the customer’s first name (FNAME) and the customer’s last name (LNAME):</p><p>为了知道在关系数据库中是怎样使用 join 操作的，让我们想象一个很小的数据库，这个数据库由两个 表格组成，每个表格包含一条记录。第一个表格，叫做 CUSTOMERS，有三个数据域：一个客户号（CUSTNUM）， 客户的名字（FNAME）和客户的姓（LNAME）：</p><pre><code>CUSTNUM        FNAME       ME========    =====       ======4681934        John        Smith</code></pre><p>The second table is called ORDERS and contains four fields: an order number (ORDERNUM), the customer number (CUSTNUM), the quantity (QUAN), and the item ordered (ITEM).</p><p>第二个表格叫做 ORDERS，其包含四个数据域：订单号（ORDERNUM），客户号（CUSTNUM），数量（QUAN）， 和订购的货品（ITEM）。</p><pre><code>ORDERNUM        CUSTNUM     QUAN ITEM========        =======     ==== ====3014953305      4681934     1    Blue Widget</code></pre><p>Note that both tables share the field CUSTNUM. This is important, as it allows a relationship between the tables.</p><p>注意两个表格共享数据域 CUSTNUM。这很重要，因为它使表格之间建立了联系。</p><p>Performing a join operation would allow us to combine the fields in the two tables to achieve a useful result, such as preparing an invoice. Using the matching values in the CUSTNUM fields of both tables, a join operation could produce the following:</p><p>执行一个 join 操作将允许我们把两个表格中的数据域结合起来，得到一个有用的结果，例如准备 一张发货单。通过使用两个表格 CUSTNUM 数字域中匹配的数值，一个 join 操作会产生以下结果：</p><pre><code>FNAME       LNAME       QUAN ITEM=====       =====       ==== ====John        Smith       1    Blue Widget</code></pre><p>To demonstrate the join program, we’ll need to make a couple of files with a shared key. To do this, we will use our distros-by-date.txt file. From this file, we will construct two additional files, one containing the release date (which will be our shared key for this demonstration) and the release name:</p><p>为了说明 join 程序，我们需要创建一对包含共享键值的文件。为此，我们将使用我们的 distros.txt 文件。 从这个文件中，我们将构建额外两个文件，一个包含发行日期（其会成为共享键值）和发行版名称：</p><pre><code>[me@linuxbox ~]$ cut -f 1,1 distros-by-date.txt &gt; distros-names.txt[me@linuxbox ~]$ paste distros-dates.txt distros-names.txt &gt; distros-key-names.txt[me@linuxbox ~]$ head distros-key-names.txt11/25/2008 Fedora10/30/2008 Ubuntu06/19/2008 SUSE05/13/2008 Fedora04/24/2008 Ubuntu11/08/2007 Fedora10/18/2007 Ubuntu10/04/2007 SUSE05/31/2007 Fedora04/19/2007 Ubuntu</code></pre><p>and the second file, which contains the release dates and the version numbers:</p><p>第二个文件包含发行日期和版本号：</p><pre><code>[me@linuxbox ~]$ cut -f 2,2 distros-by-date.txt &gt; distros-vernums.txt[me@linuxbox ~]$ paste distros-dates.txt distros-vernums.txt &gt; distros-key-vernums.txt[me@linuxbox ~]$ head distros-key-vernums.txt11/25/2008 1010/30/2008 8.1006/19/2008 11.005/13/2008 904/24/2008 8.0411/08/2007 810/18/2007 7.1010/04/2007 10.305/31/2007 704/19/2007 7.04</code></pre><p>We now have two files with a shared key (the “release date” field). It is important to point out that the files must be sorted on the key field for join to work properly.</p><p>现在我们有两个具有共享键值（ “发行日期” 数据域 ）的文件。有必要指出，为了使 join 命令 能正常工作，所有文件必须按照关键数据域排序。</p><pre><code>[me@linuxbox ~]$ join distros-key-names.txt distros-key-vernums.txt | head11/25/2008 Fedora 1010/30/2008 Ubuntu 8.1006/19/2008 SUSE 11.005/13/2008 Fedora 904/24/2008 Ubuntu 8.0411/08/2007 Fedora 810/18/2007 Ubuntu 7.1010/04/2007 SUSE 10.305/31/2007 Fedora 704/19/2007 Ubuntu 7.04</code></pre><p>Note also that, by default, join uses whitespace as the input field delimiter and a single space as the output field delimiter. This behavior can be modified by specifying options. See the join man page for details.</p><p>也要注意，默认情况下，join 命令使用空白字符做为输入字段的界定符，一个空格作为输出字段 的界定符。这种行为可以通过指定的选项来修改。详细信息，参考 join 命令手册。</p><h3 id="比较文本"><a href="#比较文本" class="headerlink" title="比较文本"></a>比较文本</h3><p>It is often useful to compare versions of text files. For system administrators and software developers, this is particularly important. A system administrator may, for example, need to compare an existing configuration file to a previous version to diagnose a system problem. Likewise, a programmer frequently needs to see what changes have been made to programs over time.</p><p>通常比较文本文件的版本很有帮助。对于系统管理员和软件开发者来说，这个尤为重要。 一名系统管理员可能，例如，需要拿现有的配置文件与先前的版本做比较，来诊断一个系统错误。 同样的，一名程序员经常需要查看程序的修改。</p><h4 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h4><p>The comm program compares two text files and displays the lines that are unique to each one and the lines they have in common. To demonstrate, we will create two nearly identical text files using cat:</p><p>这个 comm 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文把行。 为了说明问题，通过使用 cat 命令，我们将会创建两个内容几乎相同的文本文件：</p><pre><code>[me@linuxbox ~]$ cat &gt; file1.txtabcd[me@linuxbox ~]$ cat &gt; file2.txtbcde</code></pre><p>Next, we will compare the two files using comm:</p><p>下一步，我们将使用 comm 命令来比较这两个文件：</p><pre><code>[me@linuxbox ~]$ comm file1.txt file2.txta        b        c        d    e</code></pre><p>As we can see, comm produces three columns of output. The first column contains lines unique to the first file argument; the second column, the lines unique to the second file argument; the third column contains the lines shared by both files. comm supports options in the form -n where n is either 1, 2 or 3. When used, these options specify which column(s) to suppress. For example, if we only wanted to output the lines shared by both files, we would suppress the output of columns one and two:</p><p>正如我们所见到的，comm 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列， 文本行是第二列独有的；第三列包含两个文件共有的文本行。comm 支持 -n 形式的选项，这里 n 代表 1，2 或 3。这些选项使用的时候，指定了要隐藏的列。例如，如果我们只想输出两个文件共享的文本行， 我们将隐藏第一列和第二列的输出结果：</p><pre><code>[me@linuxbox ~]$ comm -12 file1.txt file2.txtbcd</code></pre><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>Like the comm program, diff is used to detect the differences between files. However, diff is a much more complex tool, supporting many output formats and the ability to process large collections of text files at once. diff is often used by software developers to examine changes between different versions of program source code, and thus has the ability to recursively examine directories of source code often referred to as source trees. One common use for diff is the creation of diff files or patches that are used by programs such as patch (which we’ll discuss shortly) to convert one version of a file (or files) to another version.</p><p>类似于 comm 程序，diff 程序被用来监测文件之间的差异。然而，diff 是一款更加复杂的工具，它支持 许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 diff 程序来检查不同程序源码 版本之间的更改，diff 能够递归地检查源码目录，经常称之为源码树。diff 程序的一个常见用例是 创建 diff 文件或者补丁，它会被其它程序使用，例如 patch 程序（我们一会儿讨论），来把文件 从一个版本转换为另一个版本。</p><p>If we use diff to look at our previous example files:</p><p>如果我们使用 diff 程序，来查看我们之前的文件实例：</p><pre><code>[me@linuxbox ~]$ diff file1.txt file2.txt1d0&lt; a4a4&gt; e</code></pre><p>we see its default style of output: a terse description of the differences between the two files. In the default format, each group of changes is preceded by a change command in the form of <em>range operation range</em> to describe the positions and type of changes required to convert the first file to the second file:</p><p>我们看到 diff 程序的默认输出风格：对两个文件之间差异的简短描述。在默认格式中， 每组的更改之前都是一个更改命令，其形式为 <em>range operation range</em> ， 用来描述要求更改的位置和类型，从而把第一个文件转变为第二个文件：</p><table><thead><tr><th align="left">Change</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">r1ar2</td><td align="left">Append the lines at the position r2 in the second file to the position r1 in the first file.</td></tr><tr><td align="left">r1cr2</td><td align="left">Change (replace) the lines at position r1 with the lines at the position r2 in the second file.</td></tr><tr><td align="left">r1dr2</td><td align="left">Delete the lines in the first file at position r1, which would have appeared at range r2 in the second file.</td></tr></tbody></table><table><thead><tr><th align="left">改变</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">r1ar2</td><td align="left">把第二个文件中位置 r2 处的文件行添加到第一个文件中的 r1 处。</td></tr><tr><td align="left">r1cr2</td><td align="left">用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。</td></tr><tr><td align="left">r1dr2</td><td align="left">删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。</td></tr></tbody></table><p>In this format, a range is a comma separated list of the starting line and the ending line. While this format is the default (mostly for POSIX compliance and backward compatibility with traditional Unix versions of diff), it is not as widely used as other, optional formats. Two of the more popular formats are the <em>context format</em> and the <em>unified format</em>.</p><p>在这种格式中，一个范围就是由逗号分隔开的开头行和结束行的列表。虽然这种格式是默认情况（主要是 为了服从 POSIX 标准且向后与传统的 Unix diff 命令兼容）， 但是它并不像其它可选格式一样被广泛地使用。最流行的两种格式是上下文模式和统一模式。</p><p>When viewed using the <em>context format</em> (the -c option), we will see this:</p><p>当使用上下文模式（带上 -c 选项），我们将看到这些：</p><pre><code>[me@linuxbox ~]$ diff -c file1.txt file2.txt*** file1.txt    2008-12-23 06:40:13.000000000 -0500--- file2.txt   2008-12-23 06:40:34.000000000 -0500****************** 1,4 ****- a  b  c  d--- 1,4 ----  b  c  d  + e</code></pre><p>The output begins with the names of the two files and their timestamps. The first file is marked with asterisks and the second file is marked with dashes. Throughout the remainder of the listing, these markers will signify their respective files. Next, we see groups of changes, including the default number of surrounding context lines. In the first group, we see:</p><p>这个输出结果以两个文件名和它们的时间戳开头。第一个文件用星号做标记，第二个文件用短横线做标记。 纵观列表的其它部分，这些标记将象征它们各自代表的文件。下一步，我们看到几组修改， 包括默认的周围上下文行数。在第一组中，我们看到：</p><pre><code>*** 1,4 ***</code></pre><p>which indicates lines one through four in the first file. Later we see:</p><p>其表示第一个文件中从第一行到第四行的文本行。随后我们看到：</p><pre><code>--- 1,4 ---</code></pre><p>which indicates lines one through four in the second file. Within a change group, lines begin with one of four indicators:</p><p>这表示第二个文件中从第一行到第四行的文本行。在更改组内，文本行以四个指示符之一开头：</p><table><thead><tr><th align="left">Indicator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">blank</td><td align="left">A line shown for context. It does not indicate a difference between the two files.</td></tr><tr><td align="left">-</td><td align="left">A line deleted. This line will appear in the first file but not in the second file.</td></tr><tr><td align="left">+</td><td align="left">A line added. This line will appear in the second file but not in the first file.</td></tr><tr><td align="left">!</td><td align="left">A line changed. The two versions of the line will be displayed, each in its respective section of the change group.</td></tr></tbody></table><table><thead><tr><th align="left">指示符</th><th align="left">意思</th></tr></thead><tbody><tr><td align="left">blank</td><td align="left">上下文显示行。它并不表示两个文件之间的差异。</td></tr><tr><td align="left">-</td><td align="left">删除行。这一行将会出现在第一个文件中，而不是第二个文件内。</td></tr><tr><td align="left">+</td><td align="left">添加行。这一行将会出现在第二个文件内，而不是第一个文件中。</td></tr><tr><td align="left">!</td><td align="left">更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。</td></tr></tbody></table><p>The <em>unified format</em> is similar to the <em>context format</em>, but is more concise. It is specified with the -u option:</p><p>这个统一模式相似于上下文模式，但是更加简洁。通过 -u 选项来指定它：</p><pre><code>[me@linuxbox ~]$ diff -u file1.txt file2.txt--- file1.txt 2008-12-23 06:40:13.000000000 -0500+++ file2.txt 2008-12-23 06:40:34.000000000 -0500@@ -1,4 +1,4 @@-a b c d+e</code></pre><p>The most notable difference between the context and unified formats is the elimination of the duplicated lines of context, making the results of the unified format shorter than the context format. In our example above, we see file timestamps like those of the context format, followed by the string @@ -1,4 +1,4 @@. This indicates the lines in the first file and the lines in the second file described in the change group. Following this are the lines themselves, with the default three lines of context. Each line starts with one of three possible characters:</p><p>上下文模式和统一模式之间最显著的差异就是重复上下文的消除，这就使得统一模式的输出结果要比上下文 模式的输出结果简短。在我们上述实例中，我们看到类似于上下文模式中的文件时间戳，其紧紧跟随字符串 @@ -1,4 +1,4 @@。这行字符串表示了在更改组中描述的第一个文件中的文本行和第二个文件中的文本行。 这行字符串之后就是文本行本身，与三行默认的上下文。每行以可能的三个字符中的一个开头：</p><table><thead><tr><th align="left">Character</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">blank</td><td align="left">This line is shared by both files.</td></tr><tr><td align="left">-</td><td align="left">This line was removed from the first file.</td></tr><tr><td align="left">+</td><td align="left">This line was added to the first file.</td></tr></tbody></table><table><thead><tr><th align="left">字符</th><th align="left">意思</th></tr></thead><tbody><tr><td align="left">空格</td><td align="left">两个文件都包含这一行。</td></tr><tr><td align="left">-</td><td align="left">在第一个文件中删除这一行。</td></tr><tr><td align="left">+</td><td align="left">添加这一行到第一个文件中。</td></tr></tbody></table><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>The patch program is used to apply changes to text files. It accepts output from diff and is generally used to convert older version of files into newer versions. Let’s consider a famous example. The Linux kernel is developed by a large, loosely organized team of contributors who submit a constant stream of small changes to the source code. The Linux kernel consists of several million lines of code, while the changes that are made by one contributor at one time are quite small. It makes no sense for a contributor to send each developer an entire kernel source tree each time a small change is made. Instead, a diff file is submitted. The diff file contains the change from the previous version of the kernel to the new version with the contributor’s changes. The receiver then uses the patch program to apply the change to his own source tree. Using diff/patch offers two significant advantages:</p><p>这个 patch 程序被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来 把较老的文件版本转变为较新的文件版本。让我们考虑一个著名的例子。Linux 内核是由一个 大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。 这个 Linux 内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者 来说，每做一个修改就给每个开发者发送整个的内核源码树，这是没有任何意义的。相反， 提交一个 diff 文件。一个 diff 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。 然后一个接受者使用 patch 程序，把这些更改应用到他自己的源码树中。使用 diff/patch 组合提供了 两个重大优点：</p><ol><li>The diff file is very small, compared to the full size of the source tree.</li><li>The diff file concisely shows the change being made, allowing reviewers of the patch to quickly evaluate it.</li><li>一个 diff 文件非常小，与整个源码树的大小相比较而言。</li><li>一个 diff 文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估它。</li></ol><p>Of course, diff/patch will work on any text file, not just source code. It would be equally applicable to configuration files or any other text.</p><p>当然，diff/patch 能工作于任何文本文件，不仅仅是源码文件。它同样适用于配置文件或任意其它文本。</p><p>To prepare a diff file for use with patch, the GNU documentation (see Further Reading below) suggests using diff as follows:</p><p>准备一个 diff 文件供 patch 程序使用，GNU 文档（查看下面的拓展阅读部分）建议这样使用 diff 命令：</p><pre><code>diff -Naur old_file new_file &gt; diff_file</code></pre><p>Where old_file and new_file are either single files or directories containing files. The r option supports recursion of a directory tree.</p><p>old_file 和 new_file 部分不是单个文件就是包含文件的目录。这个 r 选项支持递归目录树。</p><p>Once the diff file has been created, we can apply it to patch the old file into the new file:</p><p>一旦创建了 diff 文件，我们就能应用它，把旧文件修补成新文件。</p><pre><code>patch &lt; diff_file</code></pre><p>We’ll demonstrate with our test file:</p><p>我们将使用测试文件来说明：</p><pre><code>[me@linuxbox ~]$ diff -Naur file1.txt file2.txt &gt; patchfile.txt[me@linuxbox ~]$ patch &lt; patchfile.txtpatching file file1.txt[me@linuxbox ~]$ cat file1.txtbcde</code></pre><p>In this example, we created a diff file named patchfile.txt and then used the patch program to apply the patch. Note that we did not have to specify a target file to patch, as the diff file (in unified format) already contains the filenames in the header. Once the patch is applied, we can see that file1.txt now matches file2.txt.</p><p>在这个例子中，我们创建了一个名为 patchfile.txt 的 diff 文件，然后使用 patch 程序， 来应用这个补丁。注意我们没有必要指定一个要修补的目标文件，因为 diff 文件（在统一模式中）已经 在标题行中包含了文件名。一旦应用了补丁，我们能看到，现在 file1.txt 与 file2.txt 文件相匹配了。</p><p>patch has a large number of options, and there are additional utility programs that can be used to analyze and edit patches.</p><p>patch 程序有大量的选项，而且还有额外的实用程序可以被用来分析和编辑补丁。</p><h3 id="运行时编辑"><a href="#运行时编辑" class="headerlink" title="运行时编辑"></a>运行时编辑</h3><p>Our experience with text editors has been largely interactive, meaning that we manually move a cursor around, then type our changes. However, there are non-interactive ways to edit text as well. It’s possible, for example, to apply a set of changes to multiple files with a single command.</p><p>我们对于文本编辑器的经验是它们主要是交互式的，意思是我们手动移动光标，然后输入我们的修改。 然而，也有非交互式的方法来编辑文本。有可能，例如，通过单个命令把一系列修改应用到多个文件中。</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>The tr program is used to transliterate characters. We can think of this as a sort of character-based search-and-replace operation. Transliteration is the process of changing characters from one alphabet to another. For example, converting characters from lowercase to uppercase is transliteration. We can perform such a conversion with tr as follows:</p><p>这个 tr 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。 换字是一种把字符从一个字母转换为另一个字母的过程。例如，把小写字母转换成大写字母就是 换字。我们可以通过 tr 命令来执行这样的转换，如下所示：</p><pre><code>[me@linuxbox ~]$ echo &quot;lowercase letters&quot; | tr a-z A-ZLOWERCASE LETTERS</code></pre><p>As we can see, tr operates on standard input, and outputs its results on standard output. tr accepts two arguments: a set of characters to convert from and a corresponding set of characters to convert to. Character sets may be expressed in one of three ways:</p><p>正如我们所见，tr 命令操作标准输入，并把结果输出到标准输出。tr 命令接受两个参数：要被转换的字符集以及 相对应的转换后的字符集。字符集可以用三种方式来表示：</p><ol><li>An enumerated list. For example, ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>A character range. For example, A-Z. Note that this method is sometimes subject to the same issues as other commands, due to the locale collation order, and thus should be used with caution.</li><li>POSIX character classes. For example, [:upper:].</li><li>一个枚举列表。例如， ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>一个字符域。例如，A-Z 。注意这种方法有时候面临与其它命令相同的问题，归因于 语系的排序规则，因此应该谨慎使用。</li><li>POSIX 字符类。例如，[:upper:]</li></ol><p>In most cases, both character sets should be of equal length; however, it is possible for the first set to be larger than the second, particularly if we wish to convert multiple characters to a single character:</p><p>大多数情况下，两个字符集应该长度相同；然而，有可能第一个集合大于第二个，尤其如果我们 想要把多个字符转换为单个字符：</p><pre><code>[me@linuxbox ~]$ echo &quot;lowercase letters&quot; | tr [:lower:] AAAAAAAAAA AAAAAAA</code></pre><p>In addition to transliteration, tr allows characters to simply be deleted from the input stream. Earlier in this chapter, we discussed the problem of converting MS-DOS text files to Unix style text. To perform this conversion, carriage return characters need to be removed from the end of each line. This can be performed with tr as follows:</p><p>除了换字之外，tr 命令能允许字符从输入流中简单地被删除。在之前的章节中，我们讨论了转换 MS-DOS 文本文件为 Unix 风格文本的问题。为了执行这个转换，每行末尾的回车符需要被删除。 这个可以通过 tr 命令来执行，如下所示：</p><pre><code>tr -d &#39;\r&#39; &lt; dos_file &gt; unix_file</code></pre><p>where dos_file is the file to be converted and unix_file is the result. This form of the command uses the escape sequence \r to represent the carriage return character. To see a complete list of the sequences and character classes tr supports, try:</p><p>这里的 dos_file 是需要被转换的文件，unix_file 是转换后的结果。这种形式的命令使用转义序列 \r 来代表回车符。查看 tr 命令所支持地完整的转义序列和字符类别列表，试试下面的命令：</p><pre><code>[me@linuxbox ~]$ tr --help</code></pre><blockquote><p>ROT13: The Not-So-Secret Decoder Ring</p><p>ROT13: 不那么秘密的编码环</p><p>One amusing use of tr is to perform ROT13 encoding of text. ROT13 is a trivial type of encryption based on a simple substitution cipher. Calling ROT13 “encryption” is being generous; “text obfuscation” is more accurate. It is used sometimes on text to obscure potentially offensive content. The method simply moves each character thirteen places up the alphabet. Since this is half way up the possible twenty-six characters, performing the algorithm a second time on the text restores it to its original form. To perform this encoding with tr:</p><p>tr 命令的一个有趣的用法是执行 ROT13文本编码。ROT13是一款微不足道的基于一种简易的替换暗码的 加密类型。把 ROT13称为“加密”是过誉了；称其为“文本模糊处理”则更准确些。有时候它被用来隐藏文本中潜在的攻击内容。 这个方法就是简单地把每个字符在字母表中向前移动13位。因为移动的位数是可能的26个字符的一半， 所以对文本再次执行这个算法，就恢复到了它最初的形式。通过 tr 命令来执行这种编码：</p><table><thead><tr><th>echo “secret text”</th><th>tr a-zA-Z n-za-mN-ZA-M</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>frperg grkg</p><p>Performing the same procedure a second time results in the translation:</p><p>再次执行相同的过程，得到翻译结果：</p><table><thead><tr><th>echo “frperg grkg”</th><th>tr a-zA-Z n-za-mN-ZA-M</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>secret text</p><p>A number of email programs and USENET news readers support ROT13 encoding. Wikipedia contains a good article on the subject:</p><p>大量的 email 程序和 USENET 新闻读者都支持 ROT13 编码。Wikipedia 上面有一篇关于这个主题的好文章：</p><p><a href="http://en.wikipedia.org/wiki/ROT13" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/ROT13</a></p></blockquote><p>tr can perform another trick, too. Using the -s option, tr can “squeeze” (delete) repeated instances of a character:</p><p>tr 也可以完成另一个技巧。使用-s 选项，tr 命令能“挤压”（删除）重复的字符实例：</p><pre><code>[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | tr -s ababccc</code></pre><p>Here we have a string containing repeated characters. By specifying the set “ab” to tr, we eliminate the repeated instances of the letters in the set, while leaving the character that is missing from the set (“c”) unchanged. Note that the repeating characters must be adjoining. If they are not:</p><p>这里我们有一个包含重复字符的字符串。通过给 tr 命令指定字符集“ab”，我们能够消除字符集中 字母的重复实例，然而会留下不属于字符集的字符（“c”）无更改。注意重复的字符必须是相邻的。 如果它们不相邻：</p><pre><code>[me@linuxbox ~]$ echo &quot;abcabcabc&quot; | tr -s ababcabcabc</code></pre><p>the squeezing will have no effect.</p><p>那么挤压会没有效果。</p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>The name sed is short for stream editor. It performs text editing on a stream of text, either a set of specified files or standard input. sed is a powerful and somewhat complex program (there are entire books about it), so we will not cover it completely here.</p><p>名字 sed 是 stream editor（流编辑器）的简称。它对文本流，即一系列指定的文件或标准输入进行编辑。sed 是一款强大的，并且有些复杂的程序（有整本内容都是关于 sed 程序的书籍），所以在这里我们不会详尽的讨论它。</p><p>In general, the way that sed works is that it is given either a single editing command (on the command line) or the name of a script file containing multiple commands, and it then performs these commands upon each line in the stream of text. Here is a very simple example of sed in action:</p><p>总之，sed 的工作方式是要不给出单个编辑命令（在命令行中）要不就是包含多个命令的脚本文件名， 然后它就按行来执行这些命令。这里有一个非常简单的 sed 实例：</p><pre><code>[me@linuxbox ~]$ echo &quot;front&quot; | sed &#39;s/front/back/&#39;back</code></pre><p>In this example, we produce a one word stream of text using echo and pipe it into sed. sed, in turn, carries out the instruction s/front/back/ upon the text in the stream and produces the output “back” as a result. We can also recognize this command as resembling the “substitution” (search and replace) command in vi.</p><p>在这个例子中，我们使用 echo 命令产生了一个单词的文本流，然后把它管道给 sed 命令。sed，依次， 对流文本执行指令 s/front/back/，随后输出“back”。我们也能够把这个命令认为是相似于 vi 中的“替换” （查找和替代）命令。</p><p>Commands in sed begin with a single letter. In the example above, the substitution command is represented by the letter s and is followed by the search and replace strings, separated by the slash character as a delimiter. The choice of the delimiter character is arbitrary. By convention, the slash character is often used, but sed will accept any character that immediately follows the command as the delimiter. We could perform the same command this way:</p><p>sed 中的命令开始于单个字符。在上面的例子中，这个替换命令由字母 s 来代表，其后跟着查找 和替代字符串，斜杠字符做为分隔符。分隔符的选择是随意的。按照惯例，经常使用斜杠字符， 但是 sed 将会接受紧随命令之后的任意字符做为分隔符。我们可以按照这种方式来执行相同的命令：</p><pre><code>[me@linuxbox ~]$ echo &quot;front&quot; | sed &#39;s_front_back_&#39;back</code></pre><p>By using the underscore character immediately after the command, it becomes the delimiter. The ability to set the delimiter can be used to make commands more readable, as we shall see.</p><p>通过紧跟命令之后使用下划线字符，则它变成界定符。sed 可以设置界定符的能力，使命令的可读性更强， 正如我们将看到的.</p><p>Most commands in sed may be preceded by an address, which specifies which line(s) of the input stream will be edited. If the address is omitted, then the editing command is carried out on every line in the input stream. The simplest form of address is a line number. We can add one to our example:</p><p>sed 中的大多数命令之前都会带有一个地址，其指定了输入流中要被编辑的文本行。如果省略了地址， 然后会对输入流的每一行执行编辑命令。最简单的地址形式是一个行号。我们能够添加一个地址 到我们例子中：</p><pre><code>[me@linuxbox ~]$ echo &quot;front&quot; | sed &#39;1s/front/back/&#39;back</code></pre><p>Adding the address 1 to our command causes our substitution to be performed on the first line of our one-line input stream. If we specify another number:</p><p>给我们的命令添加地址 1，就导致只对仅有一行文本的输入流的第一行执行替换操作。如果我们指定另一 个数字：</p><pre><code>[me@linuxbox ~]$ echo &quot;front&quot; | sed &#39;2s/front/back/&#39;front</code></pre><p>we see that the editing is not carried out, since our input stream does not have a line two. Addresses may be expressed in many ways. Here are the most common:</p><p>我们看到没有执行这个编辑命令，因为我们的输入流没有第二行。地址可以用许多方式来表达。这里是 最常用的：</p><p>a range of line numbers</p><table><thead><tr><th align="left">Address</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">n</td><td align="left">A line number where n is a positive integer.</td></tr><tr><td align="left">$</td><td align="left">The last line.</td></tr><tr><td align="left">/regexp/</td><td align="left">Lines matching a POSIX basic regular expression. Note that the regular expression is delimited by slash characters. Optionally, the regular expression may be delimited by an alternate character, by specifying the expression with \cregexpc, where c is the alternate character.</td></tr><tr><td align="left">addr1,addr2</td><td align="left">A range of lines from addr1 to addr2, inclusive. Addresses may be any of the single address forms above.</td></tr><tr><td align="left">first~step</td><td align="left">Match the line represented by the number first, then each subsequent line at step intervals. For example 1<del>2 refers to each odd numbered line, 5</del>5 refers to the fifth line and every fifth line thereafter.</td></tr><tr><td align="left">addr1,+n</td><td align="left">Match addr1 and the following n lines.</td></tr><tr><td align="left">addr!</td><td align="left">Match all lines except addr, which may be any of the forms above.</td></tr></tbody></table><table><thead><tr><th align="left">地址</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">n</td><td align="left">行号，n 是一个正整数。</td></tr><tr><td align="left">$</td><td align="left">最后一行。</td></tr><tr><td align="left">/regexp/</td><td align="left">所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。</td></tr><tr><td align="left">addr1,addr2</td><td align="left">从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。</td></tr><tr><td align="left">first~step</td><td align="left">匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1<del>2 是指每个位于偶数行号的文本行，5</del>5 则指第五行和之后每五行位置的文本行。</td></tr><tr><td align="left">addr1,+n</td><td align="left">匹配地址 addr1 和随后的 n 个文本行。</td></tr><tr><td align="left">addr!</td><td align="left">匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。</td></tr></tbody></table><p>We’ll demonstrate different kinds of addresses using the distros.txt file from earlier in this chapter. First, a range of line numbers:</p><p>通过使用这一章中早前的 distros.txt 文件，我们将演示不同种类的地址表示法。首先，一系列行号：</p><pre><code>[me@linuxbox ~]$ sed -n &#39;1,5p&#39; distros.txtSUSE           10.2     12/07/2006Fedora         10       11/25/2008SUSE           11.0     06/19/2008Ubuntu         8.04     04/24/2008Fedora         8        11/08/2007</code></pre><p>In this example, we print a range of lines, starting with line one and continuing to line five. To do this, we use the p command, which simply causes a matched line to be printed. For this to be effective however, we must include the option -n (the no auto- print option) to cause sed not to print every line by default.</p><p>在这个例子中，我们打印出一系列的文本行，开始于第一行，直到第五行。为此，我们使用 p 命令， 其就是简单地把匹配的文本行打印出来。然而为了高效，我们必须包含选项 -n（不自动打印选项）， 让 sed 不要默认地打印每一行。</p><p>Next, we’ll try a regular expression:</p><p>下一步，我们将试用一下正则表达式：</p><pre><code>[me@linuxbox ~]$ sed -n &#39;/SUSE/p&#39; distros.txtSUSE         10.2     12/07/2006SUSE         11.0     06/19/2008SUSE         10.3     10/04/2007SUSE         10.1     05/11/2006</code></pre><p>By including the slash-delimited regular expression /SUSE/, we are able to isolate the lines containing it in much the same manner as grep.</p><p>通过包含由斜杠界定的正则表达式 /SUSE/，我们能够孤立出包含它的文本行，和 grep 程序的功能 是相同的。</p><p>Finally, we’ll try negation by adding an ! to the address:</p><p>最后，我们将试着否定上面的操作，通过给这个地址添加一个感叹号：</p><pre><code>[me@linuxbox ~]$ sed -n &#39;/SUSE/!p&#39; distros.txtFedora         10       11/25/2008Ubuntu         8.04     04/24/2008Fedora         8        11/08/2007Ubuntu         6.10     10/26/2006Fedora         7        05/31/2007Ubuntu         7.10     10/18/2007Ubuntu         7.04     04/19/2007Fedora         6        10/24/2006Fedora         9        05/13/2008Ubuntu         6.06     06/01/2006Ubuntu         8.10     10/30/2008Fedora         5        03/20/2006</code></pre><p>Here we see the expected result: all of the lines in the file except the ones matched by the regular expression.</p><p>这里我们看到期望的结果：输出了文件中所有的文本行，除了那些匹配这个正则表达式的文本行。</p><p>So far, we’ve looked at two of the sed editing commands, s and p. Here is a more complete list of the basic editing commands:</p><p>目前为止，我们已经知道了两个 sed 的编辑命令，s 和 p。这里是一个更加全面的基本编辑命令列表：</p><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">Output current line number.</td></tr><tr><td align="left">a</td><td align="left">Append text after the current line.</td></tr><tr><td align="left">d</td><td align="left">Delete the current line.</td></tr><tr><td align="left">i</td><td align="left">Insert text in front of the current line.</td></tr><tr><td align="left">p</td><td align="left">Print the current line. By default, sed prints every line and only edits lines that match a specified address within the file. The default behavior can be overridden by specifying the -n option.</td></tr><tr><td align="left">q</td><td align="left">Exit sed without processing any more lines. If the -n option is not specified, output the current line.</td></tr><tr><td align="left">Q</td><td align="left">Exit sed without processing any more lines.</td></tr><tr><td align="left">s/regexp/replacement/</td><td align="left">Substitute the contents of replacement wherever regexp is found. replacement may include the special character &amp;, which is equivalent to the text matched by regexp. In addition, replacement may include the sequences \1 through \9, which are the contents of the corresponding subexpressions in regexp. For more about this, see the discussion of back references below. After the trailing slash following replacement, an optional flag may be specified to modify the s command’s behavior.</td></tr><tr><td align="left">y/set1/set2</td><td align="left">Perform transliteration by converting characters from set1 to the corresponding characters in set2. Note that unlike tr, sed requires that both sets be of the same length.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">输出当前的行号。</td></tr><tr><td align="left">a</td><td align="left">在当前行之后追加文本。</td></tr><tr><td align="left">d</td><td align="left">删除当前行。</td></tr><tr><td align="left">i</td><td align="left">在当前行之前插入文本。</td></tr><tr><td align="left">p</td><td align="left">打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。</td></tr><tr><td align="left">q</td><td align="left">退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。</td></tr><tr><td align="left">Q</td><td align="left">退出 sed，不再处理更多的文本行。</td></tr><tr><td align="left">s/regexp/replacement/</td><td align="left">只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &amp;，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \1到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。</td></tr><tr><td align="left">y/set1/set2</td><td align="left">执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。</td></tr></tbody></table><p>The s command is by far the most commonly used editing command. We will demonstrate just some of its power by performing an edit on our distros.txt file. We discussed before how the date field in distros.txt was not in a “computer- friendly” format. While the date is formatted MM/DD/YYYY, it would be better (for ease of sorting) if the format were YYYY-MM-DD. To perform this change on the file by hand would be both time-consuming and error prone, but with sed, this change can be performed in one step:</p><p>到目前为止，这个 s 命令是最常使用的编辑命令。我们将仅仅演示一些它的功能，通过编辑我们的 distros.txt 文件。我们以前讨论过 distros.txt 文件中的日期字段不是“友好地计算机”模式。 文件中的日期格式是 MM/DD/YYYY，但如果格式是 YYYY-MM-DD 会更好一些（利于排序）。手动修改 日期格式不仅浪费时间而且易出错，但是有了 sed，只需一步就能完成修改：</p><pre><code>[me@linuxbox ~]$ sed &#39;s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/&#39; distros.txtSUSE           10.2     2006-12-07Fedora         10       2008-11-25SUSE           11.0     2008-06-19Ubuntu         8.04     2008-04-24Fedora         8        2007-11-08SUSE           10.3     2007-10-04Ubuntu         6.10     2006-10-26Fedora         7        2007-05-31Ubuntu         7.10     2007-10-18Ubuntu         7.04     2007-04-19SUSE           10.1     2006-05-11Fedora         6        2006-10-24Fedora         9        2008-05-13Ubuntu         6.06     2006-06-01Ubuntu         8.10     2008-10-30Fedora         5        2006-03-20</code></pre><p>Wow! Now that is an ugly looking command. But it works. In just one step, we have changed the date format in our file. It is also a perfect example of why regular expressions are sometimes jokingly referred to as a “write-only” medium. We can write them, but we sometimes cannot read them. Before we are tempted to run away in terror from this command, let’s look at how it was constructed. First, we know that the command will have this basic structure:</p><p>哇！这个命令看起来很丑陋。但是它起作用了。仅用一步，我们就更改了文件中的日期格式。 它也是一个关于为什么有时候会开玩笑地把正则表达式称为是“只写”媒介的完美的例子。我们 能写正则表达式，但是有时候我们不能读它们。在我们恐惧地忍不住要逃离此命令之前，让我们看一下 怎样来构建它。首先，我们知道此命令有这样一个基本的结构：</p><pre><code>sed &#39;s/regexp/replacement/&#39; distros.txt</code></pre><p>Our next step is to figure out a regular expression that will isolate the date. Since it is in MM/DD/YYYY format and appears at the end of the line, we can use an expression like this:</p><p>我们下一步是要弄明白一个正则表达式将要孤立出日期。因为日期是 MM/DD/YYYY 格式，并且 出现在文本行的末尾，我们可以使用这样的表达式：</p><pre><code>[0-9]{2}/[0-9]{2}/[0-9]{4}$</code></pre><p>which matches two digits, a slash, two digits, a slash, four digits, and the end of line. So that takes care of <em>regexp</em>, but what about <em>replacement</em>? To handle that, we must introduce a new regular expression feature that appears in some applications which use BRE. This feature is called <em>back references</em> and works like this: if the sequence \n appears in <em>replacement</em> where n is a number from one to nine, the sequence will refer to the corresponding subexpression in the preceding regular expression. To create the subexpressions, we simply enclose them in parentheses like so:</p><p>此表达式匹配两位数字，一个斜杠，两位数字，一个斜杠，四位数字，以及行尾。如此关心 <strong>regexp</strong>， 那么 <strong>replacement</strong> 又怎样呢？为了解决此问题，我们必须介绍一个正则表达式的新功能，它出现 在一些使用 BRE 的应用程序中。这个功能叫做 <strong>逆参照</strong> ，像这样工作：如果序列 <code>\n</code> 出现在 <strong>replacement</strong> 中 ，这里 n 是指从 1 到 9 的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了 创建这个子表达式，我们简单地把它们用圆括号括起来，像这样：</p><pre><code>([0-9]{2})/([0-9]{2})/([0-9]{4})$</code></pre><p>We now have three subexpressions. The first contains the month, the second contains the day of the month, and the third contains the year. Now we can construct replacement as follows:</p><p>现在我们有了三个子表达式。第一个表达式包含月份，第二个包含某月中的某天，以及第三个包含年份。 现在我们就可以构建 <strong>replacement</strong> ，如下所示：</p><pre><code>\3-\1-\2</code></pre><p>which gives us the year, a dash, the month, a dash, and the day.</p><p>此表达式给出了年份，一个短划线，月份，一个短划线，和某天。</p><p>Now, our command looks like this: 现在我们的命令看起来像下面这样：</p><pre><code>sed &#39;s/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/&#39; distros.txt</code></pre><p>We have two remaining problems. The first is that the extra slashes in our regular expression will confuse sed when it tries to interpret the s command. The second is that since sed, by default, accepts only basic regular expressions, several of the characters in our regular expression will be taken as literals, rather than as metacharacters. We can solve both these problems with a liberal application of backslashes to escape the offending characters:</p><p>我们还有两个问题。第一个是当 sed 试图解释这个 s 命令的时候在我们表达式中额外的斜杠将会使 sed 迷惑。 第二个是由于sed默认情况下只接受基本的正则表达式，在表达式中的几个字符会 被当作文字字面值，而不是元字符。我们能够通过反斜杠的自由应用来转义令人不快的字符解决这两个问题，：</p><pre><code>sed &#39;s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/&#39; distros.txt</code></pre><p>And there you have it!</p><p>你掌握了吧!</p><p>Another feature of the s command is the use of optional flags that may follow the replacement string. The most important of these is the g flag, which instructs sed to apply the search and replace globally to a line, not just to the first instance, which is the default. Here is an example:</p><p>s 命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是 g 标志，其 指示 sed 对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默认行为。 这里有个例子：</p><pre><code>[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | sed &#39;s/b/B/&#39;aaaBbbccc</code></pre><p>We see that the replacement was performed, but only to the first instance of the letter “b,” while the remaining instances were left unchanged. By adding the g flag, we are able to change all the instances:</p><p>我们看到虽然执行了替换操作，但是只针对第一个字母 “b” 实例，然而剩余的实例没有更改。通过添加 g 标志， 我们能够更改所有的实例：</p><pre><code>[me@linuxbox ~]$ echo &quot;aaabbbccc&quot; | sed &#39;s/b/B/g&#39;aaaBBBccc</code></pre><p>So far, we have only given sed single commands via the command line. It is also possible to construct more complex commands in a script file using the -f option. To demonstrate, we will use sed with our distros.txt file to build a report. Our report will feature a title at the top, our modified dates, and all the distribution names converted to upper case. To do this, we will need to write a script, so we’ll fire up our text editor and enter the following:</p><p>目前为止，通过命令行我们只让 sed 执行单个命令。使用-f 选项，也有可能在一个脚本文件中构建更加复杂的命令。 为了演示，我们将使用 sed 和 distros.txt 文件来生成一个报告。我们的报告以开头标题，修改过的日期，以及 大写的发行版名称为特征。为此，我们需要编写一个脚本，所以我们将打开文本编辑器，然后输入以下文字：</p><pre><code># sed script to produce Linux distributions report1 i\\Linux Distributions Report\s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</code></pre><p>We will save our sed script as distros.sed and run it like this:</p><p>我们将把 sed 脚本保存为 distros.sed 文件，然后像这样运行它：</p><pre><code>[me@linuxbox ~]$ sed -f distros.sed distros.txtLinux Distributions ReportSUSE    10.2    2006-12-07FEDORA    10        2008-11-25SUSE    11.0    2008-06-19UBUNTU    8.04    2008-04-24FEDORA    8        2007-11-08SUSE    10.3    2007-10-04UBUNTU    6.10    2006-10-26FEDORA    7        2007-05-31UBUNTU    7.10    2007-10-18UBUNTU    7.04    2007-04-19SUSE    10.1    2006-05-11FEDORA    6        2006-10-24FEDORA    9        2008-05-13</code></pre><p>As we can see, our script produces the desired results, but how does is do it? Let’s take another look at our script. We’ll use cat to number the lines:</p><p>正如我们所见，我们的脚本文件产生了期望的结果，但是它是如何做到的呢？让我们再看一下我们的脚本文件。 我们将使用 cat 来给每行文本编号：</p><pre><code>[me@linuxbox ~]$ cat -n distros.sed1 # sed script to produce Linux distributions report23 1 i\4 \5 Linux Distributions Report\67 s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/8 y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</code></pre><p>Line one of our script is a comment. Like many configuration files and programming languages on Linux systems, comments begin with the # character and are followed by human-readable text. Comments can be placed anywhere in the script (though not within commands themselves) and are helpful to any humans who might need to identify and/or maintain the script.</p><p>我们脚本文件的第一行是一条注释。如同 Linux 系统中的许多配置文件和编程语言一样，注释以#字符开始， 然后是人类可读的文本。注释可以被放到脚本中的任意地方（虽然不在命令本身之中），且对任何 可能需要理解和／或维护脚本的人们都很有帮助。</p><p>Line two is a blank line. Like comments, blank lines may be added to improve readability.</p><p>第二行是一个空行。正如注释一样，添加空白行是为了提高程序的可读性。</p><p>Many sed commands support line addresses. These are used to specify which lines of the input are to be acted upon. Line addresses may be expressed as single line numbers, line number ranges, and the special line number “$” which indicates the last line of input.</p><p>许多 sed 命令支持行地址。这些行地址被用来指定对输入文本的哪一行执行操作。行地址可能被 表示为单独的行号，行号范围，以及特殊的行号“$”，它表示输入文本的最后一行。</p><p>Lines three through six contain text to be inserted at the address 1, the first line of the input. The i command is followed by the sequence backslash-carriage return to produce an escaped carriage return, or what is called a line continuation character. This sequence, which can be used in many circumstances including shell scripts, allows a carriage return to be embedded in a stream of text without signaling the interpreter (in this case sed) that the end of the line has been reached. The i, and likewise, the a (which appends text, rather than inserting it) and c (which replaces text) commands, allow multiple lines of text as long as each line, except the last, ends with a line continuation character. The sixth line of our script is actually the end of our inserted text and ends with a plain carriage return rather than a line continuation character, signaling the end of the i command.</p><p>从第三行到第六行所包含地文本要被插入到地址 1 处，也就是输入文本的第一行中。这个 i 命令 之后是反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能够 被用在许多环境下，包括 shell 脚本，从而允许把回车符嵌入到文本流中，而没有通知 解释器（在这是指 sed 解释器）已经到达了文本行的末尾。这个 i 命令，同样地，命令 a（追加文本， 而不是插入文本）和 c（取代文本）命令都允许多个文本行，只要每个文本行，除了最后一行，以一个 连行符结束。实际上，脚本的第六行是插入文本的末尾，它以一个普通的回车符结尾，而不是一个 连行符，通知解释器 i 命令结束了。</p><hr><p>Note: A line continuation character is formed by a backslash followed immediately by a carriage return. No intermediary spaces are permitted.</p><p>注意：一个连行符由一个反斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字符。</p><hr><p>Line seven is our search and replace command. Since it is not preceded by an address, each line in the input stream is subject to its action.</p><p>第七行是我们的查找和替代命令。因为命令之前没有添加地址，所以输入流中的每一行文本 都得服从它的操作。</p><p>Line eight performs transliteration of the lowercase letters into uppercase letters. Note that unlike tr, the y command in sed does not support character ranges (for example, [a-z]), nor does it support POSIX character classes. Again, since the y command is not preceded by an address, it applies to every line in the input stream.</p><p>第八行执行小写字母到大写字母的字符替换操作。注意不同于 tr 命令，这个 sed 中的 y 命令不 支持字符区域（例如，[a-z]），也不支持 POSIX 字符集。再说一次，因为 y 命令之前不带地址， 所以它会操作输入流的每一行。</p><blockquote><p>People Who Like sed Also Like…</p><p>喜欢 sed 的人们也会喜欢。。。</p><p>sed is a very capable program, able to perform fairly complex editing tasks to streams of text. It is most often used for simple one line tasks rather than long scripts. Many users prefer other tools for larger tasks. The most popular of these are awk and perl. These go beyond mere tools, like the programs covered here, and extend into the realm of complete programming languages. perl, in particular, is often used in place of shell scripts for many system management and administration tasks, as well as being a very popular medium for web development. awk is a little more specialized. Its specific strength is its ability to manipulate tabular data. It resembles sed in that awk programs normally process text files line-by-line, using a scheme similar to the sed concept of an address followed by an action. While both awk and perl are outside the scope of this book, they are very good skills for the Linux command line user.</p><p>sed 是一款非常强大的程序，它能够针对文本流完成相当复杂的编辑任务。它最常 用于简单的行任务，而不是长长的脚本。许多用户喜欢使用其它工具，来执行较大的工作。 在这些工具中最著名的是 awk 和 perl。它们不仅仅是工具，像这里介绍的程序，且延伸到 完整的编程语言领域。特别是 perl，经常被用来代替 shell 脚本，来完成许多系统管理任务， 同时它也是一款非常流行网络开发语言。awk 更专用一些。其具体优点是其操作表格数据的能力。 awk 程序通常逐行处理文本文件，这点类似于 sed，awk 使用了一种方案，其与 sed 中地址 之后跟随编辑命令的概念相似。虽然关于 awk 和 perl 的内容都超出了本书所讨论的范围， 但是对于 Linux 命令行用户来说，它们都是非常好的技能。</p></blockquote><h4 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a>aspell</h4><p>The last tool we will look at is aspell, an interactive spelling checker. The aspell program is the successor to an earlier program named ispell, and can be used, for the most part, as a drop-in replacement. While the aspell program is mostly used by other programs that require spell checking capability, it can also be used very effectively as a stand-alone tool from the command line. It has the ability to intelligently check various type of text files, including HTML documents, C/C++ programs, email messages and other kinds of specialized texts.</p><p>我们要查看的最后一个工具是 aspell，一款交互式的拼写检查器。这个 aspell 程序是早先 ispell 程序 的继承者，大多数情况下，它可以被用做一个替代品。虽然 aspell 程序大多被其它需要拼写检查能力的 程序使用，但它也可以作为一个独立的命令行工具使用。它能够智能地检查各种类型的文本文件， 包括 HTML 文件，C/C++ 程序，电子邮件和其它种类的专业文本。</p><p>To spell check a text file containing simple prose, it could be used like this:</p><p>拼写检查一个包含简单的文本文件，可以这样使用 aspell:</p><pre><code>aspell check textfile</code></pre><p>where <em>textfile</em> is the name of the file to check. As a practical example, let’s create a simple text file named foo.txt containing some deliberate spelling errors:</p><p>这里的 textfile 是要检查的文件名。作为一个实际例子，让我们创建一个简单的文本文件，叫做 foo.txt， 包含一些故意的拼写错误：</p><pre><code>[me@linuxbox ~]$ cat &gt; foo.txtThe quick brown fox jimped over the laxy dog.</code></pre><p>Next we’ll check the file using aspell:</p><p>下一步我们将使用 aspell 来检查文件：</p><pre><code>[me@linuxbox ~]$ aspell check foo.txt</code></pre><p>As aspell is interactive in the check mode, we will see a screen like this:</p><p>因为 aspell 在检查模式下是交互的，我们将看到像这样的一个屏幕：</p><pre><code>The quick brown fox jimped over the laxy dog.1)jumped                        6)wimped2)gimped                        7)camped3)comped                        8)humped4)limped                        9)impede5)pimped                        0)umpedi)Ignore                        I)Ignore allr)Replace                       R)Replace alla)Add                           l)Add Lowerb)Abort                         x)Exit?</code></pre><p>At the top of the display, we see our text with a suspiciously spelled word highlighted. In the middle, we see ten spelling suggestions numbered zero through nine, followed by a list of other possible actions. Finally, at the very bottom, we see a prompt ready to accept our choice.</p><p>在显示屏的顶部，我们看到我们的文本中有一个拼写可疑且高亮显示的单词。在中间部分，我们看到 十个拼写建议，序号从 0 到 9，然后是一系列其它可能的操作。最后，在最底部，我们看到一个提示符， 准备接受我们的选择。</p><p>If we press the 1 key, aspell replaces the offending word with the word “jumped” and moves on to the next misspelled word which is “laxy.” If we select the replacement “lazy,” aspell replaces it and terminates. Once aspell has finished, we can examine our file and see that the misspellings have been corrected:</p><p>如果我们按下 1 按键，aspell 会用单词 “jumped” 代替错误单词，然后移动到下一个拼写错的单词，就是 “laxy”。如果我们选择替代物 “lazy”，aspell 会替换 “laxy” 并且终止。一旦 aspell 结束操作，我们 可以检查我们的文件，会看到拼写错误的单词已经更正了。</p><pre><code>[me@linuxbox ~]$ cat foo.txtThe quick brown fox jumped over the lazy dog.</code></pre><p>Unless told otherwise via the command line option –dont-backup, aspell creates a backup file containing the original text by appending the extension .bak to the filename.</p><p>除非由命令行选项 –dont-backup 告诉 aspell，否则通过追加扩展名.bak 到文件名中, aspell 会创建一个包含原始文本的备份文件。</p><p>Showing off our sed editing prowess, we’ll put our spelling mistakes back in so we can reuse our file:</p><p>为了炫耀 sed 的编辑本领，我们将还原拼写错误，从而能够重用我们的文件：</p><pre><code>[me@linuxbox ~]$ sed -i &#39;s/lazy/laxy/; s/jumped/jimped/&#39; foo.txt</code></pre><p>The sed option -i tells sed to edit the file “in-place,” meaning that rather than sending the edited output to standard output, it will re-write the file with the changes applied. We also see the ability to place more than one editing command on the line by separating them with a semicolon.</p><p>这个 sed 选项-i，告诉 sed 在适当位置编辑文件，意思是不要把编辑结果发送到标准输出中。sed 会把更改应用到文件中， 以此重新编写文件。我们也看到可以把多个 sed 编辑命令放在同一行，编辑命令之间由分号分隔开来。</p><p>Next, we’ll look at how aspell can handle different kinds of text files. Using a text editor such as vim (the adventurous may want to try sed), we will add some HTML markup to our file:</p><p>下一步，我们将看一下 aspell 怎样来解决不同种类的文本文件。使用一个文本编辑器，例如 vim（胆大的人可能想用 sed）， 我们将添加一些 HTML 标志到文件中：</p><pre><code>&lt;html&gt;    &lt;head&gt;          &lt;title&gt;Mispelled HTML file&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;          &lt;p&gt;The quick brown fox jimped over the laxy dog.&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>Now, if we try to spell check our modified file, we run into a problem. If we do it this way:</p><p>现在，如果我们试图拼写检查我们修改的文件，我们会遇到一个问题。如果我们这样做：</p><pre><code>[me@linuxbox ~]$ aspell check foo.txt</code></pre><p>we’ll get this:</p><p>我们会得到这些：</p><pre><code>&lt;html&gt;    &lt;head&gt;          &lt;title&gt;Mispelled HTML file&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;          &lt;p&gt;The quick brown fox jimped over the laxy dog.&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;1) HTML                     4) Hamel2) ht ml                    5) Hamil3) ht-ml                    6) hoteli) Ignore                   I) Ignore allr) Replace                  R) Replace alla) Add                      l) Add Lowerb) Abort                    x) Exit?</code></pre><p>aspell will see the contents of the HTML tags as misspelled. This problem can be overcome by including the -H (HTML) checking mode option, like this:</p><p>aspell 会认为 HTML 标志的内容是拼写错误。通过包含-H（HTML）检查模式选项，这个问题能够 解决，像这样：</p><pre><code>[me@linuxbox ~]$ aspell -H check foo.txt</code></pre><p>which will result in this:</p><p>这会导致这样的结果：</p><pre><code>&lt;html&gt;    &lt;head&gt;          &lt;title&gt;&lt;b&gt;Mispelled&lt;/b&gt; HTML file&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;          &lt;p&gt;The quick brown fox jimped over the laxy dog.&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;1) Mi spelled              6) Misapplied2) Mi-spelled              7) Miscalled3) Misspelled              8) Respelled4) Dispelled               9) Misspell5) Spelled                 0) Misledi) Ignore                  I) Ignore allr) Replace                 R) Replace alla) Add                     l) Add Lowerb) Abort                   x) Exit?</code></pre><p>The HTML is ignored and only the non-markup portions of the file are checked. In this mode, the contents of HTML tags are ignored and not checked for spelling. However, the contents of ALT tags, which benefit from checking, are checked in this mode.</p><p>这个 HTML 标志被忽略了，并且只会检查文件中非标志部分的内容。在这种模式下，HTML 标志的 内容被忽略了，不会进行拼写检查。然而，ALT 标志的内容，会被检查。</p><hr><p>Note: By default, aspell will ignore URLs and email addresses in text. This behavior can be overridden with command line options. It is also possible to specify which markup tags are checked and skipped. See the aspell man page for details.</p><p>注意：默认情况下，aspell 会忽略文本中的 URL 和电子邮件地址。通过命令行选项，可以重写此行为。 也有可能指定哪些标志进行检查及跳过。详细内容查看 aspell 命令手册。</p><hr><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this chapter, we have looked at a few of the many command line tools that operate on text. In the next chapter, we will look at several more. Admittedly, it may not seem immediately obvious how or why you might use some of these tools on a day-to-day basis, though we have tried to show some semi-practical examples of their use. We will find in later chapters that these tools form the basis of a tool set that is used to solve a host of practical problems. This will be particularly true when we get into shell scripting, where these tools will really show their worth.</p><p>在这一章中，我们已经查看了一些操作文本的命令行工具。在下一章中，我们会再看几个命令行工具。 诚然，看起来不能立即显现出怎样或为什么你可能使用这些工具为日常的基本工具， 虽然我们已经展示了一些半实际的命令用法的例子。我们将在随后的章节中发现这些工具组成 了解决实际问题的基本工具箱。这将是确定无疑的，当我们学习 shell 脚本的时候， 到时候这些工具将真正体现出它们的价值。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>The GNU Project website contains many online guides to the tools discussed in this chapter.</p><p>GNU 项目网站包含了本章中所讨论工具的许多在线指南。</p><ul><li><p>From the Coreutils package:</p></li><li><p>来自 Coreutils 软件包：</p><p><a href="http://www.gnu.org/software/coreutils/manual/coreutils.html#Output-of-entire-files" target="_blank" rel="noopener">http://www.gnu.org/software/coreutils/manual/coreutils.html#Output-of-entire-files</a></p><p><a href="http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-sorted-files" target="_blank" rel="noopener">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-sorted-files</a></p><p><a href="http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-fields-within-a-line" target="_blank" rel="noopener">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-fields-within-a-line</a></p><p><a href="http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-characters" target="_blank" rel="noopener">http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-characters</a></p></li><li><p>From the Diffutils package:</p></li><li><p>来自 Diffutils 软件包：</p><p><a href="http://www.gnu.org/software/diffutils/manual/html_mono/diff.html" target="_blank" rel="noopener">http://www.gnu.org/software/diffutils/manual/html_mono/diff.html</a></p></li><li><p>sed 工具</p><p><a href="http://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener">http://www.gnu.org/software/sed/manual/sed.html</a></p></li><li><p>aspell 工具</p><p><a href="http://aspell.net/man-html/index.html" target="_blank" rel="noopener">http://aspell.net/man-html/index.html</a></p></li><li><p>There are many other online resources for sed, in particular:</p></li><li><p>尤其对于 sed 工具，还有很多其它的在线资源：</p><p><a href="http://www.grymoire.com/Unix/Sed.html" target="_blank" rel="noopener">http://www.grymoire.com/Unix/Sed.html</a></p><p><a href="http://sed.sourceforge.net/sed1line.txt" target="_blank" rel="noopener">http://sed.sourceforge.net/sed1line.txt</a></p></li><li><p>Also try googling “sed one liners”, “sed cheat sheets”</p></li><li><p>试试用 google 搜索 “sed one liners”, “sed cheat sheets” 关键字</p></li></ul><h3 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h3><p>There are a few more interesting text manipulation commands worth investigating. Among these are: split (split files into pieces), csplit (split files into pieces based on context), and sdiff (side-by-side merge of file differences.)</p><p>有一些更有趣的文本操作命令值得。在它们之间有：split（把文件分割成碎片）， csplit（基于上下文把文件分割成碎片），和 sdiff（并排合并文件差异）。</p>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十章 正则表达式</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>In the next few chapters, we are going to look at tools used to manipulate text. As we have seen, text data plays an important role on all Unix-like systems, such as Linux. But before we can fully appreciate all of the features offered by these tools, we have to first examine a technology that is frequently associated with the most sophisticated uses of these tools — regular expressions.</p><p>接下来的几章中，我们将会看一下一些用来操作文本的工具。正如我们所见到的，在类 Unix 的 操作系统中，比如 Linux 中，文本数据起着举足轻重的作用。但是在我们能完全理解这些工具提供的 所有功能之前，我们不得不先看看，经常与这些工具的高级使用相关联的一门技术——正则表达式。</p><p>As we have navigated the many features and facilities offered by the command line, we have encountered some truly arcane shell features and commands, such as shell expansion and quoting, keyboard shortcuts, and command history, not to mention the vi editor. Regular expressions continue this “tradition” and may be (arguably) the most arcane feature of them all. This is not to suggest that the time it takes to learn about them is not worth the effort. Quite the contrary. A good understanding will enable us to perform amazing feats, though their full value may not be immediately apparent. What Are Regular Expressions?</p><p>我们已经浏览了许多由命令行提供的功能和工具，我们遇到了一些真正神秘的 shell 功能和命令， 比如 shell 展开和引用、键盘快捷键和命令历史，更不用说 vi 编辑器了。正则表达式延续了 这种“传统”，而且有可能（备受争议地）是这些‘神秘功能’中最神秘的那个。这并不是说花费时间来学习它们 是不值得的，而是恰恰相反。虽然它们的全部价值可能不能立即显现，但是较强理解这些功能 使我们能够表演令人惊奇的技艺。什么是正则表达式？</p><p>Simply put, regular expressions are symbolic notations used to identify patterns in text. In some ways, they resemble the shell’s wildcard method of matching file and pathnames, but on a much grander scale. Regular expressions are supported by many command line tools and by most programming languages to facilitate the solution of text manipulation problems. However, to further confuse things, not all regular expressions are the same; they vary slightly from tool to tool and from programming language to language. For our discussion, we will limit ourselves to regular expressions as described in the POSIX standard (which will cover most of the command line tools), as opposed to many programming languages (most notably Perl), which use slightly larger and richer sets of notations.</p><p>简而言之，正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配 文件和路径名的 shell 通配符比较相似，但其规模更庞大。许多命令行工具和大多数的编程语言 都支持正则表达式，以此来帮助解决文本操作问题。然而，并不是所有的正则表达式都是一样的， 这就进一步混淆了事情；不同工具以及不同语言之间的正则表达式都略有差异。我们将会限定 POSIX 标准中描述的正则表达式（其包括了大多数的命令行工具），供我们讨论， 与许多编程语言（最著名的 Perl 语言）相反，它们使用了更多和更丰富的符号集。</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>The main program we will use to work with regular expressions is our old pal, grep. The name “grep” is actually derived from the phrase “global regular expression print,” so we can see that grep has something to do with regular expressions. In essence, grep searches text files for the occurrence of a specified regular expression and outputs any line containing a match to standard output.</p><p>我们将使用的主要程序是我们的老朋友，grep 程序，它会用到正则表达式。实际上，“grep”这个名字 来自于短语“global regular expression print”，所以我们能看出 grep 程序和正则表达式有关联。 本质上，grep 程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。</p><p>So far, we have used grep with fixed strings, like so:</p><p>到目前为止，我们已经使用 grep 程序查找了固定的字符串，就像这样:</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | grep zip</code></pre><p>This will list all the files in the /usr/bin directory whose names contain the substring “zip”.</p><p>这个命令会列出，位于目录 /usr/bin 中，文件名中包含子字符串“zip”的所有文件。</p><p>The grep program accepts options and arguments this way:</p><p>grep 程序以这样的方式来接受选项和参数：</p><pre><code>grep [options] regex [file...]</code></pre><p>where regex is a regular expression.</p><p>这里的 regex 是指一个正则表达式。</p><p>Here is a list of the commonly used grep options:</p><p>这是一个常用的 grep 选项列表：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">Ignore case. Do not distinguish between upper and lower case characters. May also be specified –ignore-case.</td></tr><tr><td align="left">-v</td><td align="left">Invert match. Normally, grep prints lines that contain a match. This option causes grep to print every line that does not contain a match. May also be specified –invert-match.</td></tr><tr><td align="left">-c</td><td align="left">Print the number of matches (or non-matches if the -v option is also specified) instead of the lines themselves. May also be specified –count.</td></tr><tr><td align="left">-l</td><td align="left">Print the name of each file that contains a match instead of the lines themselves. May also be specified –files-with-matches.</td></tr><tr><td align="left">-L</td><td align="left">Like the -l option, but print only the names of files that do not contain matches. May also be specified –files-without-match.</td></tr><tr><td align="left">-n</td><td align="left">Prefix each matching line with the number of the line within the file. May also be specified –line-number.</td></tr><tr><td align="left">-h</td><td align="left">For multi-file searches, suppress the output of filenames. May also be specified –no-filename.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">忽略大小写。不会区分大小写字符。也可用–ignore-case 来指定。</td></tr><tr><td align="left">-v</td><td align="left">不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会打印不包含匹配项的文本行。也可用–invert-match 来指定。</td></tr><tr><td align="left">-c</td><td align="left">打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。 也可用–count 选项来指定。</td></tr><tr><td align="left">-l</td><td align="left">打印包含匹配项的文件名，而不是文本行本身，也可用–files-with-matches 选项来指定。</td></tr><tr><td align="left">-L</td><td align="left">相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用–files-without-match 来指定。</td></tr><tr><td align="left">-n</td><td align="left">在每个匹配行之前打印出其位于文件中的相应行号。也可用–line-number 选项来指定。</td></tr><tr><td align="left">-h</td><td align="left">应用于多文件搜索，不输出文件名。也可用–no-filename 选项来指定。</td></tr></tbody></table><p>In order to more fully explore grep, let’s create some text files to search:</p><p>为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：</p><pre><code>[me@linuxbox ~]$ ls /bin &gt; dirlist-bin.txt[me@linuxbox ~]$ ls /usr/bin &gt; dirlist-usr-bin.txt[me@linuxbox ~]$ ls /sbin &gt; dirlist-sbin.txt[me@linuxbox ~]$ ls /usr/sbin &gt; dirlist-usr-sbin.txt[me@linuxbox ~]$ ls dirlist*.txtdirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txtdirlist-usr-bin.txt</code></pre><p>We can perform a simple search of our list of files like this:</p><p>我们能够对我们的文件列表执行简单的搜索，像这样：</p><pre><code>[me@linuxbox ~]$ grep bzip dirlist*.txtdirlist-bin.txt:bzip2dirlist-bin.txt:bzip2recover</code></pre><p>In this example, grep searches all of the listed files for the string bzip and finds two matches, both in the file dirlist-bin.txt. If we were only interested in the list of files that contained matches rather than the matches themselves, we could specify the -l option:</p><p>在这个例子里，grep 程序在所有列出的文件中搜索字符串 bzip，然后找到两个匹配项，其都在 文件 dirlist-bin.txt 中。如果我们只是对包含匹配项的文件列表，而不是对匹配项本身感兴趣 的话，我们可以指定-l 选项：</p><pre><code>[me@linuxbox ~]$ grep -l bzip dirlist*.txtdirlist-bin.txt</code></pre><p>Conversely, if we wanted only to see a list of the files that did not contain a match, we could do this:</p><p>相反地，如果我们只想查看不包含匹配项的文件列表，我们可以这样操作：</p><pre><code>[me@linuxbox ~]$ grep -L bzip dirlist*.txtdirlist-sbin.txtdirlist-usr-bin.txtdirlist-usr-sbin.txt</code></pre><h3 id="元字符和原义字符-Metacharacters-And-Literals"><a href="#元字符和原义字符-Metacharacters-And-Literals" class="headerlink" title="元字符和原义字符(Metacharacters And Literals)"></a>元字符和原义字符(Metacharacters And Literals)</h3><p>While it may not seem apparent, our grep searches have been using regular expressions all along, albeit very simple ones. The regular expression “bzip” is taken to mean that a match will occur only if the line in the file contains at least four characters and that somewhere in the line the characters “b”, “z”, “i”, and “p” are found in that order, with no other characters in between. The characters in the string “bzip” are all literal characters, in that they match themselves. In addition to literals, regular expressions may also include metacharacters that are used to specify more complex matches. Regular expression metacharacters consist of the following:</p><p>它可能看起来不明显，但是我们的 grep 程序一直使用了正则表达式，虽然是非常简单的例子。 这个正则表达式“bzip”意味着，匹配项所在行至少包含4个字符，并且按照字符 “b”、“z”、 “i” 和 “p”的顺序 出现在匹配行的某处，字符之间没有其它的字符。字符串“bzip”中的所有字符都是原义字符，因此 它们匹配本身。除了原义字符之外，正则表达式也可能包含元字符，其被用来指定更复杂的匹配项。 正则表达式元字符由以下字符组成：</p><pre><code>^ $ . [ ] { } - ? * + ( ) | \</code></pre><p>All other characters are considered literals, though the backslash character is used in a few cases to create meta sequences, as well as allowing the metacharacters to be escaped and treated as literals instead of being interpreted as metacharacters.</p><p>其它所有字符都被认为是原义字符。在个别情况下，反斜杠会被用来创建元序列， 元字符也可以被转义为原义字符，而不是被解释为元字符。</p><hr><p>Note: As we can see, many of the regular expression metacharacters are also characters that have meaning to the shell when expansion is performed. When we pass regular expressions containing metacharacters on the command line, it is vital that they be enclosed in quotes to prevent the shell from attempting to expand them.</p><p>注意：正如我们所见到的，当 shell 执行展开的时候，许多正则表达式元字符，也是对 shell 有特殊 含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要， 这样可以阻止 shell 试图展开它们。</p><hr><h3 id="任何字符"><a href="#任何字符" class="headerlink" title="任何字符"></a>任何字符</h3><p>The first metacharacter we will look at is the dot or period character, which is used to match any character. If we include it in a regular expression, it will match any character in that character position. Here’s an example:</p><p>我们将要查看的第一个元字符是圆点字符，其被用来匹配任意字符。如果我们在正则表达式中包含它， 它将会匹配在此位置的任意一个字符。这里有个例子：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;.zip&#39; dirlist*.txtbunzip2bzip2bzip2recovergunzipgzipfunzipgpg-zippreunzipprezipprezip-binunzipunzipsfx</code></pre><p>We searched for any line in our files that matches the regular expression “.zip”. There are a couple of interesting things to note about the results. Notice that the zip program was not found. This is because the inclusion of the dot metacharacter in our regular expression increased the length of the required match to four characters, and because the name “zip” only contains three, it does not match. Also, if there had been any files in our lists that contained the file extension .zip, they would have also been matched as well, because the period character in the file extension is treated as “any character,” too.</p><p>我们在文件中查找包含正则表达式“.zip”的文本行。对于搜索结果，有几点需要注意一下。 注意没有找到这个 zip 程序。这是因为在我们的正则表达式中包含的圆点字符把所要求的匹配项的长度 增加到四个字符，并且因为字符串“zip”只包含三个字符，所以这个 zip 程序不匹配。另外，如果我们的文件列表 中有一些文件的扩展名是.zip，则它们也会成为匹配项，因为文件扩展名中的圆点符号也会被看作是 “任意字符”。</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>The caret and dollar sign characters are treated as anchors in regular expressions. This means that they cause the match to occur only if the regular expression is found at the beginning of the line or at the end of the line:</p><p>在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式 只有在文本行的开头或末尾被找到时，才算发生一次匹配。</p><pre><code>[me@linuxbox ~]$ grep -h &#39;^zip&#39; dirlist*.txtzipzipcloakzipgrepzipinfozipnotezipsplit[me@linuxbox ~]$ grep -h &#39;zip$&#39; dirlist*.txtgunzipgzipfunzipgpg-zippreunzipprezipunzipzip[me@linuxbox ~]$ grep -h &#39;^zip$&#39; dirlist*.txtzip</code></pre><p>Here we searched the list of files for the string “zip” located at the beginning of the line, the end of the line, and on a line where it is at both the beginning and the end of the line (i.e., by itself on the line.) Note that the regular expression ‘^$’ (a beginning and an end with nothing in between) will match blank lines.</p><p>这里我们分别在文件列表中搜索行首、行尾以及行首和行尾同时包含字符串“zip”（例如，zip 独占一行）的匹配行。 注意正则表达式‘^$’（行首和行尾之间没有字符）会匹配空行。</p><blockquote><p>A Crossword Puzzle Helper</p><p>字谜助手</p><p>Even with our limited knowledge of regular expressions at this point, we can do something useful.</p><p>到目前为止，甚至凭借我们有限的正则表达式知识，我们已经能做些有意义的事情了。</p><p>My wife loves crossword puzzles and she will sometimes ask me for help with a particular question. Something like, “what’s a five letter word whose third letter is ‘j’ and last letter is ‘r’ that means…?” This kind of question got me thinking.</p><p>我妻子喜欢玩字谜游戏，有时候她会因为一个特殊的问题，而向我求助。类似这样的问题，“一个 有五个字母的单词，它的第三个字母是‘j’，最后一个字母是‘r’，是哪个单词？”这类问题会 让我动脑筋想想。</p><p>Did you know that your Linux system contains a dictionary? It does. Take a look in the /usr/share/dict directory and you might find one, or several. The dictionary files located there are just long lists of words, one per line, arranged in alphabetical order. On my system, the words file contains just over 98,500 words. To find possible answers to the crossword puzzle question above, we could do this:</p><p>你知道你的 Linux 系统中带有一本英文字典吗？千真万确。看一下 /usr/share/dict 目录，你就能找到一本， 或几本。存储在此目录下的字典文件，其内容仅仅是一个长长的单词列表，每行一个单词，按照字母顺序排列。在我的 系统中，这个文件仅包含98,000个单词。为了找到可能的上述字谜的答案，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ grep -i &#39;^..j.r$&#39; /usr/share/dict/wordsMajormajor</code></pre><p>Using this regular expression, we can find all the words in our dictionary file that are five letters long and have a “j” in the third position and an “r” in the last position.</p><p>使用这个正则表达式，我们能在我们的字典文件中查找到包含五个字母，且第三个字母 是“j”，最后一个字母是“r”的所有单词。</p></blockquote><h3 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h3><p>In addition to matching any character at a given position in our regular expression, we can also match a single character from a specified set of characters by using bracket expressions. With bracket expressions, we can specify a set of characters (including characters that would otherwise be interpreted as metacharacters) to be matched. In this example, using a two character set:</p><p>除了能够在正则表达式中的给定位置匹配任意字符之外，通过使用中括号表达式， 我们也能够从一个指定的字符集合中匹配单个字符。通过中括号表达式，我们能够指定 一个待匹配字符集合（包含在不加中括号的情况下会被解释为元字符的字符）。在这个例子里，使用了一个两个字符的集合：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;[bg]zip&#39; dirlist*.txtbzip2bzip2recovergzip</code></pre><p>we match any line that contains the string “bzip” or “gzip”.</p><p>我们匹配包含字符串“bzip”或者“gzip”的任意行。</p><p>A set may contain any number of characters, and metacharacters lose their special meaning when placed within brackets. However, there are two cases in which metacharacters are used within bracket expressions, and have different meanings. The first is the caret (^), which is used to indicate negation; the second is the dash (-), which is used to indicate a character range.</p><p>一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。 然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符 是插入字符（^），其被用来表示否定；第二个是连字符字符（-），其被用来表示一个字符范围。</p><h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><p>If the first character in a bracket expression is a caret (^), the remaining characters are taken to be a set of characters that must not be present at the given character position. We do this by modifying our previous example:</p><p>如果在中括号表示式中的第一个字符是一个插入字符（^），则剩余的字符被看作是不会在给定的字符位置出现的 字符集合。通过修改之前的例子，我们试验一下：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;[^bg]zip&#39; dirlist*.txtbunzip2gunzipfunzipgpg-zippreunzipprezipprezip-binunzipunzipsfx</code></pre><p>With negation activated, we get a list of files that contain the string “zip” preceded by any character except “b” or “g”. Notice that the file zip was not found. A negated character set still requires a character at the given position, but the character must not be a member of the negated set.</p><p>通过激活否定操作，我们得到一个文件列表，它们的文件名都包含字符串“zip”，并且“zip”的前一个字符 是除了“b”和“g”之外的任意字符。注意文件 zip 没有被发现。一个否定的字符集仍然在给定位置要求一个字符， 但是这个字符必须不是否定字符集的成员。</p><p>The caret character only invokes negation if it is the first character within a bracket expression; otherwise, it loses its special meaning and becomes an ordinary character in the set.</p><p>插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去 它的特殊含义，变成字符集中的一个普通字符。</p><h3 id="传统的字符区域"><a href="#传统的字符区域" class="headerlink" title="传统的字符区域"></a>传统的字符区域</h3><p>If we wanted to construct a regular expression that would find every file in our lists beginning with an upper case letter, we could do this:</p><p>如果我们想要构建一个正则表达式，它可以在我们的列表中找到每个以大写字母开头的文件，我们 可以这样做：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;^[ABCDEFGHIJKLMNOPQRSTUVWXZY]&#39; dirlist*.txt</code></pre><p>It’s just a matter of putting all twenty-six upper case letters in a bracket expression. But the idea of all that typing is deeply troubling, so there is another way:</p><p>这只是一个在正则表达式中输入26个大写字母的问题。但是输入所有字母非常令人烦恼，所以有另外一种方式：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;^[A-Z]&#39; dirlist*.txtMAKEDEVControlPanelGETHEADPOSTXX11XorgMAKEFLOPPIESNetworkManagerNetworkManagerDispatcher</code></pre><p>By using a three character range, we can abbreviate the twenty-six letters. Any range of characters can be expressed this way including multiple ranges, such as this expression that matches all filenames starting with letters and numbers:</p><p>通过使用一个三个符区域，我们能够缩写26个字母。任意字符的区域都能按照这种方式表达，包括多个区域， 比如下面这个表达式就匹配了所有以字母和数字开头的文件名：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;^[A-Za-z0-9]&#39; dirlist*.txt</code></pre><p>In character ranges, we see that the dash character is treated specially, so how do we actually include a dash character in a bracket expression? By making it the first character in the expression. Consider these two examples:</p><p>在字符区域中，我们看到这个连字符被特殊对待，所以我们怎样在一个正则表达式中包含一个连字符呢？ 方法就是使连字符成为表达式中的第一个字符。考虑一下这两个例子：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;[A-Z]&#39; dirlist*.txt</code></pre><p>This will match every filename containing an upper case letter. While:</p><p>这会匹配包含一个大写字母的文件名。然而：</p><pre><code>[me@linuxbox ~]$ grep -h &#39;[-AZ]&#39; dirlist*.txt</code></pre><p>will match every filename containing a dash, or a upper case “A” or an uppercase “Z”.</p><p>上面的表达式会匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。</p><h3 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h3><p>The traditional character ranges are an easily understood and effective way to handle the problem of quickly specifying sets of characters. Unfortunately, they don’t always work. While we have not encountered any problems with our use of <code>grep</code> so far, we might run into problems using other programs.</p><p>传统的字符区域是一个易于理解和有效的方法，用来处理快速指定字符集合的问题。 不幸的是，它们不总是工作。到目前为止，虽然我们在使用 grep 程序的时候没有遇到任何问题， 但是我们可能在使用其它程序的时候会遭遇困难。</p><p>Back in Chapter 5, we looked at how wildcards are used to perform pathname expansion. In that discussion, we said that character ranges could be used in a manner almost identical to the way they are used in regular expressions, but here’s the problem:</p><p>回到第5章，我们看看通配符怎样被用来完成路径名展开操作。在那次讨论中，我们说过在 某种程度上，那个字符区域被使用的方式几乎与在正则表达式中的用法一样，但是有一个问题：</p><pre><code>[me@linuxbox ~]$ ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*/usr/sbin/MAKEFLOPPIES/usr/sbin/NetworkManagerDispatcher/usr/sbin/NetworkManager</code></pre><p>(Depending on the Linux distribution, we will get a different list of files, possibly an empty list. This example is from Ubuntu) This command produces the expected result — a list of only the files whose names begin with an uppercase letter, but:</p><p>（依赖于不同的 Linux 发行版，我们将得到不同的文件列表，有可能是一个空列表。这个例子来自于 Ubuntu） 这个命令产生了期望的结果——只有以大写字母开头的文件名，但是：</p><pre><code>[me@linuxbox ~]$ ls /usr/sbin/[A-Z]*/usr/sbin/biosdecode/usr/sbin/chat/usr/sbin/chgpasswd/usr/sbin/chpasswd/usr/sbin/chroot/usr/sbin/cleanup-info/usr/sbin/complain/usr/sbin/console-kit-daemon</code></pre><p>with this command we get an entirely different result (only a partial listing of the results is shown). Why is that? It’s a long story, but here’s the short version:</p><p>通过这个命令我们得到完全不同的结果（只列出了部分结果）。原因说来话长，简单来说就是：</p><p>Back when Unix was first developed, it only knew about ASCII characters, and this feature reflects that fact. In ASCII, the first thirty-two characters (numbers 0-31) are control codes (things like tabs, backspaces, and carriage returns). The next thirty-two (32-63) contain printable characters, including most punctuation characters and the numerals zero through nine. The next thirty-two (numbers 64-95) contain the uppercase letters and a few more punctuation symbols. The final thirty-one (numbers 96-127) contain the lowercase letters and yet more punctuation symbols. Based on this arrangement, systems using ASCII used a <code>collation order</code> that looked like this:</p><p>追溯到 Unix 刚刚开发的时候，它只知道 ASCII 字符，并且Unix特性也如实反映了这一事实。在 ASCII 中，前32个字符（数字0－31）都是控制码（如 tabs、backspaces和回车）。随后的32个字符（32－63）包含可打印的字符，包括大多数的标点符号和数字0到9。再随后的32个字符（64－95）包含大写字符和一些更多的标点符号。最后的31个字符（96－127）包含小写字母和更多的标点符号。基于这种安排方式，使用ASCII的系统的排序规则像下面这样：</p><pre><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code></pre><p>This differs from proper dictionary order, which is like this:</p><p>这个不同于正常的字典顺序，其像这样：</p><pre><code>aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ</code></pre><p>As the popularity of Unix spread beyond the United States, there grew a need to support characters not found in U.S. English. The ASCII table was expanded to use a full eight bits, adding characters numbers 128-255, which accommodated many more languages.</p><p>随着 Unix 系统的知名度在美国之外的国家传播开来，就需要支持不在 U.S.英语范围内的字符。于是就扩展了这个 ASCII 字符表，使用了整个8位，添加了字符（数字128－255），这样就容纳了更多的语言。</p><p>To support this ability, the POSIX standards introduced a concept called a locale, which could be adjusted to select the character set needed for a particular location. We can see the language setting of our system using this command:</p><p>为了支持这种功能，posix标准引入了”locale”概念，它能针对不同地区选择合适的字符集。：</p><pre><code>[me@linuxbox ~]$ echo $LANGen_US.UTF-8</code></pre><p>With this setting, POSIX compliant applications will use a dictionary collation order rather than ASCII order. This explains the behavior of the commands above. A character range of [A-Z] when interpreted in dictionary order includes all of the alphabetic characters except the lowercase “a”, hence our results.</p><p>通过这个设置，POSIX 相容的应用程序将会使用字典排列顺序而不是 ASCII 顺序。这就解释了上述命令的行为。当[A-Z]字符区域按照字典顺序解释的时候，包含除了小写字母“a”之外的所有字母，因此得到这样的结果。</p><p>To partially work around this problem, the POSIX standard includes a number of character classes which provide useful ranges of characters. They are described in the table below:</p><p>为了部分地解决这个问题，POSIX 标准包含了大量的字符集，其提供了有用的字符区域。如下表中所示：</p><table><thead><tr><th align="left">Character Class</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">[:alnum:]</td><td align="left">The alphanumeric characters. In ASCII, equivalent to: [A-Za-z0-9]</td></tr><tr><td align="left">[:word:]</td><td align="left">The same as [:alnum:], with the addition of the underscore (_) character.</td></tr><tr><td align="left">[:alpha:]</td><td align="left">The alphabetic characters. In ASCII, equivalent to: [A-Za-z]</td></tr><tr><td align="left">[:blank:]</td><td align="left">Includes the space and tab characters.</td></tr><tr><td align="left">[:cntrl:]</td><td align="left">The ASCII control codes. Includes the ASCII characters zero through thirty-one and 127.</td></tr><tr><td align="left">[:digit:]</td><td align="left">The numerals zero through nine.</td></tr><tr><td align="left">[:graph:]</td><td align="left">The visible characters. In ASCII, it includes characters 33 through 126.</td></tr><tr><td align="left">[:lower:]</td><td align="left">The lowercase letters.</td></tr><tr><td align="left">[:punct:]</td><td align="left">The punctuation characters. In ASCII, equivalent to:[-!”#$%&amp;’()*+,./:;&lt;=&gt;?@[\]_`{|}~]</td></tr><tr><td align="left">[:print:]</td><td align="left">The printable characters. All the characters in [:graph:] plus the space character.</td></tr><tr><td align="left">[:space:]</td><td align="left">The whitespace characters including space, tab, carriage return, newline, vertical tab, and form feed. In ASCII, equivalent to: [ \t\r\n\v\f]</td></tr><tr><td align="left">[:upper:]</td><td align="left">The upper case characters.</td></tr><tr><td align="left">[:xdigit:]</td><td align="left">Characters used to express hexadecimal numbers. In ASCII, equivalent to: [0-9A-Fa-f]</td></tr></tbody></table><table><thead><tr><th align="left">字符集</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">[:alnum:]</td><td align="left">字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]</td></tr><tr><td align="left">[:word:]</td><td align="left">与[:alnum:]相同, 但增加了下划线字符。</td></tr><tr><td align="left">[:alpha:]</td><td align="left">字母字符。在 ASCII 中，等价于：[A-Za-z]</td></tr><tr><td align="left">[:blank:]</td><td align="left">包含空格和 tab 字符。</td></tr><tr><td align="left">[:cntrl:]</td><td align="left">ASCII 的控制码。包含了0到31，和127的 ASCII 字符。</td></tr><tr><td align="left">[:digit:]</td><td align="left">数字0到9</td></tr><tr><td align="left">[:graph:]</td><td align="left">可视字符。在 ASCII 中，它包含33到126的字符。</td></tr><tr><td align="left">[:lower:]</td><td align="left">小写字母。</td></tr><tr><td align="left">[:punct:]</td><td align="left">标点符号字符。在 ASCII 中，等价于：[-!”#$%&amp;’()*+,./:;&lt;=&gt;?@[\]_`{|}~]</td></tr><tr><td align="left">[:print:]</td><td align="left">可打印的字符。在[:graph:]中的所有字符，再加上空格字符。</td></tr><tr><td align="left">[:space:]</td><td align="left">空白字符，包括空格、tab、回车、换行、vertical tab 和 form feed.在 ASCII 中， 等价于：[ \t\r\n\v\f]</td></tr><tr><td align="left">[:upper:]</td><td align="left">大写字母。</td></tr><tr><td align="left">[:xdigit:]</td><td align="left">用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f]</td></tr></tbody></table><p>Even with the character classes, there is still no convenient way to express partial ranges, such as [A-M].</p><p>甚至通过字符集，仍然没有便捷的方法来表达部分区域，比如[A-M]。</p><p>Using character classes, we can repeat our directory listing and see an improved result:</p><p>通过使用字符集，我们重做上述的例题，看到一个改进的结果：</p><pre><code>[me@linuxbox ~]$ ls /usr/sbin/[[:upper:]]*/usr/sbin/MAKEFLOPPIES/usr/sbin/NetworkManagerDispatcher/usr/sbin/NetworkManager</code></pre><p>Remember, however, that this is not an example of a regular expression, rather it is the shell performing pathname expansion. We show it here because POSIX character classes can be used for both.</p><p>记住，然而，这不是一个正则表达式的例子，而是 shell 正在执行路径名展开操作。我们在这里展示这个例子， 是因为 POSIX 规范的字符集适用于二者。</p><blockquote><p>Reverting To Traditional Collation Order</p><p>恢复到传统的排列顺序</p><p>You can opt to have your system use the traditional (ASCII) collation order by changing the value of the LANG environment variable. As we saw above, the LANG variable contains the name of the language and character set used in your locale. This value was originally determined when you selected an installation language as your Linux was installed.</p><p>通过改变环境变量 LANG 的值，你可以选择让你的系统使用传统的（ASCII）排列规则。如上所示，这个 LANG 变量包含了语种和字符集。这个值最初由你安装 Linux 系统时所选择的安装语言决定。</p><p>To see the locale settings, use the locale command:</p><p>使用 locale 命令，来查看 locale 的设置。</p><pre><code>[me@linuxbox ~]$ localeLANG=en_US.UTF-8LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=&quot;en_US.UTF-8&quot;LC_TIME=&quot;en_US.UTF-8&quot;LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=&quot;en_US.UTF-8&quot;LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=&quot;en_US.UTF-8&quot;LC_NAME=&quot;en_US.UTF-8&quot;LC_ADDRESS=&quot;en_US.UTF-8&quot;LC_TELEPHONE=&quot;en_US.UTF-8&quot;LC_MEASUREMENT=&quot;en_US.UTF-8&quot;LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;LC_ALL=</code></pre><p>To change the locale to use the traditional Unix behaviors, set the LANG variable to POSIX:</p><p>把这个 LANG 变量设置为 POSIX，来更改 locale，使其使用传统的 Unix 行为。</p><p><em>[me@linuxbox ~]$ export LANG=POSIX</em></p><p>Note that this change converts the system to use U.S. English (more specifically, ASCII) for its character set, so be sure if this is really what you want.</p><p>You can make this change permanent by adding this line to you your .bashrc file:</p><p>注意这个改动使系统为它的字符集使用 U.S.英语（更准确地说，ASCII），所以要确认一下这 是否是你真正想要的效果。通过把这条语句添加到你的.bashrc 文件中，你可以使这个更改永久有效。</p><p><em>export LANG=POSIX</em></p></blockquote><h3 id="POSIX基本正则表达式-与-POSIX扩展正则表达式"><a href="#POSIX基本正则表达式-与-POSIX扩展正则表达式" class="headerlink" title="POSIX基本正则表达式 与 POSIX扩展正则表达式"></a>POSIX基本正则表达式 与 POSIX扩展正则表达式</h3><p>Just when we thought this couldn’t get any more confusing, we discover that POSIX also splits regular expression implementations into two kinds: basic regular expressions (BRE) and extended regular expressions (ERE). The features we have covered so far are supported by any application that is POSIX-compliant and implements BRE. Our grep program is one such program.</p><p>就在我们认为这已经非常令人困惑了，我们却发现 POSIX 把正则表达式的实现分成了两类： 基本正则表达式（BRE）和扩展的正则表达式（ERE）。既服从 POSIX 规范又实现了 BRE 的任意应用程序，都支持我们目前研究的所有正则表达式特性。我们的 grep 程序就是其中一个。</p><p>What’s the difference between BRE and ERE? It’s a matter of metacharacters. With BRE, the following metacharacters are recognized:</p><p>BRE 和 ERE 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：</p><pre><code>^ $ . [ ] *</code></pre><p>All other characters are considered literals. With ERE, the following metacharacters (and their associated functions) are added:</p><p>其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:</p><pre><code>( ) { } ? + |</code></pre><p>However (and this is the fun part), the “(”, “)”, “{”, and “}” characters are treated as metacharacters in BRE if they are escaped with a backslash, whereas with ERE, preceding any metacharacter with a backslash causes it to be treated as a literal. Any weirdness that comes along will be covered in the discussions that follow.</p><p>然而（这也是有趣的地方），在 BRE 中，字符“(”，“)”，“{”，和 “}”用反斜杠转义后，被看作是元字符, 相反在 ERE 中，在任意元字符之前加上反斜杠会导致其被看作是一个文本字符。在随后的讨论中将会涵盖 很多奇异的特性。</p><p>Since the features we are going to discuss next are part of ERE, we are going to need to use a different grep. Traditionally, this has been performed by the egrep program, but the GNU version of grep also supports extended regular expressions when the -E option is used.</p><p>因为我们将要讨论的下一个特性是 ERE 的一部分，我们将要使用一个不同的 grep 程序。照惯例， 一直由 egrep 程序来执行这项操作，但是 GNU 版本的 grep 程序在使用了-E 选项之后也支持扩展的正则表达式。</p><blockquote><p>POSIX</p><p>During the 1980’s, Unix became a very popular commercial operating system, but by 1988, the Unix world was in turmoil. Many computer manufacturers had licensed the Unix source code from its creators, AT&amp;T, and were supplying various versions of the operating system with their systems. However, in their efforts to create product differentiation, each manufacturer added proprietary changes and extensions. This started to limit the compatibility of the software.</p><p>在 20 世纪 80 年代，Unix 成为一款非常流行的商业操作系统，但是到了1988年，Unix 世界 一片混乱。许多计算机制造商从 Unix 的创建者 AT&amp;T 那里得到了许可的 Unix 源码，并且 供应各种版本的操作系统。然而，在他们努力创造产品差异化的同时，每个制造商都增加了 专用的更改和扩展。这就开始限制了软件的兼容性。</p><p>As always with proprietary vendors, each was trying to play a winning game of “lock-in” with their customers. This dark time in the history of Unix is known today as “the Balkanization.”</p><p>专有软件供应商一如既往，每个供应商都试图玩嬴游戏“锁定”他们的客户。这个 Unix 历史上 的黑暗时代，就是今天众所周知的 “the Balkanization”。</p><p>Enter the IEEE (Institute of Electrical and Electronics Engineers). In the mid-1980s, the IEEE began developing a set of standards that would define how Unix (and Unix-like) systems would perform. These standards, formally known as IEEE 1003, define the application programming interfaces (APIs), shell and utilities that are to be found on a standard Unix-like system. The name “POSIX,” which stands for Portable Operating System Interface (with the “X” added to the end for extra snappiness), was suggested by Richard Stallman (yes, that Richard Stallman), and was adopted by the IEEE.</p><p>然后进入 IEEE（ 电气与电子工程师协会 ）时代。在上世纪 80 年代中叶，IEEE 开始制定一套标准， 其将会定义 Unix 系统（ 以及类 Unix 的系统 ）如何执行。这些标准，正式成为 IEEE 1003， 定义了应用程序编程接口（ APIs ），shell 和一些实用程序，其将会在标准的类 Unix 操作系统中找到。“POSIX” 这个名字，象征着可移植的操作系统接口（为了时髦一点，添加了末尾的 “X” ）， 是由 Richard Stallman 建议的（ 是的，的确是 Richard Stallman ），后来被 IEEE 采纳。</p></blockquote><h3 id="交替"><a href="#交替" class="headerlink" title="交替"></a>交替</h3><p>The first of the extended regular expression features we will discuss is called alternation, which is the facility that allows a match to occur from among a set of expressions. Just as a bracket expression allows a single character to match from a set of specified characters, alternation allows matches from a set of strings or other regular expressions. To demonstrate, we’ll use grep in conjunction with echo. First, let’s try a plain old string match:</p><p>我们将要讨论的扩展表达式的第一个特性叫做 alternation（交替），其是一款允许从一系列表达式 之间选择匹配项的实用程序。就像中括号表达式允许从一系列指定的字符之间匹配单个字符那样， alternation 允许从一系列字符串或者是其它的正则表达式中选择匹配项。为了说明问题， 我们将会结合 echo 程序来使用 grep 命令。首先，让我们试一个普通的字符串匹配：</p><pre><code>[me@linuxbox ~]$ echo &quot;AAA&quot; | grep AAAAAA[me@linuxbox ~]$ echo &quot;BBB&quot; | grep AAA[me@linuxbox ~]$</code></pre><p>A pretty straightforward example, in which we pipe the output of echo into grep and see the results. When a match occurs, we see it printed out; when no match occurs, we see no results.</p><p>一个相当直截了当的例子，我们把 echo 的输出管道给 grep，然后看到输出结果。当出现 一个匹配项时，我们看到它会打印出来；当没有匹配项时，我们看到没有输出结果。</p><p>Now we’ll add alternation, signified by the vertical bar metacharacter:</p><p>现在我们将添加 alternation，以竖杠线元字符为标记：</p><pre><code>[me@linuxbox ~]$ echo &quot;AAA&quot; | grep -E &#39;AAA|BBB&#39;AAA[me@linuxbox ~]$ echo &quot;BBB&quot; | grep -E &#39;AAA|BBB&#39;BBB[me@linuxbox ~]$ echo &quot;CCC&quot; | grep -E &#39;AAA|BBB&#39;[me@linuxbox ~]$</code></pre><p>Here we see the regular expression ‘AAA|BBB’ which means “match either the string AAA or the string BBB.” Notice that since this is an extended feature, we added the -E option to grep (though we could have just used the egrep program instead), and we enclosed the regular expression in quotes to prevent the shell from interpreting the vertical bar metacharacter as a pipe operator. Alternation is not limited to two choices:</p><p>这里我们看到正则表达式’AAA|BBB’，这意味着“匹配字符串 AAA 或者是字符串 BBB”。注意因为这是 一个扩展的特性，我们给 grep 命令（虽然我们能以 egrep 程序来代替）添加了-E 选项，并且我们 把这个正则表达式用单引号引起来，为的是阻止 shell 把竖杠线元字符解释为一个 pipe 操作符。 Alternation 并不局限于两种选择：</p><pre><code>[me@linuxbox ~]$ echo &quot;AAA&quot; | grep -E &#39;AAA|BBB|CCC&#39;AAA</code></pre><p>To combine alternation with other regular expression elements, we can use () to separate the alternation:</p><p>为了把 alternation 和其它正则表达式元素结合起来，我们可以使用()来分离 alternation。</p><pre><code>[me@linuxbox ~]$ grep -Eh &#39;^(bz|gz|zip)&#39; dirlist*.txt</code></pre><p>This expression will match the filenames in our lists that start with either “bz”, “gz”, or “zip”. Had we left off the parentheses, the meaning of this regular expression :</p><p>这个表达式将会在我们的列表中匹配以“bz”，或“gz”，或“zip”开头的文件名。如果我们删除了圆括号， 这个表达式的意思：</p><pre><code>[me@linuxbox ~]$ grep -Eh &#39;^bz|gz|zip&#39; dirlist*.txt</code></pre><p>changes to match any filename that begins with “bz” or contains “gz” or contains “zip”.</p><p>会变成匹配任意以“bz”开头，或包含“gz”，或包含“zip”的文件名。</p><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>Extended regular expressions support several ways to specify the number of times an element is matched.</p><p>扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。</p><h4 id="匹配零个或一个元素"><a href="#匹配零个或一个元素" class="headerlink" title="? - 匹配零个或一个元素"></a>? - 匹配零个或一个元素</h4><p>This quantifier means, in effect, “make the preceding element optional.” Let’s say we wanted to check a phone number for validity and we considered a phone number to be valid if it matched either of these two forms:</p><p>这个限定符意味着，实际上，“使前面的元素可有可无。”比方说我们想要查看一个电话号码的真实性， 如果它匹配下面两种格式的任意一种，我们就认为这个电话号码是真实的：</p><pre><code>(nnn) nnn-nnnnnnn nnn-nnnn</code></pre><p>where “n” is a numeral. We could construct a regular expression like this:</p><p>这里的“n”是一个数字。我们可以构建一个像这样的正则表达式：</p><pre><code>^\(?[0-9][0-9][0-9]\)?  [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</code></pre><p>In this expression, we follow the parentheses characters with question marks to indicate that they are to be matched zero or one time. Again, since the parentheses are normally metacharacters (in ERE), we precede them with backslashes to cause them to be treated as literals instead.</p><p>在这个表达式中，我们在圆括号之后加上一个问号，来表示它们将被匹配零次或一次。再一次，因为 通常圆括号都是元字符（在 ERE 中），所以我们在圆括号之前加上了反斜杠，使它们成为文本字符。</p><p>Let’s try it:</p><p>让我们试一下：</p><pre><code>[me@linuxbox ~]$ echo &quot;(555) 123-4567&quot; | grep -E &#39;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#39;(555) 123-4567[me@linuxbox ~]$ echo &quot;555 123-4567&quot; | grep -E &#39;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#39;555 123-4567[me@linuxbox ~]$ echo &quot;AAA 123-4567&quot; | grep -E &#39;^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#39;[me@linuxbox ~]$</code></pre><p>Here we see that the expression matches both forms of the phone number, but does not match one containing non-numeric characters.</p><p>这里我们看到这个表达式匹配这个电话号码的两种形式，但是不匹配包含非数字字符的号码。</p><h3 id="匹配零个或多个元素"><a href="#匹配零个或多个元素" class="headerlink" title="* - 匹配零个或多个元素"></a>* - 匹配零个或多个元素</h3><p>Like the ? metacharacter, the * is used to denote an optional item; however, unlike the ?, the item may occur any number of times, not just once. Let’s say we wanted to see if a string was a sentence; that is, it starts with an uppercase letter, then contains any number of upper and lowercase letters and spaces, and ends with a period. To match this (very crude) definition of a sentence, we could use a regular expression like this:</p><p>像 ? 元字符一样，这个 * 被用来表示一个可选的字符；然而，又与 ? 不同，匹配的字符可以出现 任意多次，不仅是一次。比方说我们想要知道是否一个字符串是一句话；也就是说，字符串开始于 一个大写字母，然后包含任意多个大写和小写的字母和空格，最后以句号收尾。为了匹配这个（非常粗略的） 语句的定义，我们能够使用一个像这样的正则表达式：</p><pre><code>[[:upper:]][[:upper:][:lower:] ]*.</code></pre><p>The expression consists of three items: a bracket expression containing the [:upper:] character class, a bracket expression containing both the [:upper:] and [:lower:] character classes and a space, and a period escaped with a backslash. The second element is trailed with an * metacharacter, so that after the leading uppercase letter in our sentence, any number of upper and lowercase letters and spaces may follow it and still match:</p><p>这个表达式由三个元素组成：一个包含[:upper:]字符集的中括号表达式，一个包含[:upper:]和[:lower:] 两个字符集以及一个空格的中括号表达式，和一个被反斜杠字符转义过的圆点。第二个元素末尾带有一个 *元字符，所以在开头的大写字母之后，可能会跟随着任意数目的大写和小写字母和空格，并且匹配：</p><pre><code>[me@linuxbox ~]$ echo &quot;This works.&quot; | grep -E &#39;[[:upper:]][[:upper:][:lower:] ]*\.&#39;This works.[me@linuxbox ~]$ echo &quot;This Works.&quot; | grep -E &#39;[[:upper:]][[:upper:][:lower:] ]*\.&#39;This Works.[me@linuxbox ~]$ echo &quot;this does not&quot; | grep -E &#39;[[:upper:]][[:upper:][:lower:] ]*\.&#39;[me@linuxbox ~]$</code></pre><p>The expression matches the first two tests, but not the third, since it lacks the required leading uppercase character and trailing period.</p><p>这个表达式匹配前两个测试语句，但不匹配第三个，因为第三个句子缺少开头的大写字母和末尾的句号。</p><h4 id="匹配一个或多个元素"><a href="#匹配一个或多个元素" class="headerlink" title="+ - 匹配一个或多个元素"></a>+ - 匹配一个或多个元素</h4><p>The + metacharacter works much like the *, except it requires at least one instance of the preceding element to cause a match. Here is a regular expression that will only match lines consisting of groups of one or more alphabetic characters separated by single spaces:</p><p>+ 元字符的作用与 * 非常相似，除了它要求前面的元素至少出现一次匹配。这个正则表达式只匹配 那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开：</p><pre><code>^([[:alpha:]]+ ?)+$[me@linuxbox ~]$ echo &quot;This that&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39;This that[me@linuxbox ~]$ echo &quot;a b c&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39;a b c[me@linuxbox ~]$ echo &quot;a b 9&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39;[me@linuxbox ~]$ echo &quot;abc  d&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39;[me@linuxbox ~]$</code></pre><p>We see that this expression does not match the line “a b 9” because it contains a non- alphabetic character; nor does it match “abc d” because more than one space character separates the characters “c” and “d”.</p><p>我们看到这个正则表达式不匹配“a b 9”这一行，因为它包含了一个非字母的字符；它也不匹配 “abc d” ，因为在字符“c”和“d”之间不止一个空格。</p><h4 id="匹配特定个数的元素"><a href="#匹配特定个数的元素" class="headerlink" title="{ } - 匹配特定个数的元素"></a>{ } - 匹配特定个数的元素</h4><p>The { and } metacharacters are used to express minimum and maximum numbers of required matches. They may be specified in four possible ways:</p><p>{ 和 } 元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：</p><table><thead><tr><th align="left">Specifier</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">{n}</td><td align="left">Match the preceding element if it occurs exactly n times.</td></tr><tr><td align="left">{n,m}</td><td align="left">Match the preceding element if it occurs at least n times, but no more than m times.</td></tr><tr><td align="left">{n,}</td><td align="left">Match the preceding element if it occurs n or more times.</td></tr><tr><td align="left">{,m}</td><td align="left">Match the preceding element if it occurs no more than m times.</td></tr></tbody></table><table><thead><tr><th align="left">限定符</th><th align="left">意思</th></tr></thead><tbody><tr><td align="left">{n}</td><td align="left">匹配前面的元素，如果它确切地出现了 n 次。</td></tr><tr><td align="left">{n,m}</td><td align="left">匹配前面的元素，如果它至少出现了 n 次，但是不多于 m 次。</td></tr><tr><td align="left">{n,}</td><td align="left">匹配前面的元素，如果它出现了 n 次或多于 n 次。</td></tr><tr><td align="left">{,m}</td><td align="left">匹配前面的元素，如果它出现的次数不多于 m 次。</td></tr></tbody></table><p>Going back to our earlier example with the phone numbers, we can use this method of specifying repetitions to simplify our original regular expression from:</p><p>回到之前处理电话号码的例子，我们能够使用这种指定重复次数的方法来简化我们最初的正则表达式：</p><pre><code>^\(?[0-9][0-9][0-9]\)?  [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</code></pre><p>简化为：</p><pre><code>^\(?[0-9]{3}\)?  [0-9]{3}-[0-9]{4}$</code></pre><p>Let’s try it:</p><p>让我们试一下：</p><pre><code>[me@linuxbox ~]$ echo &quot;(555) 123-4567&quot; | grep -E &#39;^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$&#39;(555) 123-4567[me@linuxbox ~]$ echo &quot;555 123-4567&quot; | grep -E &#39;^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$&#39;555 123-4567[me@linuxbox ~]$ echo &quot;5555 123-4567&quot; | grep -E &#39;^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$&#39;[me@linuxbox ~]$</code></pre><p>As we can see, our revised expression can successfully validate numbers both with and without the parentheses, while rejecting those numbers that are not properly formatted.</p><p>我们可以看到，我们修订的表达式能成功地验证带有和不带有圆括号的数字，而拒绝那些格式 不正确的数字。</p><h3 id="让正则表达式工作起来"><a href="#让正则表达式工作起来" class="headerlink" title="让正则表达式工作起来"></a>让正则表达式工作起来</h3><p>Let’s look at some of the commands we already know and see how they can be used with regular expressions.</p><p>让我们看看一些我们已经知道的命令，然后看一下它们怎样使用正则表达式。</p><h4 id="通过-grep-命令来验证一个电话簿"><a href="#通过-grep-命令来验证一个电话簿" class="headerlink" title="通过 grep 命令来验证一个电话簿"></a>通过 grep 命令来验证一个电话簿</h4><p>In our earlier example, we looked at single phone numbers and checked them for proper formatting. A more realistic scenario would be checking a list of numbers instead, so let’s make a list. We’ll do this by reciting a magical incantation to the command line. It will be magic because we have not covered most of the commands involved, but worry not. We will get there in future chapters. Here is the incantation:</p><p>在我们先前的例子中，我们查看过单个电话号码，并且检查了它们的格式。一个更现实的 情形是检查一个数字列表，所以我们先创建一个列表。我们将念一个神奇的咒语到命令行中。 它会很神奇，因为我们还没有涵盖所涉及的大部分命令，但是不要担心。我们将在后面的章节里面 讨论那些命令。这就是那个咒语：</p><pre><code>[me@linuxbox ~]$ for i in {1..10}; do echo &quot;(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}&quot; &gt;&gt; phonelist.txt; done</code></pre><p>This command will produce a file named phonelist.txt containing ten phone numbers. Each time the command is repeated, another ten numbers are added to the list. We can also change the value 10 near the beginning of the command to produce more or fewer phone numbers. If we examine the contents of the file, however, we see we have a problem:</p><p>这个命令会创建一个包含10个电话号码的名为 phonelist.txt 的文件。每次重复这个命令的时候，另外10个号码会被添加到这个列表中。我们也能够更改命令开头附近的数值10，来生成或多或少的电话号码。如果我们查看这个文件的内容，然而我们会发现一个问题：</p><pre><code>[me@linuxbox ~]$ cat phonelist.txt(232) 298-2265(624) 381-1078(540) 126-1980(874) 163-2885(286) 254-2860(292) 108-518(129) 44-1379(458) 273-1642(686) 299-8268(198) 307-2440</code></pre><p>Some of the numbers are malformed, which is perfect for our purposes, since we will use grep to validate them.</p><p>一些号码是残缺不全的，这正是我们想要的，因为我们将使用 grep 命令来验证电话号码的正确性。</p><p>One useful method of validation would be to scan the file for invalid numbers and display the resulting list on the display:</p><p>一个有用的验证方法是扫描这个文件，查找无效的号码，并把搜索结果显示到屏幕上：</p><pre><code>[me@linuxbox ~]$ grep -Ev &#39;^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$&#39;    phonelist.txt(292) 108-518(129) 44-1379[me@linuxbox ~]$</code></pre><p>Here we use the -v option to produce an inverse match so that we will only output the lines in the list that do not match the specified expression. The expression itself includes the anchor metacharacters at each end to ensure that the number has no extra characters at either end. This expression also requires that the parentheses be present in a valid number, unlike our earlier phone number example.</p><p>这里我们使用-v 选项来产生相反的匹配，因此我们将只输出不匹配指定表达式的文本行。这个 表达式自身的两端都包含定位点（锚）元字符，是为了确保这个号码的两端没有多余的字符。 这个表达式也要求圆括号出现在一个有效的号码中，不同于我们先前电话号码的实例。</p><h4 id="用-find-查找丑陋的文件名"><a href="#用-find-查找丑陋的文件名" class="headerlink" title="用 find 查找丑陋的文件名"></a>用 find 查找丑陋的文件名</h4><p>The find command supports a test based on a regular expression. There is an important consideration to keep in mind when using regular expressions in find versus grep. Whereas grep will print a line when the line contains a string that matches an expression, find requires that the pathname exactly match the regular expression. In the following example, we will use find with a regular expression to find every pathname that contains any character that is not a member of the following set:</p><p>这个 find 命令支持一个基于正则表达式的测试。当在使用正则表达式方面比较 find 和 grep 命令的时候， 还有一个重要问题要牢记在心。当某一行包含的字符串匹配上了一个表达式的时候，grep 命令会打印出这一行， 然而 find 命令要求路径名精确地匹配这个正则表达式。在下面的例子里面，我们将使用带有一个正则 表达式的 find 命令，来查找每个路径名，其包含的任意字符都不是以下字符集中的一员。</p><pre><code>[-\_./0-9a-zA-Z]</code></pre><p>Such a scan would reveal pathnames that contain embedded spaces and other potentially offensive characters:</p><p>这样一种扫描会发现包含空格和其它潜在不规范字符的路径名：</p><pre><code>[me@linuxbox ~]$ find . -regex &#39;.*[^-\_./0-9a-zA-Z].*&#39;</code></pre><p>Due to the requirement for an exact match of the entire pathname, we use .* at both ends of the expression to match zero or more instances of any character. In the middle of the expression, we use a negated bracket expression containing our set of acceptable pathname characters.</p><p>由于要精确地匹配整个路径名，所以我们在表达式的两端使用了.*，来匹配零个或多个字符。 在表达式中间，我们使用了否定的中括号表达式，其包含了我们一系列可接受的路径名字符。</p><h4 id="用-locate-查找文件"><a href="#用-locate-查找文件" class="headerlink" title="用 locate 查找文件"></a>用 locate 查找文件</h4><p>The locate program supports both basic (the –regexp option) and extended (the – regex option) regular expressions. With it, we can perform many of the same operations that we performed earlier with our dirlist files:</p><p>这个 locate 程序支持基本的（–regexp 选项）和扩展的（–regex 选项）正则表达式。通过 locate 命令，我们能够执行许多与先前操作 dirlist 文件时相同的操作：</p><pre><code>[me@linuxbox ~]$ locate --regex &#39;bin/(bz|gz|zip)&#39;/bin/bzcat/bin/bzcmp/bin/bzdiff/bin/bzegrep/bin/bzexe/bin/bzfgrep/bin/bzgrep/bin/bzip2/bin/bzip2recover/bin/bzless/bin/bzmore/bin/gzexe/bin/gzip/usr/bin/zip/usr/bin/zipcloak/usr/bin/zipgrep/usr/bin/zipinfo/usr/bin/zipnote/usr/bin/zipsplit</code></pre><p>Using alternation, we perform a search for pathnames that contain either bin/bz, bin/gz, or /bin/zip.</p><p>通过使用 alternation，我们搜索包含 bin/bz，bin/gz，或/bin/zip 字符串的路径名。</p><h4 id="在-less-和-vim-中查找文本"><a href="#在-less-和-vim-中查找文本" class="headerlink" title="在 less 和 vim 中查找文本"></a>在 less 和 vim 中查找文本</h4><p>less and vim both share the same method of searching for text. Pressing the / key followed by a regular expression will perform a search. If we use less to view our phonelist.txt file:</p><p>less 和 vim 两者享有相同的文本查找方法。按下/按键，然后输入正则表达式，来执行搜索任务。 如果我们使用 less 程序来浏览我们的 phonelist.txt 文件：</p><pre><code>[me@linuxbox ~]$ less phonelist.txt</code></pre><p>Then search for our validation expression:</p><p>然后查找我们有效的表达式：</p><pre><code>(232) 298-2265(624) 381-1078(540) 126-1980(874) 163-2885(286) 254-2860(292) 108-518(129) 44-1379(458) 273-1642(686) 299-8268(198) 307-2440~~~/^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$</code></pre><p>less will highlight the strings that match, leaving the invalid ones easy to spot:</p><p>less 将会高亮匹配到的字符串，这样就很容易看到无效的电话号码：</p><pre><code>(232) 298-2265(624) 381-1078(540) 126-1980(874) 163-2885(286) 254-2860(292) 108-518(129) 44-1379(458) 273-1642(686) 299-8268(198) 307-2440~~~(END)</code></pre><p>vim, on the other hand, supports basic regular expressions, so our search expression would look like this:</p><p>另一方面，vim 支持基本的正则表达式，所以我们用于搜索的表达式看起来像这样：</p><pre><code>/([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}</code></pre><p>We can see that the expression is mostly the same; however, many of the characters that are considered metacharacters in extended expressions are considered literals in basic expressions. They are only treated as metacharacters when escaped with a backslash.</p><p>我们看到表达式几乎一样；然而，在扩展表达式中，许多被认为是元字符的字符在基本的表达式 中被看作是文本字符。只有用反斜杠把它们转义之后，它们才被看作是元字符。</p><p>Depending on the particular configuration of vim on our system, the matching will be highlighted. If not, try this command mode command:</p><p>依赖于系统中 vim 的特殊配置，匹配项将会被高亮。如若不是，试试这个命令模式：</p><pre><code>:hlsearch</code></pre><p>to activate search highlighting.</p><p>来激活搜索高亮功能。</p><hr><p>Note: Depending on your distribution, vim may or may not support text search highlighting. Ubuntu, in particular, supplies a very stripped-down version of vim by default. On such systems, you may want to use your package manager to install a more complete version of vim.</p><p>注意：依赖于你的发行版，vim 有可能支持或不支持文本搜索高亮功能。尤其是 Ubuntu 自带了 一款非常简化的 vim 版本。在这样的系统中，你可能要使用你的软件包管理器来安装一个功能 更完备的 vim 版本。</p><hr><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this chapter, we’ve seen a few of the many uses of regular expressions. We can find even more if we use regular expressions to search for additional applications that use them. We can do that by searching the man pages:</p><p>在这章中，我们已经看到几个使用正则表达式例子。如果我们使用正则表达式来搜索那些使用正则表达式的应用程序， 我们可以找到更多的使用实例。通过查找手册页，我们就能找到：</p><pre><code>[me@linuxbox ~]$ cd /usr/share/man/man1[me@linuxbox man1]$ zgrep -El &#39;regex|regular expression&#39; *.gz</code></pre><p>The zgrep program provides a front end for grep, allowing it to read compressed files. In our example, we search the compressed section one man page files located in their usual location. The result of this command is a list of files containing either the string “regex” or “regular expression”. As we can see, regular expressions show up in a lot of programs.</p><p>这个 zgrep 程序是 grep 的前端，允许 grep 来读取压缩文件。在我们的例子中，我们在手册文件所在的 目录中，搜索压缩文件中的内容。这个命令的结果是一个包含字符串“regex”或者“regular expression”的文件列表。正如我们所看到的，正则表达式会出现在大量程序中。</p><p>There is one feature found in basic regular expressions that we did not cover. Called back references, this feature will be discussed in the next chapter.</p><p>基本正则表达式中有一个特性，我们没有涵盖。叫做反引用，这个特性在下一章中会被讨论到。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>There are many online resources for learning regular expressions, including various tutorials and cheat sheets.</p><p>有许多在线学习正则表达式的资源，包括各种各样的教材和速记表。</p><p>In addition, the Wikipedia has good articles on the following background topics:</p><p>另外，关于下面的背景话题，Wikipedia 有不错的文章。</p><ul><li>POSIX: <a href="http://en.wikipedia.org/wiki/Posix" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Posix</a></li><li>ASCII: <a href="http://en.wikipedia.org/wiki/Ascii" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ascii</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十九章 归档和备份</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%BD%92%E6%A1%A3%E5%92%8C%E5%A4%87%E4%BB%BD/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%BD%92%E6%A1%A3%E5%92%8C%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>One of the primary tasks of a computer system’s administrator is keeping the system’s data secure. One way this is done is by performing timely backups of the system’s files. Even if you’re not system administrators, it is often useful to make copies of things and to move large collections of files from place to place and from device to device. In this chapter, we will look at several common programs that are used to manage collections of files. There are the file compression programs:</p><p>计算机系统管理员的一个主要任务就是保护系统的数据安全，其中一种方法是通过时时备份系统文件，来保护 数据。即使你不是一名系统管理员，像做做拷贝或者在各个位置和设备之间移动大量的文件，通常也是很有帮助的。 在这一章中，我们将会看看几个经常用来管理文件集合的程序。它们就是文件压缩程序：</p><ul><li>gzip – Compress or expand files</li><li>gzip – 压缩或者展开文件</li><li>bzip2 – A block sorting file compressor</li><li>bzip2 – 块排序文件压缩器</li></ul><p>The archiving programs:</p><p>归档程序：</p><ul><li>tar – Tape archiving utility</li><li>tar – 磁带打包工具</li><li>zip – Package and compress files</li><li>zip – 打包和压缩文件</li></ul><p>And the file synchronization program:</p><p>还有文件同步程序：</p><ul><li>rsync – Remote file and directory synchronization</li><li>rsync – 同步远端文件和目录</li></ul><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>Throughout the history of computing, there has been a struggle to get the most data into the smallest available space, whether that space be memory, storage devices or network bandwidth. Many of the data services that we take for granted today, such as portable music players, high definition television, or broadband Internet, owe their existence to effective data compression techniques.</p><p>纵观计算领域的发展历史，人们努力想把最多的数据存放到到最小的可用空间中，不管是内存，存储设备 还是网络带宽。今天我们把许多数据服务都看作是理所当然的事情，但是诸如便携式音乐播放器， 高清电视，或宽带网络之类的存在都应归功于高效的数据压缩技术。</p><p>Data compression is the process of removing redundancy from data. Let’s consider an imaginary example. Say we had an entirely black picture file with the dimensions of one hundred pixels by one hundred pixels. In terms of data storage (assuming twenty-four bits, or three bytes per pixel), the image will occupy thirty thousand bytes of storage:</p><p>数据压缩就是一个删除冗余数据的过程。让我们考虑一个假想的例子，比方说我们有一张100*100像素的 纯黑的图片文件。根据数据存储方案（假定每个像素占24位，或者3个字节），那么这张图像将会占用 30,000个字节的存储空间：</p><pre><code>100 * 100 * 3 = 30,000</code></pre><p>An image that is all one color contains entirely redundant data. If we were clever, we could encode the data in such a way that we simply describe the fact that we have a block of thirty thousand black pixels. So, instead of storing a block of data containing thirty thousand zeros (black is usually represented in image files as zero), we could compress the data into the number 30,000, followed by a zero to represent our data. Such a data compression scheme is called run-length encoding and is one of the most rudimentary compression techniques. Today’s techniques are much more advanced and complex but the basic goal remains the same—get rid of redundant data.</p><p>一张单色图像包含的数据全是多余的。我们要是聪明的话，可以用这种方法来编码这些数据， 我们只要简单地描述这个事实，我们有3万个黑色的像素数据块。所以，我们不存储包含3万个0 （通常在图像文件中，黑色由0来表示）的数据块，取而代之，我们把这些数据压缩为数字30,000， 后跟一个0，来表示我们的数据。这种数据压缩方案被称为游程编码，是一种最基本的压缩技术。今天的技术更加先进和复杂，但是基本目标依然不变——避免多余数据。</p><p>Compression algorithms (the mathematical techniques used to carry out the compression) fall into two general categories, lossless and lossy. Lossless compression preserves all the data contained in the original. This means that when a file is restored from a compressed version, the restored file is exactly the same as the original, uncompressed version. Lossy compression, on the other hand, removes data as the compression is performed, to allow more compression to be applied. When a lossy file is restored, it does not match the original version; rather, it is a close approximation. Examples of lossy compression are JPEG (for images) and MP3 (for music.) In our discussion, we will look exclusively at lossless compression, since most data on computers cannot tolerate any data loss.</p><p>压缩算法（数学技巧被用来执行压缩任务）分为两大类，无损压缩和有损压缩。无损压缩保留了 原始文件的所有数据。这意味着，当还原一个压缩文件的时候，还原的文件与原文件一模一样。 而另一方面，有损压缩，执行压缩操作时会删除数据，允许更大的压缩。当一个有损文件被还原的时候， 它与原文件不相匹配; 相反，它是一个近似值。有损压缩的例子有 JPEG（图像）文件和 MP3（音频）文件。 在我们的讨论中，我们将看看完全无损压缩，因为计算机中的大多数数据是不能容忍丢失任何数据的。</p><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>The gzip program is used to compress one or more files. When executed, it replaces the original file with a compressed version of the original. The corresponding gunzip program is used to restore compressed files to their original, uncompressed form. Here is an example:</p><p>这个 gzip 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 gunzip 程序被用来把压缩文件复原为没有被压缩的版本。这里有个例子：</p><pre><code>[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt[me@linuxbox ~]$ gzip foo.txt[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz[me@linuxbox ~]$ gunzip foo.txt.gz[me@linuxbox ~]$ ls -l foo.*-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt</code></pre><p>In this example, we create a text file named foo.txt from a directory listing. Next, we run gzip, which replaces the original file with a compressed version named foo.txt.gz. In the directory listing of foo.*, we see that the original file has been replaced with the compressed version, and that the compressed version about one-fifth the size of the original. We can also see that the compressed file has the same permissions and time stamp as the original.</p><p>在这个例子里，我们创建了一个名为 foo.txt 的文本文件，其内容包含一个目录的列表清单。 接下来，我们运行 gzip 命令，它会把原始文件替换为一个叫做 foo.txt.gz 的压缩文件。在 foo.* 文件列表中，我们看到原始文件已经被压缩文件替代了，并将这个压缩文件大约是原始 文件的五分之一。我们也能看到压缩文件与原始文件有着相同的权限和时间戳。</p><p>Next, we run the gunzip program to uncompress the file. Afterward, we can see that the compressed version of the file has been replaced with the original, again with the permissions and time stamp preserved.</p><p>接下来，我们运行 gunzip 程序来解压缩文件。随后，我们能见到压缩文件已经被原始文件替代了， 同样地保留了相同的权限和时间戳。</p><p>gzip has many options. Here are a few:</p><p>gzip 命令有许多选项。这里列出了一些：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">Write output to standard output and keep original files. May also be specified with –stdout and –to-stdout.</td></tr><tr><td align="left">-d</td><td align="left">Decompress. This causes gzip to act like gunzip. May also be specified with –decompress or –uncompress.</td></tr><tr><td align="left">-f</td><td align="left">Force compression even if compressed version of the original file already exists. May also be specified with –force.</td></tr><tr><td align="left">-h</td><td align="left">Display usage information. May also be specified with –help.</td></tr><tr><td align="left">-l</td><td align="left">List compression statistics for each file compressed. May also be specified with –list.</td></tr><tr><td align="left">-r</td><td align="left">If one or more arguments on the command line are directories, recursively compress files contained within them. May also be specified with –recursive.</td></tr><tr><td align="left">-t</td><td align="left">Test the integrity of a compressed file. May also be specified with –test.</td></tr><tr><td align="left">-v</td><td align="left">Display verbose messages while compressing. May also be specified with –verbose.</td></tr><tr><td align="left">-number</td><td align="left">Set amount of compression. number is an integer in the range of 1 (fastest, least compression) to 9 (slowest, most compression). The values 1 and 9 may also be expressed as –fast and –best, respectively. The default value is 6.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">把输出写入到标准输出，并且保留原始文件。也有可能用–stdout 和–to-stdout 选项来指定。</td></tr><tr><td align="left">-d</td><td align="left">解压缩。正如 gunzip 命令一样。也可以用–decompress 或者–uncompress 选项来指定.</td></tr><tr><td align="left">-f</td><td align="left">强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用–force 选项来指定。</td></tr><tr><td align="left">-h</td><td align="left">显示用法信息。也可用–help 选项来指定。</td></tr><tr><td align="left">-l</td><td align="left">列出每个被压缩文件的压缩数据。也可用–list 选项。</td></tr><tr><td align="left">-r</td><td align="left">若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用–recursive 选项来指定。</td></tr><tr><td align="left">-t</td><td align="left">测试压缩文件的完整性。也可用–test 选项来指定。</td></tr><tr><td align="left">-v</td><td align="left">显示压缩过程中的信息。也可用–verbose 选项来指定。</td></tr><tr><td align="left">-number</td><td align="left">设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用–fast 和–best 选项来表示。默认值是整数6。</td></tr></tbody></table><p>Going back to our earlier example:</p><p>返回到我们之前的例子中：</p><pre><code>[me@linuxbox ~]$ gzip foo.txt[me@linuxbox ~]$ gzip -tv foo.txt.gzfoo.txt.gz: OK[me@linuxbox ~]$ gzip -d foo.txt.gz</code></pre><p>Here, we replaced the file foo.txt with a compressed version, named foo.txt.gz. Next, we tested the integrity of the compressed version, using the -t and -v options. Finally, we decompressed the file back to its original form. gzip can also be used in interesting ways via standard input and output:</p><p>这里，我们用压缩文件来替代文件 foo.txt，压缩文件名为 foo.txt.gz。下一步，我们测试了压缩文件 的完整性，使用了-t 和-v 选项。</p><pre><code>[me@linuxbox ~]$ ls -l /etc | gzip &gt; foo.txt.gz</code></pre><p>This command creates a compressed version of a directory listing.</p><p>这个命令创建了一个目录列表的压缩文件。</p><p>The gunzip program, which uncompresses gzip files, assumes that filenames end in the extension .gz, so it’s not necessary to specify it, as long as the specified name is not in conflict with an existing uncompressed file:</p><p>这个 gunzip 程序，会解压缩 gzip 文件，假定那些文件名的扩展名是.gz，所以没有必要指定它， 只要指定的名字与现有的未压缩文件不冲突就可以：</p><pre><code>[me@linuxbox ~]$ gunzip foo.txt.gz</code></pre><p>If our goal were only to view the contents of a compressed text file, we can do this:</p><p>如果我们的目标只是为了浏览一下压缩文本文件的内容，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ gunzip -c foo.txt.gz | less</code></pre><p>Alternately, there is a program supplied with gzip, called zcat, that is equivalent to gunzip with the -c option. It can be used like the cat command on gzip compressed files:</p><p>另外，对应于 gzip 还有一个程序，叫做 zcat，它等同于带有-c 选项的 gunzip 命令。 它可以被用来如 cat 命令作用于 gzip 压缩文件：</p><pre><code>[me@linuxbox ~]$ zcat foo.txt.gz | less</code></pre><hr><p><em>Tip:</em> There is a zless program, too. It performs the same function as the pipeline above.</p><p><em>小贴士:</em> 还有一个 zless 程序。它与上面的管道线有相同的功能。</p><hr><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>The bzip2 program, by Julian Seward, is similar to gzip, but uses a different compression algorithm that achieves higher levels of compression at the cost of compression speed. In most regards, it works in the same fashion as gzip. A file compressed with bzip2 is denoted with the extension .bz2:</p><p>这个 bzip2 程序，由 Julian Seward 开发，与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。 由 bzip2 压缩的文件，用扩展名 .bz2 来表示：</p><pre><code>[me@linuxbox ~]$ ls -l /etc &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-r--r-- 1 me     me      15738 2008-10-17 13:51 foo.txt[me@linuxbox ~]$ bzip2 foo.txt[me@linuxbox ~]$ ls -l foo.txt.bz2-rw-r--r-- 1 me     me      2792 2008-10-17 13:51 foo.txt.bz2[me@linuxbox ~]$ bunzip2 foo.txt.bz2</code></pre><p>As we can see, bzip2 can be used the same way as gzip. All the options (except for -r) that we discussed for gzip are also supported in bzip2. Note, however, that the compression level option (-number) has a somewhat different meaning to bzip2. bzip2 comes with bunzip2 and bzcat for decompressing files. bzip2 also comes with the bzip2recover program, which will try to recover damaged .bz2 files.</p><p>正如我们所看到的，bzip2 程序使用起来和 gzip 程序一样。我们之前讨论的 gzip 程序的所有选项（除了-r） ，bzip2 程序同样也支持。注意，然而，压缩级别选项（-number）对于 bzip2 程序来说，有少许不同的含义。 伴随着 bzip2 程序，有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p><blockquote><p>Don’t Be Compressive Compulsive</p><p>不要强迫性压缩</p><p>I occasionally see people attempting to compress a file, which has been already compressed with an effective compression algorithm, by doing something like this:</p><p>我偶然见到人们试图用高效的压缩算法，来压缩一个已经被压缩过的文件，通过这样做：</p><p><em>$ gzip picture.jpg</em></p><p>Don’t do it. You’re probably just wasting time and space! If you apply compression to a file that is already compressed, you will actually end up a larger file. This is because all compression techniques involve some overhead that is added to the file to describe the compression. If you try to compress a file that already contains no redundant information, the compression will not result in any savings to offset the additional overhead.</p><p>不要这样。你可能只是在浪费时间和空间！如果你再次压缩已经压缩过的文件，实际上你 会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文件中会被添加描述 此次压缩过程的信息。如果你试图压缩一个已经不包含多余信息的文件，那么再次压缩不会节省 空间，以抵消额外的花费。</p></blockquote><h3 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h3><p>A common file management task used in conjunction with compression is archiving. Archiving is the process of gathering up many files and bundling them together into a single large file. Archiving is often done as a part of system backups. It is also used when old data is moved from a system to some type of long-term storage.</p><p>一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把它们 捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某 种类型的长期存储设备中时，也会用到归档程序。</p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>In the Unix-like world of software, the tar program is the classic tool for archiving files. Its name, short for tape archive, reveals its roots as a tool for making backup tapes. While it is still used for that traditional task, it is equally adept on other storage devices as well. We often see filenames that end with the extension .tar or .tgz which indicate a “plain” tar archive and a gzipped archive, respectively. A tar archive can consist of a group of separate files, one or more directory hierarchies, or a mixture of both. The command syntax works like this:</p><p>在类 Unix 的软件世界中，这个 tar 程序是用来归档文件的经典工具。它的名字，是 tape archive 的简称，揭示了它的根源，它是一款制作磁带备份的工具。而它仍然被用来完成传统任务， 它也同样适用于其它的存储设备。我们经常看到扩展名为 .tar 或者 .tgz 的文件，它们各自表示“普通” 的 tar 包和被 gzip 程序压缩过的 tar 包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者 两者混合体组成。命令语法如下：</p><pre><code>tar mode[options] pathname...</code></pre><p>where mode is one of the following operating modes (only a partial list is shown here; see the tar man page for a complete list):</p><p>这里的 mode 是指以下操作模式（这里只展示了一部分，查看 tar 的手册来得到完整列表）之一：</p><table><thead><tr><th align="left">Mode</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">Create an archive from a list of files and/or directories.</td></tr><tr><td align="left">x</td><td align="left">Extract an archive.</td></tr><tr><td align="left">r</td><td align="left">Append specified pathnames to the end of an archive.</td></tr><tr><td align="left">t</td><td align="left">List the contents of an archive.</td></tr></tbody></table><table><thead><tr><th align="left">模式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">为文件和／或目录列表创建归档文件。</td></tr><tr><td align="left">x</td><td align="left">抽取归档文件。</td></tr><tr><td align="left">r</td><td align="left">追加具体的路径到归档文件的末尾。</td></tr><tr><td align="left">t</td><td align="left">列出归档文件的内容。</td></tr></tbody></table><p>tar uses a slightly odd way of expressing options, so we’ll need some examples to show how it works. First, let’s re-create our playground from the previous chapter:</p><p>tar 命令使用了稍微有点奇怪的方式来表达它的选项，所以我们需要一些例子来展示它是 怎样工作的。首先，让我们重新创建之前我们用过的操练场:</p><pre><code>[me@linuxbox ~]$ mkdir -p playground/dir-{00{1..9},0{10..99},100}[me@linuxbox ~]$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}</code></pre><p>Next, let’s create a tar archive of the entire playground:</p><p>下一步，让我们创建整个操练场的 tar 包：</p><pre><code>[me@linuxbox ~]$ tar cf playground.tar playground</code></pre><p>This command creates a tar archive named playground.tar that contains the entire playground directory hierarchy. We can see that the mode and the f option, which is used to specify the name of the tar archive, may be joined together, and do not require a leading dash. Note, however, that the mode must always be specified first, before any other option.</p><p>这个命令创建了一个名为 playground.tar 的 tar 包，其包含整个 playground 目录层次结果。我们 可以看到模式 c 和选项 f，其被用来指定这个 tar 包的名字，模式和选项可以写在一起，而且不 需要开头的短横线。注意，然而，必须首先指定模式，然后才是其它的选项。</p><p>To list the contents of the archive, we can do this:</p><p>要想列出归档文件的内容，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ tar tf playground.tar</code></pre><p>For a more detailed listing, we can add the v (verbose) option:</p><p>为了得到更详细的列表信息，我们可以添加选项 v：</p><pre><code>[me@linuxbox ~]$ tar tvf playground.tar</code></pre><p>Now, let’s extract the playground in a new location. We will do this by creating a new directory named foo, and changing the directory and extracting the tar archive:</p><p>现在，抽取 tar 包 playground 到一个新位置。我们先创建一个名为 foo 的新目录，更改目录， 然后抽取 tar 包中的文件：</p><pre><code>[me@linuxbox ~]$ mkdir foo[me@linuxbox ~]$ cd foo[me@linuxbox ~]$ tar xf ../playground.tar[me@linuxbox ~]$ lsplayground</code></pre><p>If we examine the contents of ~/foo/playground, we see that the archive was successfully installed, creating a precise reproduction of the original files. There is one caveat, however: unless you are operating as the superuser, files and directories extracted from archives take on the ownership of the user performing the restoration, rather than the original owner.</p><p>如果我们检查 ~/foo/playground 目录中的内容，会看到这个归档文件已经被成功地安装了，也即创建了 一个精确的原始文件的副本。然而，这里有一个警告：除非你是超级用户，要不然从归档文件中抽取的文件 和目录的所有权由执行此复原操作的用户所拥有，而不属于原始所有者。</p><p>Another interesting behavior of tar is the way it handles pathnames in archives. The default for pathnames is relative, rather than absolute. tar does this by simply removing any leading slash from the pathname when creating the archive. To demonstrate, we will recreate our archive, this time specifying an absolute pathname:</p><p>tar 命令另一个有趣的行为是它处理归档文件路径名的方式。默认情况下，路径名是相对的，而不是绝对 路径。当以相对路径创建归档文件的时候，tar 命令会简单地删除路径名开头的斜杠。为了说明问题，我们将会 重新创建我们的归档文件，但是这次指定用绝对路径创建：</p><pre><code>[me@linuxbox foo]$ cd[me@linuxbox ~]$ tar cf playground2.tar ~/playground</code></pre><p>Remember, ~/playground will expand into /home/me/playground when we press the enter key, so we will get an absolute pathname for our demonstration. Next, we will extract the archive as before and watch what happens:</p><p>记住，当按下回车键后，~/playground 会展开成 /home/me/playground，所以我们将会得到一个 绝对路径名。接下来，和之前一样我们会抽取归档文件，观察发生什么事情：</p><pre><code>[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ tar xf ../playground2.tar[me@linuxbox foo]$ lshome     playground[me@linuxbox foo]$ ls homeme[me@linuxbox foo]$ ls home/meplayground</code></pre><p>Here we can see that when we extracted our second archive, it recreated the directory home/me/playground relative to our current working directory, ~/foo, not relative to the root directory, as would have been the case with an absolute pathname. This may seem like an odd way for it to work, but it’s actually more useful this way, as it allows us to extract archives to any location rather than being forced to extract them to their original locations. Repeating the exercise with the inclusion of the verbose option (v) will give a clearer picture of what’s going on.</p><p>这里我们看到当我们抽取第二个归档文件时，它重新创建了 home/me/playground 目录， 相对于我们当前的工作目录，~/foo，而不是相对于 root 目录，作为带有绝对路径名的案例。 这看起来似乎是一种奇怪的工作方式，但事实上这种方式很有用，因为这样就允许我们抽取文件 到任意位置，而不是强制地把抽取的文件放置到原始目录下。加上 verbose（v）选项，重做 这个练习，将会展现更加详细的信息。</p><p>Let’s consider a hypothetical, yet practical example, of tar in action. Imagine we want to copy the home directory and its contents from one system to another and we have a large USB hard drive that we can use for the transfer. On our modern Linux system, the drive is “automagically” mounted in the /media directory. Let’s also imagine that the disk has a volume name of BigDisk when we attach it. To make the tar archive, we can do the following:</p><p>让我们考虑一个假设，tar 命令的实际应用。假定我们想要复制家目录及其内容到另一个系统中， 并且有一个大容量的 USB 硬盘，可以把它作为传输工具。在现代 Linux 系统中， 这个硬盘会被“自动地”挂载到 /media 目录下。我们也假定硬盘中有一个名为 BigDisk 的逻辑卷。 为了制作 tar 包，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ sudo tar cf /media/BigDisk/home.tar /home</code></pre><p>After the tar file is written, we unmount the drive and attach it to the second computer. Again, it is mounted at /media/BigDisk. To extract the archive, we do this:</p><p>tar 包制作完成之后，我们卸载硬盘，然后把它连接到第二个计算机上。再一次，此硬盘被 挂载到 /media/BigDisk 目录下。为了抽取归档文件，我们这样做：</p><pre><code>[me@linuxbox2 ~]$ cd /[me@linuxbox2 /]$ sudo tar xf /media/BigDisk/home.tar</code></pre><p>What’s important to see here is that we must first change directory to /, so that the extraction is relative to the root directory, since all pathnames within the archive are relative.</p><p>值得注意的一点是，因为归档文件中的所有路径名都是相对的，所以首先我们必须更改目录到根目录下， 这样抽取的文件路径就相对于根目录了。</p><p>When extracting an archive, it’s possible to limit what is extracted from the archive. For example, if we wanted to extract a single file from an archive, it could be done like this:</p><p>当抽取一个归档文件时，有可能限制从归档文件中抽取什么内容。例如，如果我们想要抽取单个文件， 可以这样实现：</p><pre><code>tar xf archive.tar pathname</code></pre><p>By adding the trailing pathname to the command, tar will only restore the specified file. Multiple pathnames may be specified. Note that the pathname must be the full, exact relative pathname as stored in the archive. When specifying pathnames, wildcards are not normally supported; however, the GNU version of tar (which is the version most often found in Linux distributions) supports them with the –wildcards option. Here is an example using our previous playground.tar file:</p><p>通过给命令添加末尾的路径名，tar 命令就只会恢复指定的文件。可以指定多个路径名。注意 路径名必须是完全的，精准的相对路径名，就如存储在归档文件中的一样。当指定路径名的时候， 通常不支持通配符；然而，GNU 版本的 tar 命令（在 Linux 发行版中最常出现）通过 –wildcards 选项来 支持通配符。这个例子使用了之前 playground.tar 文件：</p><pre><code>[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ tar xf ../playground2.tar --wildcards &#39;home/me/playground/dir-\*/file-A&#39;</code></pre><p>This command will extract only files matching the specified pathname including the wildcard dir-*.</p><p>这个命令将只会抽取匹配特定路径名的文件，路径名中包含了通配符 dir-*。</p><p>tar is often used in conjunction with find to produce archives. In this example, we will use find to produce a set of files to include in an archive:</p><p>tar 命令经常结合 find 命令一起来制作归档文件。在这个例子里，我们将会使用 find 命令来 产生一个文件集合，然后这些文件被包含到归档文件中。</p><pre><code>[me@linuxbox ~]$ find playground -name &#39;file-A&#39; -exec tar rf playground.tar &#39;{}&#39; &#39;+&#39;</code></pre><p>Here we use find to match all the files in playground named file-A and then, using the -exec action, we invoke tar in the append mode (r) to add the matching files to the archive playground.tar.</p><p>这里我们使用 find 命令来匹配 playground 目录中所有名为 file-A 的文件，然后使用-exec 行为，来 唤醒带有追加模式（r）的 tar 命令，把匹配的文件添加到归档文件 playground.tar 里面。</p><p>Using tar with find is a good way of creating incremental backups of a directory tree or an entire system. By using find to match files newer than a timestamp file, we could create an archive that only contains files newer than the last archive, assuming that the timestamp file is updated right after each archive is created.</p><p>使用 tar 和 find 命令，来创建逐渐增加的目录树或者整个系统的备份，是个不错的方法。通过 find 命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件， 假定这个时间戳文件恰好在每个归档文件创建之后被更新了。</p><p>tar can also make use of both standard input and output. Here is a comprehensive example:</p><p>tar 命令也可以利用标准输出和输入。这里是一个完整的例子:</p><pre><code>[me@linuxbox foo]$ cd[me@linuxbox ~]$ find playground -name &#39;file-A&#39; | tar cf - --files-from=-   | gzip &gt; playground.tgz</code></pre><p>In this example, we used the find program to produce a list of matching files and piped them into tar. If the filename “-” is specified, it is taken to mean standard input or output, as needed (by the way, this convention of using “-” to represent standard input/output is used by a number of other programs, too.) The –files-from option (which may be also be specified as -T) causes tar to read its list of pathnames from a file rather than the command line. Lastly, the archive produced by tar is piped into gzip to create the compressed archive playground.tgz. The .tgz extension is the conventional extension given to gzip-compressed tar files. The extension .tar.gz is also used sometimes.</p><p>在这个例子里面，我们使用 find 程序产生了一个匹配文件列表，然后把它们管道到 tar 命令中。 如果指定了文件名“-”，则其被看作是标准输入或输出，正是所需（顺便说一下，使用“-”来表示 标准输入／输出的惯例，也被大量的其它程序使用）。这个 –file-from 选项（也可以用 -T 来指定） 导致 tar 命令从一个文件而不是命令行来读入它的路径名列表。最后，这个由 tar 命令产生的归档 文件被管道到 gzip 命令中，然后创建了压缩归档文件 playground.tgz。此 .tgz 扩展名是命名 由 gzip 压缩的 tar 文件的常规扩展名。有时候也会使用 .tar.gz 这个扩展名。</p><p>While we used the gzip program externally to produced our compressed archive, modern versions of GNU tar support both gzip and bzip2 compression directly, with the use of the z and j options, respectively. Using our previous example as a base, we can simplify it this way:</p><p>虽然我们使用 gzip 程序来制作我们的压缩归档文件，但是现在的 GUN 版本的 tar 命令 ，gzip 和 bzip2 压缩两者都直接支持，各自使用 z 和 j 选项。以我们之前的例子为基础， 我们可以这样简化它：</p><pre><code>[me@linuxbox ~]$ find playground -name &#39;file-A&#39; | tar czf playground.tgz -T -</code></pre><p>If we had wanted to create a bzip2 compressed archive instead, we could have done this:</p><p>如果我们本要创建一个由 bzip2 压缩的归档文件，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ find playground -name &#39;file-A&#39; | tar cjf playground.tbz -T -</code></pre><p>By simply changing the compression option from z to j (and changing the output file’s extension to .tbz to indicate a bzip2 compressed file) we enabled bzip2 compression. Another interesting use of standard input and output with the tar command involves transferring files between systems over a network. Imagine that we had two machines running a Unix-like system equipped with tar and ssh. In such a scenario, we could transfer a directory from a remote system (named remote-sys for this example) to our local system:</p><p>通过简单地修改压缩选项，把 z 改为 j（并且把输出文件的扩展名改为 .tbz，来指示一个 bzip2 压缩文件）， 就使 bzip2 命令压缩生效了。另一个 tar 命令与标准输入和输出的有趣使用，涉及到在系统之间经过 网络传输文件。假定我们有两台机器，每台都运行着类 Unix，且装备着 tar 和 ssh 工具的操作系统。 在这种情景下，我们可以把一个目录从远端系统（名为 remote-sys）传输到我们的本地系统中：</p><pre><code>[me@linuxbox ~]$ mkdir remote-stuff[me@linuxbox ~]$ cd remote-stuff[me@linuxbox remote-stuff]$ ssh remote-sys &#39;tar cf - Documents&#39; | tar xf -me@remote-sys’s password:[me@linuxbox remote-stuff]$ lsDocuments</code></pre><p>Here we were able to copy a directory named Documents from the remote system remote-sys to a directory within the directory named remote-stuff on the local system. How did we do this? First, we launched the tar program on the remote system using ssh. You will recall that ssh allows us to execute a program remotely on a networked computer and “see” the results on the local system—the standard output produced on the remote system is sent to the local system for viewing. We can take advantage of this by having tar create an archive (the c mode) and send it to standard output, rather than a file (the f option with the dash argument), thereby transporting the archive over the encrypted tunnel provided by ssh to the local system. On the local system, we execute tar and have it expand an archive (the x mode) supplied from standard input (again, the f option with the dash argument).</p><p>这里我们能够从远端系统 remote-sys 中复制目录 Documents 到本地系统名为 remote-stuff 目录中。 我们怎样做的呢？首先，通过使用 ssh 命令在远端系统中启动 tar 程序。你可记得 ssh 允许我们 在远程联网的计算机上执行程序，并且在本地系统中看到执行结果——远端系统中产生的输出结果 被发送到本地系统中查看。我们可以利用。在本地系统中，我们执行 tar 命令，</p><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>The zip program is both a compression tool and an archiver. The file format used by the program is familiar to Windows users, as it reads and writes .zip files. In Linux, however, gzip is the predominant compression program with bzip2 being a close second.</p><p>这个 zip 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，Windows 用户比较熟悉， 因为它读取和写入.zip 文件。然而，在 Linux 中 gzip 是主要的压缩程序，而 bzip2则位居第二。</p><p>In its most basic usage, zip is invoked like this:</p><p>在 zip 命令最基本的使用中，可以这样唤醒 zip 命令：</p><pre><code>zip options zipfile file...</code></pre><p>For example, to make a zip archive of our playground, we would do this:</p><p>例如，制作一个 playground 的 zip 版本的文件包，这样做：</p><pre><code>[me@linuxbox ~]$ zip -r playground.zip playground</code></pre><p>Unless we include the -r option for recursion, only the playground directory (but none of its contents) is stored. Although the addition of the extension .zip is automatic a, we will include the file extension for clarity.</p><p>除非我们包含-r 选项，要不然只有 playground 目录（没有任何它的内容）被存储。虽然会自动添加 .zip 扩展名，但为了清晰起见，我们还是包含文件扩展名。</p><p>During the creation of the zip archive, zip will normally display a series of messages like this:</p><p>在创建 zip 版本的文件包时，zip 命令通常会显示一系列的信息：</p><pre><code>adding: playground/dir-020/file-Z (stored 0%)adding: playground/dir-020/file-Y (stored 0%)adding: playground/dir-020/file-X (stored 0%)adding: playground/dir-087/ (stored 0%)adding: playground/dir-087/file-S (stored 0%)</code></pre><p>These messages show the status of each file added to the archive. zip will add files to the archive using one of two storage methods: either it will “store” a file without compression, as shown here, or it will “deflate” the file which performs compression. The numeric value displayed after the storage method indicates the amount of compression achieved. Since our playground only contains empty files, no compression is performed on its contents.</p><p>这些信息显示了添加到文件包中每个文件的状态。zip 命令会使用两种存储方法之一，来添加 文件到文件包中：要不它会“store”没有压缩的文件，正如这里所示，或者它会“deflate”文件， 执行压缩操作。在存储方法之后显示的数值表明了压缩量。因为我们的 playground 目录 只是包含空文件，没有对它的内容执行压缩操作。</p><p>Extracting the contents of a zip file is straightforward when using the unzip program:</p><p>使用 unzip 程序，来直接抽取一个 zip 文件的内容。</p><pre><code>[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ unzip ../playground.zip</code></pre><p>One thing to note about zip (as opposed to tar) is that if an existing archive is specified, it is updated rather than replaced. This means that the existing archive is preserved, but new files are added and matching files are replaced. Files may be listed and extracted selectively from a zip archive by specifying them to unzip:</p><p>对于 zip 命令（与 tar 命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新 而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。可以列出 文件或者有选择地从一个 zip 文件包中抽取文件，只要给 unzip 命令指定文件名：</p><pre><code>[me@linuxbox ~]$ unzip -l playground.zip playground/dir-87/file-ZArchive: ../playground.zip    Length      Date    Time    Name         0    10-05-08  09:25   playground/dir-87/file-Z         0                      1 file[me@linuxbox ~]$ cd foo[me@linuxbox foo]$ unzip ./playground.zip playground/dir-87/file-ZArchive: ../playground.zipreplace playground/dir-87/file-Z? [y]es, [n]o, [A]ll, [N]one,[r]ename: yextracting: playground/dir-87/file-Z</code></pre><p>Using the -l option causes unzip to merely list the contents of the archive without extracting the file. If no file(s) are specified, unzip will list all files in the archive. The -v option can be added to increase the verbosity of the listing. Note that when the archive extraction conflicts with an existing file, the user is prompted before the file is replaced.</p><p>使用-l 选项，导致 unzip 命令只是列出文件包中的内容而没有抽取文件。如果没有指定文件， unzip 程序将会列出文件包中的所有文件。添加这个-v 选项会增加列表的冗余信息。注意当抽取的 文件与已经存在的文件冲突时，会在替代此文件之前提醒用户。</p><p>Like tar, zip can make use of standard input and output, though its implementation is somewhat less useful. It is possible to pipe a list of filenames to zip via the -@ option:</p><p>像 tar 命令一样，zip 命令能够利用标准输入和输出，虽然它的实施不大有用。通过-@选项，有可能把一系列的 文件名管道到 zip 命令。</p><pre><code>[me@linuxbox foo]$ cd[me@linuxbox ~]$ find playground -name &quot;file-A&quot; | zip -@ file-A.zip</code></pre><p>Here we use find to generate a list of files matching the test -name “file-A”, and pipe the list into zip, which creates the archive file-A.zip containing the selected files.</p><p>这里我们使用 find 命令产生一系列与“file-A”相匹配的文件列表，并且把此列表管道到 zip 命令， 然后创建包含所选文件的文件包 file-A.zip。</p><p>zip also supports writing its output to standard output, but its use is limited because very few programs can make use of the output. Unfortunately, the unzip program, does not accept standard input. This prevents zip and unzip from being used together to perform network file copying like tar.</p><p>zip 命令也支持把它的输出写入到标准输出，但是它的使用是有限的，因为很少的程序能利用输出。 不幸地是，这个 unzip 程序，不接受标准输入。这就阻止了 zip 和 unzip 一块使用，像 tar 命令那样， 来复制网络上的文件。</p><p>zip can, however, accept standard input, so it can be used to compress the output of other programs:</p><p>然而，zip 命令可以接受标准输入，所以它可以被用来压缩其它程序的输出：</p><pre><code>[me@linuxbox ~]$ ls -l /etc/ | zip ls-etc.zip -adding: - (deflated 80%)</code></pre><p>In this example we pipe the output of ls into zip. Like tar, zip interprets the trailing dash as “use standard input for the input file.”</p><p>在这个例子里，我们把 ls 命令的输出管道到 zip 命令。像 tar 命令，zip 命令把末尾的横杠解释为 “使用标准输入作为输入文件。”</p><p>The unzip program allows its output to be sent to standard output when the -p (for pipe) option is specified:</p><p>这个 unzip 程序允许它的输出发送到标准输出，当指定了-p 选项之后：</p><pre><code>[me@linuxbox ~]$ unzip -p ls-etc.zip | less</code></pre><p>We touched on some of the basic things that zip/unzip can do. They both have a lot of options that add to their flexibility, though some are platform specific to other systems. The man pages for both zip and unzip are pretty good and contain useful examples. However, the main use of these programs is for exchanging files with Windows systems, rather than performing compression and archiving on Linux, where tar and gzip are greatly preferred.</p><p>我们讨论了一些 zip/unzip 可以完成的基本操作。它们两个都有许多选项，其增加了 命令的灵活性，虽然一些选项只针对于特定的平台。zip 和 unzip 命令的说明手册都相当不错， 并且包含了有用的实例。然而，这些程序的主要用途是为了和 Windows 系统交换文件， 而不是在 Linux 系统中执行压缩和打包操作，tar 和 gzip 程序在 Linux 系统中更受欢迎。</p><h3 id="同步文件和目录"><a href="#同步文件和目录" class="headerlink" title="同步文件和目录"></a>同步文件和目录</h3><p>A common strategy for maintaining a backup copy of a system involves keeping one or more directories synchronized with another directory (or directories) located on either the local system (usually a removable storage device of some kind) or with a remote system. We might, for example, have a local copy of a web site under development and synchronize it from time to time with the “live” copy on a remote web server. In the Unix-like world, the preferred tool for this task is rsync. This program can synchronize both local and remote directories by using the rsync remote-update protocol, which allows rsync to quickly detect the differences between two directories and perform the minimum amount of copying required to bring them into sync. This makes rsync very fast and economical to use, compared to other kinds of copy programs.</p><p>维护系统备份的常见策略是保持一个或多个目录与另一个本地系统（通常是某种可移动的存储设备） 或者远端系统中的目录（或多个目录）同步。我们可能，例如有一个正在开发的网站的本地备份， 需要时不时的与远端网络服务器中的文件备份保持同步。在类 Unix 系统的世界里，能完成此任务且 备受人们喜爱的工具是 rsync。这个程序能同步本地与远端的目录，通过使用 rsync 远端更新协议，此协议 允许 rsync 快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。比起其它种类的复制程序， 这就使 rsync 命令非常快速和高效。</p><p>rsync is invoked like this:</p><p>rsync 被这样唤醒：</p><pre><code>rsync options source destination</code></pre><p>where source and destination are one of the following:</p><p>这里 source 和 destination 是下列选项之一：</p><ul><li>A local file or directory</li><li>A remote file or directory in the form of [user@]host:path</li><li>A remote rsync server specified with a URI of rsync://[user@]host[:port]/path</li><li>一个本地文件或目录</li><li>一个远端文件或目录，以[user@]host:path 的形式存在</li><li>一个远端 rsync 服务器，由 rsync://[user@]host[:port]/path 指定</li></ul><p>Note that either the source or destination must be a local file. Remote to remote copying is not supported.</p><p>注意 source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制</p><p>Let’s try rsync out on some local files. First, let’s clean out our foo directory:</p><p>让我们试着对一些本地文件使用 rsync 命令。首先，清空我们的 foo 目录：</p><pre><code>[me@linuxbox ~]$ rm -rf foo/*</code></pre><p>Next, we’ll synchronize the playground directory with a corresponding copy in foo:</p><p>下一步，我们将同步 playground 目录和它在 foo 目录中相对应的副本</p><pre><code>[me@linuxbox ~]$ rsync -av playground foo</code></pre><p>We’ve included both the -a option (for archiving—causes recursion and preservation of file attributes) and the -v option (verbose output) to make a mirror of the playground directory within foo. While the command runs, we will see a list of the files and directories being copied. At the end, we will see a summary message like this:</p><p>我们包括了-a 选项（递归和保护文件属性）和-v 选项（冗余输出）， 来在 foo 目录中制作一个 playground 目录的镜像。当这个命令执行的时候， 我们将会看到一系列的文件和目录被复制。在最后，我们将看到一条像这样的总结信息：</p><pre><code>sent 135759 bytes received 57870 bytes 387258.00 bytes/sectotal size is 3230 speedup is 0.02</code></pre><p>indicating the amount of copying performed. If we run the command again, we will see a different result:</p><p>说明复制的数量。如果我们再次运行这个命令，我们将会看到不同的结果：</p><pre><code>[me@linuxbox ~]$ rsync -av playgound foobuilding file list ... donesent 22635 bytes received 20 bytestotal size is 3230 speedup is 0.1445310.00 bytes/sec</code></pre><p>Notice that there was no listing of files. This is because rsync detected that there were no differences between ~/playground and ~/foo/playground, and therefore it didn’t need to copy anything. If we modify a file in playground and run rsync again:</p><p>注意到没有文件列表。这是因为 rsync 程序检测到在目录~/playground 和 ~/foo/playground 之间 不存在差异，因此它不需要复制任何数据。如果我们在 playground 目录中修改一个文件，然后 再次运行 rsync 命令：</p><pre><code>[me@linuxbox ~]$ touch playground/dir-099/file-Z[me@linuxbox ~]$ rsync -av playground foobuilding file list ... doneplayground/dir-099/file-Zsent 22685 bytes received 42 bytes 45454.00 bytes/sectotal size is 3230 speedup is 0.14</code></pre><p>we see that rsync detected the change and copied only the updated file. As a practical example, let’s consider the imaginary external hard drive that we used earlier with tar. If we attach the drive to our system and, once again, it is mounted at / media/BigDisk, we can perform a useful system backup by first creating a directory, named /backup on the external drive and then using rsync to copy the most important stuff from our system to the external drive:</p><p>我们看到 rsync 命令检测到更改，并且只是复制了更新的文件。作为一个实际的例子， 让我们考虑一个假想的外部硬盘，之前我们在 tar 命令中用到过的。如果我们再次把此 硬盘连接到我们的系统中，它被挂载到/media/BigDisk 目录下，我们可以执行一个有 用的系统备份了，首先在外部硬盘上创建一个目录，名为/backup，然后使用 rsync 程序 从我们的系统中复制最重要的数据到此外部硬盘上：</p><pre><code>[me@linuxbox ~]$ mkdir /media/BigDisk/backup[me@linuxbox ~]$ sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup</code></pre><p>In this example, we copied the /etc, /home, and /usr/local directories from our system to our imaginary storage device. We included the –delete option to remove files that may have existed on the backup device that no longer existed on the source device (this is irrelevant the first time we make a backup, but will be useful on subsequent copies.) Repeating the procedure of attaching the external drive and running this rsync command would be a useful (though not ideal) way of keeping a small system backed up. Of course, an alias would be helpful here, too. We could create an alias and add it to our .bashrc file to provide this feature:</p><p>在这个例子里，我们把/etc，/home，和/usr/local 目录从我们的系统中复制到假想的存储设备中。 我们包含了–delete 这个选项，来删除可能在备份设备中已经存在但却不再存在于源设备中的文件， （这与我们第一次创建备份无关，但是会在随后的复制操作中有用途）。挂载外部驱动器，运行 rsync 命令，不断重复这个过程，是一个不错的（虽然不理想）方式来保存少量的系统备份文件。 当然，别名会对这个操作更有帮助些。我们将会创建一个别名，并把它添加到.bashrc 文件中， 来提供这个特性：</p><pre><code>alias backup=&#39;sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup&#39;</code></pre><p>Now all we have to do is attach our external drive and run the backup command to do the job.</p><p>现在我们所做的事情就是连接外部驱动器，然后运行 backup 命令来完成工作。</p><h4 id="在网络间使用-rsync-命令"><a href="#在网络间使用-rsync-命令" class="headerlink" title="在网络间使用 rsync 命令"></a>在网络间使用 rsync 命令</h4><p>One of the real beauties of rsync is that it can be used to copy files over a network. After all, the “r” in rsync stands for “remote.” Remote copying can be done in one of two ways. The first way is with another system that has rsync installed, along with a remote shell program such as ssh. Let’s say we had another system on our local network with a lot of available hard drive space and we wanted to perform our backup operation using the remote system instead of an external drive. Assuming that it already had a directory named /backup where we could deliver our files, we could do this:</p><p>rsync 程序的真正好处之一，是它可以被用来在网络间复制文件。毕竟，rsync 中的“r”象征着“remote”。 远程复制可以通过两种方法完成。第一个方法要求另一个系统已经安装了 rsync 程序，还安装了 远程 shell 程序，比如 ssh。比方说我们本地网络中的一个系统有大量可用的硬盘空间，我们想要 用远程系统来代替一个外部驱动器，来执行文件备份操作。假定远程系统中有一个名为/backup 的目录， 其用来存放我们传送的文件，我们这样做：</p><pre><code>[me@linuxbox ~]$ sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup</code></pre><p>We made two changes to our command to facilitate the network copy. First, we added the –rsh=ssh option, which instructs rsync to use the ssh program as its remote shell. In this way, we were able to use an ssh encrypted tunnel to securely transfer the data from the local system to the remote host. Second, we specified the remote host by prefixing its name (in this case the remote host is named remote-sys) to the destination path name.</p><p>我们对命令做了两处修改，来方便网络间文件复制。首先，我们添加了–rsh=ssh 选项，其指示 rsync 使用 ssh 程序作为它的远程 shell。以这种方式，我们就能够使用一个 ssh 加密通道，把数据 安全地传送到远程主机中。其次，通过在目标路径名前加上远端主机的名字（在这种情况下， 远端主机名为 remote-sys），来指定远端主机。</p><p>The second way that rsync can be used to synchronize files over a network is by using an rysnc server. rsync can be configured to run as a daemon and listen to incoming requests for synchronization. This is often done to allow mirroring of a remote system. For example, Red Hat Software maintains a large repository of software packages under development for its Fedora distribution. It is useful for software testers to mirror this collection during the testing phase of the distribution release cycle. Since files in the repository change frequently (often more than once a day), it is desirable to maintain a local mirror by periodic synchronization, rather than by bulk copying of the repository. One of these repositories is kept at Georgia Tech; we could mirror it using our local copy of rsync and their rsync server like this:</p><p>rsync 可以被用来在网络间同步文件的第二种方式是通过使用 rsync 服务器。rsync 可以被配置为一个 守护进程，监听即将到来的同步请求。这样做经常是为了进行一个远程系统的镜像操作。例如，Red Hat 软件中心为它的 Fedora 发行版，维护着一个巨大的正在开发中的软件包的仓库。对于软件测试人员， 在发行周期的测试阶段，定期镜像这些软件集合是非常有帮助的。因为仓库中的这些文件会频繁地 （通常每天不止一次）改动，定期同步本地镜像而不是大量地拷贝软件仓库，这是更为明智的。 这些软件库之一被维护在乔治亚理工大学；我们可以使用本地 rsync 程序和它们的 rsync 服务器来镜像它。</p><pre><code>[me@linuxbox ~]$ mkdir fedora-devel[me@linuxbox ~]$ rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linux- core/development/i386/os fedora-devel</code></pre><p>In this example, we use the URI of the remote rsync server, which consists of a protocol (rsync://), followed by the remote host name (rsync.gtlib.gatech.edu), followed by the pathname of the repository.</p><p>在这个例子里，我们使用了远端 rsync 服务器的 URI，其由协议（rsync://），远端主机名 （rsync.gtlib.gatech.edu），和软件仓库的路径名组成。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The man pages for all of the commands discussed here are pretty clear and contain useful examples. In addition, the GNU Project has a good online manual for its version of tar. It can be found here:</p></li><li><p>在这里讨论的所有命令的手册文档都相当清楚明白，并且包含了有用的例子。另外， GNU 版本的 tar 命令有一个不错的在线文档。可以在下面链接处找到：</p><p><a href="http://www.gnu.org/software/tar/manual/index.html" target="_blank" rel="noopener">http://www.gnu.org/software/tar/manual/index.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十八章 查找文件</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>As we have wandered around our Linux system, one thing has become abundantly clear: a typical Linux system has a lot of files! This begs the question, “how do we find things?” We already know that the Linux file system is well organized according to conventions that have been passed down from one generation of Unix-like system to the next, but the sheer number of files can present a daunting problem. In this chapter, we will look at two tools that are used to find files on a system. These tools are:</p><p>随着我们在Linux 系统中的不断探索， 一件事已经变得非常清楚：一个典型的 Linux 系统包含很多文件！ 这就引发了一个问题，“我们怎样查找东西？”。虽然我们已经知道 Linux 文件系统已经根据类 Unix 系统的 代代相传的惯例而被良好地组织起来了。但是海量的文件会引起一个可怕的问题。在这一章中，我们将察看 两个用来在系统中查找文件的工具。这些工具是：</p><ul><li>locate – Find files by name</li><li>locate – 通过名字来查找文件</li><li>find – Search for files in a directory hierarchy</li><li>find – 在一个目录层次结构中搜索文件</li></ul><p>We will also look at a command that is often used with file search commands to process the resulting list of files:</p><p>我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：</p><ul><li>xargs – Build and execute command lines from standard input</li><li>xargs – 从标准输入生成和执行命令行</li></ul><p>In addition, we will introduce a couple of commands to assist us in our exploration:</p><p>另外，我们将介绍两个命令以便在我们探索的过程中协助我们：</p><ul><li>touch – Change file times</li><li>touch – 更改文件时间</li><li>stat – Display file or file system status</li><li>stat – 显示文件或文件系统状态</li></ul><h3 id="locate-查找文件的简单方法"><a href="#locate-查找文件的简单方法" class="headerlink" title="locate - 查找文件的简单方法"></a>locate - 查找文件的简单方法</h3><p>The locate program performs a rapid database search of pathnames and outputs every name that matches a given substring. Say, for example, we want to find all the programs with names that begin with “zip.” Since we are looking for programs, we can assume that the directory containing the programs would end with “bin/”. Therefore, we could try to use locate this way to find our files:</p><p>这个 locate 程序会执行一次快速的路径名数据库搜索，并且输出每个与给定子字符串相匹配的路径名。比如说， 例如，我们想要找到所有名字以“zip”开头的程序。因为我们正在查找程序，可以假定包含 程序的目录以”bin/”结尾。因此，我们试着以这种方式使用 locate 命令，来找到我们的文件：</p><pre><code>[me@linuxbox ~]$ locate bin/zip</code></pre><p>locate will search its database of pathnames and output any that contain the string “bin/zip”:</p><p>locate 命令将会搜索它的路径名数据库，输出任一个包含字符串“bin/zip”的路径名：</p><pre><code>/usr/bin/zip/usr/bin/zipcloak/usr/bin/zipgrep/usr/bin/zipinfo/usr/bin/zipnote/usr/bin/zipsplit</code></pre><p>If the search requirement is not so simple, locate can be combined with other tools such as grep to design more interesting searches:</p><p>如果搜索要求没有这么简单，locate 可以结合其它工具，比如说 grep 命令，来设计更加 有趣的搜索：</p><pre><code>[me@linuxbox ~]$ locate zip | grep bin/bin/bunzip2/bin/bzip2/bin/bzip2recover/bin/gunzip/bin/gzip/usr/bin/funzip/usr/bin/gpg-zip/usr/bin/preunzip/usr/bin/prezip/usr/bin/prezip-bin/usr/bin/unzip/usr/bin/unzipsfx/usr/bin/zip/usr/bin/zipcloak/usr/bin/zipgrep/usr/bin/zipinfo/usr/bin/zipnote/usr/bin/zipsplit</code></pre><p>The locate program has been around for a number of years, and there are several different variants in common use. The two most common ones found in modern Linux distributions are slocate and mlocate, though they are usually accessed by a symbolic link named locate. The different versions of locate have overlapping options sets. Some versions include regular expression matching (which we’ll cover in an upcoming chapter) and wild card support. Check the man page for locate to determine which version of locate is installed.</p><p>这个 locate 程序已经存在了很多年了，它有几个不同的变体被普遍使用着。在现在 Linux 发行版中两个最常见的变体是 slocate 和 mlocate，尽管它们通常被名为 locate 的 符号链接访问。不同版本的 locate 命令拥有重叠的选项集合。一些版本包括正则表达式 匹配（我们会在下一章中讨论）和通配符支持。可以查看 locate 命令的手册来确定安装了 哪个版本的 locate 程序。</p><blockquote><p>Where Does The locate Database Come From?</p><p>locate 数据库来自何方？</p><p>You may notice that, on some distributions, locate fails to work just after the system is installed, but if you try again the next day, it works fine. What gives? The locate database is created by another program named updatedb. Usually, it is run periodically as a cron job; that is, a task performed at regular intervals by the cron daemon. Most systems equipped with locate run updatedb once a day. Since the database is not updated continuously, you will notice that very recent files do not show up when using locate. To overcome this, it’s possible to run the updatedb program manually by becoming the superuser and running updatedb at the prompt.</p><p>你可能注意到了，在一些发行版中，仅仅在系统安装之后，locate 不能工作， 但是如果你第二天再试一下，它就正常工作了。怎么回事呢？locate 数据库由另一个叫做 updatedb 的程序创建。通常，这个程序作为一个定时任务（jobs）周期性运转；也就是说，一个任务 在特定的时间间隔内被 cron 守护进程执行。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，你会发现 目前最新的文件不会出现。为了克服这个问题，通过更改为超级用户身份，在提示符下运行 updatedb 命令， 可以手动运行 updatedb 程序。</p></blockquote><h3 id="find-查找文件的复杂方式"><a href="#find-查找文件的复杂方式" class="headerlink" title="find - 查找文件的复杂方式"></a>find - 查找文件的复杂方式</h3><p>While the locate program can find a file based solely on its name, the find program searches a given directory (and its subdirectories) for files based on a variety of attributes. We’re going to spend a lot of time with find because it has a lot of interesting features that we will see again and again when we start to cover programming concepts in later chapters.</p><p>locate 程序只能依据文件名来查找文件，而 find 程序能基于各种各样的属性 搜索一个给定目录（以及它的子目录），来查找文件。我们将要花费大量的时间学习 find 命令，因为 它有许多有趣的特性，当我们开始在随后的章节里面讨论编程概念的时候，我们将会重复看到这些特性。</p><p>In its simplest use, find is given one or more names of directories to search. For example, to produce a list of our home directory:</p><p>在它的最简单的使用方式中，find 命令接收一个或多个目录名来执行搜索。例如，输出我们的家目录的路径名列表（包括文件及目录，译者注）。</p><pre><code>[me@linuxbox ~]$ find ~</code></pre><p>On most active user accounts, this will produce a large list. Since the list is sent to standard output, we can pipe the list into other programs. Let’s use wc to count the number of files:</p><p>在最活跃的用户帐号中，这将产生一张很大的列表。因为这张列表被发送到标准输出， 我们可以把这个列表管道到其它的程序中。让我们使用 wc 程序来计算出文件的数量：</p><pre><code>[me@linuxbox ~]$ find ~ | wc -l47068</code></pre><p>Wow, we’ve been busy! The beauty of find is that it can be used to identify files that meet specific criteria. It does this through the (slightly strange) application of options, tests, and actions. We’ll look at the tests first.</p><p>哇，我们一直很忙（在 home 路径下执行了很多操作，译者注）！find 命令的魅力所在就是它能够被用来找到符合特定标准的文件。它通过 （有点奇怪）应用选项，测试条件，和操作来做到这一点。我们先看一下测试条件：</p><h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p>Let’s say that we want a list of directories from our search. To do this, we could add the following test:</p><p>比如说我们想在我们的搜索中得到目录列表。我们可以添加以下测试条件：</p><pre><code>[me@linuxbox ~]$ find ~ -type d | wc -l1695</code></pre><p>Adding the test -type d limited the search to directories. Conversely, we could have limited the search to regular files with this test:</p><p>添加测试条件-type d 限制了只搜索目录。相反地，我们可以使用这个测试条件来限定搜索普通文件：</p><pre><code>[me@linuxbox ~]$ find ~ -type f | wc -l38737</code></pre><p>Here are the common file type tests supported by find:</p><p>这里是 find 命令支持的常见文件类型测试条件：</p><table><thead><tr><th align="left">File Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">Block special device file</td></tr><tr><td align="left">c</td><td align="left">Character special device file</td></tr><tr><td align="left">d</td><td align="left">Directory</td></tr><tr><td align="left">f</td><td align="left">Regular file</td></tr><tr><td align="left">l</td><td align="left">Symbolic link</td></tr></tbody></table><table><thead><tr><th align="left">文件类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">块特殊设备文件</td></tr><tr><td align="left">c</td><td align="left">字符特殊设备文件</td></tr><tr><td align="left">d</td><td align="left">目录</td></tr><tr><td align="left">f</td><td align="left">普通文件</td></tr><tr><td align="left">l</td><td align="left">符号链接</td></tr></tbody></table><p>We can also search by file size and filename by adding some additional tests: Let’s look for all the regular files that match the wild card pattern “*.JPG” and are larger than one megabyte:</p><p>我们也可以通过加入一些额外的测试条件，根据文件大小和文件名来搜索：让我们查找所有文件名匹配 通配符模式“*.JPG”和文件大小大于1M 的普通文件：</p><pre><code>[me@linuxbox ~]$ find ~ -type f -name &quot;*.JPG&quot; -size +1M | wc -l840</code></pre><p>In this example, we add the -name test followed by the wild card pattern. Notice how we enclose it in quotes to prevent pathname expansion by the shell. Next, we add the -size test followed by the string “+1M”. The leading plus sign indicates that we are looking for files larger than the specified number. A leading minus sign would change the meaning of the string to be smaller than the specified number. No sign means, “match the value exactly.” The trailing letter “M” indicates that the unit of measurement is megabytes. The following characters may be used to specify units:</p><p>在这个例子里面，我们加入了 -name 测试条件，后面跟通配符模式。注意，我们把它用双引号引起来， 从而阻止 shell 展开路径名。紧接着，我们加入 -size 测试条件，后跟字符串“+1M”。开头的加号表明 我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则意味着查找小于指定数的文件。 若没有符号意味着“精确匹配这个数”。结尾字母“M”表明测量单位是兆字节。下面的字符可以 被用来指定测量单位：</p><table><thead><tr><th align="left">Character</th><th align="left">Unit</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">512 byte blocks. This is the default if no unit is specified.</td></tr><tr><td align="left">c</td><td align="left">Bytes</td></tr><tr><td align="left">w</td><td align="left">Two byte words</td></tr><tr><td align="left">k</td><td align="left">Kilobytes (Units of 1024 bytes)</td></tr><tr><td align="left">M</td><td align="left">Megabytes (Units of 1048576 bytes)</td></tr><tr><td align="left">G</td><td align="left">Gigabytes (Units of 1073741824 bytes)</td></tr></tbody></table><table><thead><tr><th align="left">字符</th><th align="left">单位</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">512 个字节块。如果没有指定单位，则这是默认值。</td></tr><tr><td align="left">c</td><td align="left">字节</td></tr><tr><td align="left">w</td><td align="left">两个字节的字</td></tr><tr><td align="left">k</td><td align="left">千字节(1024个字节单位)</td></tr><tr><td align="left">M</td><td align="left">兆字节(1048576个字节单位)</td></tr><tr><td align="left">G</td><td align="left">千兆字节(1073741824个字节单位)</td></tr></tbody></table><p>find supports a large number of different tests. Below is a rundown of the common ones. Note that in cases where a numeric argument is required, the same “+” and “-” notation discussed above can be applied:</p><p>find 命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要数值参数的 情况下，可以应用以上讨论的“+”和“-”符号表示法：</p><table><thead><tr><th align="left">Test</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-cmin n</td><td align="left">Match files or directories whose content or attributes were last modified exactly n minutes ago. To specify less than n minutes ago, use -n and to specify more than n minutes ago, use +n.</td></tr><tr><td align="left">-cnewer file</td><td align="left">Match files or directories whose contents or attributes were last modified more recently than those of file.</td></tr><tr><td align="left">-ctime n</td><td align="left">Match files or directories whose contents or attributes were last modified n*24 hours ago.</td></tr><tr><td align="left">-empty</td><td align="left">Match empty files and directories.</td></tr><tr><td align="left">-group name</td><td align="left">Match file or directories belonging to group. group may be expressed as either a group name or as a numeric group ID.</td></tr><tr><td align="left">-iname pattern</td><td align="left">Like the -name test but case insensitive.</td></tr><tr><td align="left">-inum n</td><td align="left">Match files with inode number n. This is helpful for finding all the hard links to a particular inode.</td></tr><tr><td align="left">-mmin n</td><td align="left">Match files or directories whose contents were modified n minutes ago.</td></tr><tr><td align="left">-mtime n</td><td align="left">Match files or directories whose contents were modified n*24 hours ago.</td></tr><tr><td align="left">-name pattern</td><td align="left">Match files and directories with the specified wild card pattern.</td></tr><tr><td align="left">-newer file</td><td align="left">Match files and directories whose contents were modified more recently than the specified file. This is very useful when writing shell scripts that perform file backups. Each time you make a backup, update a file (such as a log), then use find to determine which files that have changed since the last update.</td></tr><tr><td align="left">-nouser</td><td align="left">Match file and directories that do not belong to a valid user. This can be used to find files belonging to deleted accounts or to detect activity by attackers.</td></tr><tr><td align="left">-nogroup</td><td align="left">Match files and directories that do not belong to a valid group.</td></tr><tr><td align="left">-perm mode</td><td align="left">Match files or directories that have permissions set to the specified mode. mode may be expressed by either octal or symbolic notation.</td></tr><tr><td align="left">-samefile name</td><td align="left">Similar to the -inum test. Matches files that share the same inode number as file name.</td></tr><tr><td align="left">-size n</td><td align="left">Match files of size n.</td></tr><tr><td align="left">-type c</td><td align="left">Match files of type c.</td></tr><tr><td align="left">-user name</td><td align="left">Match files or directories belonging to user name. The user may be expressed by a user name or by a numeric user ID.</td></tr></tbody></table><table><thead><tr><th align="left">测试条件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-cmin n</td><td align="left">匹配内容或属性最后修改时间正好在 n 分钟之前的文件或目录。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</td></tr><tr><td align="left">-cnewer file</td><td align="left">匹配内容或属性最后修改时间晚于 file 的文件或目录。</td></tr><tr><td align="left">-ctime n</td><td align="left">匹配内容和属性最后修改时间在 n*24小时之前的文件和目录。</td></tr><tr><td align="left">-empty</td><td align="left">匹配空文件和目录。</td></tr><tr><td align="left">-group name</td><td align="left">匹配属于一个组的文件或目录。组可以用组名或组 ID 来表示。</td></tr><tr><td align="left">-iname pattern</td><td align="left">就像-name 测试条件，但是不区分大小写。</td></tr><tr><td align="left">-inum n</td><td align="left">匹配 inode 号是 n的文件。这对于找到某个特殊 inode 的所有硬链接很有帮助。</td></tr><tr><td align="left">-mmin n</td><td align="left">匹配内容被修改于 n 分钟之前的文件或目录。</td></tr><tr><td align="left">-mtime n</td><td align="left">匹配的文件或目录的内容被修改于 n*24小时之前。</td></tr><tr><td align="left">-name pattern</td><td align="left">用指定的通配符模式匹配的文件和目录。</td></tr><tr><td align="left">-newer file</td><td align="left">匹配内容晚于指定的文件的文件和目录。这在编写执行备份的 shell 脚本的时候很有帮。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来判断哪些文件自从上一次更新之后被更改了。</td></tr><tr><td align="left">-nouser</td><td align="left">匹配不属于一个有效用户的文件和目录。这可以用来查找 属于被删除的帐户的文件或监测攻击行为。</td></tr><tr><td align="left">-nogroup</td><td align="left">匹配不属于一个有效的组的文件和目录。</td></tr><tr><td align="left">-perm mode</td><td align="left">匹配权限已经设置为指定的 mode的文件或目录。mode 可以用 八进制或符号表示法。</td></tr><tr><td align="left">-samefile name</td><td align="left">类似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</td></tr><tr><td align="left">-size n</td><td align="left">匹配大小为 n 的文件</td></tr><tr><td align="left">-type c</td><td align="left">匹配文件类型是 c 的文件。</td></tr><tr><td align="left">-user name</td><td align="left">匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户 ID 来表示。</td></tr></tbody></table><p>This is not a complete list. The find man page has all the details.</p><p>这不是一个完整的列表。find 命令手册有更详细的说明。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>Even with all the tests that find provides, we may still need a better way to describe the logical relationships between the tests. For example, what if we needed to determine if all the files and subdirectories in a directory had secure permissions? We would look for all the files with permissions that are not 0600 and the directories with permissions that are not 0700. Fortunately, find provides a way to combine tests using logical operators to create more complex logical relationships. To express the aforementioned test, we could do this:</p><p>即使拥有了 find 命令提供的所有测试条件，我们还需要一个更好的方式来描述测试条件之间的逻辑关系。例如， 如果我们需要确定是否一个目录中的所有的文件和子目录拥有安全权限，怎么办呢？ 我们可以查找权限不是0600的文件和权限不是0700的目录。幸运地是，find 命令提供了 一种方法来结合测试条件，通过使用逻辑操作符来创建更复杂的逻辑关系。 为了表达上述的测试条件，我们可以这样做：</p><pre><code>[me@linuxbox ~]$ find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)</code></pre><p>Yikes! That sure looks weird. What is all this stuff? Actually, the operators are not that complicated once you get to know them. Here is the list:</p><p>呀！这的确看起来很奇怪。这些是什么东西？实际上，这些操作符没有那么复杂，一旦你知道了它们的原理。 这里是操作符列表：</p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-and</td><td align="left">Match if the tests on both sides of the operator are true. May be shortened to -a. Note that when no operator is present, -and is implied by default.</td></tr><tr><td align="left">-or</td><td align="left">Match if a test on either side of the operator is true. May be shortened to -o.</td></tr><tr><td align="left">-not</td><td align="left">Match if the test following the operator is false. May be abbreviated with an exclamation point (!).</td></tr><tr><td align="left">()</td><td align="left">Groups tests and operators together to form larger expressions. This is used to control the precedence of the logical evaluations. By default, find evaluates from left to right. It is often necessary to override the default evaluation order to obtain the desired result. Even if not needed, it is helpful sometimes to include the grouping characters to improve readability of the command. Note that since the parentheses characters have special meaning to the shell, they must be quoted when using them on the command line to allow them to be passed as arguments to find. Usually the backslash character is used to escape them.</td></tr></tbody></table><table><thead><tr><th align="left">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-and</td><td align="left">如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。</td></tr><tr><td align="left">-or</td><td align="left">若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</td></tr><tr><td align="left">-not</td><td align="left">若操作符后面的测试条件是假，则匹配。可以简写为一个感叹号（!）。</td></tr><tr><td align="left">()</td><td align="left">把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，find 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。</td></tr></tbody></table><p>With this list of operators in hand, let’s deconstruct our find command. When viewed from the uppermost level, we see that our tests are arranged as two groupings separated by an -or operator:</p><p>通过这张操作符列表，我们重建 find 命令。从最外层看，我们看到测试条件被分为两组，由一个 -or 操作符分开：</p><pre><code>( expression 1 ) -or ( expression 2 )</code></pre><p>This makes sense, since we are searching for files with a certain set of permissions and for directories with a different set. If we are looking for both files and directories, why do we use -or instead of -and? Because as find scans through the files and directories, each one is evaluated to see if it matches the specified tests. We want to know if it is either a file with bad permissions or a directory with bad permissions. It can’t be both at the same time. So if we expand the grouped expressions, we can see it this way:</p><p>这看起来合理，因为我们正在搜索具有不同权限集合的文件和目录。如果我们文件和目录两者都查找， 那为什么要用 -or 来代替 -and 呢？因为 find 命令扫描文件和目录时，会计算每一个对象，看看它是否 匹配指定的测试条件。我们想要知道它是具有错误权限的文件还是有错误权限的目录。它不可能同时符合这 两个条件。所以如果展开组合起来的表达式，我们能这样解释它：</p><pre><code>( file with bad perms ) -or ( directory with bad perms )</code></pre><p>Our next challenge is how to test for “bad permissions.” How do we do that? Actually we don’t. What we will test for is “not good permissions,” since we know what “good permissions” are. In the case of files, we define good as 0600 and for directories, as</p><ol><li>The expression that will test files for “not good” permissions is:</li></ol><p>下一个挑战是怎样来检查“错误权限”，这个怎样做呢？事实上我们不从这个角度入手。我们将测试 “不是正确权限”，因为我们知道什么是“正确权限”。对于文件，我们定义正确权限为0600， 目录则为0700。测试具有“不正确”权限的文件表达式为：</p><pre><code>-type f -and -not -perms 0600</code></pre><p>and for directories:</p><p>对于目录，表达式为：</p><pre><code>-type d -and -not -perms 0700</code></pre><p>As noted in the table of operators above, the -and operator can be safely removed, since it is implied by default. So if we put this all back together, we get our final command:</p><p>正如上述操作符列表中提到的，这个-and 操作符能够被安全地删除，因为它是默认使用的操作符。 所以如果我们把这两个表达式连起来，就得到最终的命令：</p><pre><code>find ~ ( -type f -not -perms 0600 ) -or ( -type d -not -perms 0700 )</code></pre><p>However, since the parentheses have special meaning to the shell, we must escape them to prevent the shell from trying to interpret them. Preceding each one with a backslash character does the trick.</p><p>然而，因为圆括号对于 shell 有特殊含义，我们必须转义它们，来阻止 shell 解释它们。在圆括号字符 之前加上一个反斜杠字符来转义它们。</p><p>There is another feature of logical operators that is important to understand. Let’s say that we have two expressions separated by a logical operator:</p><p>逻辑操作符还有另外一个特性要重点理解。比方说我们有两个由逻辑操作符分开的表达式：</p><pre><code>expr1 -operator expr2</code></pre><p>In all cases, expr1 will always be performed; however the operator will determine if expr2 is performed. Here’s how it works:</p><p>在所有情况下，总会执行表达式 expr1；然而操作符将决定是否执行表达式 expr2。这里 列出了它是怎样工作的：</p><table><thead><tr><th align="left">Results of expr1</th><th align="left">Operator</th><th align="left">expr2 is…</th></tr></thead><tbody><tr><td align="left">True</td><td align="left">-and</td><td align="left">Always performed</td></tr><tr><td align="left">False</td><td align="left">-and</td><td align="left">Never performed</td></tr><tr><td align="left">Ture</td><td align="left">-or</td><td align="left">Never performed</td></tr><tr><td align="left">False</td><td align="left">-or</td><td align="left">Always performed</td></tr></tbody></table><table><thead><tr><th align="left">expr1 的结果</th><th align="left">操作符</th><th align="left">expr2 is…</th></tr></thead><tbody><tr><td align="left">真</td><td align="left">-and</td><td align="left">总要执行</td></tr><tr><td align="left">假</td><td align="left">-and</td><td align="left">从不执行</td></tr><tr><td align="left">真</td><td align="left">-or</td><td align="left">从不执行</td></tr><tr><td align="left">假</td><td align="left">-or</td><td align="left">总要执行</td></tr></tbody></table><p>Why does this happen? It’s done to improve performance. Take -and, for example. We know that the expression expr1 -and expr2 cannot be true if the result of expr1 is false, so there is no point in performing expr2. Likewise, if we have the expression expr1 -or expr2 and the result of expr1 is true, there is no point in performing expr2, as we already know that the expression expr1 -or expr2 is true. OK, so it helps it go faster. Why is this important? It’s important because we can rely on this behavior to control how actions are performed, as we shall soon see..</p><p>为什么这会发生呢？这样做是为了提高性能。以 -and 为例，我们知道如果表达式 expr1的结果为假， 表达式 expr1 -and expr2不能为真，所以没有必要执行 expr2。同样地，如果我们有表达式 expr1 -or expr2，并且表达式 expr1的结果为真，那么就没有必要执行 expr2，因为我们已经知道 表达式 expr1 -or expr2 为真。好，这样会执行快一些。为什么这个很重要？ 它很重要是因为我们能依靠这种行为来控制怎样来执行操作。我们会很快看到…</p><h3 id="预定义的操作"><a href="#预定义的操作" class="headerlink" title="预定义的操作"></a>预定义的操作</h3><p>Let’s get some work done! Having a list of results from our find command is useful, but what we really want to do is act on the items on the list. Fortunately, find allows actions to be performed based on the search results. There are a set of predefined actions and several ways to apply user-defined actions. First let’s look at a few of the predefined actions:</p><p>让我们做一些工作吧！执行 find 命令得到结果列表很有用处，但是我们真正想要做的事情是操作列表 中的某些条目。幸运地是，find 命令允许基于搜索结果来执行操作。有许多预定义的操作和几种方式来 应用用户定义的操作。首先，让我们看一下几个预定义的操作：</p><table><thead><tr><th align="left">Action</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-delete</td><td align="left">Delete the currently matching file.</td></tr><tr><td align="left">-ls</td><td align="left">Perform the equivalent of ls -dils on the matching file. Output is sent to standard output.</td></tr><tr><td align="left">-print</td><td align="left">Output the full pathname of the matching file to standard output. This is the default action if no other action is specified.</td></tr><tr><td align="left">-quit</td><td align="left">Quit once a match has been made.</td></tr></tbody></table><table><thead><tr><th align="left">操作</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-delete</td><td align="left">删除当前匹配的文件。</td></tr><tr><td align="left">-ls</td><td align="left">对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。</td></tr><tr><td align="left">-print</td><td align="left">把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</td></tr><tr><td align="left">-quit</td><td align="left">一旦找到一个匹配，退出。</td></tr></tbody></table><p>As with the tests, there are many more actions. See the find man page for full details. In our very first example, we did this:</p><p>和测试条件一样，还有更多的操作。查看 find 命令手册得到更多细节。在第一个例子里， 我们这样做：</p><pre><code>find ~</code></pre><p>which produced a list of every file and subdirectory contained within our home directory. It produced a list because the -print action is implied if no other action is specified. Thus our command could also be expressed as:</p><p>这个命令输出了我们家目录中包含的每个文件和子目录。它会输出一个列表，因为会默认使用-print 操作 ，如果没有指定其它操作的话。因此我们的命令也可以这样表述：</p><pre><code>find ~ -print</code></pre><p>We can use find to delete files that meet certain criteria. For example, to delete files that have the file extension “.BAK” (which is often used to designate backup files), we could use this command:</p><p>我们可以使用 find 命令来删除符合一定条件的文件。例如，来删除扩展名为“.BAK”（这通常用来指定备份文件） 的文件，我们可以使用这个命令：</p><pre><code>find ~ -type f -name &#39;*.BAK&#39; -delete</code></pre><p>In this example, every file in the user’s home directory (and its subdirectories) is searched for filenames ending in .BAK. When they are found, they are deleted.</p><p>在这个例子里面，用户家目录（和它的子目录）下的每个文件中搜索以.BAK 结尾的文件名。当找到后，就删除它们。</p><hr><p>Warning: It should go without saying that you should use extreme caution when using the -delete action. Always test the command first by substituting the -print action for -delete to confirm the search results.</p><p>警告：当使用 -delete 操作时，不用说，你应该格外小心。每次都应该首先用 -print 操作代替 -delete 测试一下命令，来确认搜索结果。</p><hr><p>Before we go on, let’s take another look at how the logical operators affect actions. Consider the following command:</p><p>在我们继续之前，让我们看一下逻辑运算符是怎样影响操作的。考虑以下命令：</p><pre><code>find ~ -type f -name &#39;*.BAK&#39; -print</code></pre><p>As we have seen, this command will look for every regular file (-type f) whose name ends with .BAK (-name ‘*.BAK’) and will output the relative pathname of each matching file to standard output (-print). However, the reason the command performs the way it does is determined by the logical relationships between each of the tests and actions. Remember, there is, by default, an implied -and relationship between each test and action. We could also express the command this way to make the logical relationships easier to see:</p><p>正如我们所见到的，这个命令会查找每个文件名以.BAK (-name ‘*.BAK’) 结尾的普通文件 (-type f)， 并把每个匹配文件的相对路径名输出到标准输出 (-print)。然而，此命令按这个方式执行的原因，是 由每个测试和操作之间的逻辑关系决定的。记住，在每个测试和操作之间会默认应用 -and 逻辑运算符。 我们也可以这样表达这个命令，使逻辑关系更容易看出：</p><pre><code>find ~ -type f -and -name &#39;*.BAK&#39; -and -print</code></pre><p>With our command fully expressed, let’s look at how the logical operators affect its execution:</p><p>当命令被充分表达之后，让我们看看逻辑运算符是如何影响其执行的：</p><table><thead><tr><th align="left">Test/Action</th><th align="left">Is Performed Only If…</th></tr></thead><tbody><tr><td align="left">-print</td><td align="left">-type f and -name ‘*.BAK’ are true</td></tr><tr><td align="left">-name ‘*.BAK’</td><td align="left">-type f is true</td></tr><tr><td align="left">-type f</td><td align="left">Is always performed, since it is the first test/action in an -and relationship.</td></tr></tbody></table><table><thead><tr><th align="left">测试／行为</th><th align="left">只有…的时候，才被执行</th></tr></thead><tbody><tr><td align="left">-print</td><td align="left">只有 -type f and -name ‘*.BAK’为真的时候</td></tr><tr><td align="left">-name ‘*.BAK’</td><td align="left">只有 -type f 为真的时候</td></tr><tr><td align="left">-type f</td><td align="left">总是被执行，因为它是与 -and 关系中的第一个测试／行为。</td></tr></tbody></table><p>Since the logical relationship between the tests and actions determines which of them are performed, we can see that the order of the tests and actions is important. For instance, if we were to reorder the tests and actions so that the -print action was the first one, the command would behave much differently:</p><p>因为测试和行为之间的逻辑关系决定了哪一个会被执行，我们可以看出知道测试和行为的顺序很重要。例如， 如果我们重新安排测试和行为之间的顺序，让 -print 行为是第一个，那么这个命令执行起来会截然不同：</p><pre><code>find ~ -print -and -type f -and -name &#39;*.BAK&#39;</code></pre><p>This version of the command will print each file (the -print action always evaluates to true) and then test for file type and the specified file extension.</p><p>这个版本的命令会打印出每个文件（-print 行为总是为真），然后测试文件类型和指定的文件扩展名。</p><h3 id="用户定义的行为"><a href="#用户定义的行为" class="headerlink" title="用户定义的行为"></a>用户定义的行为</h3><p>In addition to the predefined actions, we can also invoke arbitrary commands. The traditional way of doing this is with the -exec action. This action works like this:</p><p>除了预定义的行为之外，我们也可以调用任意的命令。传统方式是通过 -exec 行为。这个 行为像这样工作：</p><pre><code>-exec command {} ;</code></pre><p>where command is the name of a command, {} is a symbolic representation of the current pathname and the semicolon is a required delimiter indicating the end of the command. Here’s an example of using -exec to act like the -delete action discussed earlier:</p><p>这里的 command 就是指一个命令的名字，{}是当前路径名的符号表示，分号是必要的分隔符 表明命令的结束。这里是一个使用 -exec 行为的例子，其作用如之前讨论的 -delete 行为：</p><pre><code>-exec rm &#39;{}&#39; &#39;;&#39;</code></pre><p>Again, since the brace and semicolon characters have special meaning to the shell, they must be quoted or escaped.</p><p>重述一遍，因为花括号和分号对于 shell 有特殊含义，所以它们必须被引起来或被转义。</p><p>It’s also possible to execute a user defined action interactively. By using the -ok action in place of -exec, the user is prompted before execution of each specified command:</p><p>我们也可以交互式地执行一个用户定义的行为。通过使用 -ok 行为来代替 -exec，在执行每个指定的命令之前， 会提示用户：</p><pre><code>find ~ -type f -name &#39;foo*&#39; -ok ls -l &#39;{}&#39; &#39;;&#39;&lt; ls ... /home/me/bin/foo &gt; ? y-rwxr-xr-x 1 me    me 224 2007-10-29 18:44 /home/me/bin/foo&lt; ls ... /home/me/foo.txt &gt; ? y-rw-r--r-- 1 me    me 0 2008-09-19 12:53 /home/me/foo.txt</code></pre><p>In this example, we search for files with names starting with the string “foo” and execute the command ls -l each time one is found. Using the -ok action prompts the user before the ls command is executed.</p><p>在这个例子里面，我们搜索以字符串“foo”开头的文件名，并且对每个匹配的文件执行 ls -l 命令。 使用 -ok 行为，会在 ls 命令执行之前提示用户。</p><h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>When the -exec action is used, it launches a new instance of the specified command each time a matching file is found. There are times when we might prefer to combine all of the search results and launch a single instance of the command. For example, rather than executing the commands like this:</p><p>当 -exec 行为被使用的时候，若每次找到一个匹配的文件，它会启动一个新的指定命令的实例。 我们可能更愿意把所有的搜索结果结合起来，再运行一个命令的实例。例如，与其像这样执行命令：</p><pre><code>ls -l file1ls -l file2</code></pre><p>we may prefer to execute it this way:</p><p>我们更喜欢这样执行命令：</p><pre><code>ls -l file1 file2</code></pre><p>thus causing the command to be executed only one time rather than multiple times. There are two ways we can do this. The traditional way, using the external command xargs and the alternate way, using a new feature in find itself. We’ll talk about the alternate way first.</p><p>这样就导致命令只被执行一次而不是多次。有两种方法可以这样做。传统方式是使用外部命令 xargs，另一种方法是，使用 find 命令自己的一个新功能。我们先讨论第二种方法。</p><p>By changing the trailing semicolon character to a plus sign, we activate the ability of find to combine the results of the search into an argument list for a single execution of the desired command. Going back to our example, this:</p><p>通过把末尾的分号改为加号，就激活了 find 命令的一个功能，把搜索结果结合为一个参数列表， 然后用于所期望的命令的一次执行。再看一下之前的例子，这个例子中：</p><pre><code>find ~ -type f -name &#39;foo*&#39; -exec ls -l &#39;{}&#39; &#39;;&#39;-rwxr-xr-x 1 me     me 224 2007-10-29 18:44 /home/me/bin/foo-rw-r--r-- 1 me     me 0 2008-09-19 12:53 /home/me/foo.txt</code></pre><p>will execute ls each time a matching file is found. By changing the command to:</p><p>每次找到一个匹配的文件， 就会执行一次 ls 命令。通过把命令改为：</p><pre><code>find ~ -type f -name &#39;foo*&#39; -exec ls -l &#39;{}&#39; +-rwxr-xr-x 1 me     me 224 2007-10-29 18:44 /home/me/bin/foo-rw-r--r-- 1 me     me 0 2008-09-19 12:53 /home/me/foo.txt</code></pre><p>we get the same results, but the system only has to execute the ls command once.</p><p>虽然我们得到一样的结果，但是系统只需要执行一次 ls 命令。</p><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>The xargs command performs an interesting function. It accepts input from standard input and converts it into an argument list for a specified command. With our example, we would use it like this:</p><p>这个 xargs 命令会执行一个有趣的函数。它从标准输入接受输入，并把输入转换为一个特定命令的 参数列表。对于我们的例子，我们可以这样使用它：</p><pre><code>find ~ -type f -name &#39;foo*&#39; -print | xargs ls -l-rwxr-xr-x 1 me     me 224 2007-10-29 18:44 /home/me/bin/foo-rw-r--r-- 1 me     me 0 2008-09-19 12:53 /home/me/foo.txt</code></pre><p>Here we see the output of the find command piped into xargs which, in turn, constructs an argument list for ls command and then executes it.</p><p>这里我们看到 find 命令的输出被管道到 xargs 命令，之后，xargs 会为 ls 命令构建 参数列表，然后执行 ls 命令。</p><hr><p>Note: While the number of arguments that can be placed into a command line is quite large, it’s not unlimited. It is possible to create commands that are too long for the shell to accept. When a command line exceeds the maximum length supported by the system, xargs executes the specified command with the maximum number of arguments possible and then repeats this process until standard input is exhausted. To see the maximum size of the command line, execute xargs with the –show-limits option.</p><p>注意：当被放置到命令行中的参数个数相当大时，参数个数是有限制的。有可能创建的命令 太长以至于 shell 不能接受。当命令行超过系统支持的最大长度时，xargs 会执行带有最大 参数个数的指定命令，然后重复这个过程直到耗尽标准输入。执行带有 –show–limits 选项 的 xargs 命令，来查看命令行的最大值。</p><hr><blockquote><p>Dealing With Funny Filenames</p><p>处理古怪的文件名</p><p>Unix-like systems allow embedded spaces (and even newlines!) in filenames. This causes problems for programs like xargs that construct argument lists for other programs. An embedded space will be treated as a delimiter and the resulting command will interpret each space-separated word as a separate argument. To overcome this, find and xarg allow the optional use of a null character as argument separator. A null character is defined in ASCII as the character represented by the number zero (as opposed to, for example, the space character, which is defined in ASCII as the character represented by the number 32). The find command provides the action -print0, which produces null separated output, and the xargs command has the –null option, which accepts null separated input. Here’s an example:</p><p>类 Unix 的系统允许在文件名中嵌入空格（甚至换行符）。这就给一些程序，如为其它 程序构建参数列表的 xargs 程序，造成了问题。一个嵌入的空格会被看作是一个分隔符，生成的 命令会把每个空格分离的单词解释为单独的参数。为了解决这个问题，find 命令和 xarg 程序 允许使用一个可选的 null 字符作为参数分隔符。一个 null 字符被定义在 ASCII 码中，由数字 零来表示（相反的，例如，空格字符在 ASCII 码中由数字32表示）。find 命令提供的 -print0 行为， 则会产生由 null 字符分离的输出，并且 xargs 命令有一个 –null 选项，这个选项会接受由 null 字符 分离的输入。这里有一个例子：</p><table><thead><tr><th>find ~ -iname ‘*.jpg’ -print0</th><th>xargs –null ls -l</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>Using this technique, we can ensure that all files, even those containing embedded spaces in their names, are handled correctly.</p><p>使用这项技术，我们可以保证所有文件，甚至那些文件名中包含空格的文件，都能被正确地处理。</p></blockquote><h3 id="返回操练场"><a href="#返回操练场" class="headerlink" title="返回操练场"></a>返回操练场</h3><p>It’s time to put find to some (almost) practical use. We’ll create a playground and try out some of what we have learned.</p><p>到实际使用 find 命令的时候了。我们将会创建一个操练场，来实践一些我们所学到的知识。</p><p>First, let’s create a playground with lots of subdirectories and files:</p><p>首先，让我们创建一个包含许多子目录和文件的操练场：</p><pre><code>[me@linuxbox ~]$ mkdir -p playground/dir-{00{1..9},0{10..99},100}[me@linuxbox ~]$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}</code></pre><p>Marvel in the power of the command line! With these two lines, we created a playground directory containing one hundred subdirectories each containing twenty-six empty files. Try that with the GUI!</p><p>惊叹于命令行的强大功能！只用这两行，我们就创建了一个包含一百个子目录，每个子目录中 包含了26个空文件的操练场。试试用 GUI 来创建它！</p><p>The method we employed to accomplish this magic involved a familiar command (mkdir), an exotic shell expansion (braces) and a new command, touch. By combining mkdir with the -p option (which causes mkdir to create the parent directories of the specified paths) with brace expansion, we were able to create one hundred directories.</p><p>我们用来创造这个奇迹的方法中包含一个熟悉的命令（mkdir），一个奇异的 shell 扩展（花括号） 和一个新命令，touch。通过结合 mkdir 命令和-p 选项（导致 mkdir 命令创建指定路径的父目录），以及 花括号展开，我们能够创建一百个目录。</p><p>The touch command is usually used to set or update the access, change, and modify times of files. However, if a filename argument is that of a nonexistent file, an empty file is created.</p><p>这个 touch 命令通常被用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个 不存在的文件，则会创建一个空文件。</p><p>In our playground, we created one hundred instances of a file named file-A. Let’s find them:</p><p>在我们的操练场中，我们创建了一百个名为 file-A 的文件实例。让我们找到它们：</p><pre><code>[me@linuxbox ~]$ find playground -type f -name &#39;file-A&#39;</code></pre><p>Note that unlike ls, find does not produce results in sorted order. Its order is determined by the layout of the storage device. To confirm that we actually have one hundred instances of the file we can confirm it this way:</p><p>注意不同于 ls 命令，find 命令的输出结果是无序的。其顺序由存储设备的布局决定。为了确定实际上 我们拥有一百个此文件的实例，我们可以用这种方式来确认：</p><pre><code>[me@linuxbox ~]$ find playground -type f -name &#39;file-A&#39; | wc -l</code></pre><p>Next, let’s look at finding files based on their modification times. This will be helpful when creating backups or organizing files in chronological order. To do this, we will first create a reference file against which we will compare modification time:</p><p>下一步，让我们看一下基于文件的修改时间来查找文件。当创建备份文件或者以年代顺序来 组织文件的时候，这会很有帮助。为此，首先我们将创建一个参考文件，我们将与其比较修改时间：</p><pre><code>[me@linuxbox ~]$ touch playground/timestamp</code></pre><p>This creates an empty file named timestamp and sets its modification time to the current time. We can verify this by using another handy command, stat, which is a kind of souped-up version of ls. The stat command reveals all that the system understands about a file and its attributes:</p><p>这个创建了一个空文件，名为 timestamp，并且把它的修改时间设置为当前时间。我们能够验证 它通过使用另一个方便的命令，stat，是一款加大马力的 ls 命令版本。这个 stat 命令会展示系统对 某个文件及其属性所知道的所有信息：</p><pre><code>[me@linuxbox ~]$ stat playground/timestampFile: &#39;playground/timestamp&#39;Size: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 803h/2051d Inode: 14265061 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)Access: 2008-10-08 15:15:39.000000000 -0400Modify: 2008-10-08 15:15:39.000000000 -0400Change: 2008-10-08 15:15:39.000000000 -0400</code></pre><p>If we touch the file again and then examine it with stat, we will see that the file’s times have been updated.</p><p>如果我们再次 touch 这个文件，然后用 stat 命令检测它，我们会发现所有文件的时间已经更新了。</p><pre><code>[me@linuxbox ~]$ touch playground/timestamp[me@linuxbox ~]$ stat playground/timestampFile: &#39;playground/timestamp&#39;Size: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 803h/2051d Inode: 14265061 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)Access: 2008-10-08 15:23:33.000000000 -0400Modify: 2008-10-08 15:23:33.000000000 -0400Change: 2008-10-08 15:23:33.000000000 -0400</code></pre><p>Next, let’s use find to update some of our playground files:</p><p>下一步，让我们使用 find 命令来更新一些操练场中的文件：</p><pre><code>[me@linuxbox ~]$ find playground -type f -name &#39;file-B&#39; -exec touch &#39;{}&#39; &#39;;&#39;</code></pre><p>This updates all files in the playground named file-B. Next we’ll use find to identify the updated files by comparing all the files to the reference file timestamp:</p><p>这会更新操练场中所有名为 file-B 的文件。接下来我们会使用 find 命令 通过把所有文件与参考文件 timestamp 做比较，来找到已更新的文件：</p><pre><code>[me@linuxbox ~]$ find playground -type f -newer playground/timestamp</code></pre><p>The results contain all one hundred instances of file-B. Since we performed a touch on all the files in the playground named file-B after we updated timestamp, they are now “newer” than timestamp and thus can be identified with the -newer test.</p><p>搜索结果包含所有一百个文件 file-B 的实例。因为我们在更新了文件 timestamp 之后， touch 了操练场中名为 file-B 的所有文件，所以现在它们“新于”timestamp 文件，因此能被用 -newer 测试条件找到。</p><p>Finally, let’s go back to the bad permissions test we performed earlier and apply it to playground:</p><p>最后，让我们回到之前那个错误权限的例子中，把它应用于操练场里：</p><pre><code>[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)</code></pre><p>This command lists all one hundred directories and twenty-six hundred files in playground (as well as timestamp and playground itself, for a total of 2702) because none of them meets our definition of “good permissions.” With our knowledge of operators and actions, we can add actions to this command to apply new permissions to the files and directories in our playground:</p><p>这个命令列出了操练场中所有一百个目录和二百六十个文件（还有 timestamp 和操练场本身，共 2702 个） ，因为没有一个符合我们“正确权限”的定义。通过对运算符和行为知识的了解，我们可以给这个命令 添加行为，对实战场中的文件和目录应用新的权限。</p><pre><code>[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -exec chmod 0600 &#39;{}&#39; &#39;;&#39; \)   -or \( -type d -not -perm 0711 -exec chmod 0700 &#39;{}&#39; &#39;;&#39; \)</code></pre><p>On a day-to-day basis, we might find it easier to issue two commands, one for the directories and one for the files, rather than this one large compound command, but it’s nice to know that we can do it this way. The important point here is to understand how the operators and actions can be used together to perform useful tasks.</p><p>在日常的基础上，我们可能发现运行两个命令会比较容易一些，一个操作目录，另一个操作文件， 而不是这一个长长的复合命令，但是很高兴知道，我们能这样执行命令。这里最重要的一点是要 理解怎样把操作符和行为结合起来使用，来执行有用的任务。</p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>Finally, we have the options. The options are used to control the scope of a find search. They may be included with other tests and actions when constructing find expressions. Here is a list of the most commonly used ones:</p><p>最后，我们有这些选项。这些选项被用来控制 find 命令的搜索范围。当构建 find 表达式的时候， 它们可能被其它的测试条件和行为包含，这里有一个最常被使用的选项的列表：</p><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-depth</td><td align="left">Direct find to process a directory’s files before the directory itself. This option is automatically applied when the -delete action is specified.</td></tr><tr><td align="left">-maxdepth levels</td><td align="left">Set the maximum number of levels that find will descend into a directory tree when performing tests and actions.</td></tr><tr><td align="left">-mindepth levels</td><td align="left">Set the minimum number of levels that find will descend into a directory tree before applying tests and actions.</td></tr><tr><td align="left">-mount</td><td align="left">Direct find not to traverse directories that are mounted on other file systems.</td></tr><tr><td align="left">-noleaf</td><td align="left">Direct find not to optimize its search based on the assumption that it is searching a Unix-like file system. This is needed when scanning DOS/Windows file systems and CD-ROMs.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-depth</td><td align="left">指示 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。</td></tr><tr><td align="left">-maxdepth levels</td><td align="left">当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数</td></tr><tr><td align="left">-mindepth levels</td><td align="left">在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。</td></tr><tr><td align="left">-mount</td><td align="left">指示 find 程序不要搜索挂载到其它文件系统上的目录。</td></tr><tr><td align="left">-noleaf</td><td align="left">指示 find 程序不要基于自己在搜索 Unix 的文件系统的假设，来优化它的搜索。 在搜索DOS/Windows 文件系统和CD/ROMS的时候，我们需要这个选项</td></tr></tbody></table><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The locate, updatedb, find, and xargs programs are all part the GNU Project’s findutils package. The GNU Project provides a website with extensive on-line documentation, which is quite good and should be read if you are using these programs in high security environments:</p></li><li><p>程序 locate，updatedb，find 和 xargs 都是 GNU 项目 findutils 软件包的一部分。 这个 GUN 项目提供了大量的在线文档，这些文档相当出色，如果你在高安全性的 环境中使用这些程序，你应该读读这些文档。</p><p><a href="http://www.gnu.org/software/findutils/" target="_blank" rel="noopener">http://www.gnu.org/software/findutils/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十七章 网络系统</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>When it comes to networking, there is probably nothing that cannot be done with Linux. Linux is used to build all sorts of networking systems and appliances, including firewalls, routers, name servers, NAS (Network Attached Storage) boxes and on and on.</p><p>当谈及到网络系统层面，几乎任何东西都能由 Linux 来实现。Linux 被用来创建各式各样的网络系统和装置， 包括防火墙，路由器，名称服务器，网络连接式存储设备等等。</p><p>Just as the subject of networking is vast, so are the number of commands that can be used to configure and control it. We will focus our attention on just a few of the most frequently used ones. The commands chosen for examination include those used to monitor networks and those used to transfer files. In addition, we are going to explore the ssh program that is used to perform remote logins. This chapter will cover:</p><p>被用来配置和操作网络系统的命令数目，就如网络系统一样巨大。我们仅仅会关注一些最经常 使用到的命令。我们要研究的命令包括那些被用来监测网络和传输文件的命令。另外，我们 还会探讨用来远端登录的 ssh 程序。这章会介绍：</p><ul><li>ping - Send an ICMP ECHO_REQUEST to network hosts</li><li>ping - 发送 ICMP ECHO_REQUEST 数据包到网络主机</li><li>traceroute - Print the route packets trace to a network host</li><li>traceroute - 打印到一台网络主机的路由数据包</li><li>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</li><li>netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员</li><li>ftp - Internet file transfer program</li><li>ftp - 因特网文件传输程序</li><li>wget - Non-interactive network downloader</li><li>wget - 非交互式网络下载器</li><li>ssh - OpenSSH SSH client (remote login program)</li><li>ssh - OpenSSH SSH 客户端（远程登录程序）</li></ul><p>We’re going to assume a little background in networking. In this, the Internet age, everyone using a computer needs a basic understanding of networking concepts. To make full use of this chapter we should be familiar with the following terms:</p><p>我们假定你已经知道了一点网络系统背景知识。在这个因特网时代，每个计算机用户需要理解基本的网络 系统概念。为了能够充分利用这一章节的内容，我们应该熟悉以下术语：</p><ul><li>IP (Internet Protocol) address</li><li>IP (网络协议)地址</li><li>Host and domain name</li><li>主机和域名</li><li>URI (Uniform Resource Identifier)</li><li>URI（统一资源标识符）</li></ul><p>Please see the “Further Reading” section below for some useful articles regarding these terms.</p><p>请查看下面的“拓展阅读”部分，有几篇关于这些术语的有用文章。</p><hr><p>Note: Some of the commands we will cover may (depending on your distribution) require the installation of additional packages from your distribution’s repositories, and some may require superuser privileges to execute.</p><p>注意：一些将要讲到的命令可能（取决于系统发行版）需要从系统发行版的仓库中安装额外的软件包， 并且一些命令可能需要超级用户权限才能执行。</p><hr><h3 id="检查和监测网络"><a href="#检查和监测网络" class="headerlink" title="检查和监测网络"></a>检查和监测网络</h3><p>Even if you’re not the system administrator, it’s often helpful to examine the performance and operation of a network.</p><p>即使你不是一名系统管理员，检查一个网络的性能和运作情况也是经常有帮助的。</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>The most basic network command is ping. The ping command sends a special network packet called an ICMP ECHO_REQUEST to a specified host. Most network devices receiving this packet will reply to it, allowing the network connection to be verified.</p><p>最基本的网络命令是 ping。这个 ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。</p><hr><p>Note: It is possible to configure most network devices (including Linux hosts) to ignore these packets. This is usually done for security reasons, to partially obscure a host from a potential attacker. It is also common for firewalls to be configured to block IMCP traffic.</p><p>注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样做是出于网络安全 原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。</p><hr><p>For example, to see if we can reach linuxcommand.org (one of our favorite sites ;-), we can use use ping like this:</p><p>例如，看看我们能否连接到网站 linuxcommand.org（我们最喜欢的网站之一）， 我们可以这样使用 ping 命令：</p><pre><code>[me@linuxbox ~]$ ping linuxcommand.org</code></pre><p>Once started, ping continues to send packets at a specified interval (default is one second) until it is interrupted:</p><p>一旦启动，ping 命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断：</p><pre><code>[me@linuxbox ~]$ ping linuxcommand.orgPING linuxcommand.org (66.35.250.210) 56(84) bytes of data.64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1ttl=43 time=107 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2ttl=43 time=108 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=4ttl=43 time=106 ms64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=5ttl=43 time=105 ms...</code></pre><p>After it is interrupted (in this case after the sixth packet) by pressing Ctrl-c, ping prints performance statistics. A properly performing network will exhibit zero percent packet loss. A successful “ping” will indicate that the elements of the network (its interface cards, cabling, routing and gateways) are in generally good working order.</p><p>按下组合键 Ctrl-c，中断这个命令之后，ping 打印出运行统计信息。一个正常工作的网络会报告 零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关） 都处于正常的工作状态。</p><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p>The traceroute program (some systems use the similar tracepath program instead) displays a listing of all the “hops” network traffic takes to get from the local system to a specified host. For example, to see the route taken to reach slashdot.org, we would do this:</p><p>这个 traceroute 程序（一些系统使用相似的 tracepath 程序来代替）会显示从本地到指定主机 要经过的所有“跳数”的网络流量列表。例如，看一下到达 slashdot.org 需要经过的路由， 我们将这样做：</p><pre><code>[me@linuxbox ~]$ traceroute slashdot.org</code></pre><p>The output looks like this:</p><p>命令输出看起来像这样：</p><pre><code>traceroute to slashdot.org (216.34.181.45), 30 hops max, 40 bytepackets1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms2 * * *3 ge-4-13-ur01.rockville.md.bad.comcast.net (68.87.130.9) 14.622ms 14.885 ms 15.169 ms4 po-30-ur02.rockville.md.bad.comcast.net (68.87.129.154) 17.634ms 17.626 ms 17.899 ms5 po-60-ur03.rockville.md.bad.comcast.net (68.87.129.158) 15.992ms 15.983 ms 16.256 ms6 po-30-ar01.howardcounty.md.bad.comcast.net (68.87.136.5) 22.835...</code></pre><p>In the output, we can see that connecting from our test system to slashdot.org requires traversing sixteen routers. For routers that provided identifying information, we see their host names, IP addresses and performance data, which includes three samples of round-trip time from the local system to the router. For routers that do not provide identifying information (because of router configuration, network congestion, firewalls, etc.), we see asterisks as in the line for hop number two.</p><p>从输出结果中，我们可以看到连接测试系统到 slashdot.org 网站需要经由16个路由器。对于那些 提供标识信息的路由器，我们能看到它们的主机名，IP 地址和性能数据，这些数据包括三次从本地到 此路由器的往返时间样本。对于那些没有提供标识信息的路由器（由于路由器配置，网络拥塞，防火墙等 方面的原因），我们会看到几个星号，正如行中所示。</p><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>The netstat program is used to examine various network settings and statistics. Through the use of its many options, we can look at a variety of features in our network setup. Using the “-ie” option, we can examine the network interfaces in our system:</p><p>netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：</p><pre><code>[me@linuxbox ~]$ netstat -ieeth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67        inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link        UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1        RX packets:238488 errors:0 dropped:0 overruns:0 frame:0        TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0        collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX        bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000lo      Link encap:Local Loopback        inet addr:127.0.0.1 Mask:255.0.0.0...</code></pre><p>In the example above, we see that our test system has two network interfaces. The first, called eth0, is the Ethernet interface and the second, called lo, is the loopback interface, a virtual interface that the system uses to “talk to itself.”</p><p>在上述实例中，我们看到我们的测试系统有两个网络接口。第一个，叫做 eth0，是 以太网接口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来 “自言自语”。</p><p>When performing causal network diagnostics, the important things to look for are the presence of the word “UP” at the beginning of the fourth line for each interface, indicating that the network interface is enabled, and the presence of a valid IP address in the inet addr field on the second line. For systems using DHCP (Dynamic Host Configuration Protocol), a valid IP address in this field will verify that the DHCP is working.</p><p>当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词 “UP”，说明这个网络接口已经生效，还要查看第二行中 inet addr 字段出现的有效 IP 地址。对于使用 DHCP（动态主机配置协议）的系统，在 这个字段中的一个有效 IP 地址则证明了 DHCP 工作正常。</p><p>Using the “-r” option will display the kernel’s network routing table. This shows how the network is configured to send packets from network to network:</p><p>使用这个“-r”选项会显示内核的网络路由表。这展示了系统是如何配置网络之间发送数据包的。</p><pre><code>[me@linuxbox ~]$ netstat -rKernel IP routing tableDestination     Gateway     Genmask         Flags    MSS  Window  irtt Iface192.168.1.0     *           255.255.255.0   U        0    0          0 eth0default         192.168.1.1 0.0.0.0         UG       0    0          0 eth0</code></pre><p>In this simple example, we see a typical routing table for a client machine on a LAN (Local Area Network) behind a firewall/router. The first line of the listing shows the destination 192.168.1.0. IP addresses that end in zero refer to networks rather than individual hosts, so this destination means any host on the LAN. The next field, Gateway, is the name or IP address of the gateway (router) used to go from the current host to the destination network. An asterisk in this field indicates that no gateway is needed.</p><p>在这个简单的例子里面，我们看到了，位于防火墙之内的局域网中，一台客户端计算机的典型路由表。 第一行显示了目的地 192.168.1.0。IP 地址以零结尾是指网络，而不是独立主机， 所以这个目的地意味着局域网中的任何一台主机。下一个字段，Gateway， 是网关（路由器）的名字或 IP 地址，用它来连接当前的主机和目的地的网络。 若这个字段显示一个星号，则表明不需要网关。</p><p>The last line contains the destination default. This means any traffic destined for a network that is not otherwise listed in the table. In our example, we see that the gateway is defined as a router with the address of 192.168.1.1, which presumably knows what to do with the destination traffic.</p><p>最后一行包含目的地 default。指的是发往任何表上没有列出的目的地网络的流量。 在我们的实例中，我们看到网关被定义为地址 192.168.1.1 的路由器，它应该能 知道怎样来处理目的地流量。</p><p>The netstat program has many options and we have only looked at a couple. Check out the netstat man page for a complete list.</p><p>netstat 程序有许多选项，我们仅仅讨论了几个。查看 netstat 命令的手册，可以 得到所有选项的完整列表。</p><h3 id="网络中传输文件"><a href="#网络中传输文件" class="headerlink" title="网络中传输文件"></a>网络中传输文件</h3><p>What good is a network unless we know how to move files across it? There are many programs that move data over networks. We will cover two of them now and several more in later sections.</p><p>网络有什么用处呢？除非我们知道了怎样通过网络来传输文件。有许多程序可以用来在网络中 传送数据。我们先讨论两个，随后的章节里再介绍几个。</p><h4 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h4><p>One of the true “classic” programs, ftp gets it name from the protocol it uses, the File Transfer Protocol. FTP is used widely on the Internet for file downloads. Most, if not all, web browsers support it and you often see URIs starting with the protocol ftp://. Before there were web browsers, there was the ftp program. ftp is used to communicate with FTP servers, machines that contain files that can be uploaded and downloaded over a network.</p><p>ftp 命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。 FTP 被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP， 你经常可以看到它们的 URI 以协议 ftp://开头。在出现网络浏览器之前，ftp 程序已经存在了。 ftp 程序可用来与 FTP 服务器进行通信，FTP 服务器就是存储文件的计算机，这些文件能够通过 网络下载和上传。</p><p>FTP (in its original form) is not secure, because it sends account names and passwords in cleartext. This means that they are not encrypted and anyone sniffing the network can see them. Because of this, almost all FTP done over the Internet is done by anonymous FTP servers. An anonymous server allows anyone to login using the login name “anonymous” and a meaningless password.</p><p>FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。</p><p>In the example below, we show a typical session with the ftp program downloading an Ubuntu iso image located in the /pub/cd_images/Ubuntu-8.04 directory of the anonymous FTP server fileserver:</p><p>在下面的例子中，我们将展示一个典型的会话，从匿名 FTP 服务器，其名字是 fileserver， 的/pub/_images/Ubuntu-8.04的目录下，使用 ftp 程序下载一个 Ubuntu 系统映像文件。</p><pre><code>[me@linuxbox ~]$ ftp fileserverConnected to fileserver.localdomain.220 (vsFTPd 2.0.1)Name (fileserver:me): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; cd pub/cd\_images/Ubuntu-8.04250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso226 Directory send OK.ftp&gt; lcd DesktopLocal directory now /home/me/Desktopftp&gt; get ubuntu-8.04-desktop-i386.isolocal: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-i386.iso200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for ubuntu-8.04-desktop-i386.iso (733079552 bytes).226 File send OK.733079552 bytes received in 68.56 secs (10441.5 kB/s)ftp&gt; bye</code></pre><p>Here is an explanation of the commands entered during this session:</p><p>这里是对会话期间所输入命令的解释说明：</p><table><thead><tr><th align="left">Command</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">ftp fileserver</td><td align="left">Invoke the ftp program and have it connect to FTP server fileserver.</td></tr><tr><td align="left">anonymous</td><td align="left">Login name. After the login prompt, a password prompt will appear. Some servers will accept a blank password, others will require a password in the form of a email address. In that case, try something like “<a href="mailto:user@example.com" target="_blank" rel="noopener">user@example.com</a>”.</td></tr><tr><td align="left">cd pub/cd_images/Ubuntu-8.04</td><td align="left">Change to the directory on the remote system containing the desired file. Note that on most anonymous FTP servers, the files for public downloading are found somewhere under the pub directory.</td></tr><tr><td align="left">ls</td><td align="left">List the directory on the remote system.</td></tr><tr><td align="left">lcd Desktop</td><td align="left">Change the directory on the local system to ~/Desktop. In the example, the ftp program was invoked when the working directory was ~. This command changes the working directory to ~/Desktop.</td></tr><tr><td align="left">get ubuntu-8.04-desktop- i386.iso</td><td align="left">Tell the remote system to transfer the file ubuntu-8.04-desktop- i386.iso to the local system. Since the working directory on the local system was changed to ~/Desktop, the file will be downloaded there.</td></tr><tr><td align="left">bye</td><td align="left">Log off the remote server and end the ftp program session. The commands quit and exit may also be used.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">意思</th></tr></thead><tbody><tr><td align="left">ftp fileserver</td><td align="left">唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。</td></tr><tr><td align="left">anonymous</td><td align="left">登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “<a href="mailto:user@example.com" target="_blank" rel="noopener">user@example.com</a>”。</td></tr><tr><td align="left">cd pub/cd_images/Ubuntu-8.04</td><td align="left">跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到</td></tr><tr><td align="left">ls</td><td align="left">列出远端系统中的目录。</td></tr><tr><td align="left">lcd Desktop</td><td align="left">跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop</td></tr><tr><td align="left">get ubuntu-8.04-desktop-i386.iso</td><td align="left">告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。</td></tr><tr><td align="left">bye</td><td align="left">退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。</td></tr></tbody></table><p>Typing “help” at the “ftp&gt;” prompt will display a list of the supported commands. Using ftp on a server where sufficient permissions have been granted, it is possible to perform many ordinary file management tasks. It’s clumsy, but it does work.</p><p>在 “ftp&gt;” 提示符下，输入 “help”，会显示所支持命令的列表。使用 ftp 登录到一台 授予了用户足够权限的服务器中，则可以执行很多普通的文件管理任务。虽然很笨拙， 但它真能工作。</p><h4 id="lftp-更好的-ftp"><a href="#lftp-更好的-ftp" class="headerlink" title="lftp - 更好的 ftp"></a>lftp - 更好的 ftp</h4><p>ftp is not the only command line FTP client. In fact, there are many. One of better (and more popular) ones is lftp by Alexander Lukyanov. It works much like the traditional ftp program, but has many additional convenience features including multiple protocol support (including HTTP), automatic re-try on failed downloads, background processes, tab completion of path names, and many more.</p><p>ftp 并不是唯一的命令行形式的 FTP 客户端。实际上，还有很多。其中比较好（也更流行的）是 lftp 程序， 由 Alexander Lukyanov 编写完成。虽然 lftp 工作起来与传统的 ftp 程序很相似，但是它带有额外的便捷特性，包括 多协议支持（包括 HTTP），若下载失败会自动地重新下载，后台处理，用 tab 按键来补全路径名，还有很多。</p><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>Another popular command line program for file downloading is wget. It is useful for downloading content from both web and FTP sites. Single files, multiple files, and even entire sites can be downloaded. To download the first page of linuxcommand.org we could do this:</p><p>另一个流行的用来下载文件的命令行程序是 wget。若想从网络和 FTP 网站两者上都能下载数据，wget 是很有用处的。 不只能下载单个文件，多个文件，甚至整个网站都能下载。下载 linuxcommand.org 网站的首页， 我们可以这样做：</p><pre><code>[me@linuxbox ~]$ wget http://linuxcommand.org/index.php--11:02:51-- http://linuxcommand.org/index.php        =&gt; `index.php&#39;Resolving linuxcommand.org... 66.35.250.210Connecting to linuxcommand.org|66.35.250.210|:80... connected.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]  [ &lt;                        =&gt; ]        3,120       --.--K/s11:02:51 (161.75 MB/s) - &#39;index.php&#39; saved [3120]</code></pre><p>The program’s many options allow wget to recursively download, download files in the background (allowing you to log off but continue downloading), and complete the download of a partially downloaded file. These features are well documented in its better-than-average man page.</p><p>这个程序的许多选项允许 wget 递归地下载，在后台下载文件（你退出后仍在下载），能完成未下载 全的文件。这些特性在其优秀的命令手册中有着详尽地说明。</p><h3 id="与远程主机安全通信"><a href="#与远程主机安全通信" class="headerlink" title="与远程主机安全通信"></a>与远程主机安全通信</h3><p>For many years, Unix-like operating systems have had the ability to be administered remotely via a network. In the early days, before the general adoption of the Internet, there were a couple of popular programs used to log in to remote hosts. These were the rlogin and telnet programs. These programs, however, suffer from the same fatal flaw that the ftp program does; they transmit all their communications (including login names and passwords) in cleartext. This makes them wholly inappropriate for use in the Internet age.</p><p>通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 rlogin 和 telnet 程序。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不 适合使用在因特网时代。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>To address this problem, a new protocol called SSH (Secure Shell) was developed. SSH solves the two basic problems of secure communication with a remote host. First, it authenticates that the remote host is who it says it is (thus preventing so-called “man in the middle” attacks), and second, it encrypts all of the communications between the local and remote hosts.</p><p>为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。 SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。</p><p>SSH consists of two parts. An SSH server runs on the remote host, listening for incoming connections on port twenty-two, while an SSH client is used on the local system to communicate with the remote server.</p><p>SSH 由两部分组成。SSH 服务端运行在远端主机上，在端口 22 上监听收到的外部连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。</p><p>Most Linux distributions ship an implementation of SSH called OpenSSH from the BSD project. Some distributions include both the client and the server packages by default (for example, Red Hat), while others (such as Ubuntu) only supply the client. To enable a system to receive remote connections, it must have the OpenSSH-server package installed, configured and running, and (if the system is either running or is behind a firewall) it must allow incoming network connections on TCP port 22.</p><p>大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 OpenSSH，来自于 BSD 项目。一些发行版 默认包含客户端和服务端两个软件包（例如 Red Hat），而另一些（比方说 Ubuntu）则只提供客户端。 为了能让系统接受远端的连接，它必须安装 OpenSSH-server 软件包，配置，运行它， 并且（如果系统正在运行，或者系统在防火墙之后）它必须允许在 TCP 端口 22 上接收网络连接。</p><hr><p>Tip: If you don’t have a remote system to connect to but want to try these examples, make sure the OpenSSH-server package is installed on your system and use localhost as the name of the remote host. That way, your machine will create network connections with itself.</p><p>小贴示：如果你没有远端系统去连接，但还想试试这些实例，则确认安装了 OpenSSH-server 软件包 ，则可使用 localhost 作为远端主机的名字。这种情况下，计算机会和它自己创建网络连接。</p><hr><p>The SSH client program used to connect to remote SSH servers is called, appropriately enough, ssh. To connect to a remote host named remote-sys, we would use the ssh client program like so:</p><p>用来与远端 SSH 服务器相连接的 SSH 客户端程序，顺理成章，叫做 ssh。想要连接到名叫 remote-sys 的远端主机，我们可以这样使用 ssh 客户端程序：</p><pre><code>[me@linuxbox ~]$ ssh remote-sysThe authenticity of host &#39;remote-sys (192.168.1.4)&#39; can&#39;t beestablished.RSA key fingerprint is41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.Are you sure you want to continue connecting (yes/no)?</code></pre><p>The first time the connection is attempted, a message is displayed indicating that the authenticity of the remote host cannot be established. This is because the client program has never seen this remote host before. To accept the credentials of the remote host, enter “yes” when prompted. Once the connection is established, the user is prompted for his/her password:</p><p>第一次尝试连接，提示信息表明远端主机的真实性不能确立。这是因为客户端程序以前从没有 看到过这个远端主机。为了接受远端主机的身份验证凭据，输入“yes”。一旦建立了连接，会提示 用户输入他或她的密码：</p><pre><code>Warning: Permanently added &#39;remote-sys,192.168.1.4&#39; (RSA) to the listof known hosts.me@remote-sys&#39;s password:</code></pre><p>After the password is successfully entered, we receive the shell prompt from the remote system:</p><p>成功地输入密码之后，我们会接收到远端系统的 shell 提示符：</p><pre><code>Last login: Sat Aug 30 13:00:48 2008[me@remote-sys ~]$</code></pre><p>The remote shell session continues until the user enters the exit command at the remote shell prompt, thereby closing the remote connection. At this point, the local shell session resumes and the local shell prompt reappears.</p><p>远端 shell 会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接。这时候，本地的 shell 会话 恢复，本地 shell 提示符重新出现。</p><p>It is also possible to connect to remote systems using a different user name. For example, if the local user “me” had an account named “bob” on a remote system, user me could log in to the account bob on the remote system as follows:</p><p>也有可能使用不同的用户名连接到远程系统。例如，如果本地用户“me”，在远端系统中有一个帐号名 “bob”，则用户 me 能够用 bob 帐号登录到远端系统，如下所示：</p><pre><code>[me@linuxbox ~]$ ssh bob@remote-sysbob@remote-sys&#39;s password:Last login: Sat Aug 30 13:03:21 2008[bob@remote-sys ~]$</code></pre><p>As stated before, ssh verifies the authenticity of the remote host. If the remote host does not successfully authenticate, the following message appears:</p><p>正如之前所讲到的，ssh 验证远端主机的真实性。如果远端主机不能成功地通过验证，则会提示以下信息：</p><pre><code>[me@linuxbox ~]$ ssh remote-sys@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middleattack)!...</code></pre><p>This message is caused by one of two possible situations. First, an attacker may be attempting a “man-in-the-middle” attack. This is rare, since everybody knows that ssh alerts the user to this. The more likely culprit is that the remote system has been changed somehow; for example, its operating system or SSH server has been reinstalled. In the interests of security and safety however, the first possibility should not be dismissed out of hand. Always check with the administrator of the remote system when this message occurs.</p><p>有两种可能的情形会提示这些信息。第一，某个攻击者企图制造“中间人”袭击。这很少见， 因为每个人都知道 ssh 会针对这种状况发出警告。最有可能的罪魁祸首是远端系统已经改变了； 例如，它的操作系统或者是 SSH 服务器重新安装了。然而，为了安全起见，第一个可能性不应该 被轻易否定。当这条消息出现时，总要与远端系统的管理员查对一下。</p><p>After it has been determined that the message is due to a benign cause, it is safe to correct the problem on the client side. This is done by using a text editor (vim perhaps) to remove the obsolete key from the ~/.ssh/known_hosts file. In the example message above, we see this:</p><p>当确定了这条消息归结为一个良性的原因之后，那么在客户端更正问题就很安全了。 使用文本编辑器（可能是 vim）从文件~/.ssh/known_hosts 中删除废弃的钥匙， 就解决了问题。在上面的例子里，我们看到这样一句话：</p><pre><code>Offending key in /home/me/.ssh/known_hosts:1</code></pre><p>This means that line one of the known_hosts file contains the offending key. Delete this line from the file, and the ssh program will be able to accept new authentication credentials from the remote system.</p><p>这意味着 known_hosts 文件的第一行包含那个冲突的钥匙。从文件中删除这一行，则 ssh 程序 就能够从远端系统接受新的身份验证凭据。</p><p>Besides opening a shell session on a remote system, ssh also allows us to execute a single command on a remote system. For example, to execute the free command on a remote host named remote-sys and have the results displayed on the local system:</p><p>除了能够在远端系统中打开一个 shell 会话，ssh 程序也允许我们在远端系统中执行单个命令。 例如，在名为 remote-sys 的远端主机上，执行 free 命令，并把输出结果显示到本地系统 shell 会话中。</p><pre><code>[me@linuxbox ~]$ ssh remote-sys freeme@twin4&#39;s password:            total   used       free     shared buffers cachedMem:        775536  507184   268352          0  110068 154596-/+ buffers/cache: 242520  533016Swap: 0 1572856 0 110068 154596[me@linuxbox ~]$</code></pre><p>It’s possible to use this technique in more interesting ways, such as this example in which we perform an ls on the remote system and redirect the output to a file on the local system:</p><p>有可能以更有趣的方式来利用这项技术，比方说下面的例子，我们在远端系统中执行 ls 命令， 并把命令输出重定向到本地系统中的一个文件里面。</p><pre><code>[me@linuxbox ~]$ ssh remote-sys &#39;ls \*&#39; &gt; dirlist.txtme@twin4&#39;s password:[me@linuxbox ~]$</code></pre><p>Notice the use of the single quotes in the command above. This is done because we do not want the pathname expansion performed on the local machine; rather, we want it to be performed on the remote system. Likewise, if we had wanted the output redirected to a file on the remote machine, we could have placed the redirection operator and the filename within the single quotes:</p><p>注意，上面的例子中使用了单引号。这样做是因为我们不想路径名展开操作在本地执行，而希望 它在远端系统中被执行。同样地，如果我们想要把输出结果重定向到远端主机的文件中，我们可以 把重定向操作符和文件名都放到单引号里面。</p><pre><code>[me@linuxbox ~]$ ssh remote-sys &#39;ls * &gt; dirlist.txt&#39;</code></pre><blockquote><p>Tunneling With SSH</p><p><em>SSH 通道</em></p><p>Part of what happens when you establish a connection with a remote host via SSH is that an encrypted tunnel is created between the local and remote systems. Normally, this tunnel is used to allow commands typed at the local system to be transmitted safely to the remote system, and for the results to be transmitted safely back. In addition to this basic function, the SSH protocol allows most types of network traffic to be sent through the encrypted tunnel, creating a sort of VPN (Virtual Private Network) between the local and remote systems.</p><p>当你通过 SSH 协议与远端主机建立连接的时候，其中发生的事就是在本地与远端系统之间 创建了一条加密通道。通常，这条通道被用来把在本地系统中输入的命令安全地传输到远端系统， 同样地，再把执行结果安全地发送回来。除了这个基本功能之外，SSH 协议允许大多数 网络流量类型通过这条加密通道来被传送，在本地与远端系统之间创建一种 VPN（虚拟专用网络）。</p><p>Perhaps the most common use of this feature is to allow X Window system traffic to be transmitted. On a system running an X server (that is, a machine displaying a GUI), it is possible to launch and run an X client program (a graphical application) on a remote system and have its display appear on the local system. It’s easy to do, here’s an example: let’s say we are sitting at a Linux system called linuxbox which is running an X server, and we want to run the xload program on a remote system named remote-sys and see the program’s graphical output on our local system. We could do this:</p><p>可能这个特性的最普遍的用法是允许传递 X 窗口系统流量。在运行着 X 服务端的系统（也就是， 能显示 GUI 的机器）上，能登录远端系统并运行一个 X 客户端程序（一个图形化应用）， 而应用程序的显示结果出现在本地。这很容易完成，这里有个例子：假设我们正坐在一台名为 linuxbox 的 Linux 系统前，且系统中运行着 X 服务端，现在我们想要在名为 remote-sys 的远端系统中 运行 xload 程序，但是要在我们的本地系统中看到这个程序的图形化输出。我们可以这样做：</p><pre><code>[me@linuxbox ~]$ ssh -X remote-sysme@remote-sys&#39;s password:Last login: Mon Sep 08 13:23:11 2008[me@remote-sys ~]$ xload</code></pre><p>After the xload command is executed on the remote system, its window appears on the local system. On some systems, you may need to use the “-Y” option rather than the “-X” option to do this.</p><p>这个 xload 命令在远端执行之后，它的窗口就会出现在本地。在某些系统中，你可能需要 使用 “－Y” 选项，而不是 “－X” 选项来完成这个操作。</p></blockquote><h4 id="scp-和-sftp"><a href="#scp-和-sftp" class="headerlink" title="scp 和 sftp"></a>scp 和 sftp</h4><p>The OpenSSH package also includes two programs that can make use of an SSH encrypted tunnel to copy files across the network. The first, scp (secure copy) is used much like the familiar cp program to copy files. The most notable difference is that the source or destination pathnames may be preceded with the name of a remote host, followed by a colon character. For example, if we wanted to copy a document named document.txt from our home directory on the remote system, remote-sys, to the current working directory on our local system, we could do this:</p><p>OpenSSH 软件包也包含两个程序，它们可以利用 SSH 加密通道在网络间复制文件。 第一个，scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。最显著的区别就是 源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头。例如，如果我们想要 从 remote-sys 远端系统的家目录下复制文档 document.txt，到我们本地系统的当前工作目录下， 可以这样操作：</p><pre><code>[me@linuxbox ~]$ scp remote-sys:document.txt .me@remote-sys&#39;s password:document.txt100%        5581        5.5KB/s         00:00[me@linuxbox ~]$</code></pre><p>As with ssh, you may apply a user name to the beginning of the remote host’s name if the desired remote host account name does not match that of the local system:</p><p>和 ssh 命令一样，如果所需的远端主机帐户名与本地系统中的不一致， 那么你可以把用户名添加到远端主机名的开头：</p><pre><code>[me@linuxbox ~]$ scp bob@remote-sys:document.txt .</code></pre><p>The second SSH file copying program is sftp which, as its name implies, is a secure replacement for the ftp program. sftp works much like the original ftp program that we used earlier; however, instead of transmitting everything in cleartext, it uses an SSH encrypted tunnel. sftp has an important advantage over conventional ftp in that it does not require an FTP server to be running on the remote host. It only requires the SSH server. This means that any remote machine that can connect with the SSH client can also be used as a FTP-like server. Here is a sample session:</p><p>第二个 SSH 文件复制程序是 sftp，顾名思义，它是 ftp 程序的安全替代品。sftp 工作起来与我们 之前使用的 ftp 程序很相似；然而，它不用明码形式来传递数据，它使用加密的 SSH 通道。sftp 有一个 重要特性强于传统的 ftp 命令，就是 sftp 不需要远端系统中运行 FTP 服务端。它仅仅需要 SSH 服务端。 这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似于 FTP 的服务器来使用。 这里是一个样本会话：</p><pre><code>[me@linuxbox ~]$ sftp remote-sysConnecting to remote-sys...me@remote-sys&#39;s password:sftp&gt; lsubuntu-8.04-desktop-i386.isosftp&gt; lcd Desktopsftp&gt; get ubuntu-8.04-desktop-i386.isoFetching /home/me/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-desktop-i386.iso/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35sftp&gt; bye</code></pre><hr><p>Tip: The SFTP protocol is supported by many of the graphical file managers found in Linux distributions. Using either Nautilus (GNOME) or Konqueror (KDE), we can enter a URI beginning with sftp:// into the location bar and operate on files stored on a remote system running an SSH server.</p><p>小贴示：SFTP 协议被许多 Linux 发行版中的图形化文件管理器支持。使用 Nautilus (GNOME), 或者是 Konqueror (KDE)，我们都能在位置栏中输入以 sftp:// 开头的 URI，来操作存储在运行着 SSH 服务端的远端系统中的文件。</p><hr><blockquote><p>An SSH Client For Windows?</p><p><em>Windows 中的 SSH 客户端</em></p><p>Let’s say you are sitting at a Windows machine but you need to log in to your Linux server and get some real work done, what do you do? Get an SSH client program for your Windows box, of course! There are a number of these. The most popular one is probably PuTTY by Simon Tatham and his team. The PuTTY program displays a terminal window and allow a Windows user to open an SSH (or telnet) session on a remote host. The program also provides analogs for the scp and sftp programs.</p><p>比方说你正坐在一台 Windows 机器前面，但是你需要登录到你的 Linux 服务器中，去完成 一些实际的工作，那该怎么办呢？当然是找一个 Windows 平台下的 SSH 客户端！有很多这样 的工具。最流行的可能就是由 Simon Tatham 和他的团队开发的 PuTTY 了。PuTTY 程序 能够显示一个终端窗口，而且允许 Windows 用户在远端主机中打开一个 SSH（或者 telnet）会话。 这个程序也提供了 scp 和 sftp 程序的类似物。</p><p>PuTTY is available at <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></p><p>PuTTY 可在链接 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a> 处得到。</p></blockquote><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>For a broad (albeit dated) look at network administration, the Linux Documentation Project provides the Linux Network Administrator’s Guide:</p></li><li><p>Linux 文档项目提供了 Linux 网络管理指南，可以广泛地（虽然过时了）了解网络管理方面的知识。</p><p><a href="http://tldp.org/LDP/nag2/index.html" target="_blank" rel="noopener">http://tldp.org/LDP/nag2/index.html</a></p></li><li><p>Wikipedia contains many good networking articles. Here are some of the basics:</p></li><li><p>Wikipedia 上包含了许多网络方面的优秀文章。这里有一些基础的：</p><p><a href="http://en.wikipedia.org/wiki/Internet_protocol_address" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Internet_protocol_address</a></p><p><a href="http://en.wikipedia.org/wiki/Host_name" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Host_name</a></p><p><a href="http://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Uniform_Resource_Identifier</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十六章 存储媒介</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%AA%92%E4%BB%8B/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%AA%92%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>In previous chapters we’ve looked at manipulating data at the file level. In this chapter, we will consider data at the device level. Linux has amazing capabilities for handling storage devices, whether physical storage, such as hard disks, or network storage, or virtual storage devices like RAID (Redundant Array of Independent Disks) and LVM (Logical Volume Manager).</p><p>在前面章节中，我们已经在文件级别上见识了数据的操作。在这章里，我们将从设备级别来考虑数据。 Linux 有着令人惊奇的能力来处理存储设备，不管是物理设备，比如说硬盘，还是网络设备，或者是 虚拟存储设备，像 RAID（独立磁盘冗余阵列)和 LVM（逻辑卷管理器）。</p><p>However, since this is not a book about system administration, we will not try to cover this entire topic in depth. What we will try to do is introduce some of the concepts and key commands that are used to manage storage devices.</p><p>然而，这不是一本关于系统管理的书籍，我们不会试图深入地覆盖整个主题。我们将努力做的就是 介绍一些概念和用来管理存储设备的重要命令。</p><p>To carry out the exercises in this chapter, we will use a USB flash drive, a CD-RW disk (for systems equipped with a CD-ROM burner) and a floppy disk (again, if the system is so equipped.)</p><p>为了做这一章的练习，我们将会使用 USB 闪存，CD-RW 光盘（如果系统配备了 CD-ROM 烧录器） 和一张软盘（如果系统有这样配备的话）。</p><p>We will look at the following commands:</p><p>我们将看看以下命令：</p><ul><li>mount – Mount a file system</li><li>mount – 挂载一个文件系统</li><li>umount – Unmount a file system</li><li>umount – 卸载一个文件系统</li><li>fsck – Check and repair a file system</li><li>fsck – 检查和修复一个文件系统</li><li>fdisk – Partition table manipulator</li><li>fdisk – 分区表控制器</li><li>mkfs – Create a file system</li><li>mkfs – 创建文件系统</li><li>fdformat – Format a floppy disk</li><li>fdformat – 格式化一张软盘</li><li>dd – Write block oriented data directly to a device</li><li>dd — 把面向块的数据直接写入设备</li><li>genisoimage (mkisofs) – Create an ISO 9660 image file</li><li>genisoimage (mkisofs) – 创建一个 ISO 9660的映像文件</li><li>wodim (cdrecord) – Write data to optical storage media</li><li>wodim (cdrecord) – 把数据写入光存储媒介</li><li>md5sum – Calculate an MD5 checksum</li><li>md5sum – 计算 MD5检验码</li></ul><h3 id="挂载和卸载存储设备"><a href="#挂载和卸载存储设备" class="headerlink" title="挂载和卸载存储设备"></a>挂载和卸载存储设备</h3><p>Recent advances in the Linux desktop have made storage device management extremely easy for desktop users. For the most part, we attach a device to our system and it “just works.” Back in the old days (say, 2004), this stuff had to be done manually. On non- desktop systems (i.e., servers) this is still a largely manual procedure since servers often have extreme storage needs and complex configuration requirements.</p><p>Linux 桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易。大多数情况下，我们 只要把设备连接到系统中，它就能工作。在过去（比如说，2004年），这个工作必须手动完成。 在非桌面系统中（例如，服务器中），这仍然是一个主要地手动过程，因为服务器经常有极端的存储需求 和复杂的配置要求。</p><p>The first step in managing a storage device is attaching the device to the file system tree. This process, called mounting, allows the device to participate with the operating system. As we recall from Chapter 3, Unix-like operating systems, like Linux, maintain a single file system tree with devices attached at various points. This contrasts with other operating systems such as MS-DOS and Windows that maintain separate trees for each device (for example C:, D:, etc.).</p><p>管理存储设备的第一步是把设备连接到文件系统树中。这个叫做”挂载”的过程允许设备连接到操作系统中。 回想一下第三章，类 Unix 的操作系统，比如Linux在单一文件系统树中维护连接在各个节点的各种设备。 这与其它操作系统形成对照，比如说 MS-DOS 和 Windows 系统中，每个设备（例如 C:\，D:\，等） 保持着单独的文件系统树。</p><p>There is a file named /etc/fstab that lists the devices (typically hard disk partitions) that are to be mounted at boot time. Here is an example /etc/fstab file from a Fedora 7 system:</p><p>有一个叫做/etc/fstab 的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下面是 来自于 Fedora 7系统的/etc/fstab 文件实例：</p><pre><code>LABEL=/12               /               ext3        defaults        1   1LABEL=/home             /home           ext3        defaults        1   2LABEL=/boot             /boot           ext3        defaults        1   2tmpfs                   /dev/shm        tmpfs       defaults        0   0devpts                  /dev/pts        devpts      gid=5,mode=620  0   0sysfs                   /sys            sysfs       defaults        0   0proc                    /proc           proc        defaults        0   0LABEL=SWAP-sda3         /swap           swap        defaults        0   0</code></pre><p>Most of the file systems listed in this example file are virtual and are not applicable to our discussion. For our purposes, the interesting ones are the first three:</p><p>在这个实例中所列出的大多数文件系统是虚拟的，并不适用于我们的讨论。就我们的目的而言， 前三个是我们感兴趣的：</p><pre><code>LABEL=/12               /               ext3        defaults        1   1LABEL=/home             /home           ext3        defaults        1   2LABEL=/boot             /boot           ext3        defaults        1   2</code></pre><p>These are the hard disk partitions. Each line of the file consists of six fields, as follows:</p><p>这些是硬盘分区。每行由六个字段组成，如下所示：</p><table><thead><tr><th align="left">Field</th><th align="left">Contents</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Device</td><td align="left">Traditionally, this field contains the actual name of a device file associated with the physical device, such as /dev/hda1 (the first partition of the master device on the first IDE channel). But with today’s computers, which have many devices that are hot pluggable (like USB drives), many modern Linux distributions associate a device with a text label instead. This label (which is added to the storage media when it is formatted) is read by the operating system when the device is attached to the system. That way, no matter which device file is assigned to the actual physical device, it can still be correctly identified.</td></tr><tr><td align="left">2</td><td align="left">Mount Point</td><td align="left">The directory where the device is attached to the file system tree.</td></tr><tr><td align="left">3</td><td align="left">File System Type</td><td align="left">Linux allows many file system types to be mounted. Most native Linux file systems are ext3, but many others are supported, such as FAT16 (msdos), FAT32 (vfat), NTFS (ntfs), CD-ROM (iso9660), etc.</td></tr><tr><td align="left">4</td><td align="left">Options</td><td align="left">File systems can be mounted with various options. It is possible, for example, to mount file systems as read-only, or prevent any programs from being executed from them (a useful security feature for removable media.)</td></tr><tr><td align="left">5</td><td align="left">Frequency</td><td align="left">A single number that specifies if and when a file system is to be backed up with the dump command.</td></tr><tr><td align="left">6</td><td align="left">Order</td><td align="left">A single number that specifies in what order file systems should be checked with the fsck command.</td></tr></tbody></table><table><thead><tr><th align="left">字段</th><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">设备名</td><td align="left">传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个 IDE 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 USB 驱动设备），许多 现代的 Linux 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时， 这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。 那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。</td></tr><tr><td align="left">2</td><td align="left">挂载点</td><td align="left">设备所连接到的文件系统树的目录。</td></tr><tr><td align="left">3</td><td align="left">文件系统类型</td><td align="left">Linux 允许挂载许多文件系统类型。大多数本地的 Linux 文件系统是 ext3， 但是也支持很多其它的，比方说 FAT16 (msdos), FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660)，等等。</td></tr><tr><td align="left">4</td><td align="left">选项</td><td align="left">文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统， 或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。）</td></tr><tr><td align="left">5</td><td align="left">频率</td><td align="left">一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。</td></tr><tr><td align="left">6</td><td align="left">次序</td><td align="left">一位数字，指定 fsck 命令按照什么次序来检查文件系统。</td></tr></tbody></table><h3 id="查看挂载的文件系统列表"><a href="#查看挂载的文件系统列表" class="headerlink" title="查看挂载的文件系统列表"></a>查看挂载的文件系统列表</h3><p>The mount command is used to mount file systems. Entering the command without arguments will display a list of the file systems currently mounted:</p><p>这个 mount 命令被用来挂载文件系统。执行这个不带参数的命令，将会显示 一系列当前挂载的文件系统：</p><pre><code>[me@linuxbox ~]$ mount/dev/sda2 on / type ext3 (rw)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,gid=5,mode=620)/dev/sda5 on /home type ext3 (rw)/dev/sda1 on /boot type ext3 (rw)tmpfs on /dev/shm type tmpfs (rw)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)fusectl on /sys/fs/fuse/connections type fusectl (rw)/dev/sdd1 on /media/disk type vfat (rw,nosuid,nodev,noatime,uhelper=hal,uid=500,utf8,shortname=lower)twin4:/musicbox on /misc/musicbox type nfs4 (rw,addr=192.168.1.4)</code></pre><p>The format of the listing is: device on mount_point type file_system_type (options). For example, the first line shows that device /dev/sda2 is mounted as the root file system and it is of type ext3 and is both readable and writable (the option “rw”). This listing also has two interesting entries at the bottom of the list. The next to last entry shows a 2 gigabyte SD memory card in a card reader mounted at /media/disk, and the last entry is a network drive mounted at /misc/musicbox.</p><p>这个列表的格式是：设备 on 挂载点 type 文件系统类型（选项）。例如，第一行所示设备/dev/sda2 作为根文件系统被挂载，文件系统类型是 ext3，并且可读可写（这个“rw”选项）。在这个列表的底部有 两个有趣的条目。倒数第二行显示了在读卡器中的一张2G 的 SD 内存卡，挂载到了/media/disk 上。最后一行 是一个网络设备，挂载到了/misc/musicbox 上。</p><p>For our first experiment, we will work with a CD-ROM. First, let’s look at a system before a CD-ROM is inserted:</p><p>第一次实验，我们将使用一张 CD-ROM。首先，在插入 CD-ROM 之前，我们将看一下系统：</p><pre><code>[me@linuxbox ~]$ mount/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,gid=5,mode=620)/dev/hda1 on /boot type ext3 (rw)tmpfs on /dev/shm type tmpfs (rw)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)</code></pre><p>This listing is from a CentOS 5 system, which is using LVM (Logical Volume Manager) to create its root file system. Like many modern Linux distributions, this system will attempt to automatically mount the CD-ROM after insertion. After we insert the disk, we see the following:</p><p>这个列表来自于 CentOS 5系统，使用 LVM（逻辑卷管理器）来创建它的根文件系统。正如许多现在的 Linux 发行版一样，这个 系统试图自动挂载插入的 CD-ROM。当我们插入光盘后，我们看看下面的输出：</p><pre><code>[me@linuxbox ~]$ mount/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,gid=5,mode=620)/dev/hda1 on /boot type ext3 (rw)tmpfs on /dev/shm type tmpfs (rw)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,nodev,uid=500)</code></pre><p>After we insert the disk, we see the same listing as before with one additional entry. At the end of the listing we see that the CD-ROM (which is device /dev/hdc on this system) has been mounted on /media/live-1.0.10-8, and is type iso9660 (a CD- ROM). For purposes of our experiment, we’re interested in the name of the device. When you conduct this experiment yourself, the device name will most likely be different.</p><p>当我们插入光盘后，除了额外的一行之外，我们看到和原来一样的列表。在列表的末尾，我们 看到 CD-ROM 已经挂载到了/media/live-1.0.10-8上，它的文件类型是 iso9660（CD-ROM）。 就我们的实验目的而言，我们对这个设备的名字感兴趣。当你自己进行这个实验时，这个 设备名字是最有可能不同的。</p><p>Warning: In the examples that follow, it is vitally important that you pay close attention to the actual device names in use on your system and do not use the names used in this text!</p><p>警告：在随后的实例中，至关重要的是你要密切注意用在你系统中的实际设备名，并且 不要使用此文本中使用的名字！</p><p>Also note that audio CDs are not the same as CD-ROMs. Audio CDs do not contain file systems and thus cannot be mounted in the usual sense.</p><p>还要注意音频 CD 和 CD-ROM 不一样。音频 CD 不包含文件系统，这样在通常意义上，它就不能被挂载了。</p><p>Now that we have the device name of the CD-ROM drive, let’s unmount the disk and remount it another location in the file system tree. To do this, we become the superuser (using the command appropriate for our system) and unmount the disk with the umount (notice the spelling) command:</p><p>现在我们拥有 CD-ROM 光盘的设备名字，让我们卸载这张光盘，并把它重新挂载到文件系统树 的另一个位置。我们需要超级用户身份（使用系统相应的命令）来进行操作，并且用 umount（注意这个命令的拼写）来卸载光盘：</p><pre><code>[me@linuxbox ~]$ su -Password:[root@linuxbox ~]# umount /dev/hdc</code></pre><p>The next step is to create a new mount point for the disk. A mount point is simply a directory somewhere on the file system tree. Nothing special about it. It doesn’t even have to be an empty directory, though if you mount a device on a non-empty directory, you will not be able to see the directory’s previous contents until you unmount the device. For our purposes, we will create a new directory:</p><p>下一步是创建一个新的光盘挂载点。简单地说，一个挂载点就是文件系统树中的一个目录。它没有 什么特殊的。它甚至不必是一个空目录，如果你把设备挂载到了一个非空目录上，你将不能看到 这个目录中原来的内容，直到你卸载这个设备。就我们的目的而言，我们将创建一个新目录：</p><pre><code>[root@linuxbox ~]# mkdir /mnt/cdrom</code></pre><p>Finally, we mount the CD-ROM at the new mount point. The -t option is used to specify the file system type:</p><p>最后，我们把这个 CD-ROW 挂载到一个新的挂载点上。这个-t 选项用来指定文件系统类型：</p><pre><code>[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom</code></pre><p>Afterward, we can examine the contents of the CD-ROM via the new mount point:</p><p>之后，我们可以通过这个新挂载点来查看 CD-ROW 的内容：</p><pre><code>[root@linuxbox ~]# cd /mnt/cdrom[root@linuxbox cdrom]# ls</code></pre><p>Notice what happens when we try to unmount the CD-ROM:</p><p>注意当我们试图卸载这个 CD-ROW 时，发生了什么事情。</p><pre><code>[root@linuxbox cdrom]# umount /dev/hdcumount: /mnt/cdrom: device is busy</code></pre><p>Why is this? The reason is that we cannot unmount a device if the device is being used by someone or some process. In this case, we changed our working directory to the mount point for the CD-ROM, which causes the device to be busy. We can easily remedy the issue by changing the working directory to something other than the mount point:</p><p>这是怎么回事呢？原因是我们不能卸载一个设备，如果某个用户或进程正在使用这个设备的话。在这种 情况下，我们把工作目录更改到了 CD-ROW 的挂载点，这个挂载点导致设备忙碌。我们可以很容易地修复这个问题 通过把工作目录改到其它目录而不是这个挂载点。</p><pre><code>[root@linuxbox cdrom]# cd[root@linuxbox ~]# umount /dev/hdc</code></pre><p>Now the device unmounts successfully.</p><p>现在这个设备成功卸载了。</p><blockquote><p>Why Unmounting Is Important</p><p>为什么卸载重要</p><p>If you look at the output of the free command, which displays statistics about memory usage, you will see a statistic called “buffers.” Computer systems are designed to go as fast as possible. One of the impediments to system speed is slow devices. Printers are a good example. Even the fastest printer is extremely slow by computer standards. A computer would be very slow indeed if it had to stop and wait for a printer to finish printing a page. In the early days of PCs (before multi-tasking), this was a real problem. If you were working on a spreadsheet or text document, the computer would stop and become unavailable every time you printed. The computer would send the data to the printer as fast as the printer could accept it, but it was very slow since printers don’t print very fast. This problem was solved by the advent of the printer buffer, a device containing some RAM memory that would sit between the computer and the printer. With the printer buffer in place, the computer would send the printer output to the buffer and it would quickly be stored in the fast RAM so the computer could go back to work without waiting. Meanwhile, the printer buffer would slowly spool the data to the printer from the buffer’s memory at the speed at which the printer could accept it.</p><p>如果你看一下 free 命令的输出结果，这个命令用来显示关于内存使用情况的统计信息，你 会看到一个统计值叫做”buffers“。计算机系统旨在尽可能快地运行。系统运行速度的 一个阻碍是缓慢的设备。打印机是一个很好的例子。即使最快速的打印机相比于计算机标准也 极其地缓慢。一台计算机确实会运行得非常慢，如果它要停下来等待一台打印机打印完一页。 在早期的个人电脑时代（多任务之前），这真是个问题。如果你正在编辑电子表格 或者是文本文档，每次你要打印文件时，计算机都会停下来而且变得不能使用。 计算机能以打印机可接受的最快速度把数据发送给打印机，但由于打印机不能快速地打印， 这个发送速度会非常慢。由于打印机缓存的出现，这个问题被解决了。打印机缓存是一个包含一些 RAM 内存 的设备，位于计算机和打印机之间。通过打印机缓存，计算机把要打印的结果发送到这个缓存区， 数据会迅速地存储到这个 RAM 中，这样计算机就能回去工作，而不用等待。与此同时，打印机缓存将会 以打印机可接受的速度把缓存中的数据缓慢地输出给打印机。</p><p>This idea of buffering is used extensively in computers to make them faster. Don’t let the need to occasionally read or write data to/from slow devices impede the speed of the system. Operating systems store data read from, and to be written to storage devices in memory for as long as possible before actually having to interact with the slower device. On a Linux system for example, you will notice that the system seems to fill up memory the longer it is used. This does not mean Linux is “using“ all the memory, it means that Linux is taking advantage of all the available memory to do as much buffering as it can.</p><p>缓存被广泛地应用于计算机中，使其运行得更快。别让偶尔地的读取或写入慢设备的需求阻碍了 系统的运行速度。在真正与比较慢的设备交互之前，操作系统会尽可能多的读取或写入数据到内存中的 存储设备里。以 Linux 操作系统为例，你会注意到系统看似填充了多于它所需要的内存。 这不意味着 Linux 正在使用所有的内存，它意味着 Linux 正在利用所有可用的内存，来作为缓存区。</p><p>This buffering allows writing to storage devices to be done very quickly, because the writing to the physical device is being deferred to a future time. In the meantime, the data destined for the device is piling up in memory. From time to time, the operating system will write this data to the physical device.</p><p>这个缓存区允许非常快速地对存储设备进行写入，因为写入物理设备的操作被延迟到后面进行。同时， 这些注定要传送到设备中的数据正在内存中堆积起来。时不时地，操作系统会把这些数据 写入物理设备。</p><p>Unmounting a device entails writing all the remaining data to the device so that it can be safely removed. If the device is removed without unmounting it first, the possibility exists that not all the data destined for the device has been transferred. In some cases, this data may include vital directory updates, which will lead to file system corruption, one of the worst things that can happen on a computer.</p><p>卸载一个设备需要把所有剩余的数据写入这个设备，所以设备可以被安全地移除。如果 没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据输送完毕。在某些情况下， 这些数据可能包含重要的目录更新信息，这将导致文件系统损坏，这是发生在计算机中的最坏的事情之一。</p></blockquote><h3 id="确定设备名称"><a href="#确定设备名称" class="headerlink" title="确定设备名称"></a>确定设备名称</h3><p>It’s sometimes difficult to determine the name of a device. Back in the old days, it wasn’t very hard. A device was always in the same place and it didn’t change. Unix-like systems like it that way. Back when Unix was developed, “changing a disk drive” involved using a forklift to remove a washing machine-sized device from the computer room. In recent years, the typical desktop hardware configuration has become quite dynamic and Linux has evolved to become more flexible than its ancestors. In the examples above we took advantage of the modern Linux desktop’s ability to “automagically” mount the device and then determine the name after the fact. But what if we are managing a server or some other environment where this does not occur? How can we figure it out?</p><p>有时很难来确定设备名称。在以前，这并不是很难。一台设备总是在某个固定的位置，也不会 挪动它。类 Unix 的系统喜欢设备那样安排。退回到 Unix 系统的时代，“更改一个磁盘驱动器”更像是要用一辆 叉车从机房中移除一台如洗衣机大小的设备那样困难。最近几年，典型的桌面硬件配置已经变得相当动态，并且 Linux 已经发展地比其祖先更加灵活。在以上事例中，我们利用现代 Linux 桌面系统的功能来“自动地”挂载 设备，然后再确定设备名称。但是如果我们正在管理一台服务器或者是其它一些（这种自动挂载功能）不会 发生的环境，我们又如何能查清设备名呢？</p><p>First, let’s look at how the system names devices. If we list the contents of the /dev directory (where all devices live), we can see that there are lots and lots of devices:</p><p>首先，让我们看一下系统怎样来命名设备。如果我们列出目录/dev（所有设备的住所）的内容，我们 会看到许许多多的设备：</p><pre><code>[me@linuxbox ~]$ ls /dev</code></pre><p>The contents of this listing reveal some patterns of device naming. Here are a few:</p><p>这个列表的内容揭示了一些设备命名的模式。这里有几个：</p><table><thead><tr><th align="left">Pattern</th><th align="left">Device</th></tr></thead><tbody><tr><td align="left">/dev/fd*</td><td align="left">Floppy disk drives</td></tr><tr><td align="left">/dev/hd*</td><td align="left">IDE (PATA) disks on older systems. Typical motherboards contain two IDE connectors or channels, each with a cable with two attachment points for drives. The first drive on the cable is called the master device and the second is called the slave device. The device names are ordered such that /dev/hda refers to the master device on the first channel, /dev/hdb is the slave device on the first channel; /dev/hdc, the master device on the second channel, and so on. A trailing digit indicates the partition number on the device. For example, /dev/hda1 refers to the first partition on the first hard drive on the system while / dev/hda refers to the entire drive.</td></tr><tr><td align="left">/dev/lp*</td><td align="left">Printers</td></tr><tr><td align="left">/dev/sd*</td><td align="left">SCSI disks. On recent Linux systems, the kernel treats all disk- like devices (including PATA/SATA hard disks, flash drives, and USB mass storage devices, such as portable music players and digital cameras) as SCSI disks. The rest of the naming system is similar to the older /dev/hd* naming scheme described above.</td></tr><tr><td align="left">/dev/sr*</td><td align="left">Optical drives (CD/DVD readers and burners)</td></tr></tbody></table><table><thead><tr><th align="left">模式</th><th align="left">设备</th></tr></thead><tbody><tr><td align="left">/dev/fd*</td><td align="left">软盘驱动器</td></tr><tr><td align="left">/dev/hd*</td><td align="left">老系统中的 IDE(PATA)磁盘。典型的主板包含两个 IDE 连接器或者是通道，每个连接器 带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备， 第二个叫做从设备。设备名称这样安排，/dev/hda 是指第一通道上的主设备名；/dev/hdb 是第一通道上的从设备名；/dev/hdc 是第二通道上的主设备名，等等。末尾的数字表示 硬盘驱动器上的分区。例如，/dev/hda1是指系统中第一硬盘驱动器上的第一个分区，而 /dev/hda 则是指整个硬盘驱动器。</td></tr><tr><td align="left">/dev/lp*</td><td align="left">打印机</td></tr><tr><td align="left">/dev/sd*</td><td align="left">SCSI 磁盘。在最近的 Linux 系统中，内核把所有类似于磁盘的设备（包括 PATA/SATA 硬盘， 闪存，和 USB 存储设备，比如说可移动的音乐播放器和数码相机）看作 SCSI 磁盘。 剩下的命名系统类似于上述所描述的旧的/dev/hd*命名方案。</td></tr><tr><td align="left">/dev/sr*</td><td align="left">光盘（CD/DVD 读取器和烧写器）</td></tr></tbody></table><p>In addition, we often see symbolic links such as /dev/cdrom, /dev/dvd and /dev/ floppy, which point to the actual device files, provided as a convenience. If you are working on a system that does not automatically mount removable devices, you can use the following technique to determine how the removable device is named when it is attached. First, start a real-time view of the /var/log/messages file (you may require superuser privileges for this):</p><p>另外，我们经常看到符号链接比如说/dev/cdrom，/dev/dvd 和/dev/floppy，它们指向实际的 设备文件，提供这些链接是为了方便使用。如果你工作的系统不能自动挂载可移动的设备，你可以使用 下面的技巧来决定当可移动设备连接后，它是怎样被命名的。首先，启动一个实时查看文件/var/log/messages （你可能需要超级用户权限）：</p><pre><code>[me@linuxbox ~]$ sudo tail -f /var/log/messages</code></pre><p>The last few lines of the file will be displayed and then pause. Next, plug in the removable device. In this example, we will use a 16 MB flash drive. Almost immediately, the kernel will notice the device and probe it:</p><p>这个文件的最后几行会被显示，然后停止。下一步，插入这个可移动的设备。在 这个例子里，我们将使用一个16MB 闪存。瞬间，内核就会发现这个设备， 并且探测它：</p><pre><code>Jul 23 10:07:53 linuxbox kernel: usb 3-2: new full speed USB deviceusing uhci_hcd and address 2Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration #1 chosenfrom 1 choiceJul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation for USB MassStorage devicesJul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short(5), using 36Jul 23 10:07:58 linuxbox kernel: scsi 3:0:0:0: Direct-Access EasyDisk 1.00 PQ: 0 ANSI: 2Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-bytehardware sectors (16 MB)Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect isoffJul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drivecache: write throughJul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-bytehardware sectors (16 MB)Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect isoffJul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drivecache: write throughJul 23 10:07:59 linuxbox kernel: sdb: sdb1Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSIremovable diskJul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scsi genericsg3 type 0</code></pre><p>After the display pauses again, type Ctrl-c to get the prompt back. The interesting parts of the output are the repeated references to “[sdb]” which matches our expectation of a SCSI disk device name. Knowing this, two lines become particularly illuminating:</p><p>显示再次停止之后，输入 Ctrl-c，重新得到提示符。输出结果的有趣部分是一再提及“[sdb]”， 这正好符和我们期望的 SCSI 磁盘设备名称。知道这一点后，有两行输出变得颇具启发性：</p><pre><code>Jul 23 10:07:59 linuxbox kernel: sdb: sdb1Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSIremovable disk</code></pre><p>This tells us the device name is /dev/sdb for the entire device and /dev/sdb1 for the first partition on the device. As we have seen, working with Linux is full of interesting detective work!</p><p>这告诉我们这个设备名称是/dev/sdb 指整个设备，/dev/sdb1是这个设备的第一分区。 正如我们所看到的，使用 Linux 系统充满了有趣的监测工作。</p><p>Tip: Using the tail -f /var/log/messages technique is a great way to watch what the system is doing in near real-time.</p><p>小贴士：使用这个 tail -f /var/log/messages 技巧是一个很不错的方法，可以实时 观察系统的一举一动。</p><p>With our device name in hand, we can now mount the flash drive:</p><p>既然知道了设备名称，我们就可以挂载这个闪存驱动器了：</p><pre><code>[me@linuxbox ~]$ sudo mkdir /mnt/flash[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash[me@linuxbox ~]$ dfFilesystem      1K-blocks   Used        Available   Use%    Mounted on/dev/sda2       15115452    5186944     9775164     35%     //dev/sda5       59631908    31777376    24776480    57%     /home/dev/sda1       147764      17277       122858      13%     /boottmpfs           776808      0           776808      0%      /dev/shm/dev/sdb1       15560       0           15560       0%      /mnt/flash</code></pre><p>The device name will remain the same as long as it remains physically attached to the computer and the computer is not rebooted.</p><p>这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动。</p><h3 id="创建新的文件系统"><a href="#创建新的文件系统" class="headerlink" title="创建新的文件系统"></a>创建新的文件系统</h3><p>Let’s say that we want to reformat the flash drive with a Linux native file system, rather than the FAT32 system it has now. This involves two steps: 1. (optional) create a new partition layout if the existing one is not to our liking, and 2. create a new, empty file system on the drive.</p><p>假若我们想要用 Linux 本地文件系统来重新格式化这个闪存驱动器，而不是它现用的 FAT32系统。 这涉及到两个步骤：1.（可选的）创建一个新的分区布局若已存在的分区不是我们喜欢的。2. 在这个闪存上创建一个新的空的文件系统。</p><p>Warning! In the following exercise, we are going to format a flash drive. Use a drive that contains nothing you care about because it will be erased! Again, make absolutely sure you are specifying the correct device name for your system, not the one shown in the text. Failure to heed this warning could result in you formatting (i.e., erasing) the wrong drive!</p><p>注意！在下面的练习中，我们将要格式化一个闪存驱动器。拿一个不包含有用数据的驱动器 作为实验品，因为它将会被擦除！再次，请确定你指定了正确的系统设备名称。未能注意此 警告可能导致你格式化（即擦除）错误的驱动器！</p><h3 id="用-fdisk-命令操作分区"><a href="#用-fdisk-命令操作分区" class="headerlink" title="用 fdisk 命令操作分区"></a>用 fdisk 命令操作分区</h3><p>The fdisk program allows us to interact directly with disk-like devices (such as hard disk drives and flash drives) at a very low level. With this tool we can edit, delete, and create partitions on the device. To work with our flash drive, we must first unmount it (if needed) and then invoke the fdisk program as follows:</p><p>这个 fdisk 程序允许我们直接在底层与类似磁盘的设备（比如说硬盘驱动器和闪存驱动器）进行交互。 使用这个工具可以在设备上编辑，删除，和创建分区。以我们的闪存驱动器为例， 首先我们必须卸载它（如果需要的话），然后调用 fdisk 程序，如下所示：</p><pre><code>[me@linuxbox ~]$ sudo umount /dev/sdb1[me@linuxbox ~]$ sudo fdisk /dev/sdb</code></pre><p>Notice that we must specify the device in terms of the entire device, not by partition number. After the program starts up, we will see the following prompt:</p><p>注意我们必须指定设备名称，就整个设备而言，而不是通过分区号。这个程序启动后，我们 将看到以下提示：</p><pre><code>Command (m for help):</code></pre><p>Entering an “m” will display the program menu:</p><p>输入”m”会显示程序菜单：</p><pre><code>Command actiona       toggle a bootable flag....</code></pre><p>The first thing we want to do is examine the existing partition layout. We do this by entering “p” to print the partition table for the device:</p><p>我们想要做的第一件事情是检查已存在的分区布局。输入”p”会打印出这个设备的分区表：</p><pre><code>Command (m for help): pDisk /dev/sdb: 16 MB, 16006656 bytes1 heads, 31 sectors/track, 1008 cylindersUnits = cylinders of 31 * 512 = 15872 bytesDevice Boot     Start        End     Blocks   Id        System/dev/sdb1           2       1008      15608+   b       w95 FAT32</code></pre><p>In this example, we see a 16 MB device with a single partition (1) that uses 1006 of the available 1008 cylinders on the device. The partition is identified as Windows 95 FAT32 partition. Some programs will use this identifier to limit the kinds of operation that can be done to the disk, but most of the time it is not critical to change it. However, in the interest of demonstration, we will change it to indicate a Linux partition. To do this, we must first find out what ID is used to identify a Linux partition. In the listing above, we see that the ID “b” is used to specify the exiting partition. To see a list of the available partition types, we refer back to the program menu. There we can see the following choice:</p><p>在此例中，我们看到一个16MB 的设备只有一个分区(1)，此分区占用了可用的1008个柱面中的1006个, 并被标识为 Windows 95 FAT32分区。有些程序会使用这个标志符来限制一些可以对磁盘所做的操作， 但大多数情况下更改这个标志符没有危害。然而，为了叙述方便，我们将会更改它， 以此来表明是个 Linux 分区。在更改之前，首先我们必须找到被用来识别一个 Linux 分区的 ID 号码。 在上面列表中，我们看到 ID 号码“b”被用来指定这个已存在的分区。要查看可用的分区类型列表， 参考之前的程序菜单。我们会看到以下选项：</p><pre><code>l   list known partition types</code></pre><p>If we enter “l” at the prompt, a large list of possible types is displayed. Among them we see “b” for our existing partition type and “83” for Linux.</p><p>如果我们在提示符下输入“l”，就会显示一个很长的可能类型列表。在它们之中会看到“b”为已存在分区 类型的 ID 号，而“83”是针对 Linux 系统的 ID 号。</p><p>Going back to the menu, we see this choice to change a partition ID:</p><p>回到之前的菜单，看到这个选项来更改分区 ID 号：</p><pre><code>t   change a partition&#39;s system id</code></pre><p>We enter “t” at the prompt enter the new ID:</p><p>我们先输入“t”，再输入新的 ID 号：</p><pre><code>Command (m for help): tSelected partition 1Hex code (type L to list codes): 83Changed system type of partition 1 to 83 (Linux)</code></pre><p>This completes all the changes that we need to make. Up to this point, the device has been untouched (all the changes have been stored in memory, not on the physical device), so we will write the modified partition table to the device and exit. To do this, we enter “w” at the prompt:</p><p>这就完成了我们需要做得所有修改。到目前为止，还没有接触这个设备（所有修改都存储在内存中， 而不是在此物理设备中），所以我们将会把修改过的分区表写入此设备，再退出。为此，我们输入 在提示符下输入”w”:</p><pre><code>Command (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: If you have created or modified any DOS 6.xpartitions, please see the fdisk manual page for additionalinformation.Syncing disks.[me@linuxbox ~]$</code></pre><p>If we had decided to leave the device unaltered, we could have entered “q” at the prompt, which would have exited the program without writing the changes. We can safely ignore the ominous sounding warning message.</p><p>如果我们已经决定保持设备不变，可在提示符下输入”q”，这将退出程序而没有写更改。我们 可以安全地忽略这些不祥的警告信息。</p><h3 id="用-mkfs-命令创建一个新的文件系统"><a href="#用-mkfs-命令创建一个新的文件系统" class="headerlink" title="用 mkfs 命令创建一个新的文件系统"></a>用 mkfs 命令创建一个新的文件系统</h3><p>With our partition editing done (lightweight though it might have been) it’s time to create a new file system on our flash drive. To do this, we will use mkfs (short for “make file system”), which can create file systems in a variety of formats. To create an ext3 file system on the device, we use the “-t” option to specify the “ext3” system type, followed by the name of device containing the partition we wish to format:</p><p>完成了分区编辑工作（它或许是轻量级的），是时候在我们的闪存驱动器上创建一个新的文件系统了。 为此，我们会使用 mkfs（”make file system”的简写），它能创建各种格式的文件系统。 在此设备上创建一个 ext3文件系统，我们使用”-t” 选项来指定这个”ext3”系统类型，随后是我们要格式化的设备分区名称：</p><pre><code>[me@linuxbox ~]$ sudo mkfs -t ext3 /dev/sdb1mke2fs 1.40.2 (12-Jul-2007)Filesystem label=OS type: LinuxBlock size=1024 (log=0)Fragment size=1024 (log=0)3904 inodes, 15608 blocks780 blocks (5.00%) reserved for the super userFirst data block=1Maximum filesystem blocks=159907842 block groups8192 blocks per group, 8192 fragments per group1952 inodes per groupSuperblock backups stored on blocks:8193Writing inode tables: doneCreating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: doneThis filesystem will be automatically checked every 34 mounts or180 days, whichever comes first. Use tune2fs -c or -i to override.[me@linuxbox ~]$</code></pre><p>The program will display a lot of information when ext3 is the chosen file system type. To re-format the device to its original FAT32 file system, specify “vfat” as the file system type:</p><p>当 ext3被选为文件系统类型时，这个程序会显示许多信息。若把这个设备重新格式化为它最初的 FAT32文件 系统，指定”vfat”作为文件系统类型：</p><pre><code>[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1</code></pre><p>This process of partitioning and formatting can be used anytime additional storage devices are added to the system. While we worked with a tiny flash drive, the same process can be applied to internal hard disks and other removable storage devices like USB hard drives.</p><p>任何时候添加额外的存储设备到系统中时，都可以使用这个分区和格式化的过程。虽然我们 只以一个小小的闪存驱动器为例，同样的操作可以被应用到内部硬盘和其它可移动的存储设备上 像 USB 硬盘驱动器。</p><h3 id="测试和修复文件系统"><a href="#测试和修复文件系统" class="headerlink" title="测试和修复文件系统"></a>测试和修复文件系统</h3><p>In our earlier discussion of the /etc/fstab file, we saw some mysterious digits at the end of each line. Each time the system boots, it routinely checks the integrity of the file systems before mounting them. This is done by the fsck program (short for “file system check”). The last number in each fstab entry specifies the order the devices are to be checked. In our example above, we see that the root file system is checked first, followed by the home and boot file systems. Devices with a zero as the last digit are not routinely checked.</p><p>在之前讨论文件/etc/fstab 时，我们会在每行的末尾看到一些神秘的数字。每次系统启动时， 在挂载系统之前，都会按照惯例检查文件系统的完整性。这个任务由 fsck 程序（是”file system check”的简写）完成。每个 fstab 项中的最后一个数字指定了设备的检查顺序。 在上面的实例中，我们看到首先检查根文件系统，然后是 home 和 boot 文件系统。若最后一个数字 是零则相应设备不会被检查。</p><p>In addition to checking the integrity of file systems, fsck can also repair corrupt file systems with varying degrees of success, depending on the amount of damage. On Unix- like file systems, recovered portions of files are placed in the lost+found directory, located in the root of each file system.</p><p>除了检查文件系统的完整性之外，fsck 还能修复受损的文件系统，其成功度依赖于损坏的数量。 在类 Unix 的文件系统中，文件恢复的部分被放置于 lost+found 目录里面，位于每个文件 系统的根目录下面。</p><p>To check our flash drive (which should be unmounted first), we could do the following:</p><p>检查我们的闪存驱动器（首先应该卸载），我们能执行下面的操作：</p><pre><code>[me@linuxbox ~]$ sudo fsck /dev/sdb1fsck 1.40.8 (13-Mar-2008)e2fsck 1.40.8 (13-Mar-2008)/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks</code></pre><p>In my experience, file system corruption is quite rare unless there is a hardware problem, such as a failing disk drive. On most systems, file system corruption detected at boot time will cause the system to stop and direct you to run fsck before continuing.</p><p>以我的经验，文件系统损坏情况相当罕见，除非硬件存在问题，如磁盘驱动器故障。 在大多数系统中，系统启动阶段若探测到文件系统已经损坏了，则会导致系统停止下来， 在系统继续执行之前，会指导你运行 fsck 程序。</p><blockquote><p>What The fsck?</p><p>什么是 fsck?</p><p>In Unix culture, the word “fsck” is often used in place of a popular word with which it shares three letters. This is especially appropriate, given that you will probably be uttering the aforementioned word if you find yourself in a situation where you are forced to run fsck.</p><p>在 Unix 文化中，”fsck”这个单词往往会被用来指代另一个和它仅有一个字母差别的常用词。 因为如果你遇到了迫不得已需要运行 fsck 命令的糟糕境遇时，这个词经常会脱口而出。</p><h3 id="格式化软盘"><a href="#格式化软盘" class="headerlink" title="格式化软盘"></a>格式化软盘</h3></blockquote><p>For those of us still using computers old enough to be equipped with floppy diskette drives, we can manage those devices, too. Preparing a blank floppy for use is a two step process. First, we perform a low-format on the diskette, then create a file system. To accomplish the formatting, we use the fdformat program specifying the name of the floppy device (usually /dev/fd0):</p><p>对于那些还在使用配备了软盘驱动器的计算机的用户，我们也能管理这些设备。准备一 张可用的空白软盘要分两个步骤。首先，对这张软盘执行低级格式化，然后创建一个文件系统。 为了完成格式化，我们使用 fdformat 程序，同时指定软盘设备名称（通常为/dev/fd0）：</p><pre><code>[me@linuxbox ~]$ sudo fdformat /dev/fd0Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.Formatting ... doneVerifying ... done</code></pre><p>Next, we apply a FAT file system to the diskette with mkfs:</p><p>接下来，通过 mkfs 命令，给这个软盘创建一个 FAT 文件系统：</p><pre><code>[me@linuxbox ~]$ sudo mkfs -t msdos /dev/fd0</code></pre><p>Notice that we use the “msdos” file system type to get the older (and smaller) style file allocation tables. After a diskette is prepared, it may be mounted like other devices.</p><p>注意我们使用这个“msdos”文件系统类型来得到旧（小的）风格的文件分配表。当一个软磁盘 被准备好之后，则可能像其它设备一样挂载它。</p><h3 id="直接把数据移入-出设备"><a href="#直接把数据移入-出设备" class="headerlink" title="直接把数据移入/出设备"></a>直接把数据移入/出设备</h3><p>While we usually think of data on our computers as being organized into files, it is also possible to think of the data in “raw” form. If we look at a disk drive, for example, we see that it consists of a large number of “blocks” of data that the operating system sees as directories and files. However, if we could treat a disk drive as simply a large collection of data blocks, we could perform useful tasks, such as cloning devices.</p><p>虽然我们通常认为计算机中的数据以文件形式来组织数据，也可以“原始的”形式来考虑数据。 如果我们看一下磁盘驱动器，例如， 我们看到它由大量的数据“块”组成，而操作系统却把这些数据块看作目录和文件。然而，如果 把磁盘驱动器简单地看成一个数据块大集合，我们就能执行有用的任务，如克隆设备。</p><p>The dd program performs this task. It copies blocks of data from one place to another. It uses a unique syntax (for historical reasons) and is usually used this way:</p><p>这个 dd 程序能执行此任务。它可以把数据块从一个地方复制到另一个地方。它使用独特的语法（由于历史原因） ，经常它被这样使用：</p><pre><code>dd if=input_file of=output_file [bs=block_size [count=blocks]]</code></pre><p>Let’s say we had two USB flash drives of the same size and we wanted to exactly copy the first drive to the second. If we attached both drives to the computer and they are assigned to devices /dev/sdb and /dev/sdc respectively, we could copy everything on the first drive to the second drive with the following:</p><p>比方说我们有两个相同容量的 USB 闪存驱动器，并且要精确地把第一个驱动器（中的内容） 复制给第二个。如果连接两个设备到计算机上，它们各自被分配到设备/dev/sdb 和 /dev/sdc 上，这样我们就能通过下面的命令把第一个驱动器中的所有数据复制到第二个 驱动器中。</p><pre><code>dd if=/dev/sdb of=/dev/sdc</code></pre><p>Alternately, if only the first device were attached to the computer, we could copy its contents to an ordinary file for later restoration or copying:</p><p>或者，如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件中供 以后恢复或复制数据：</p><pre><code>dd if=/dev/sdb of=flash_drive.img</code></pre><hr><p>Warning! The dd command is very powerful. Though its name derives from “data definition,” it is sometimes called “destroy disk” because users often mistype either the if or of specifications. <em>Always double check your input and output specifications before pressing enter!</em></p><p>警告！这个 dd 命令非常强大。虽然它的名字来自于“数据定义”，有时候也把它叫做“清除磁盘” 因为用户经常会误输入 if 或 of 的规范。<em>在按下回车键之前，要再三检查输入与输出规范！</em></p><hr><h3 id="创建-CD-ROM-映像"><a href="#创建-CD-ROM-映像" class="headerlink" title="创建 CD-ROM 映像"></a>创建 CD-ROM 映像</h3><p>Writing a recordable CD-ROM (either a CD-R or CD-RW) consists of two steps; first, constructing an iso image file that is the exact file system image of the CD-ROM and second, writing the image file onto the CD-ROM media.</p><p>写入一个可记录的 CD-ROM（一个 CD-R 或者是 CD-RW）由两步组成；首先，构建一个 iso 映像文件， 这就是一个 CD-ROM 的文件系统映像，第二步，把这个映像文件写入到 CD-ROM 媒介中。</p><h4 id="创建一个-CD-ROM-的映像拷贝"><a href="#创建一个-CD-ROM-的映像拷贝" class="headerlink" title="创建一个 CD-ROM 的映像拷贝"></a>创建一个 CD-ROM 的映像拷贝</h4><p>If we want to make an iso image of an existing CD-ROM, we can use dd to read all the data blocks off the CD-ROM and copy them to a local file. Say we had an Ubuntu CD and we wanted to make an iso file that we could later use to make more copies. After inserting the CD and determining its device name (we’ll assume /dev/cdrom), we can make the iso file like so:</p><p>如果想要制作一张现有 CD-ROM 的 iso 映像，我们可以使用 dd 命令来读取 CD-ROW 中的所有数据块， 并把它们复制到本地文件中。比如说我们有一张 Ubuntu CD，用它来制作一个 iso 文件，以后我们可以用它来制作更多的拷贝。插入这张 CD 之后，确定 它的设备名称（假定是/dev/cdrom），然后像这样来制作 iso 文件：</p><pre><code>dd if=/dev/cdrom of=ubuntu.iso</code></pre><p>This technique works for data DVDs as well, but will not work for audio CDs, as they do not use a file system for storage. For audio CDs, look at the cdrdao command.</p><p>这项技术也适用于 DVD 光盘，但是不能用于音频 CD，因为它们不使用文件系统来存储数据。 对于音频 CD，看一下 cdrdao 命令。</p><h4 id="从文件集合中创建一个映像"><a href="#从文件集合中创建一个映像" class="headerlink" title="从文件集合中创建一个映像"></a>从文件集合中创建一个映像</h4><p>To create an iso image file containing the contents of a directory, we use the genisoimage program. To do this, we first create a directory containing all the files we wish to include in the image and then execute the genisoimage command to create the image file. For example, if we had created a directory called ~/cd-rom-files and filled it with files for our CD-ROM, we could create an image file named cd- rom.iso with the following command:</p><p>创建一个包含目录内容的 iso 映像文件，我们使用 genisoimage 程序。为此，我们首先创建 一个目录，这个目录中包含了要包括到此映像中的所有文件，然后执行这个 genisoimage 命令 来创建映像文件。例如，如果我们已经创建一个叫做~/cd-rom-files 的目录，然后用文件 填充此目录，再通过下面的命令来创建一个叫做 cd-rom.iso 映像文件：</p><pre><code>genisoimage -o cd-rom.iso -R -J ~/cd-rom-files</code></pre><p>The “-R” option adds metadata for the Rock Ridge extensions, which allows the use of long filenames and POSIX style file permissions. Likewise, the “-J” option enables the Joliet extensions, which permit long filenames for Windows.</p><p>“-R”选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 同样地，这个”-J”选项使 Joliet 扩展生效，这样 Windows 中就支持长文件名了。</p><blockquote><p>A Program By Any Other Name…</p><p>一个有着其它名字的程序。。。</p><p>If you look at on-line tutorials for creating and burning optical media like CD- ROMs and DVDs, you will frequently encounter two programs called mkisofs and cdrecord. These programs were part of a popular package called “cdrtools” authored by Jorg Schilling. In the summer of 2006, Mr. Schilling made a license change to a portion of the cdrtools package which, in the opinion of many in the Linux community, created a license incompatibility with the GNU GPL. As a result, a fork of the cdrtools project was started that now includes replacement programs for cdrecord and mkisofs named wodim and genisoimage, respectively.</p><p>如果你看一下关于创建和烧写光介质如 CD-ROMs 和 DVD 的在线文档，你会经常碰到两个程序 叫做 mkisofs 和 cdrecord。这些程序是流行软件包”cdrtools”的一部分，”cdrtools”由 Jorg Schilling 编写成。在2006年春天，Schilling 先生更改了部分 cdrtools 软件包的协议，Linux 社区许多人的看法是， 这创建了一个与 GNU GPL 不相兼容的协议。结果，就 fork 了这个 cdrtools 项目， 目前新项目里面包含了 cdrecord 和 mkisofs 的替代程序，分别是 wodim 和 genisoimage。</p></blockquote><h3 id="写入-CD-ROM-镜像"><a href="#写入-CD-ROM-镜像" class="headerlink" title="写入 CD-ROM 镜像"></a>写入 CD-ROM 镜像</h3><p>After we have an image file, we can burn it onto our optical media. Most of the commands we will discuss below can be applied to both recordable CD-ROM and DVD media.</p><p>有了一个映像文件之后，我们可以把它烧写到光盘中。下面讨论的大多数命令对可 记录的 CD-ROW 和 DVD 媒介都适用。</p><h4 id="直接挂载一个-ISO-镜像"><a href="#直接挂载一个-ISO-镜像" class="headerlink" title="直接挂载一个 ISO 镜像"></a>直接挂载一个 ISO 镜像</h4><p>There is a trick that we can use to mount an iso image while it is still on our hard disk and treat it as though it was already on optical media. By adding the “-o loop” option to mount (along with the required “-t iso9660” file system type), we can mount the image file as though it were a device and attach it to the file system tree:</p><p>有一个诀窍，我们可以用它来挂载 iso 映像文件，虽然此文件仍然在我们的硬盘中，但我们 当作它已经在光盘中了。添加 “-o loop” 选项来挂载（同时带有必需的 “-t iso9660” 文件系统类型）， 挂载这个映像文件就好像它是一台设备，把它连接到文件系统树上：</p><pre><code>mkdir /mnt/iso_imagemount -t iso9660 -o loop image.iso /mnt/iso_image</code></pre><p>In the example above, we created a mount point named /mnt/iso_image and then mounted the image file image.iso at that mount point. After the image is mounted, it can be treated just as though it were a real CD-ROM or DVD. Remember to unmount the image when it is no longer needed.</p><p>上面的示例中，我们创建了一个挂载点叫做/mnt/iso_image，然后把此映像文件 image.iso 挂载到挂载点上。映像文件被挂载之后，可以把它当作，就好像它是一张 真正的 CD-ROM 或者 DVD。当不再需要此映像文件后，记得卸载它。</p><h4 id="清除一张可重写入的-CD-ROM"><a href="#清除一张可重写入的-CD-ROM" class="headerlink" title="清除一张可重写入的 CD-ROM"></a>清除一张可重写入的 CD-ROM</h4><p>Rewritable CD-RW media needs to be erased or blanked before it can be reused. To do this, we can use wodim, specifying the device name for the CD writer and the type of blanking to be performed. The wodim program offers several types. The most minimal (and fastest) is the “fast” type:</p><p>可重写入的 CD-RW 媒介在被重使用之前需要擦除或清空。为此，我们可以用 wodim 命令，指定 设备名称和清空的类型。此 wodim 程序提供了几种清空类型。最小（且最快）的是 “fast” 类型：</p><pre><code>wodim dev=/dev/cdrw blank=fast</code></pre><h4 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h4><p>To write an image, we again use wodim, specifying the name of the optical media writer device and the name of the image file:</p><p>写入一个映像文件，我们再次使用 wodim 命令，指定光盘设备名称和映像文件名：</p><pre><code>wodim dev=/dev/cdrw image.iso</code></pre><p>In addition to the device name and image file, wodim supports a very large set of options. Two common ones are “-v” for verbose output, and “-dao” which writes the disk in disk-at-once mode. This mode should be used if you are preparing a disk for commercial reproduction. The default mode for wodim is track-at-once, which is useful for recording music tracks.</p><p>除了设备名称和映像文件之外，wodim 命令还支持非常多的选项。常见的两个选项是，”-v” 可详细输出， 和 “－dao” 以 disk-at-once 模式写入光盘。如果你正在准备一张光盘为的是商业复制，那么应该使用这种模式。 wodim 命令的默认模式是 track-at-once，这对于录制音乐很有用。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>We have just touched on the many ways that the command line can be used to manage storage media. Take a look at the man pages of the commands we have covered. Some of them support huge numbers of options and operations. Also, look for on-line tutorials for adding hard drives to your Linux system (there are many) and working with optical media.</p><p>我们刚才谈到了很多方法，可以使用命令行管理存储介质。看看我们所讲过命令的手册页。 一些命令支持大量的选项和操作。此外，寻找一些如何添加硬盘驱动器到 Linux 系统（有许多）的在线教程， 这些教程也要适用于光介质存储设备。</p><h3 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h3><p>It’s often useful to verify the integrity of an iso image that we have downloaded. In most cases, a distributor of an iso image will also supply a checksum file. A checksum is the result of an exotic mathematical calculation resulting in a number that represents the content of the target file. If the contents of the file change by even one bit, the resulting checksum will be much different. The most common method of checksum generation uses the md5sum program. When you use md5sum, it produces a unique hexadecimal number:</p><p>通常验证一下我们已经下载的 iso 映像文件的完整性很有用处。在大多数情况下，iso 映像文件的贡献者也会提供 一个 checksum 文件。一个 checksum 是一个神奇的数学运算的计算结果，这个数学计算会产生一个能表示目标文件内容的数字。 如果目标文件的内容即使更改一个二进制位，checksum 的结果将会非常不一样。 生成 checksum 数字的最常见方法是使用 md5sum 程序。当你使用 md5sum 程序的时候， 它会产生一个独一无二的十六进制数字：</p><pre><code>md5sum image.iso34e354760f9bb7fbf85c96f6a3f94ece    image.iso</code></pre><p>After you download an image, you should run md5sum against it and compare the results with the md5sum value supplied by the publisher.</p><p>当你下载完映像文件之后，你应该对映像文件执行 md5sum 命令，然后把运行结果与发行商提供的 md5sum 数值作比较。</p><p>In addition to checking the integrity of a downloaded file, we can use md5sum to verify newly written optical media. To do this, we first calculate the checksum of the image file and then calculate a checksum for the media. The trick to verifying the media is to limit the calculation to only the portion of the optical media that contains the image. We do this by determining the number of 2048 byte blocks the image contains (optical media is always written in 2048 byte blocks) and reading that many blocks from the media. On some types of media, this is not required. A CD-R written in disk-at-once mode can be checked this way:</p><p>除了检查下载文件的完整性之外，我们也可以使用 md5sum 程序验证新写入的光学存储介质。 为此，首先我们计算映像文件的 checksum 数值，然后计算此光学存储介质的 checksum 数值。 这种验证光学介质的技巧是限定只对 光学存储介质中包含映像文件的部分计算 checksum 数值。 通过确定映像文件所包含的 2048 个字节块的数目（光学存储介质总是以 2048 个字节块的方式写入） 并从存储介质中读取那么多的字节块，我们就可以完成操作。 某些类型的存储介质，并不需要这样做。一个以 disk-at-once 模式写入的 CD-R，可以用下面的方式检验：</p><pre><code>md5sum /dev/cdrom34e354760f9bb7fbf85c96f6a3f94ece    /dev/cdrom</code></pre><p>Many types of media, such as DVDs require a precise calculation of the number of blocks. In the example below, we check the integrity of the image file dvd-image.iso and the disk in the DVD reader /dev/dvd. Can you figure out how this works?</p><p>许多存储介质类型，如 DVD 需要精确地计算字节块的数目。在下面的例子中，我们检验了映像文件 dvd-image.iso 以及 DVD 光驱中磁盘 /dev/dvd 文件的完整性。你能弄明白这是怎么回事吗？</p><pre><code>md5sum dvd-image.iso; dd if=/dev/dvd bs=2048 count=$(( $(stat -c &quot;%s&quot; dvd-image.iso) / 2048 )) | md5sum</code></pre>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十五章 软件包管理</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>If we spend any time in the Linux community, we hear many opinions as to which of the many Linux distributions is “best.” Often, these discussions get really silly, focusing on such things as the prettiness of the desktop background (some people won’t use Ubuntu because its default color scheme is brown!) and other trivial matters.</p><p>如果我们花些时间在 Linux 社区里，我们会看到很多像Linux发行版中哪一个是“最佳”之类的观点。 这些讨论通常非常可笑，集中在一些像桌面背景的漂亮程度（一些人不使用 Ubuntu， 只是因为 Ubuntu 默认主题颜色是棕色的！）和其它的琐碎东西上。</p><p>The most important determinant of distribution quality is the packaging system and the vitality of the distribution’s support community. As we spend more time with Linux, we see that its software landscape is extremely dynamic. Things are constantly changing. Most of the top-tier Linux distributions release new versions every six months and many individual program updates every day. To keep up with this blizzard of software, we need good tools for package management.</p><p>Linux 发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性。随着我们 花更多的时间在 Linux 上，我们会发现它的变化是非常快的。大多数一线 Linux 发行版每隔六个月发布一个新版本，并且许多独立的程序每天都会更新。为了能和这些 如暴风雪一般多的软件保持联系，我们需要一些好工具来进行软件包管理。</p><p>Package management is a method of installing and maintaining software on the system. Today, most people can satisfy all of their software needs by installing packages from their Linux distributor. This contrasts with the early days of Linux, when one had to download and compile source code in order to install software. Not that there is anything wrong with compiling source code; in fact, having access to source code is the great wonder of Linux. It gives us (and everybody else) the ability to examine and improve the system. It’s just that having a pre-compiled package is faster and easier to deal with. In this chapter, we will look at some of the command line tools used for package management. While all of the major distributions provide powerful and sophisticated graphical programs for maintaining the system, it is important to learn about the command line programs, too. They can perform many tasks that are difficult (or impossible) to do with their graphical counterparts.</p><p>软件包管理是指系统中一种安装和维护软件的方法。今天，通过从 Linux 发行版中安装的软件包， 已能满足许多人所有的软件需求。这不同于早期的 Linux，人们需要下载和编译源码来安装软件。 编译源码没有任何问题，事实上，拥有对源码的访问权限是 Linux 的伟大奇迹。它赋予我们（ 其它每个人）检测和提高系统性能的能力。只是若有一个预先编译好的软件包处理起来要相对 容易快速些。这章中，我们将查看一些用于包管理的命令行工具。虽然所有主流 Linux 发行版都 提供了强大且精致的图形管理程序来维护系统，但是学习命令行程序也非常重要。因为它们 可以完成许多让图形化管理程序处理起来困难（或者不可能）的任务。</p><h3 id="打包系统"><a href="#打包系统" class="headerlink" title="打包系统"></a>打包系统</h3><p>Different distributions use different packaging systems and as a general rule, a package intended for one distribution is not compatible with another distribution. Most distributions fall into one of two camps of packaging technologies: the Debian “.deb” camp and the Red Hat “.rpm” camp. There are some important exceptions such as Gentoo, Slackware, and Foresight, but most others use one of these two basic systems.</p><p>不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。</p><table><thead><tr><th align="left">Packaging System</th><th align="left">Distributions (Partial Listing)</th></tr></thead><tbody><tr><td align="left">Debian Style (.deb)</td><td align="left">Debian, Ubuntu, Xandros, Linspire</td></tr><tr><td align="left">Red Hat Style (.rpm)</td><td align="left">Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td></tr></tbody></table><table><thead><tr><th align="left">包管理系统</th><th align="left">发行版 (部分列表)</th></tr></thead><tbody><tr><td align="left">Debian Style (.deb)</td><td align="left">Debian, Ubuntu, Xandros, Linspire</td></tr><tr><td align="left">Red Hat Style (.rpm)</td><td align="left">Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</td></tr></tbody></table><h3 id="软件包管理系统是怎样工作的"><a href="#软件包管理系统是怎样工作的" class="headerlink" title="软件包管理系统是怎样工作的"></a>软件包管理系统是怎样工作的</h3><p>The method of software distribution found in the proprietary software industry usually entails buying a piece of installation media such as an “install disk” and then running an “installation wizard” to install a new application on the system.</p><p>在商业化软件中，获取软件的最新版本通常需要买一张安装媒介，比方说”安装盘”，然后运行 一个”安装向导”，来在系统中安装新的应用程序。</p><p>Linux doesn’t work that way. Virtually all software for a Linux system will be found on the Internet. Most of it will be provided by the distribution vendor in the form of package files and the rest will be available in source code form that can be installed manually. We’ll talk a little about how to install software by compiling source code in a later chapter.</p><p>Linux 不是这样。Linux 系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以 包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样 通过编译源码来安装软件。</p><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>The basic unit of software in a packaging system is the package file. A package file is a compressed collection of files that comprise the software package. A package may consist of numerous programs and data files that support the programs. In addition to the files to be installed, the package file also includes metadata about the package, such as a text description of the package and its contents. Additionally, many packages contain pre- and post-installation scripts that perform configuration tasks before and after the package installation.</p><p>在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。</p><p>Package files are created by a person known as a package maintainer, often (but not always) an employee of the distribution vendor. The package maintainer gets the software in source code form from the upstream provider (the author of the program), compiles it, and creates the package metadata and any necessary installation scripts. Often, the package maintainer will apply modifications to the original source code to improve the program’s integration with the other parts of the Linux distribution.</p><p>软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者 从上游提供商（程序作者）那里得到软件源码，然后编译源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 Linux 发行版其它部分的融合性。</p><h3 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h3><p>While some software projects choose to perform their own packaging and distribution, most packages today are created by the distribution vendors and interested third parties. Packages are made available to the users of a distribution in central repositories that may contain many thousands of packages, each specially built and maintained for the distribution.</p><p>虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。</p><p>A distribution may maintain several different repositories for different stages of the software development life cycle. For example, there will usually be a “testing” repository that contains packages that have just been built and are intended for use by brave souls who are looking for bugs before they are released for general distribution. A distribution will often have a “development” repository where work-in-progress packages destined for inclusion in the distribution’s next major release are kept.</p><p>因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会 有一个”测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用， 在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个”开发”资源库， 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。</p><p>A distribution may also have related third-party repositories. These are often needed to supply software that, for legal reasons such as patents or DRM anti-circumvention issues, cannot be included with the distribution. Perhaps the best known case is that of encrypted DVD support, which is not legal in the United States. The third-party repositories operate in countries where software patents and anti-circumvention laws do not apply. These repositories are usually wholly independent of the distribution they support and to use them, one must know about them and manually include them in the configuration files for the package management system.</p><p>一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因， 比如说专利或者是 DRM 反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是 对加密DVD的播放支持，在美国这是不合法的。第三方资源库在一些软件专利和反规避法案不 生效的国家中设立并分发资源。这些资源库通常完全地独立于它们所支持的资源库，要想使用它们， 你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。</p><h3 id="依赖性"><a href="#依赖性" class="headerlink" title="依赖性"></a>依赖性</h3><p>Programs seldom stand alone; rather, they rely on the presence of other software components to get their work done. Common activities, such as input/output for example, are handled by routines shared by many programs. These routines are stored in what are called shared libraries, which provide essential services to more than one program. If a package requires a shared resource such as a shared library, it is said to have a dependency. Modern package management systems all provide some method of dependency resolution to ensure that when a package is installed, all of its dependencies are installed, too.</p><p>程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。程序所共有的活动，如输入/输出， 就是由一个被多个程序调用的子例程处理的。这些子例程存储在动态链接库中。动态链接库为多个程 序提供基本服务。如果一个软件包需要一些共享的资源，如一个动态链接库，它就被称作有一个依赖。 现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软件包时，其所有的依赖也被安装。</p><h3 id="上层和底层软件包工具"><a href="#上层和底层软件包工具" class="headerlink" title="上层和底层软件包工具"></a>上层和底层软件包工具</h3><p>Package management systems usually consist of two types of tools: low-level tools which handle tasks such as installing and removing package files, and high-level tools that perform metadata searching and dependency resolution. In this chapter, we will look at the tools supplied with Debian-style systems (such as Ubuntu and many others) and those used by recent Red Hat products. While all Red Hat-style distributions rely on the same low-level program (rpm), they use different high-level tools. For our discussion, we will cover the high-level program yum, used by Fedora, Red Hat Enterprise Linux, and CentOS. Other Red Hat-style distributions provide high-level tools with comparable features.</p><p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian 风格的系统 （比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat 产品使用的工具。虽然所有基于 Red Hat 风格的发行版都依赖于相同的底层程序（rpm）, 但是它们却使用不同的上层工具。在我们的讨论中，我们将研究Fedora, Red Hat 企业版，和 CentOs所使用的 yum 。其它Red Hat 风格的发行版提供了带有类似yum的其他上层工具。</p><table><thead><tr><th align="left">Distributions</th><th align="left">Low-Level Tools</th><th align="left">High-Level Tools</th></tr></thead><tbody><tr><td align="left">Debian-Style</td><td align="left">dpkg</td><td align="left">apt-get, aptitude</td></tr><tr><td align="left">Fedora, Red Hat Enterprise Linux, CentOS</td><td align="left">rpm</td><td align="left">yum</td></tr></tbody></table><table><thead><tr><th align="left">发行版</th><th align="left">底层工具</th><th align="left">上层工具</th></tr></thead><tbody><tr><td align="left">Debian-Style</td><td align="left">dpkg</td><td align="left">apt-get, aptitude</td></tr><tr><td align="left">Fedora, Red Hat Enterprise Linux, CentOS</td><td align="left">rpm</td><td align="left">yum</td></tr></tbody></table><h3 id="常见软件包管理任务"><a href="#常见软件包管理任务" class="headerlink" title="常见软件包管理任务"></a>常见软件包管理任务</h3><p>There are many operations that can be performed with the command line package management tools. We will look at the most common. Be aware that the low-level tools also support creation of package files, an activity outside the scope of this book. In the discussion below, the term “package_name” refers to the actual name of a package rather than the term “package_file,” which is the name of the file that contains the package.</p><p>通过命令行软件包管理工具可以完成许多操作。我们将会看一下最常用的工具。注意底层工具也 支持软件包文件的创建，这个话题超出了本书叙述的范围。在以下的讨论中，”package_name” 这个术语是指软件包实际名称，而不是指”package_file”，它是包含在软件包中的文件名。</p><h3 id="查找资源库中的软件包"><a href="#查找资源库中的软件包" class="headerlink" title="查找资源库中的软件包"></a>查找资源库中的软件包</h3><p>Using the high-level tools to search repository metadata, a package can be located based on its name or description.</p><p>使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-cache search search_string</td></tr><tr><td align="left">Red Hat</td><td align="left">yum search search_string</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-cache search search_string</td></tr><tr><td align="left">Red Hat</td><td align="left">yum search search_string</td></tr></tbody></table><p>Example: To search a yum repository for the emacs text editor, this command could be used:</p><p>例如：搜索一个 yum 资源库来查找 emacs 文本编辑器，使用以下命令：</p><pre><code>yum search emacs</code></pre><h3 id="从资源库中安装一个软件包"><a href="#从资源库中安装一个软件包" class="headerlink" title="从资源库中安装一个软件包"></a>从资源库中安装一个软件包</h3><p>High-level tools permit a package to be downloaded from a repository and installed with full dependency resolution.</p><p>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-get install package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum install package_name</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-get install package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum install package_name</td></tr></tbody></table><p>Example: To install the emacs text editor from an apt repository:</p><p>例如：从一个 apt 资源库来安装 emacs 文本编辑器：</p><pre><code>apt-get update; apt-get install emacs</code></pre><h3 id="通过软件包文件来安装软件"><a href="#通过软件包文件来安装软件" class="headerlink" title="通过软件包文件来安装软件"></a>通过软件包文件来安装软件</h3><p>If a package file has been downloaded from a source other than a repository, it can be installed directly (though without dependency resolution) using a low-level tool.</p><p>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –install package_file</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -i package_file</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –install package_file</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -i package_file</td></tr></tbody></table><p>Example: If the emacs-22.1-7.fc7-i386.rpm package file had been downloaded from a non-repository site, it would be installed this way:</p><p>例如：如果已经从一个并非资源库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm， 则可以通过这种方法来安装它：</p><pre><code>rpm -i emacs-22.1-7.fc7-i386.rpm</code></pre><hr><p>Note: Since this technique uses the low-level rpm program to perform the installation, no dependency resolution is performed. If rpm discovers a missing dependency, rpm will exit with an error.</p><p>注意：因为这项技术使用底层的 rpm 程序来执行安装任务，所以没有运行依赖解析。 如果 rpm 程序发现缺少了一个依赖，则会报错并退出。</p><hr><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p>Packages can be uninstalled using either the high-level or low-tools. The high-level tools are shown below.</p><p>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get remove package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum erase package_name</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get remove package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum erase package_name</td></tr></tbody></table><p>Example: To uninstall the emacs package from a Debian-style system:</p><p>例如：从 Debian 风格的系统中卸载 emacs 软件包：</p><pre><code>apt-get remove emacs</code></pre><h3 id="经过资源库来更新软件包"><a href="#经过资源库来更新软件包" class="headerlink" title="经过资源库来更新软件包"></a>经过资源库来更新软件包</h3><p>The most common package management task is keeping the system up-to-date with the latest packages. The high-level tools can perform this vital task in one single step.</p><p>最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成 这个至关重要的任务。</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-get upgrade</td></tr><tr><td align="left">Red Hat</td><td align="left">yum update</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-get update; apt-get upgrade</td></tr><tr><td align="left">Red Hat</td><td align="left">yum update</td></tr></tbody></table><p>Example: To apply any available updates to the installed packages on a Debian-style system:</p><p>例如：更新安装在 Debian 风格系统中的软件包：</p><pre><code>apt-get update; apt-get upgrade</code></pre><h3 id="经过软件包文件来升级软件"><a href="#经过软件包文件来升级软件" class="headerlink" title="经过软件包文件来升级软件"></a>经过软件包文件来升级软件</h3><p>If an updated version of a package has been downloaded from a non-repository source, it can be installed, replacing the previous version:</p><p>如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来 替代先前的版本：</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –install package_file</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -U package_file</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –install package_file</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -U package_file</td></tr></tbody></table><p>Example: Updating an existing installation of emacs to the version contained in the package file emacs-22.1-7.fc7-i386.rpm on a Red Hat system:</p><p>例如：把 Red Hat 系统中所安装的 emacs 的版本更新到软件包文件 emacs-22.1-7.fc7-i386.rpmz 所包含的 emacs 版本。</p><pre><code>rpm -U emacs-22.1-7.fc7-i386.rpm</code></pre><hr><p>Note: dpkg does not have a specific option for upgrading a package versus installing one as rpm does.</p><p>注意：rpm 程序安装一个软件包和升级一个软件包所用的选项是不同的，而 dpkg 程序所用的选项是相同的。</p><hr><h3 id="列出所安装的软件包"><a href="#列出所安装的软件包" class="headerlink" title="列出所安装的软件包"></a>列出所安装的软件包</h3><p>These commands can be used to display a list of all the packages installed on the system:</p><p>下表中的命令可以用来显示安装到系统中的所有软件包列表：</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –list</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -qa</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –list</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -qa</td></tr></tbody></table><h3 id="确定是否安装了一个软件包"><a href="#确定是否安装了一个软件包" class="headerlink" title="确定是否安装了一个软件包"></a>确定是否安装了一个软件包</h3><p>These low-level tools can be used to display whether a specified package is installed:</p><p>这些底端工具可以用来显示是否安装了一个指定的软件包：</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –status package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -q package_name</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –status package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -q package_name</td></tr></tbody></table><p>Example: To determine if the emacs package is installed on a Debian style system:</p><p>例如：确定是否 Debian 风格的系统中安装了这个 emacs 软件包：</p><pre><code>dpkg --status emacs</code></pre><h3 id="显示所安装软件包的信息"><a href="#显示所安装软件包的信息" class="headerlink" title="显示所安装软件包的信息"></a>显示所安装软件包的信息</h3><p>If the name of an installed package is known, the following commands can be used to display a description of the package:</p><p>如果知道了所安装软件包的名字，使用以下命令可以显示这个软件包的说明信息：</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-cache show package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum info package_name</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">apt-cache show package_name</td></tr><tr><td align="left">Red Hat</td><td align="left">yum info package_name</td></tr></tbody></table><p>Example: To see a description of the emacs package on a Debian-style system:</p><p>例如：查看 Debian 风格的系统中 emacs 软件包的说明信息：</p><pre><code>apt-cache show emacs</code></pre><h3 id="查找安装了某个文件的软件包"><a href="#查找安装了某个文件的软件包" class="headerlink" title="查找安装了某个文件的软件包"></a>查找安装了某个文件的软件包</h3><p>To determine what package is responsible for the installation of a particular file, the following commands can be used:</p><p>确定哪个软件包对所安装的某个特殊文件负责，使用下表中的命令：</p><table><thead><tr><th align="left">Style</th><th align="left">Command(s)</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –search file_name</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -qf file_name</td></tr></tbody></table><table><thead><tr><th align="left">风格</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">Debian</td><td align="left">dpkg –search file_name</td></tr><tr><td align="left">Red Hat</td><td align="left">rpm -qf file_name</td></tr></tbody></table><p>Example: To see what package installed the /usr/bin/vim file on a Red Hat system:</p><p>例如：在 Red Hat 系统中，查看哪个软件包安装了/usr/bin/vim 这个文件</p><pre><code>rpm -qf /usr/bin/vim</code></pre><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In the chapters that follow, we will explore many different programs covering a wide range of application areas. While most of these programs are commonly installed by default, we may need to install additional packages if necessary programs are not already installed on our system. With our newfound knowledge (and appreciation) of package management, we should have no problem installing and managing the programs we need.</p><p>在随后的章节里面，我们将探讨许多不同的程序，这些程序涵盖了广泛的应用程序领域。虽然 大多数程序一般是默认安装的，但是若所需程序没有安装在系统中，那么我们可能需要安装额外的软件包。 通过我们新学到的（和了解的）软件包管理知识，我们应该能够安装和管理所需程序。</p><blockquote><p>The Linux Software Installation Myth</p><p>Linux 软件安装谣言</p><p>People migrating from other platforms sometimes fall victim to the myth that software is somehow difficult to install under Linux and that the variety of packaging schemes used by different distributions is a hindrance. Well, it is a hindrance, but only to proprietary software vendors who wish to distribute binary- only versions of their secret software.</p><p>从其它平台迁移过来的用户有时会成为谣言的受害者，说是在 Linux 系统中，安装软件有些 困难，并且不同系统发行版所使用的各种各样的打包方案是一个障碍。唉，它是一个障碍， 但只是针对于那些希望把他们的秘密软件只以二进制版本发行的专有软件供应商。</p><p>The Linux software ecosystem is based on the idea of open source code. If a program developer releases source code for a product, it is likely that a person associated with a distribution will package the product and include it in their repository. This method ensures that the product is well integrated into the distribution and the user is given the convenience of “one-stop shopping” for software, rather than having to search for each product’s web site.</p><p>Linux 软件生态系统是基于开放源代码理念。如果一个程序开发人员发布了一款产品的 源码，那么与系统发行版相关联的开发人员可能就会把这款产品打包，并把它包含在 他们的资源库中。这种方法保证了这款产品能很好地与系统发行版整合在一起，同时为用户 “一站式采购”软件提供了方便，从而用户不必去搜索每个产品的网站。</p><p>Device drivers are are handled in much the same way, except that instead of being separate items in a distribution’s repository, they become part of the Linux kernel itself. Generally speaking, there is no such thing as a “driver disk” in Linux. Either the kernel supports a device or it doesn’t, and the Linux kernel supports a lot of devices. Many more, in fact, than Windows does. Of course, this is of no consolation if the particular device you need is not supported. When that happens, you need to look at the cause. A lack of driver support is usually caused by one of three things:</p><p>设备驱动差不多也以同样的方式来处理，但它们不是系统发行版资源库中单独的项目， 它们本身是 Linux 系统内核的一部分。一般来说，在 Linux 当中没有一个类似于“驱动盘”的东西。 Linux内核要么支持一个设备，要不就不支持。Linux 内核支持很多设备，事实上，Linux支持的设备数目多于 Windows 所支持的。当然，万一你需要的特定设备不被Linux支持，也于事无补。当那种情况 发生时，你需要查找一下原因。缺少驱动程序支持通常是由以下三种情况之一导致：</p><ol><li><em>The device is too new.</em> Since many hardware vendors don’t actively support Linux development, it falls upon a member of the Linux community to write the kernel driver code. This takes time.</li><li><em>The device is too exotic.</em> Not all distributions include every possible device driver. Each distribution builds their own kernels, and since kernels are very configurable (which is what makes it possible to run Linux on everything from wristwatches to mainframes) they may have overlooked a particular device. By locating and downloading the source code for the driver, it is possible for you (yes, you) to compile and install the driver yourself. This process is not overly difficult, but it is rather involved. We’ll talk about compiling software in a later chapter.</li><li><em>The hardware vendor is hiding something.</em> They have neither released source code for a Linux driver, nor have they released the technical documentation for somebody to create one for them. This means that the hardware vendor is trying to keep the programming interfaces to the device a secret. Since we don’t want secret devices in our computers, I suggest that you remove the offending hardware and pitch it into the trash, with your other useless items.</li><li><em>设备太新。</em> 因为许多硬件供应商没有积极地支持 Linux 的发展，那么编写内核 驱动代码的任务就由一些 Linux 社区来承担，而这需要花费时间。</li><li><em>设备太奇异。</em> 不是所有的发行版都包含每个可能的设备驱动。每个发行版会建立 它们自己的内核，因为内核是可以配置的（这使得从手表到主机的每台设备上运行 Linux 成为可能）， 这样它们可能会忽略某个特殊设备。通过定位和下载驱动程序的源码，可能需要你自己（是的，由你） 来编译和安装驱动。这个过程不是很难，而是需要参与的。我们将在随后的章节里来讨论编译软件。</li><li><em>硬件供应商隐藏信息。</em> 他们既不发布应用于 Linux 系统的驱动程序代码， 也不发布技术文档来让某人创建它。这意味着硬件供应商试图保密此设备的程序接口。因为我们 不想在计算机中使用保密的设备，所以我建议删除这令人厌恶的硬件， 把它和其它无用的东西都扔到垃圾桶里。</li></ol></blockquote><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Spend some time getting to know the package management system for your distribution. Each distribution provides documentation for its package management tools. In addition, here are some more generic sources:</p><p>花些时间来了解你所用发行版中的软件包管理系统。每个发行版都提供了关于自带软件包管理工具的 文档。另外，这里有一些更普遍的资源：</p><ul><li><p>The Debian GNU/Linux FAQ chapter on package management provides an overview of package management on Debian systems :</p></li><li><p>Debian GNU/Linux FAQ 关于软件包管理一章对软件包管理进行了概述：</p><p><a href="http://www.debian.org/doc/FAQ/ch-pkgtools.en.html" target="_blank" rel="noopener">http://www.debian.org/doc/FAQ/ch-pkgtools.en.html</a></p></li><li><p>The home page for the RPM project:</p></li><li><p>RPM 工程的主页：</p><p><a href="http://www.rpm.org/" target="_blank" rel="noopener">http://www.rpm.org</a></p></li><li><p>The home page for the YUM project at Duke University:</p></li><li><p>杜克大学 YUM 工程的主页：</p><p><a href="http://linux.duke.edu/projects/yum/" target="_blank" rel="noopener">http://linux.duke.edu/projects/yum/</a></p></li><li><p>For a little background, the Wikipedia has an article on metadata:</p></li><li><p>了解一点儿背景知识，Wikipedia 上有一篇关于 metadata 的文章：</p><p><a href="http://en.wikipedia.org/wiki/Metadata" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Metadata</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十四章 自定义shell提示符</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%AE%9A%E4%B9%89shell%E6%8F%90%E7%A4%BA%E7%AC%A6/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%AE%9A%E4%B9%89shell%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>In this chapter we will look at a seemingly trivial detail — our shell prompt. This examination will reveal some of the inner workings of the shell and the terminal emulator program itself.</p><p>在这一章中，我们将会看一下表面上看来很琐碎的细节－shell 提示符。但这会揭示一些 shell 和 终端仿真器的内部工作方式。</p><p>Like so many things in Linux, the shell prompt is highly configurable, and while we have pretty much taken it for granted, the prompt is a really useful device once we learn how to control it.</p><p>和 Linux 内的许多程序一样，shell 提示符是可高度配置的，虽然我们把它相当多地看作是理所当然的， 但是我们一旦学会了怎样控制它，shell 提示符是一个相当有用的工具。</p><p>Anatomy Of A Prompt</p><h3 id="解剖一个提示符"><a href="#解剖一个提示符" class="headerlink" title="解剖一个提示符"></a>解剖一个提示符</h3><p>Our default prompt looks something like this:</p><p>我们默认的提示符看起来像这样：</p><pre><code>[me@linuxbox ~]$</code></pre><p>Notice that it contains our user name, our host name and our current working directory, but how did it get that way? Very simply, it turns out. The prompt is defined by an environment variable named PS1 (short for “prompt string one”). We can view the contents of PS1 with the echo command:</p><p>注意它包含我们的用户名，主机名和当前工作目录，但是它又是怎样得到这些东西的呢？ 结果证明非常简单。提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one” 的简写）。我们可以通过 echo 命令来查看 PS1的内容。</p><pre><code>[me@linuxbox ~]$ echo $PS1[\u@\h \W]\$</code></pre><hr><p>Note: Don’t worry if your results are not exactly the same as the example above. Every Linux distribution defines the prompt string a little differently, some quite exotically.</p><p>注意：如果你 shell 提示符的内容和上例不是一模一样，也不必担心。每个 Linux 发行版 定义的提示符稍微有点不同，其中一些相当异于寻常。</p><hr><p>From the results, we can see that PS1 contains a few of the characters we see in our prompt such as the brackets, the at-sign, and the dollar sign, but the rest are a mystery. The astute among us will recognize these as backslash-escaped special characters like those we saw in Chapter 8. Here is a partial list of the characters that the shell treats specially in the prompt string:</p><p>从输出结果中，我们看到那个 PS1 环境变量包含一些这样的字符，比方说中括号，@符号，和美元符号， 但是剩余部分就是个谜。我们中一些机敏的人会把这些看作是由反斜杠转义的特殊字符，就像我们 在第八章中看到的一样。这里是一部分字符列表，在提示符中 shell 会特殊对待这些字符：</p><table><thead><tr><th align="left">Sequence</th><th align="left">Value Displayed</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">ASCII bell. This makes the computer beep when it is encountered.</td></tr><tr><td align="left">\d</td><td align="left">Current date in day, month, date format. For example, “Mon May 26.”</td></tr><tr><td align="left">\h</td><td align="left">Host name of the local machine minus the trailing domain name.</td></tr><tr><td align="left">\H</td><td align="left">Full host name.</td></tr><tr><td align="left">\j</td><td align="left">Number of jobs running in the current shell session.</td></tr><tr><td align="left">\l</td><td align="left">Name of the current terminal device.</td></tr><tr><td align="left">\n</td><td align="left">A newline character.</td></tr><tr><td align="left">\r</td><td align="left">A carriage return.</td></tr><tr><td align="left">\s</td><td align="left">Name of the shell program.</td></tr><tr><td align="left">\t</td><td align="left">Current time in 24 hour hours:minutes:seconds format.</td></tr><tr><td align="left">\T</td><td align="left">Current time in 12 hour format.</td></tr><tr><td align="left">@</td><td align="left">Current time in 12 hour AM/PM format.</td></tr><tr><td align="left">\A</td><td align="left">Current time in 24 hour hours:minutes format.</td></tr><tr><td align="left">\u</td><td align="left">User name of the current user.</td></tr><tr><td align="left">\v</td><td align="left">Version number of the shell.</td></tr><tr><td align="left">\V</td><td align="left">Version and release numbers of the shell.</td></tr><tr><td align="left">\w</td><td align="left">Name of the current working directory.</td></tr><tr><td align="left">\W</td><td align="left">Last part of the current working directory name.</td></tr><tr><td align="left">!</td><td align="left">History number of the current command.</td></tr><tr><td align="left">#</td><td align="left">Number of commands entered into this shell session.</td></tr><tr><td align="left">$</td><td align="left">This displays a “$” character unless you have superuser privileges. In that case, it displays a “#” instead.</td></tr><tr><td align="left">[</td><td align="left">Signals the start of a series of one or more non-printing characters. This is used to embed non-printing control characters which manipulate the terminal emulator in some way, such as moving the cursor or changing text colors.</td></tr><tr><td align="left">]</td><td align="left">Signals the end of a non-printing character sequence.</td></tr></tbody></table><table><thead><tr><th align="left">序列</th><th align="left">显示值</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">以 ASCII 格式编码的铃声 . 当遇到这个转义序列时，计算机会发出嗡嗡的响声。</td></tr><tr><td align="left">\d</td><td align="left">以日，月，天格式来表示当前日期。例如，“Mon May 26.”</td></tr><tr><td align="left">\h</td><td align="left">本地机的主机名，但不带末尾的域名。</td></tr><tr><td align="left">\H</td><td align="left">完整的主机名。</td></tr><tr><td align="left">\j</td><td align="left">运行在当前 shell 会话中的工作数。</td></tr><tr><td align="left">\l</td><td align="left">当前终端设备名。</td></tr><tr><td align="left">\n</td><td align="left">一个换行符。</td></tr><tr><td align="left">\r</td><td align="left">一个回车符。</td></tr><tr><td align="left">\s</td><td align="left">shell 程序名。</td></tr><tr><td align="left">\t</td><td align="left">以24小时制，hours:minutes:seconds 的格式表示当前时间.</td></tr><tr><td align="left">\T</td><td align="left">以12小时制表示当前时间。</td></tr><tr><td align="left">@</td><td align="left">以12小时制，AM/PM 格式来表示当前时间。</td></tr><tr><td align="left">\A</td><td align="left">以24小时制，hours:minutes 格式表示当前时间。</td></tr><tr><td align="left">\u</td><td align="left">当前用户名。</td></tr><tr><td align="left">\v</td><td align="left">shell 程序的版本号。</td></tr><tr><td align="left">\V</td><td align="left">Version and release numbers of the shell.</td></tr><tr><td align="left">\w</td><td align="left">当前工作目录名。</td></tr><tr><td align="left">\W</td><td align="left">当前工作目录名的最后部分。</td></tr><tr><td align="left">!</td><td align="left">当前命令的历史号。</td></tr><tr><td align="left">#</td><td align="left">当前 shell 会话中的命令数。</td></tr><tr><td align="left">$</td><td align="left">这会显示一个”$”字符，除非你拥有超级用户权限。在那种情况下， 它会显示一个”#”字符。</td></tr><tr><td align="left">[</td><td align="left">标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印 的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。</td></tr><tr><td align="left">]</td><td align="left">标志着非打印字符序列结束。</td></tr></tbody></table><p>Trying Some Alternate Prompt Designs</p><h3 id="试试一些可替代的提示符设计"><a href="#试试一些可替代的提示符设计" class="headerlink" title="试试一些可替代的提示符设计"></a>试试一些可替代的提示符设计</h3><p>With this list of special characters, we can change the prompt to see the effect. First, we’ll back up the existing string so we can restore it later. To do this, we will copy the existing string into another shell variable that we create ourselves:</p><p>参照这个特殊字符列表，我们可以更改提示符来看一下效果。首先， 我们把原来提示符字符串的内容备份一下，以备之后恢复原貌。为了完成备份， 我们把已有的字符串复制到另一个 shell 变量中，这个变量是我们自己创造的。</p><pre><code>[me@linuxbox ~]$ ps1_old=&quot;$PS1&quot;</code></pre><p>We create a new variable called ps1_old and assign the value of PS1 to it. We can verify that the string has been copied with the echo command:</p><p>我们新创建了一个叫做 ps1_old 的变量，并把变量 PS1的值赋 ps1_old。通过 echo 命令可以证明 我们的确复制了 PS1的值。</p><pre><code>[me@linuxbox ~]$ echo $ps1_old[\u@\h \W]\$</code></pre><p>We can restore the original prompt at any time during our terminal session by simply reversing the process:</p><p>在终端会话中，我们能在任一时间复原提示符，只要简单地反向操作就可以了。</p><pre><code>[me@linuxbox ~]$ PS1=&quot;$ps1_old&quot;</code></pre><p>Now that we are ready to proceed, let’s see what happens if we have an empty prompt string:</p><p>现在，我们准备开始，让我们看看如果有一个空的字符串会发生什么：</p><pre><code>[me@linuxbox ~]$ PS1=</code></pre><p>If we assign nothing to the prompt string, we get nothing. No prompt string at all! The prompt is still there, but displays nothing, just as we asked it to. Since this is kind of disconcerting to look at, we’ll replace it with a minimal prompt:</p><p>如果我们没有给提示字符串赋值，那么我们什么也得不到。根本没有提示字符串！提示符仍然在那里， 但是什么也不显示，正如我们所要求的那样。我们将用一个最小的提示符来代替它：</p><pre><code>PS1=&quot;\$ &quot;</code></pre><p>That’s better. At least now we can see what we are doing. Notice the trailing space within the double quotes. This provides the space between the dollar sign and the cursor when the prompt is displayed.</p><p>这样要好一些。至少能看到我们在做什么。注意双引号中末尾的空格。当提示符显示的时候， 这个空格把美元符号和光标分离开。</p><p>Let’s add a bell to our prompt:</p><p>在提示符中添加一个响铃：</p><pre><code>$ PS1=&quot;\a\$ &quot;</code></pre><p>Now we should hear a beep each time the prompt is displayed. This could get annoying, but it might be useful if we needed notification when an especially long-running command has been executed.</p><p>现在每次提示符显示的时候，我们应该能听到嗡嗡声。这会变得很烦人，但是它可能会 很有用，特别是当一个需要运行很长时间的命令执行完后，我们要得到通知。</p><p>Next, let’s try to make an informative prompt with some host name and time-of-day information:</p><p>下一步，让我们试着创建一个信息丰富的提示符，包含主机名和当天时间的信息。</p><pre><code>$ PS1=&quot;\A \h \$ &quot;17:33 linuxbox $</code></pre><p>Try out the other sequences listed in the table above and see if you can come up with a brilliant new prompt.</p><p>试试其他上表中列出的转义序列，看看你能否想出精彩的新提示符。</p><p>Adding Color</p><h3 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h3><p>Most terminal emulator programs respond to certain non-printing character sequences to control such things as character attributes (like color, bold text and the dreaded blinking text) and cursor position. We’ll cover cursor position in a little bit, but first we’ll look at color.</p><p>大多数终端仿真器程序支持一定的非打印字符序列来控制，比方说字符属性（像颜色，黑体和可怕的闪烁） 和光标位置。我们会更深入地讨论光标位置，但首先我们要看一下字体颜色。</p><blockquote><p>Terminal Confusion</p><p>混乱的终端时代</p><p>Back in ancient times, when terminals were hooked to remote computers, there were many competing brands of terminals and they all worked differently. They had different keyboards and they all had different ways of interpreting control information. Unix and Unix-like systems have two rather complex subsystems to deal with the babel of terminal control (called termcap and terminfo). If you look in the deepest recesses of your terminal emulator settings you may find a setting for the type of terminal emulation.</p><p>回溯到终端连接到远端计算机的时代，有许多竞争的终端品牌，它们各自工作不同。 它们有着不同的键盘，以不同的方式来解释控制信息。Unix 和类 Unix 的系统有两个 相当复杂的子系统来处理终端控制领域的混乱局面（称为 termcap 和 terminfo）。如果你 查看一下终端仿真器最底层的属性设置，可能会找到一个关于终端仿真器类型的设置。</p><p>In an effort to make terminals speak some sort of common language, the American National Standards Institute (ANSI) developed a standard set of character sequences to control video terminals. Old time DOS users will remember the ANSI.SYS file that was used to enable interpretation of these codes.</p><p>为了努力使所有的终端都讲某种通用语言，美国国家标准委员会（ANSI）制定了 一套标准的字符序列集合来控制视频终端。原先 DOS 用户会记得 ANSI.SYS 文件， 这是一个用来使这些编码解释生效的文件。</p></blockquote><p>Character color is controlled by sending the terminal emulator an ANSI escape code embedded in the stream of characters to be displayed. The control code does not “print out” on the display, rather it is interpreted by the terminal as an instruction. As we saw in the table above, the [ and ] sequences are used to encapsulate non-printing characters. An ANSI escape code begins with an octal 033 (the code generated by the escape key) followed by an optional character attribute followed by an instruction. For example, the code to set the text color to normal (attribute = 0), black text is:</p><p>字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI 转义编码来控制的。 这个控制编码不会“打印”到屏幕上，而是被终端解释为一个指令。正如我们在上表看到的字符序列， 这个 [ 和 ] 序列被用来封装这些非打印字符。一个 ANSI 转义编码以一个八进制033（这个编码是由 退出按键产生的）开头，其后跟着一个可选的字符属性，在之后是一个指令。例如，把文本颜色 设为正常（attribute = 0），黑色文本的编码如下：</p><pre><code>\033[0;30m</code></pre><p>Here is a table of available text colors. Notice that the colors are divided into two groups, differentiated by the application of the bold character attribute (1) which creates the appearance of “light” colors:</p><p>这里是一个可用的文本颜色列表。注意这些颜色被分为两组，由应用程序粗体字符属性（1） 分化开来，这个属性可以描绘出“浅”色文本。</p><table><thead><tr><th align="left">Sequence</th><th align="left">Text Color</th><th align="left">Sequence</th><th align="left">Text Color</th></tr></thead><tbody><tr><td align="left">\033[0;30m</td><td align="left">Black</td><td align="left">\033[1;30m</td><td align="left">Dark Gray</td></tr><tr><td align="left">\033[0;31m</td><td align="left">Red</td><td align="left">\033[1;31m</td><td align="left">Light Red</td></tr><tr><td align="left">\033[0;32m</td><td align="left">Green</td><td align="left">\033[1;32m</td><td align="left">Light Green</td></tr><tr><td align="left">\033[0;33m</td><td align="left">Brown</td><td align="left">\033[1;33m</td><td align="left">Yellow</td></tr><tr><td align="left">\033[0;34m</td><td align="left">Blue</td><td align="left">\033[1;34m</td><td align="left">Light Blue</td></tr><tr><td align="left">\033[0;35m</td><td align="left">Purple</td><td align="left">\033[1;35m</td><td align="left">Light Purple</td></tr><tr><td align="left">\033[0;36m</td><td align="left">Cyan</td><td align="left">\033[1;36m</td><td align="left">Light Cyan</td></tr><tr><td align="left">\033[0;37m</td><td align="left">Light Gray</td><td align="left">\033[1;37m</td><td align="left">White</td></tr></tbody></table><table><thead><tr><th align="left">序列</th><th align="left">文本颜色</th><th align="left">序列</th><th align="left">文本颜色</th></tr></thead><tbody><tr><td align="left">\033[0;30m</td><td align="left">黑色</td><td align="left">\033[1;30m</td><td align="left">深灰色</td></tr><tr><td align="left">\033[0;31m</td><td align="left">红色</td><td align="left">\033[1;31m</td><td align="left">浅红色</td></tr><tr><td align="left">\033[0;32m</td><td align="left">绿色</td><td align="left">\033[1;32m</td><td align="left">浅绿色</td></tr><tr><td align="left">\033[0;33m</td><td align="left">棕色</td><td align="left">\033[1;33m</td><td align="left">黄色</td></tr><tr><td align="left">\033[0;34m</td><td align="left">蓝色</td><td align="left">\033[1;34m</td><td align="left">浅蓝色</td></tr><tr><td align="left">\033[0;35m</td><td align="left">粉红</td><td align="left">\033[1;35m</td><td align="left">浅粉色</td></tr><tr><td align="left">\033[0;36m</td><td align="left">青色</td><td align="left">\033[1;36m</td><td align="left">浅青色</td></tr><tr><td align="left">\033[0;37m</td><td align="left">浅灰色</td><td align="left">\033[1;37m</td><td align="left">白色</td></tr></tbody></table><p>Let’s try to make a red prompt. We’ll insert the escape code at the beginning:</p><p>让我们试着制作一个红色提示符。我们将在开头加入转义编码：</p><pre><code>&lt;me@linuxbox ~&gt;$ PS1=&#39;\[\033[0;31m\]&lt;\u@\h \W&gt;\$&#39;&lt;me@linuxbox ~&gt;$</code></pre><p>That works, but notice that all the text that we type after the prompt is also red. To fix this, we will add another escape code to the end of the prompt that tells the terminal emulator to return to the previous color:</p><p>我们的提示符生效了，但是注意我们在提示符之后输入的文本也是红色的。为了修改这个问题， 我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色。</p><pre><code>&lt;me@linuxbox ~&gt;$ PS1=&#39;\[\033[0;31m\]&lt;\u@\h \W&gt;\$\[\033[0m\]&#39;&lt;me@linuxbox ~&gt;$</code></pre><p>That’s better!</p><p>这看起来要好些！</p><p>It’s also possible to set the text background color using the codes listed below. The background colors do not support the bold attribute.</p><p>也有可能要设置文本的背景颜色，使用下面列出的转义编码。这个背景颜色不支持黑体属性。</p><table><thead><tr><th>\033[0;40m</th><th>Blue</th><th>\033[1;44m</th><th>Black</th></tr></thead><tbody><tr><td>\033[0;41m</td><td>Red</td><td>\033[1;45m</td><td>Purple</td></tr><tr><td>\033[0;42m</td><td>Green</td><td>\033[1;46m</td><td>Cyan</td></tr><tr><td>\033[0;43m</td><td>Brown</td><td>\033[1;47m</td><td>Light Gray</td></tr></tbody></table><table><thead><tr><th>\033[0;40m</th><th>蓝色</th><th>\033[1;44m</th><th>黑色</th></tr></thead><tbody><tr><td>\033[0;41m</td><td>红色</td><td>\033[1;45m</td><td>紫色</td></tr><tr><td>\033[0;42m</td><td>绿色</td><td>\033[1;46m</td><td>青色</td></tr><tr><td>\033[0;43m</td><td>棕色</td><td>\033[1;47m</td><td>浅灰色</td></tr></tbody></table><p>We can create a prompt with a red background by applying a simple change to the first escape code:</p><p>我们可以创建一个带有红色背景的提示符，只是对第一个转义编码做个简单的修改。</p><pre><code>&lt;me@linuxbox ~&gt;$ PS1=&#39;\[\033[0;41m\]&lt;\u@\h \W&gt;\$\[\033[0m\] &#39;&lt;me@linuxbox ~&gt;$</code></pre><p>Try out the color codes and see what you can create!</p><p>试试这些颜色编码，看看你能定制出怎样的提示符！</p><hr><p>Note: Besides the normal (0) and bold (1) character attributes, text may also be given underscore (4), blinking (5), and inverse (7) attributes as well. In the interests of good taste, many terminal emulators refuse to honor the blinking attribute, however.</p><p>注意：除了正常的 (0) 和黑体 (1) 字符属性之外，文本也可以具有下划线 (4)，闪烁 (5)， 和反向 (7) 属性。为了拥有好品味，然而，许多终端仿真器拒绝使用这个闪烁属性。</p><hr><p>Moving The Cursor</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>Escape codes can be used to position the cursor. This is commonly used to provide a clock or some other kind of information at a different location on the screen such as an upper corner each time the prompt is drawn. Here is a list of the escape codes that position the cursor:</p><p>转义编码也可以用来定位光标。这些编码被普遍地用来，每次当提示符出现的时候，会在屏幕的不同位置 比如说上面一个角落，显示一个时钟或者其它一些信息。这里是一系列用来定位光标的转义编码：</p><table><thead><tr><th align="left">Escape Code</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">\033[l;cH</td><td align="left">Move the cursor to line l and column c.</td></tr><tr><td align="left">\033[nA</td><td align="left">Move the cursor up n lines.</td></tr><tr><td align="left">\033[nB</td><td align="left">Move the cursor down n lines.</td></tr><tr><td align="left">\033[nC</td><td align="left">Move the cursor forward n characters.</td></tr><tr><td align="left">\033[nD</td><td align="left">Move the cursor backward n characters.</td></tr><tr><td align="left">\033[2J</td><td align="left">Clear the screen and move the cursor to the upper left corner (line 0, column 0).</td></tr><tr><td align="left">\033[K</td><td align="left">Clear from the cursor position to the end of the current line.</td></tr><tr><td align="left">\033[s</td><td align="left">Store the current cursor position.</td></tr><tr><td align="left">\033[u</td><td align="left">Recall the stored cursor position.</td></tr></tbody></table><table><thead><tr><th align="left">转义编码</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">\033[l;cH</td><td align="left">把光标移到第 l 行，第 c 列。</td></tr><tr><td align="left">\033[nA</td><td align="left">把光标向上移动 n 行。</td></tr><tr><td align="left">\033[nB</td><td align="left">把光标向下移动 n 行。</td></tr><tr><td align="left">\033[nC</td><td align="left">把光标向前移动 n 个字符。</td></tr><tr><td align="left">\033[nD</td><td align="left">把光标向后移动 n 个字符。</td></tr><tr><td align="left">\033[2J</td><td align="left">清空屏幕，把光标移到左上角（第零行，第零列）。</td></tr><tr><td align="left">\033[K</td><td align="left">清空从光标位置到当前行末的内容。</td></tr><tr><td align="left">\033[s</td><td align="left">存储当前光标位置。</td></tr><tr><td align="left">\033[u</td><td align="left">唤醒之前存储的光标位置。</td></tr></tbody></table><p>Using the codes above, we’ll construct a prompt that draws a red bar at the top of the screen containing a clock (rendered in yellow text) each time the prompt is displayed. The code for the prompt is this formidable looking string:</p><p>使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方画出一个 包含时钟（由黄色文本渲染）的红色长条。构建好的提示符的编码就是这串看起来令人敬畏的字符串：</p><pre><code>PS1=&#39;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$ &#39;</code></pre><p>Let’s take a look at each part of the string to see what it does:</p><p>让我们分别看一下这个字符串的每一部分所表示的意思：</p><table><thead><tr><th align="left">Squence</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">[</td><td align="left">Begins a non-printing character sequence. The real purpose of this is to allow bash to correctly calculate the size of the visible prompt. Without this, command line editing features will improperly position the cursor.</td></tr><tr><td align="left">\033[s</td><td align="left">Store the cursor position. This is needed to return to the prompt location after the bar and clock have been drawn at the top of the screen. Be aware that some terminal emulators do not honor this code.</td></tr><tr><td align="left">\033[0;0H</td><td align="left">Move the cursor to the upper left corner, which is line zero, column zero.</td></tr><tr><td align="left">\033[0;41m</td><td align="left">Set the background color to red.</td></tr><tr><td align="left">\033[K</td><td align="left">Clear from the current cursor location (the top left corner) to the end of the line. Since the background color is now red, the line is cleared to that color creating our bar. Note that clearing to the end of the line does not change the cursor position, which remains at the upper left corner.</td></tr><tr><td align="left">\033[1;33m</td><td align="left">Set the text color to yellow.</td></tr><tr><td align="left">\t</td><td align="left">Display the current time. While this is a “printing” element, we still include it in the non-printing portion of the prompt, since we don’t want bash to include the clock when calculating the true size of the displayed prompt.</td></tr><tr><td align="left">\033[0m</td><td align="left">Turn off color. This affects both the text and background.</td></tr><tr><td align="left">\033[u</td><td align="left">Restore the cursor position saved earlier.</td></tr><tr><td align="left">]</td><td align="left">End non-printing characters sequence.</td></tr><tr><td align="left">&lt;\u@\h \W&gt;$</td><td align="left">Prompt string.</td></tr></tbody></table><table><thead><tr><th align="left">序列</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">[</td><td align="left">开始一个非打印字符序列。其真正的目的是为了让 bash 能够正确地计算提示符的大小。如果没有这个转义字符的话，命令行编辑 功能会弄错光标的位置。</td></tr><tr><td align="left">\033[s</td><td align="left">存储光标位置。这个用来使光标能回到原来提示符的位置， 当长条和时钟显示到屏幕上方之后。当心一些 终端仿真器不推崇这个编码。</td></tr><tr><td align="left">\033[0;0H</td><td align="left">把光标移到屏幕左上角，也就是第零行，第零列的位置。</td></tr><tr><td align="left">\033[0;41m</td><td align="left">把背景设置为红色。</td></tr><tr><td align="left">\033[K</td><td align="left">清空从当前光标位置到行末的内容。因为现在 背景颜色是红色，则被清空行背景成为红色，以此来创建长条。注意虽然一直清空到行末， 但是不改变光标位置，它仍然在屏幕左上角。</td></tr><tr><td align="left">\033[1;33m</td><td align="left">把文本颜色设为黄色。</td></tr><tr><td align="left">\t</td><td align="left">显示当前时间。虽然这是一个可“打印”的元素，但我们仍把它包含在提示符的非打印部分， 因为我们不想 bash 在计算可见提示符的真正大小时包括这个时钟在内。</td></tr><tr><td align="left">\033[0m</td><td align="left">关闭颜色设置。这对文本和背景都起作用。</td></tr><tr><td align="left">\033[u</td><td align="left">恢复到之前保存过的光标位置处。</td></tr><tr><td align="left">]</td><td align="left">结束非打印字符序列。</td></tr><tr><td align="left">&lt;\u@\h \W&gt;$</td><td align="left">提示符字符串。</td></tr></tbody></table><p>Saving The Prompt</p><h3 id="保存提示符"><a href="#保存提示符" class="headerlink" title="保存提示符"></a>保存提示符</h3><p>Obviously, we don’t want to be typing that monster all the time, so we’ll want to store our prompt someplace. We can make the prompt permanent by adding it to our .bashrc file. To do so, add these two lines to the file:</p><p>显然地，我们不想总是敲入那个怪物，所以我们将要把这个提示符存储在某个地方。通过把它 添加到我们的.bashrc 文件，可以使这个提示符永久存在。为了达到目的，把下面这两行添加到.bashrc 文件中。</p><pre><code>PS1=&#39;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;\u@\h \W&gt;\$ &#39;export PS1</code></pre><p>Summing Up</p><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>Believe it or not, there is much more that can be done with prompts involving shell functions and scripts that we haven’t covered here, but this is a good start. Not everyone will care enough to change the prompt, since the default prompt is usually satisfactory. But for those of us who like to tinker, the shell provides the opportunity for many hours of trivial fun.</p><p>不管你信不信，如果加上我们在这里没有论及的 shell 函数和脚本，还有许多事情可以由提示符来完成。 但这是一个好的开始。并不是每个人都会花心思来更改提示符，因为通常默认的提示符就很让人满意。 但是对于我们这些喜欢思考的人们来说，shell 却提供了许多制造琐碎乐趣的机会。</p><p>Further Reading</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Bash Prompt HOWTO from the Linux Documentation Project provides a pretty complete discussion of what the shell prompt can be made to do. It is available at:</p></li><li><p>The Bash Prompt HOWTO 来自于 Linux 文档工程，对 shell 提示符的用途进行了相当 完备的论述。可在以下链接中得到：</p><p><a href="http://tldp.org/HOWTO/Bash-Prompt-HOWTO/" target="_blank" rel="noopener">http://tldp.org/HOWTO/Bash-Prompt-HOWTO/</a></p></li><li><p>Wikipedia has a good article on the ANSI Escape Codes:</p></li><li><p>Wikipedia 上有一篇关于 ANSI Escape Codes 的好文章：</p><p><a href="http://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/ANSI_escape_code</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十三章 vi简介</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-vi%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-vi%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>There is an old joke about a visitor to New York City asking a passerby for directions to the city’s famous classical music venue:</p><p>Visitor: Excuse me, how do I get to Carnegie Hall?</p><p>Passerby: Practice, practice, practice!</p><p>有一个古老的笑话，说是一个在纽约的游客向行人打听这座城市中著名古典音乐场馆的方向：</p><p>游客： 请问一下，我怎样去卡内基音乐大厅？</p><p>行人： 练习，练习，练习!</p><p>Learning the Linux command line, like becoming an accomplished pianist, is not something that we pick up in an afternoon. It takes years of practice. In this chapter, we will introduce the vi (pronounced “vee eye”) text editor, one of the core programs in the Unix tradition. vi is somewhat notorious for its difficult user interface, but when we see a master sit down at the keyboard and begin to “play,” we will indeed be witness to some great art. We won’t become masters in this chapter, but when we are done, we will know how to play “chopsticks” in vi.</p><p>学习 Linux 命令行，就像要成为一名造诣很深的钢琴家一样，它不是我们一下午就能学会的技能。这需要 经历几年的勤苦练习。在这一章中，我们将介绍 vi（发音“vee eye”）文本编辑器，它是 Unix 传统中核心程序之一。 vi 因它难用的用户界面而有点声名狼藉，但是当我们看到一位大师坐在钢琴前开始演奏时，我们的确成了 伟大艺术的见证人。虽然我们在这里不能成为 vi 大师，但是当我们学完这一章后， 我们会知道怎样在 vi 中弹奏像“Chopsticks”那样的钢琴小品。</p><p>Why We Should Learn vi</p><h3 id="为什么我们应该学习-vi"><a href="#为什么我们应该学习-vi" class="headerlink" title="为什么我们应该学习 vi"></a>为什么我们应该学习 vi</h3><p>In this modern age of graphical editors and easy-to-use text-based editors such as nano, why should we learn vi? There are three good reasons:</p><p>在现在这个图形化编辑器和易于使用的基于文本编辑器的时代，比如说 nano，为什么我们还应该学习 vi 呢？ 下面有三个充分的理由：</p><ul><li>vi is always available. This can be a lifesaver if we have a system with no graphical interface, such as a remote server or a local system with a broken X configuration. nano, while increasingly popular is still not universal. POSIX, a standard for program compatibility on Unix systems, requires that vi be present.</li><li>vi 很多系统都预装。如果我们的系统没有图形界面，比方说一台远端服务器或者是一个 X 配置损坏了的本地系统，那么 vi 就成了我们的救星。虽然 nano 逐渐流行起来，但是它 还没有普及。POSIX，这套 Unix 系统中程序兼容的标准，就要求系统要预装 vi。</li><li>vi is lightweight and fast. For many tasks, it’s easier to bring up vi than it is to find the graphical text editor in the menus and wait for its multiple megabytes to load. In addition, vi is designed for typing speed. As we shall see, a skilled vi user never has to lift his or her fingers from the keyboard while editing.</li><li>vi 轻量级且执行快。对于许多任务来说，启动 vi 比起在菜单中找到一个图形化文本编辑器，  再等待其数倍兆字节的数据加载而言，要容易的多。另外，vi 是为了加快输入速度而设计的。 我们将会看到，当一名熟练的 vi 用户在编辑文件时，他或她的手从不需要移开键盘。</li><li>We don’t want other Linux and Unix users to think we are sissies.</li><li>我们不希望其他 Linux 和 Unix 用户把我们看作胆小鬼。</li></ul><p>Okay, maybe two good reasons.</p><p>好吧，可能只有两个充分的理由。</p><p>A Little Background</p><h3 id="一点儿背景介绍"><a href="#一点儿背景介绍" class="headerlink" title="一点儿背景介绍"></a>一点儿背景介绍</h3><p>The first version of vi was written in 1976 by Bill Joy, a University of California at Berkley student who later went on to co-found Sun Microsystems. vi derives its name from the word “visual,” because it was intended to allow editing on a video terminal with a moving cursor. Previous to visual editors, there were line editors which operated on a single line of text at a time. To specify a change, we tell a line editor to go to a particular line and describe what change to make, such as adding or deleting text. With the advent of video terminals (rather than printer-based terminals like teletypes) visual editing became possible. vi actually incorporates a powerful line editor called ex, and we can use line editing commands while using vi.</p><p>第一版 vi 是在1976由 Bill Joy 写成的，当时他是加州大学伯克利分校的学生， 后来他共同创建了 Sun 微系统公司。vi 这个名字 来源于单词“visual”，因为它打算在带有可移动光标的视频终端上编辑文本。在发明可视化编辑器之前， 有一次只能操作一行文本的行编辑器。为了编辑，我们需要告诉行编辑器到一个特殊行并且 说明做什么修改，比方说添加或删除文本。视频终端（而不是基于打印机的终端，像电传打印机）的出现 ，使可视化编辑成为可能。vi 实际上整合了一个强大的行编辑器 ———— ex , 所以我们在使用 vi 时能运行行编辑命令。</p><p>Most Linux distributions don’t include real vi; rather, they ship with an enhanced replacement called vim (which is short for “vi improved”) written by Bram Moolenaar. vim is a substantial improvement over traditional Unix vi and is usually symbolically linked (or aliased) to the name “vi” on Linux systems. In the discussions that follow, we will assume that we have a program called “vi” that is really vim.</p><p>大多数 Linux 发行版不包含真正的 vi；而是自带一款高级替代版本，叫做 vim（它是“vi improved”的简写）由 Bram Moolenaar 开发的。vim 相对于传统的 Unix vi 来说，取得了实质性进步。通常，vim 在 Linux 系统中是“vi”的符号链接（或别名）。 在随后的讨论中，我们将会假定我们有一个叫做“vi”的程序，但它其实是 vim。</p><p>Starting And Stopping vi</p><h3 id="启动和退出-vi"><a href="#启动和退出-vi" class="headerlink" title="启动和退出 vi"></a>启动和退出 vi</h3><p>To start vi, we simply type the following:</p><p>要想启动 vi，只要简单地输入以下命令：</p><pre><code>[me@linuxbox ~]$ vi</code></pre><p>And a screen like this should appear:</p><p>一个像这样的屏幕应该出现：</p><pre><code>VIM - Vi Improved....</code></pre><p>Just as we did with nano earlier, the first thing to learn is how to exit. To exit, we enter the following command (note that the colon character is part of the command):</p><p>正如我们之前操作 nano 时，首先要学的是怎样退出 vi。要退出 vi，输入下面的命令（注意冒号是命令的一部分）：</p><pre><code>:q</code></pre><p>The shell prompt should return. If, for some reason, vi will not quit (usually because we made a change to a file that has not yet been saved), we can tell vi that we really mean it by adding an exclamation point to the command:</p><p>shell 提示符应该重新出现。如果由于某种原因，vi 不能退出（通常因为我们对文件做了修改，却没有保存文件）。 通过给命令加上叹号，我们可以告诉 vi 我们真要退出 vi。（注意感叹号是命令的一部分）</p><pre><code>:q!</code></pre><p>Tip: If you get “lost” in vi, try pressing the Esc key twice to find your way again.</p><p>小贴示：如果你在 vi 中“迷失”了，试着按下 Esc 键两次来回到普通模式。</p><blockquote><p>Compatibility Mode</p><p>兼容模式</p><p>In the example startup screen above (taken from Ubuntu 8.04), we see the text “Running in Vi compatible mode.” This means that vim will run in a mode that is closer to the normal behavior of vi rather than the enhanced behavior of vim. For purposes of this chapter, we will want to run vim with its enhanced behavior. To do this, you have a few options:</p><p>在上面的截屏中（来自于 Ubuntu 8.04），我们看到一行文字 “运行于 Vi 兼容模式。” 这意味着 vim 将以近似于 vi 的普通的模式 运行，而不是以 vim 的高级的模式运行。出于本章的教学目的，我们将使用 vim 和它的的高级模式。 要这样使用vim，可以通过如下方法：</p><p>Try running vim instead of vi.</p><p>用 vim 来代替 vi。</p><p>If that works, consider adding alias vi=’vim’ to your .bashrc file.</p><p>如果命令生效，考虑在你的.bashrc 文件中添加 alias vi=’vim’。</p><p>Alternately, use this command to add a line to your vim configuration file:</p><p>或者，使用以下命令在你的 vim 配置文件中添加一行：</p><p><em>echo “set nocp” &gt;&gt; ~/.vimrc</em></p><p>Different Linux distributions package vim in different ways. Some distributions install a minimal version of vim by default that only supports a limiting set of vim features. While preforming the lessons that follow, you may encounter missing features. If this is the case, install the full version of vim.</p><p>不同 Linux 发行版自带的 vim 软件包各不相同。一些发行版预装了 vim 的最简版， 其只支持很有限的 vim 特性。在随后练习里，你可能发现你的 vim 缺失一些特性。 若是如此，请安装 vim 的完整版。</p></blockquote><p>Editing Modes</p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>Let’s start up vi again, this time passing to it the name of a nonexistent file. This is how we can create a new file with vi:</p><p>再次启动 vi，这次传递给 vi 一个不存在的文件名。这也是用 vi 创建新文件的方法。</p><pre><code>[me@linuxbox ~]$ rm -f foo.txt[me@linuxbox ~]$ vi foo.txt</code></pre><p>If all goes well, we should get a screen like this:</p><p>如果一切正常，我们应该获得一个像这样的屏幕：</p><pre><code>....&quot;foo.txt&quot; [New File]</code></pre><p>The leading tilde characters (”~”) indicate that no text exists on that line. This shows that we have an empty file. Do not type anything yet!</p><p>每行开头的波浪号（”~”）表示那一行没有文本。这里我们有一个空文件。先别进行输入！</p><p>The second most important thing to learn about vi (after learning how to exit) is that vi is a modal editor. When vi starts up, it begins in command mode. In this mode, almost every key is a command, so if we were to start typing, vi would basically go crazy and make a big mess.</p><p>关于 vi ，第二重要的事是知晓vi 是一个模式编辑器。（第一件事是如何退出 vi ）vi 启动后会直接进入 命令模式。这种模式下，几乎每个按键都是一个命令，所以如果我们直接输入文本，vi 会发疯，弄得一团糟。</p><p>Entering Insert Mode</p><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><p>In order to add some text to our file, we must first enter insert mode. To do this, we press the “i” key. Afterwards, we should see the following at the bottom of the screen if vim is running in its usual enhanced mode (this will not appear in vi compatible mode):</p><p>为了在文件中添加文本，我们需要先进入插入模式。按下”i”键进入插入模式。之后，我们应当 在屏幕底部看到如下的信息，如果 vi 运行在高级模式下（ vi 在兼容模式下不会显示这行信息）：</p><pre><code>-- INSERT --</code></pre><p>Now we can enter some text. Try this:</p><p>现在我们能输入一些文本了。试着输入这些文本：</p><pre><code>The quick brown fox jumped over the lazy dog.</code></pre><p>To exit insert mode and return to command mode, press the Esc key.</p><p>若要退出插入模式返回命令模式，按下 Esc 按键。</p><p>Saving Our Work</p><h4 id="保存我们的工作"><a href="#保存我们的工作" class="headerlink" title="保存我们的工作"></a>保存我们的工作</h4><p>To save the change we just made to our file, we must enter an ex command while in command mode. This is easily done by pressing the “:” key. After doing this, a colon character should appear at the bottom of the screen:</p><p>为了保存我们刚才对文件所做的修改，我们必须在命令模式下输入一个 ex 命令。 通过按下”:”键，这很容易完成。按下冒号键之后，一个冒号字符应该出现在屏幕的底部：</p><pre><code>:</code></pre><p>To write our modified file, we follow the colon with a “w” then Enter:</p><p>为了写入我们修改的文件，我们在冒号之后输入”w”字符，然后按下回车键：</p><pre><code>:w</code></pre><p>The file will be written to the hard drive and we should get a confirmation message at the bottom of the screen, like this:</p><p>文件将会写入到硬盘，而且我们会在屏幕底部看到一行确认信息，就像这样：</p><pre><code>&quot;foo.txt&quot; [New] 1L, 46C written</code></pre><p>Tip: If you read the vim documentation, you will notice that (confusingly) command mode is called normal mode and ex commands are called command mode. Beware.</p><p>小贴示：如果你阅读 vim 的文档，你会发现命令模式被（令人困惑地）叫做普通模式，ex 命令 叫做命令模式。当心。</p><p>Moving The Cursor Around</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>While in command mode, vi offers a large number of movement commands, some of which it shares with less. Here is a subset:</p><p>当在 vi 命令模式下时，vi 提供了大量的移动命令，其中一些与 less 阅读器的相同。这里 列举了一些：</p><table><thead><tr><th align="left">Key</th><th align="left">Move The Cursor</th></tr></thead><tbody><tr><td align="left">l or Right Arrow</td><td align="left">Right one character.</td></tr><tr><td align="left">h or Left Arrow</td><td align="left">Left one character</td></tr><tr><td align="left">j or Down Arrow</td><td align="left">Down one line</td></tr><tr><td align="left">k or Up Arrow</td><td align="left">Up one line</td></tr><tr><td align="left">0 (zero)</td><td align="left">To the beginning of the current line.</td></tr><tr><td align="left">^</td><td align="left">To the first non-whitespace character on the current line.</td></tr><tr><td align="left">$</td><td align="left">To the end of the current line.</td></tr><tr><td align="left">w</td><td align="left">To the beginning of the next word or puntuation character.</td></tr><tr><td align="left">W</td><td align="left">To the beginning of the next word, ignoring puntuation character.</td></tr><tr><td align="left">b</td><td align="left">To the beginning of the previous word or punctuation character.</td></tr><tr><td align="left">B</td><td align="left">To the beginning of the previous word, ignoring punctuation characters.</td></tr><tr><td align="left">Ctrl-f or Page Down</td><td align="left">Down one page.</td></tr><tr><td align="left">Ctrl-b or Page Up</td><td align="left">Up one page.</td></tr><tr><td align="left">numberG</td><td align="left">To line number. For example, 1G moves to the first line of the file.</td></tr><tr><td align="left">G</td><td align="left">To the last line of the file.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">移动光标</th></tr></thead><tbody><tr><td align="left">l or 右箭头</td><td align="left">向右移动一个字符</td></tr><tr><td align="left">h or 左箭头</td><td align="left">向左移动一个字符</td></tr><tr><td align="left">j or 下箭头</td><td align="left">向下移动一行</td></tr><tr><td align="left">k or 上箭头</td><td align="left">向上移动一行</td></tr><tr><td align="left">0 (零按键)</td><td align="left">移动到当前行的行首。</td></tr><tr><td align="left">^</td><td align="left">移动到当前行的第一个非空字符。</td></tr><tr><td align="left">$</td><td align="left">移动到当前行的末尾。</td></tr><tr><td align="left">w</td><td align="left">移动到下一个单词或标点符号的开头。</td></tr><tr><td align="left">W</td><td align="left">移动到下一个单词的开头，忽略标点符号。</td></tr><tr><td align="left">b</td><td align="left">移动到上一个单词或标点符号的开头。</td></tr><tr><td align="left">B</td><td align="left">移动到上一个单词的开头，忽略标点符号。</td></tr><tr><td align="left">Ctrl-f or Page Down</td><td align="left">向下翻一页</td></tr><tr><td align="left">Ctrl-b or Page Up</td><td align="left">向上翻一页</td></tr><tr><td align="left">numberG</td><td align="left">移动到第 number 行。例如，1G 移动到文件的第一行。</td></tr><tr><td align="left">G</td><td align="left">移动到文件末尾。</td></tr></tbody></table><p>Why are the h, j, k, and l keys used for cursor movement? Because when vi was originally written, not all video terminals had arrow keys, and skilled typists could use regular keyboard keys to move the cursor without ever having to lift their fingers from the keyboard.</p><p>为什么 h，j，k，和 l 按键被用来移动光标呢？因为在开发 vi 之初，并不是所有的视频终端都有 箭头按键，熟练的打字员可以使用组合键来移动光标，他们的手指从不需要移开键盘。</p><p>Many commands in vi can be prefixed with a number, as with the “G” command listed above. By prefixing a command with a number, we may specify the number of times a command is to be carried out. For example, the command “5j” causes vi to move the cursor down five lines.</p><p>vi 中的许多命令都可以在前面加上一个数字，比方说上面提到的”G”命令。在命令之前加上一个 数字，我们就可以指定命令执行的次数。例如，命令”5j”将光标下移5行。</p><p>Basic Editing</p><h3 id="基本编辑"><a href="#基本编辑" class="headerlink" title="基本编辑"></a>基本编辑</h3><p>Most editing consists of a few basic operations such as inserting text, deleting text and moving text around by cutting and pasting. vi, of course, supports all of these operations in its own unique way. vi also provides a limited form of undo. If we press the “u” key while in command mode, vi will undo the last change that you made. This will come in handy as we try out some of the basic editing commands.</p><p>大多数编辑工作由一些基本的操作组成，比如说插入文本，删除文本和通过剪切和粘贴来移动文本。 vi，当然，有它独特方式来实现所有的操作。vi 也提供了撤销功能，但有些限制。如果我们按下“u” 按键，当在命令模式下，vi 将会撤销你所做的最后一次修改。当我们试着执行一些基本的 编辑命令时，这会很方便。</p><p>Appending Text</p><h4 id="追加文本"><a href="#追加文本" class="headerlink" title="追加文本"></a>追加文本</h4><p>vi has several different ways of entering insert mode. We have already used the i command to insert text.</p><p>vi 有几种不同进入插入模式的方法。我们已经使用了 i 命令来插入文本。</p><p>Let’s go back to our foo.txt file for a moment:</p><p>让我们再次进入到我们的 foo.txt 文件：</p><pre><code>The quick brown fox jumped over the lazy dog.</code></pre><p>If we wanted to add some text to the end of this sentence, we would discover that the i command will not do it, since we can’t move the cursor beyond the end of the line. vi provides a command to append text, the sensibly named “a” command. If we move the cursor to the end of the line and type “a”, the cursor will move past the end of the line and vi will enter insert mode. This will allow us to add some more text:</p><p>如果我们想要在这个句子的末尾添加一些文本，我们会发现 i 命令不能完成任务，因为我们不能把 光标移到行尾。vi 提供了追加文本的命令，明智地命名为”a”。如果我们把光标移动到行尾，输入”a”, 光标就会越过行尾，同时 vi 会进入插入模式。这让我们能添加文本到行末：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.</code></pre><p>Remember to press the Esc key to exit insert mode.</p><p>记得按 Esc 键来退出插入模式。</p><p>Since we will almost always want to append text to the end of a line, vi offers a shortcut to move to end of the current line and start appending. It’s the “A” command. Let’s try it and add some more lines to our file.</p><p>因为我们几乎总是想要在行尾添加文本，所以 vi 提供了一个快捷键。光标将移动到行尾，同时 vi 进入输入模式。 它是”A”命令。试着用一下它，向文件添加更多行。</p><p>First, we’ll move the cursor to the beginning of the line using the “0” (zero) command. Now we type “A” and add the following lines of text:</p><p>首先，使用”0”(零)命令，将光标移动到行首。现在我们输入”A”，然后输入下面这些文本：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5</code></pre><p>Again, press the Esc key to exit insert mode.</p><p>再一次，按下 Esc 键退出插入模式。</p><p>As we can see, the “A” command is more useful as it moves the cursor to the end of the line before starting insert mode.</p><p>正如我们所看到的， “A” 命令非常有用，因为它在进入到插入模式前，先将光标移到了行尾。</p><p>Opening A Line</p><h4 id="打开一行"><a href="#打开一行" class="headerlink" title="打开一行"></a>打开一行</h4><p>Another way we can insert text is by “opening” a line. This inserts a blank line between two existing lines and enters insert mode. This has two variants:</p><p>我们插入文本的另一种方式是“打开（open）”一行。这会在两行之间插入一个空白行，并且进入到插入模式。 这种方式有两个变体：</p><table><thead><tr><th align="left">Command</th><th align="left">Opens</th></tr></thead><tbody><tr><td align="left">o</td><td align="left">The line below the current line.</td></tr><tr><td align="left">O</td><td align="left">The line above the current line.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">打开行</th></tr></thead><tbody><tr><td align="left">o</td><td align="left">当前行的下方打开一行。</td></tr><tr><td align="left">O</td><td align="left">当前行的上方打开一行。</td></tr></tbody></table><p>We can demonstrate this as follows: place the cursor on “Line 3” then press the o key.</p><p>我们可以演示一下：把光标移到”Line 3”上，再按下小 o 按键。</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3line 4line 5</code></pre><p>A new line was opened below the third line and we entered insert mode. Exit insert mode by pressing the Esc key. Press the u key to undo our change.</p><p>在第三行之下打开了新的一行，并且进入插入模式。按下 Esc，退出插入模式。按下 u 按键，撤销我们的修改。</p><p>Press the O key to open the line above the cursor:</p><p>按下大 O 按键在光标之上打开新的一行：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5</code></pre><p>Exit insert mode by pressing the Esc key and undo our change by pressing u.</p><p>按下 Esc 按键，退出插入模式，并且按下 u 按键，撤销我们的更改。</p><p>Deleting Text</p><h4 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h4><p>As we might expect, vi offers a variety of ways to delete text, all of which contain one of two keystrokes. First, the x key will delete a character at the cursor location. x may be preceded by a number specifying how many characters are to be deleted. The d key is more general purpose. Like x, it may be preceded by a number specifying the number of times the deletion is to be performed. In addition, d is always followed by a movement command that controls the size of the deletion. Here are some examples:</p><p>正如我们所愿，vi 提供了各种删除文本到的方法，而且只需一或两个按键。首先， x 按键会删除光标位置的一个字符。可以在 x 命令之前带上一个数字，来指明要删除的字符个数。 d 按键更通用一些。跟 x 命令一样，d 命令之前可以带上一个数字，来指定要执行的删除次数。另外， d 命令之后总是带上一个移动命令，用来控制删除的范围。这里有些实例：</p><table><thead><tr><th align="left">Command</th><th align="left">Deletes</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">The current character.</td></tr><tr><td align="left">3x</td><td align="left">The current character and the next two character.</td></tr><tr><td align="left">dd</td><td align="left">The current line.</td></tr><tr><td align="left">5dd</td><td align="left">The current line and the next four lines.</td></tr><tr><td align="left">dW</td><td align="left">From the cursor position to the beginning of the next word.</td></tr><tr><td align="left">d$</td><td align="left">From the cursor position to the end of the current line.</td></tr><tr><td align="left">d0</td><td align="left">From the cursor position to the beginning of the current line.</td></tr><tr><td align="left">d^</td><td align="left">From the cursor position to the first non-whitespace character of the line.</td></tr><tr><td align="left">dG</td><td align="left">From the current line to the end of the file.</td></tr><tr><td align="left">d20G</td><td align="left">From the current line to the twentieth line of the file.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">删除的文本</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">当前字符</td></tr><tr><td align="left">3x</td><td align="left">当前字符及其后的两个字符。</td></tr><tr><td align="left">dd</td><td align="left">当前行。</td></tr><tr><td align="left">5dd</td><td align="left">当前行及随后的四行文本。</td></tr><tr><td align="left">dW</td><td align="left">从光标位置开始到下一个单词的开头。</td></tr><tr><td align="left">d$</td><td align="left">从光标位置开始到当前行的行尾。</td></tr><tr><td align="left">d0</td><td align="left">从光标位置开始到当前行的行首。</td></tr><tr><td align="left">d^</td><td align="left">从光标位置开始到文本行的第一个非空字符。</td></tr><tr><td align="left">dG</td><td align="left">从当前行到文件的末尾。</td></tr><tr><td align="left">d20G</td><td align="left">从当前行到文件的第20行。</td></tr></tbody></table><p>Place the cursor on the word “It” on the first line of our text. Press the x key repeatedly until the rest of the sentence is deleted. Next, press the u key repeatedly until the deletion is undone.</p><p>把光标放到第一行单词“It”之上。重复按下 x 按键直到删除剩下的部分。下一步，重复按下 u 按键 直到恢复原貌。</p><p>Note: Real vi only supports a single level of undo. vim supports multiple levels.</p><p>注意：真正的 vi 只是支持单层面的 undo 命令。vim 则支持多个层面的。</p><p>Let’s try the deletion again, this time using the d command. Again, move the cursor to the word “It” and press dW to delete the word:</p><p>我们再次执行删除命令，这次使用 d 命令。还是移动光标到单词”It”之上，按下的 dW 来删除单词：</p><pre><code>The quick brown fox jumped over the lazy dog. was cool.Line 2Line 3Line 4Line 5</code></pre><p>Press d$ to delete from the cursor position to the end of the line:</p><p>按下 d$删除从光标位置到行尾的文本：</p><pre><code>The quick brown fox jumped over the lazy dog.Line 2Line 3Line 4Line 5</code></pre><p>Press dG to delete from the current line to the end of the file:</p><p>按下 dG 按键删除从当前行到文件末尾的所有行：</p><pre><code>~....</code></pre><p>Press u three times to undo the deletion.</p><p>连续按下 u 按键三次，来恢复删除部分。</p><p>Cutting, Copying And Pasting Text</p><h4 id="剪切，复制和粘贴文本"><a href="#剪切，复制和粘贴文本" class="headerlink" title="剪切，复制和粘贴文本"></a>剪切，复制和粘贴文本</h4><p>The d command not only deletes text, it also “cuts” text. Each time we use the d command the deletion is copied into a paste buffer (think clipboard) that we can later recall with the p command to paste the contents of the buffer after the cursor or the P command to paste the contents before the cursor.</p><p>这个 d 命令不仅删除文本，它还“剪切”文本。每次我们使用 d 命令，删除的部分被复制到一个 粘贴缓冲区中（看作剪切板）。过后我们执行小 p 命令把剪切板中的文本粘贴到光标位置之后， 或者是大 P 命令把文本粘贴到光标之前。</p><p>The y command is used to “yank” (copy) text in much the same way the d command is used to cut text. Here are some examples combining the y command with various movement commands:</p><p>y 命令用来“拉”（复制）文本，和 d 命令剪切文本的方式差不多。这里有些把 y 命令和各种移动命令 结合起来使用的实例：</p><table><thead><tr><th align="left">Command</th><th align="left">Copies</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">The current line.</td></tr><tr><td align="left">5yy</td><td align="left">The current line and the next four lines.</td></tr><tr><td align="left">yW</td><td align="left">From the current cursor position to the beginning of the next word.</td></tr><tr><td align="left">y$</td><td align="left">From the current cursor location to the end of the current line.</td></tr><tr><td align="left">y0</td><td align="left">From the current cursor location to the beginning of the line.</td></tr><tr><td align="left">y^</td><td align="left">From the current cursor location to the first non- whitespace character in the line.</td></tr><tr><td align="left">yG</td><td align="left">From the current line to the end of the file.</td></tr><tr><td align="left">y20G</td><td align="left">From the current line to the twentieth line of the file.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">复制的内容</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">当前行。</td></tr><tr><td align="left">5yy</td><td align="left">当前行及随后的四行文本。</td></tr><tr><td align="left">yW</td><td align="left">从当前光标位置到下一个单词的开头。</td></tr><tr><td align="left">y$</td><td align="left">从当前光标位置到当前行的末尾。</td></tr><tr><td align="left">y0</td><td align="left">从当前光标位置到行首。</td></tr><tr><td align="left">y^</td><td align="left">从当前光标位置到文本行的第一个非空字符。</td></tr><tr><td align="left">yG</td><td align="left">从当前行到文件末尾。</td></tr><tr><td align="left">y20G</td><td align="left">从当前行到文件的第20行。</td></tr></tbody></table><p>Let’s try some copy and paste. Place the cursor on the first line of the text and type yy to copy the current line. Next, move the cursor to the last line (G) and type p to paste the line below the current line:</p><p>我们试着做些复制和粘贴工作。把光标放到文本第一行，输入 yy 来复制当前行。下一步，把光标移到 最后一行（G），输入小写的 p 把复制的一行粘贴到当前行的下面：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5The quick brown fox jumped over the lazy dog. It was cool.</code></pre><p>Just as before, the u command will undo our change. With the cursor still positioned on the last line of the file, type P to paste the text above the current line:</p><p>和以前一样，u 命令会撤销我们的修改。这时光标仍位于文件的最后一行，输入大写的 P 命令把 所复制的文本粘贴到当前行之上：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4The quick brown fox jumped over the lazy dog. It was cool.Line 5</code></pre><p>Try out some of the other y commands in the table above and get to know the behavior of both the p and P commands. When you are done, return the file to its original state.</p><p>试着执行上表中其他的一些 y 命令，了解小写 p 和大写 P 命令的行为。当你完成练习之后，把文件 恢复原样。</p><p>Joining Lines</p><h4 id="连接行"><a href="#连接行" class="headerlink" title="连接行"></a>连接行</h4><p>vi is rather strict about its idea of a line. Normally, it is not possible to move the cursor to the end of a line and delete the end-of-line character to join one line with the one below it. Because of this, vi provides a specific command, J (not to be confused with j, which is for cursor movement) to join lines together.</p><p>vi 对于行的概念相当严格。通常，用户不可能通过删除“行尾结束符”（end-of-line character）来连接 当前行和它下面的一行。由于这个原因，vi 提供了一个特定的命令，大写的 J（不要与小写的 j 混淆了， j 是用来移动光标的）用于链接行与行。</p><p>If we place the cursor on line 3 and type the J command, here’s what happens:</p><p>如果我们把光标放到 line 3上，输入大写的 J 命令，看看发生什么情况：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3 Line 4Line 5</code></pre><p>Search And Replace</p><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><p>vi has the ability to move the cursor to locations based on searches. It can do this on both a single line or over an entire file. It can also perform text replacements with or without confirmation from the user.</p><p>vi 能把光标移到搜索到的匹配项上。vi 不仅能在搜索一特定行，还能进行全文搜索。 它也可以在有或没有用户确认的情况下实现文本替换。</p><p>Searching Within A Line</p><h4 id="查找一行"><a href="#查找一行" class="headerlink" title="查找一行"></a>查找一行</h4><p>The f command searches a line and moves the cursor to the next instance of a specified character. For example, the command fa would move the cursor to the next occurrence of the character “a” within the current line. After performing a character search within a line, the search may be repeated by typing a semicolon.</p><p>f 命令能搜索一特定行，并将光标移动到下一个匹配的字符上。例如，命令 fa 会把光标定位到同一行中 下一个出现的”a”字符上。在进行了一次行内搜索后，输入分号能重复这次搜索。</p><p>Searching The Entire File</p><h4 id="查找整个文件"><a href="#查找整个文件" class="headerlink" title="查找整个文件"></a>查找整个文件</h4><p>To move the cursor to the next occurrence of a word or phrase, the / command is used. This works the same way as we learned earlier in the less program. When you type the / command a “/” will appear at the bottom of the screen. Next, type the word or phrase to be searched for, followed by the Enter key. The cursor will move to the next location containing the search string. A search may be repeated using the previous search string with the n command. Here’s an example:</p><p>移动光标到下一个出现的单词或短语上，使用 / 命令。这个命令和我们之前在 less 程序中学到 的一样。当你输入/命令后，一个”/”字符会出现在屏幕底部。接下来，输入要查找的单词或短语， 按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 n 命令来重复先前的查找。 这里有个例子：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5</code></pre><p>Place the cursor on the first line of the file. Type:</p><p>移动光标到文件的第一行。输入：</p><pre><code>/Line</code></pre><p>followed by the Enter key. The cursor will move to line 2. Next, type n and the cursor will move to line 3. Repeating the n command will move the cursor down the file until it runs out of matches. While we have so far only used words and phrases for our search patterns, vi allows the use of regular expressions, a powerful method of expressing complex text patterns. We will cover regular expressions in some detail in a later chapter.</p><p>然后敲回车。光标会移动到第二行。然后输入 n，这时光标移动到第三行。重复键入 n 命令，光标会 继续向下移动直到遍历所有的匹配项。至此我们只是通过输入单词和短语进行搜索，但 vi 支持正则 表达式，一种用于表达复杂文本的方法。我们将会在之后的章节中详细讲解正则表达式。</p><p>Global Search And Replace</p><h4 id="全局查找和替代"><a href="#全局查找和替代" class="headerlink" title="全局查找和替代"></a>全局查找和替代</h4><p>vi uses an ex command to perform search and replace operations (called “substitution” in vi) over a range of lines or the entire file. To change the word “Line” to “line” for the entire file, we would enter the following command:</p><p>vi 使用 ex 命令来执行查找和替代操作（vi 中叫做“替换”）。将整个文件中的单词“Line”更改为“line”， 输入以下命令：</p><pre><code>:%s/Line/line/g</code></pre><p>Let’s break this command down into separate items and see what each one does:</p><p>我们把这个命令分解为几个单独的部分，看一下每部分的含义：</p><table><thead><tr><th align="left">Item</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">:</td><td align="left">The colon character starts an ex command.</td></tr><tr><td align="left">%</td><td align="left">Specifies the range of lines for the operation. % is a shortcut meaning from the first line to the last line. Alternately, the range could have been specified 1,5 (since our file is five lines long), or 1,$ which means “from line 1 to the last line in the file.” If the range of lines is omitted, the operation is only performed on the current line.</td></tr><tr><td align="left">s</td><td align="left">Specifies the operation. In this case, substitution (search and replace).</td></tr><tr><td align="left">/Line/line</td><td align="left">The search pattern and the replacement text.</td></tr><tr><td align="left">g</td><td align="left">This means “global” in the sense that the search and replace is performed on every instance of the search string in the line. If omitted, only the first instance of the search string on each line is replaced.</td></tr></tbody></table><table><thead><tr><th align="left">条目</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">:</td><td align="left">冒号字符运行一个 ex 命令。</td></tr><tr><td align="left">%</td><td align="left">指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对当前行生效。</td></tr><tr><td align="left">s</td><td align="left">指定操作。在这种情况下是，替换（查找与替代）。</td></tr><tr><td align="left">/Line/line</td><td align="left">查找类型与替代文本。</td></tr><tr><td align="left">g</td><td align="left">这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。</td></tr></tbody></table><p>After executing our search and replace command our file looks like this:</p><p>执行完查找和替代命令之后，我们的文件看起来像这样：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.line 2line 3line 4line 5</code></pre><p>We can also specify a substitution command with user confirmation. This is done by adding a “c” to the end of the command. For example:</p><p>我们也可以指定一个需要用户确认的替换命令。通过添加一个”c”字符到这个命令的末尾，来完成 这个替换命令。例如：</p><pre><code>:%s/line/Line/gc</code></pre><p>This command will change our file back to its previous form; however, before each substitution, vi stops and asks us to confirm the substitution with this message:</p><p>这个命令会把我们的文件恢复先前的模样；然而，在执行每个替换命令之前，vi 会停下来， 通过下面的信息，来要求我们确认这个替换：</p><pre><code>replace with Line (y/n/a/q/l/^E/^Y)?</code></pre><p>Each of the characters within the parentheses is a possible choice as follows:</p><p>括号中的每个字符都是一个可能的选择，如下所示：</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">Perform the substitution.</td></tr><tr><td align="left">n</td><td align="left">Skip this instance of the pattern.</td></tr><tr><td align="left">a</td><td align="left">Perform the substitution on this and all subsequent instances of the pattern.</td></tr><tr><td align="left">q or esc</td><td align="left">Quit the substitution.</td></tr><tr><td align="left">l</td><td align="left">Perform this substitution and then quit. Short for”last”.</td></tr><tr><td align="left">Ctrl-e, Ctrl-y</td><td align="left">Scroll down and scroll up, respectively. Useful for viewing the context of the proposed substitution.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">执行替换操作</td></tr><tr><td align="left">n</td><td align="left">跳过这个匹配的实例</td></tr><tr><td align="left">a</td><td align="left">对这个及随后所有匹配的字符串执行替换操作。</td></tr><tr><td align="left">q or esc</td><td align="left">退出替换操作。</td></tr><tr><td align="left">l</td><td align="left">执行这次替换并退出。l 是 “last” 的简写。</td></tr><tr><td align="left">Ctrl-e, Ctrl-y</td><td align="left">分别是向下滚动和向上滚动。用于查看建议替换的上下文。</td></tr></tbody></table><p>If you type y, the substitution will be performed, n will cause vi to skip this instance and move on to the next one.</p><p>如果你输入 y，则执行这个替换，输入 n 则会导致 vi 跳过这个实例，而移到下一个匹配项上。</p><p>Editing Multiple Files</p><h3 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h3><p>It’s often useful to edit more than one file at a time. You might need to make changes to multiple files or you may need to copy content from one file into another. With vi we can open multiple files for editing by specifying them on the command line:</p><p>同时能够编辑多个文件是很有用的。你可能需要更改多个文件或者从一个文件复制内容到 另一个文件。通过 vi，我们可以打开多个文件来编辑，只要在命令行中指定要编辑的文件名。</p><pre><code>vi file1 file2 file3...</code></pre><p>Let’s exit our existing vi session and create a new file for editing. Type :wq to exit vi saving our modified text. Next, we’ll create an additional file in our home directory that we can play with. We’ll create the file by capturing some output from the ls command:</p><p>我们先退出已经存在的 vi 会话，然后创建一个新文件来编辑。输入:wq 来退出 vi 并且保存了所做的修改。 下一步，我们将在家目录下创建一个额外的用来玩耍的文件。通过获取从 ls 命令的输出，来创建这个文件。</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</code></pre><p>Let’s edit our old file and our new one with vi:</p><p>用 vi 来编辑我们的原文件和新创建的文件：</p><pre><code>[me@linuxbox ~]$ vi foo.txt ls-output.txt</code></pre><p>vi will start up and we will see the first file on the screen:</p><p>vi 启动，我们会看到第一个文件显示出来：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5</code></pre><p>Switching Between Files</p><h4 id="文件之间切换"><a href="#文件之间切换" class="headerlink" title="文件之间切换"></a>文件之间切换</h4><p>To switch from one file to the next, use this ex command:</p><p>从这个文件切换下一个文件，使用这个 ex 命令：</p><pre><code>:n</code></pre><p>To move back to the previous file use:</p><p>回到先前的文件使用：</p><pre><code>:N</code></pre><p>While we can move from one file to another, vi enforces a policy that prevents us from switching files if the current file has unsaved changes. To force vi to switch files and abandon your changes, add an exclamation point (!) to the command.</p><p>当我们从一个文件移到另一个文件时，如果当前文件没有保存修改，vi 会阻止我们切换文件， 这是 vi 强制执行的政策。在命令之后添加感叹号，可以强迫 vi 放弃修改而转换文件。</p><p>In addition to the switching method described above, vim (and some versions of vi) also provide some ex commands that make multiple files easier to manage. We can view a list of files being edited with the :buffers command. Doing so will display a list of the files at the bottom of the display:</p><p>另外，上面所描述的切换方法，vim（和一些版本的 vi）也提供了一些 ex 命令，这些命令使 多个文件更容易管理。我们可以查看正在编辑的文件列表，使用:buffers 命令。运行这个 命令后，屏幕顶部就会显示出一个文件列表：</p><pre><code>:buffers1 #     &quot;foo.txt&quot;                 line 12 %a    &quot;ls-output.txt&quot;           line 0Press ENTER or type command to continue</code></pre><p>To switch to another buffer (file), type :buffer followed by the number of the buffer you wish to edit. For example, to switch from buffer 1 which contains the file foo.txt to buffer 2 containing the file ls-output.txt we would type this:</p><p>要切换到另一个缓冲区（文件），输入 :buffer, 紧跟着你想要编辑的缓冲器编号。比如，要从包含文件 foo.txt 的1号缓冲区切换到包含文件 ls-output.txt 的2号缓冲区，我们会这样输入：</p><pre><code>:buffer 2</code></pre><p>and our screen now displays the second file.</p><p>我们的屏幕现在会显示第二个文件。</p><p>Opening Additional Files For Editing</p><h4 id="打开另一个文件并编辑"><a href="#打开另一个文件并编辑" class="headerlink" title="打开另一个文件并编辑"></a>打开另一个文件并编辑</h4><p>It’s also possible to add files to our current editing session. The ex command :e (short for “edit”) followed by a filename will open an additional file. Let’s end our current editing session and return to the command line.</p><p>在我们的当前的编辑会话里也能添加别的文件。ex 命令 :e (编辑(edit) 的简写) 紧跟要打开的文件名将会打开 另外一个文件。 让我们结束当前的会话回到命令行。</p><p>Start vi again with just one file:</p><p>重新启动vi并只打开一个文件</p><pre><code>[me@linuxbox ~]$ vi foo.txt</code></pre><p>To add our second file, enter:</p><p>要加入我们的第二个文件，输入：</p><pre><code>:e ls-output.txt</code></pre><p>And it should appear on the screen. The first file is still present as we can verify:</p><p>它应该显示在屏幕上。 我们可以这样来确认第一个文件仍然存在：</p><pre><code>:buffers 1 # &quot;foo.txt&quot; line 1 2 %a &quot;ls-output.txt&quot; line 0Press ENTER or type command to continue </code></pre><p>Note: You cannot switch to files loaded with the :e command using either the :n or :N command. To switch files, use the :buffer command followed by the buffer number.</p><p>注意：当文件由 ：e 命令加载，你将无法用 :n 或 :N 命令来切换文件。 这时要使用 :buffer 命令加缓冲区号码，来切换文件。</p><p>Copying Content From One File Into Another</p><h4 id="跨文件复制黏贴"><a href="#跨文件复制黏贴" class="headerlink" title="跨文件复制黏贴"></a>跨文件复制黏贴</h4><p>Often while editing multiple files, we will want to copy a portion of one file into another file that we are editing. This is easily done using the usual yank and paste commands we used earlier. We can demonstrate as follows. First, using our two files, switch to buffer 1 (foo.txt) by entering:</p><p>当我们编辑多个文件时，经常地要复制文件的一部分到另一个正在编辑的文件。使用之前我们学到的 拉（yank）和粘贴命令，这很容易完成。说明如下。以打开的两个文件为例，首先转换到缓冲区1（foo.txt） ，输入：</p><pre><code>:buffer 1</code></pre><p>which should give us this:</p><p>我们应该得到如下输出：</p><pre><code>The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5</code></pre><p>Next, move the cursor to the first line, and type yy to yank (copy) the line.</p><p>下一步，把光标移到第一行，并且输入 yy 来复制这一行。</p><p>Switch to the second buffer by entering:</p><p>转换到第二个缓冲区，输入：</p><pre><code>:buffer 2</code></pre><p>The screen will now contain some file listings like this (only a portion is shown here):</p><p>现在屏幕会包含一些文件列表（这里只列出了一部分）：</p><pre><code>total 343700-rwxr-xr-x 1 root root    31316  2007-12-05  08:58 [....</code></pre><p>Move the cursor to the first line and paste the line we copied from the preceding file by typing the p command:</p><p>移动光标到第一行，输入 p 命令把我们从前面文件中复制的一行粘贴到这个文件中：</p><pre><code>total 343700The quick brown fox jumped over the lazy dog. It was cool.-rwxr-xr-x 1 root root    31316  2007-12-05  08:58 [....</code></pre><p>Inserting An Entire File Into Another</p><h4 id="插入整个文件到另一个文件"><a href="#插入整个文件到另一个文件" class="headerlink" title="插入整个文件到另一个文件"></a>插入整个文件到另一个文件</h4><p>It’s also possible to insert an entire file into one that we are editing. To see this in action, let’s end our vi session and start a new one with just a single file:</p><p>我们也可以把整个文件插入到我们正在编辑的文件中。看一下实际操作，结束 vi 会话，重新 启动一个只打开一个文件的 vi 会话：</p><pre><code>[me@linuxbox ~]$ vi ls-output.txt</code></pre><p>We will see our file listing again:</p><p>再一次看到我们的文件列表：</p><pre><code>total 343700-rwxr-xr-x 1 root root    31316  2007-12-05  08:58 [</code></pre><p>Move the cursor to the third line, then enter the following ex command:</p><p>移动光标到第三行，然后输入以下 ex 命令：</p><pre><code>:r foo.txt</code></pre><p>The :r command (short for “read”) inserts the specified file before the cursor position. Our screen should now look like this:</p><p>这个:r 命令（是”read”的简称）把指定的文件插入到光标位置之前。现在屏幕应该看起来像这样：</p><pre><code>total 343700-rwxr-xr-x 1 root root     31316 2007-12-05  08:58 [....The quick brown fox jumped over the lazy dog. It was cool.Line 2Line 3Line 4Line 5-rwxr-xr-x 1 root root     111276 2008-01-31  13:36 a2p....</code></pre><p>Saving Our Work</p><h3 id="保存工作"><a href="#保存工作" class="headerlink" title="保存工作"></a>保存工作</h3><p>Like everything else in vi, there are several different ways to save our edited files. We have already covered the ex command :w, but there are some others we may also find helpful.</p><p>像 vi 中的其它操作一样，有几种不同的方法来保存我们所修改的文件。我们已经研究了:w 这个 ex 命令， 但还有几种方法，可能我们也觉得有帮助。</p><p>In command mode, typing ZZ will save the current file and exit vi. Likewise, the ex command :wq will combine the :w and :q commands into one that will both save the file and exit.</p><p>在命令模式下，输入 ZZ 就会保存并退出当前文件。同样地，ex 命令:wq 把:w 和:q 命令结合到 一起，来完成保存和退出任务。</p><p>The :w command may also specify an optional filename. This acts like “Save As…” For example, if we were editing foo.txt and wanted to save an alternate version called foo1.txt, we would enter the following:</p><p>这个:w 命令也可以指定可选的文件名。这个的作用就如”Save As…“。例如，如果我们 正在编辑 foo.txt 文件，想要保存一个副本，叫做 foo1.txt，那么我们可以执行以下命令：</p><pre><code>:w foo1.txt</code></pre><hr><p>Note: While the command above saves the file under a new name, it does not change the name of the file you are editing. As you continue to edit, you will still be editing foo.txt, not foo1.txt.</p><p>注意：当上面的命令以一个新名字保存文件时，它并没有更改你正在编辑的文件的名字。 如果你继续编辑，你还是在编辑文件 foo.txt，而不是 foo1.txt。</p><hr><p>Further Reading</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Even with all that we have covered in this chapter, we have barely scratched the surface of what vi and vim can do. Here are a couple of on-line resources you can use to continue your journey towards vi mastery:</p><p>即使把这章所学的内容都加起来，我们也只是学了 vi 和 vim 的一点儿皮毛而已。这里 有一些在线资料，可以帮助你进一步掌握 vi。</p><ul><li><p>Learning The vi Editor – A Wikibook from Wikipedia that offers a concise guide to vi and several of its work-a-likes including vim. It’s available at:</p></li><li><p>学习 vi 编辑器－一本来自于 Wikipedia 的 Wikibook，是一本关于 vi 的简要指南，并 介绍了几个类似 vi 的程序，其中包括 vim。它可以在以下链接中得到：</p><p><a href="http://en.wikibooks.org/wiki/Vi" target="_blank" rel="noopener">http://en.wikibooks.org/wiki/Vi</a></p></li><li><p>The Vim Book - The vim project has a 570-page book that covers (almost) all of the features in vim. You can find it at:</p></li><li><p>The Vim Book－vim 项目包括一本书，570页，（几乎）包含了 vim 的全部特性。你能在下面链接中找到它：</p><p><a href="ftp://ftp.vim.org/pub/vim/doc/book/vimbook-OPL.pdf" target="_blank" rel="noopener">ftp://ftp.vim.org/pub/vim/doc/book/vimbook-OPL.pdf</a>.</p></li><li><p>A Wikipedia article on Bill Joy, the creator of vi.:</p></li><li><p>Wikipedia 上关于 Bill Joy（vi 创始人）的文章。</p><p><a href="http://en.wikipedia.org/wiki/Bill_Joy" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Bill_Joy</a></p></li><li><p>A Wikipedia article on Bram Moolenaar, the author of vim:</p></li><li><p>Wikipedia 上关于 Bram Moolenaar（vim 作者）的文章：</p><p><a href="http://en.wikipedia.org/wiki/Bram_Moolenaar" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Bram_Moolenaar</a></p></li><li><p>Wikipedia 上关于开头作者提到的Chopsticks钢琴曲的介绍：</p><p><a href="https://en.wikipedia.org/wiki/Chopsticks_(music)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Chopsticks_(music)</a></p></li><li><p>Youku 上视频一段 Chopsticks” (The Celebrated Chop Waltz) on Piano：</p><p><a href="http://v.youku.com/v_show/id_XMzEyOTk4ODkwMA==.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzEyOTk4ODkwMA==.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十二章 shell环境</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-shell%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-shell%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>As we discussed earlier, the shell maintains a body of information during our shell session called the environment. Data stored in the environment is used by programs to determine facts about our configuration. While most programs use configuration files to store program settings, some programs will also look for values stored in the environment to adjust their behavior. Knowing this, we can use the environment to customize our shell experience.</p><p>恰如我们之前所讲的，shell 在 shell 会话中保存着大量信息。这些信息被称为 (shell 的) 环境。 程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储程序设置， 一些程序会根据环境变量来调整他们的行为。知道了这些，我们就可以用环境变量来自定制 shell 体验。</p><p>In this chapter, we will work with the following commands:</p><ul><li>printenv – Print part or all of the environment</li><li>set – Set shell options</li><li>export – Export environment to subsequently executed programs</li><li>alias – Create an alias for a command</li></ul><p>在这一章，我们将用到以下命令：</p><ul><li>printenv - 打印部分或所有的环境变量</li><li>set - 设置 shell 选项</li><li>export — 导出环境变量，让随后执行的程序知道。</li><li>alias - 创建命令别名</li></ul><h3 id="什么存储在环境变量中？"><a href="#什么存储在环境变量中？" class="headerlink" title="什么存储在环境变量中？"></a>什么存储在环境变量中？</h3><p>The shell stores two basic types of data in the environment, though, with bash, the types are largely indistinguishable. They are environment variables and shell variables. Shell variables are bits of data placed there by bash, and environment variables are basically everything else. In addition to variables, the shell also stores some programmatic data, namely aliases and shell functions. We covered aliases in Chapter 6, and shell functions (which are related to shell scripting) will be covered in Part 5.</p><p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。我们 已经在第六章讨论了别名，而 shell 函数（涉及到 shell 脚本）将会在本章第五部分叙述。</p><h3 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h3><p>We can use either the set builtin in bash or the printenv program to see what is stored in the environment. The set command will show both the shell and environment variables, while printenv will only display the latter. Since the list of environment contents will be fairly long, it is best to pipe the output of either command into less:</p><p>我们可以用 bash 的内建命令 set，或者是 printenv 程序来查看环境变量。set 命令可以 显示 shell 或环境变量，而 printenv 只是显示环境变量。因为环境变量列表比较长，最好 把每个命令的输出通过管道传递给 less 来阅读：</p><pre><code>[me@linuxbox ~]$ printenv | less</code></pre><p>Doing so, we should get something that looks like this:</p><p>执行以上命令之后，我们应该能得到类似以下内容：</p><pre><code>KDE_MULTIHEAD=falseSSH_AGENT_PID=6666HOSTNAME=linuxboxGPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1SHELL=/bin/bashTERM=xtermXDG_MENU_PREFIX=kde-HISTSIZE=1000XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705-1177056199GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/share/config/gtkrc-2.0GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/config/gtkrcGS_LIB=/home/me/.fontsWINDOWID=29360136QTDIR=/usr/lib/qt-3.3QTINC=/usr/lib/qt-3.3/includeKDE_FULL_SESSION=trueUSER=meLS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:\*.cmd=00;32:\*.exe:</code></pre><p>What we see is a list of environment variables and their values. For example, we see a variable called USER, which contains the value “me”. The printenv command can also list the value of a specific variable:</p><p>我们所看到的是环境变量及其数值的列表。例如，我们看到一个叫做 USER 的变量，这个变量值是 “me”。printenv 命令也能够列出特定变量的数值：</p><pre><code>[me@linuxbox ~]$ printenv USERme</code></pre><p>The set command, when used without options or arguments, will display both the shell and environment variables, as well as any defined shell functions. Unlike printenv, its output is courteously sorted in alphabetical order:</p><p>当使用没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数 都会被显示。不同于 printenv 命令，set 命令的输出很友好地按照首字母顺序排列：</p><pre><code>[me@linuxbox ~]$ set | less</code></pre><p>It is also possible to view the contents of a variable using the echo command, like this:</p><p>也可以通过 echo 命令来查看一个变量的内容，像这样：</p><pre><code>[me@linuxbox ~]$ echo $HOME/home/me</code></pre><p>One element of the environment that neither set nor printenv displays is aliases. To see them, enter the alias command without arguments:</p><p>别名无法通过使用 set 或 printenv 来查看。 用不带参数的 alias 来查看别名:</p><pre><code>[me@linuxbox ~]$ aliasalias l.=&#39;ls -d .* --color=tty&#39;alias ll=&#39;ls -l --color=tty&#39;alias ls=&#39;ls --color=tty&#39;alias vi=&#39;vim&#39;alias which=&#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#39;</code></pre><h3 id="一些有趣的环境变量"><a href="#一些有趣的环境变量" class="headerlink" title="一些有趣的环境变量"></a>一些有趣的环境变量</h3><p>The environment contains quite a few variables, and though your environment may differ from the one presented here, you will likely see the following variables in your environment:</p><p>shell 环境中包含相当多的变量。虽然你的 shell 环境可能与这里的不同，你可能会看到 以下的环境变量：</p><table><thead><tr><th align="left">Variable</th><th align="left">Contents</th></tr></thead><tbody><tr><td align="left">DISPLAY</td><td align="left">The name of your display if you are running a graphical environment. Usually this is “:0”, meaning the first display generated by the X server.</td></tr><tr><td align="left">EDITOR</td><td align="left">The name of the program to be used for text editing.</td></tr><tr><td align="left">SHELL</td><td align="left">The name of your shell program.</td></tr><tr><td align="left">HOME</td><td align="left">The pathname of your home directory.</td></tr><tr><td align="left">LANG</td><td align="left">Defines the character set and collation order of your language.</td></tr><tr><td align="left">OLD_PWD</td><td align="left">The previous working directory.</td></tr><tr><td align="left">PAGER</td><td align="left">The name of the program to be used for paging output. This is often set to /usr/bin/less.</td></tr><tr><td align="left">PATH</td><td align="left">A colon-separated list of directories that are searched when you enter the name of a executable program.</td></tr><tr><td align="left">PS1</td><td align="left">Prompt String 1. This defines the contents of your shell prompt. As we will later see, this can be extensively customized.</td></tr><tr><td align="left">PWD</td><td align="left">The current working directory.</td></tr><tr><td align="left">TERM</td><td align="left">The name of your terminal type. Unix-like systems support many terminal protocols; this variable sets the protocol to be used with your terminal emulator.</td></tr><tr><td align="left">TZ</td><td align="left">Specifies your timezone. Most Unix-like systems maintain the computer’s internal clock in Coordinated Universal Time (UTC) and then displays the local time by applying an offset specified by this variable.</td></tr><tr><td align="left">USER</td><td align="left">Your user name.</td></tr></tbody></table><table><thead><tr><th align="left">变量</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">DISPLAY</td><td align="left">如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td></tr><tr><td align="left">EDITOR</td><td align="left">文本编辑器的名字。</td></tr><tr><td align="left">SHELL</td><td align="left">shell 程序的名字。</td></tr><tr><td align="left">HOME</td><td align="left">用户家目录。</td></tr><tr><td align="left">LANG</td><td align="left">定义了字符集以及语言编码方式。</td></tr><tr><td align="left">OLD_PWD</td><td align="left">先前的工作目录。</td></tr><tr><td align="left">PAGER</td><td align="left">页输出程序的名字。这经常设置为/usr/bin/less。</td></tr><tr><td align="left">PATH</td><td align="left">由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td></tr><tr><td align="left">PS1</td><td align="left">Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td></tr><tr><td align="left">PWD</td><td align="left">当前工作目录。</td></tr><tr><td align="left">TERM</td><td align="left">终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td></tr><tr><td align="left">TZ</td><td align="left">指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td></tr><tr><td align="left">USER</td><td align="left">你的用户名</td></tr></tbody></table><p>Don’t worry if some of these values are missing. They vary by distribution.</p><p>如果缺失了一些变量，不要担心，这些变量会因发行版本的不同而不同。</p><h3 id="如何建立-shell-环境？"><a href="#如何建立-shell-环境？" class="headerlink" title="如何建立 shell 环境？"></a>如何建立 shell 环境？</h3><p>When we log on to the system, the bash program starts, and reads a series of configuration scripts called startup files, which define the default environment shared by all users. This is followed by more startup files in our home directory that define our personal environment. The exact sequence depends on the type of shell session being started. There are two kinds: a login shell session and a non-login shell session.</p><p>当我们登录系统后， bash 程序启动，并且会读取一系列称为启动文件的配置脚本， 这些文件定义了默认的可供所有用户共享的 shell 环境。然后是读取更多位于我们自己家目录中 的启动文件，这些启动文件定义了用户个人的 shell 环境。确切的启动顺序依赖于要运行的 shell 会话 类型。有两种 shell 会话类型：一个是登录 shell 会话，另一个是非登录 shell 会话。</p><p>A login shell session is one in which we are prompted for our user name and password; when we start a virtual console session, for example. A non-login shell session typically occurs when we launch a terminal session in the GUI.</p><p>登录 shell 会话会在其中提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。 非登录 shell 会话通常当我们在 GUI 下启动终端会话时出现。</p><p>Login shells read one or more startup files as shown in Table 12-2:</p><p>登录 shell 会读取一个或多个启动文件，正如表12－2所示：</p><table><thead><tr><th align="left">File</th><th align="left">Contents</th></tr></thead><tbody><tr><td align="left">/etc/profile</td><td align="left">A global configuration script that applies to all users.</td></tr><tr><td align="left">~/.bash_profile</td><td align="left">A user’s personal startup file. Can be used to extend or override settings in the global configuration script.</td></tr><tr><td align="left">~/.bash_login</td><td align="left">If ~/.bash_profile is not found, bash attempts to read this script.</td></tr><tr><td align="left">~/.profile</td><td align="left">If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu.</td></tr></tbody></table><table><thead><tr><th align="left">文件</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">/etc/profile</td><td align="left">应用于所有用户的全局配置脚本。</td></tr><tr><td align="left">~/.bash_profile</td><td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr><tr><td align="left">~/.bash_login</td><td align="left">如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td></tr><tr><td align="left">~/.profile</td><td align="left">如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td></tr></tbody></table><p>Non-login shell sessions read the following startup files:</p><p>非登录 shell 会话会读取以下启动文件：</p><table><thead><tr><th align="left">File</th><th align="left">Contents</th></tr></thead><tbody><tr><td align="left">/etc/bash.bashrc</td><td align="left">A global configuration script that applies to all users.</td></tr><tr><td align="left">~/.bashrc</td><td align="left">A user’s personal startup file. Can be used to extend or override settings in the global configuration script.</td></tr></tbody></table><table><thead><tr><th align="left">文件</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">/etc/bash.bashrc</td><td align="left">应用于所有用户的全局配置文件。</td></tr><tr><td align="left">~/.bashrc</td><td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td></tr></tbody></table><p>In addition to reading the startup files above, non-login shells also inherit the environment from their parent process, usually a login shell.</p><p>除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。</p><p>Take a look at your system and see which of these startup files you have. Remember— since most of the filenames listed above start with a period (meaning that they are hidden), you will need to use the “-a” option when using ls.</p><p>浏览一下你的系统，看一看系统中有哪些启动文件。记住－因为上面列出的大多数文件名都以圆点开头 （意味着它们是隐藏文件），你需要使用带”-a”选项的 ls 命令。</p><p>The ~/.bashrc file is probably the most important startup file from the ordinary user’s point of view, since it is almost always read. Non-login shells read it by default and most startup files for login shells are written in such a way as to read the ~/.bashrc file as well.</p><p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p><h3 id="一个启动文件的内容"><a href="#一个启动文件的内容" class="headerlink" title="一个启动文件的内容"></a>一个启动文件的内容</h3><p>If we take a look inside a typical .bash_profile (taken from a CentOS 4 system), it looks something like this:</p><p>如果我们看一下典型的 .bash_profile 文件（来自于 CentOS 4 系统），它看起来像这样：</p><pre><code># .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then. ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/binexport PATH</code></pre><p>Lines that begin with a “#” are comments and are not read by the shell. These are there for human readability. The first interesting thing occurs on the fourth line, with the following code:</p><p>以”#”开头的行是注释，shell 不会读取它们。它们在那里是为了方便人们阅读。第一件有趣的事情 发生在第四行，伴随着以下代码：</p><pre><code>if [ -f ~/.bashrc ]; then. ~/.bashrcfi</code></pre><p>This is called an if compound command, which we will cover fully when we get to shell scripting in Part 5, but for now we will translate:</p><p>这叫做一个 if 复合命令，我们将会在第五部分详细地介绍它，现在我们对它翻译一下：</p><pre><code>If the file ~/.bashrc exists, thenread the ~/.bashrc file.</code></pre><p>We can see that this bit of code is how a login shell gets the contents of .bashrc. The next thing in our startup file has to do with the PATH variable.</p><p>我们可以看到这一小段代码就是一个登录 shell 得到 .bashrc 文件内容的方式。在我们启动文件中， 下一件有趣的事与 PATH 变量有关系。</p><p>Ever wonder how the shell knows where to find commands when we enter them on the command line? For example, when we enter ls, the shell does not search the entire computer to find /bin/ls (the full pathname of the ls command), rather, it searches a list of directories that are contained in the PATH variable.</p><p>是否曾经对 shell 怎样知道在哪里找到我们在命令行中输入的命令感到迷惑？例如，当我们输入 ls 后， shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找一个目录列表， 这些目录包含在 PATH 变量中。</p><p>The PATH variable is often (but not always, depending on the distribution) set by the /etc/profile startup file and with this code:</p><p>PATH 变量经常（但不总是，依赖于发行版）在 /etc/profile 启动文件中设置，通过这些代码：</p><pre><code>PATH=$PATH:$HOME/bin</code></pre><p>PATH is modified to add the directory $HOME/bin to the end of the list. This is an example of parameter expansion, which we touched on in Chapter 8. To demonstrate how this works, try the following:</p><p>修改 PATH 变量，添加目录 $HOME/bin 到目录列表的末尾。这是一个参数展开的实例， 参数展开我们在第八章中提到过。为了说明这是怎样工作的，试试下面的例子：</p><pre><code>[me@linuxbox ~]$ foo=&quot;This is some&quot;[me@linuxbox ~]$ echo $fooThis is some[me@linuxbox ~]$ foo=&quot;$foo text.&quot;[me@linuxbox ~]$ echo $fooThis is some text.</code></pre><p>Using this technique, we can append text to the end of a variable’s contents. By adding the string $HOME/bin to the end of the PATH variable’s contents, the directory $HOME/bin is added to the list of directories searched when a command is entered. This means that when we want to create a directory within our home directory for storing our own private programs, the shell is ready to accommodate us. All we have to do is call it bin, and we’re ready to go.</p><p>使用这种技巧，我们可以把文本附加到一个变量值的末尾。通过添加字符串 $HOME/bin 到 PATH 变量值 的末尾，则目录 $HOME/bin 就添加到了命令搜索目录列表中。这意味着当我们想要在自己的家目录下， 创建一个目录来存储我们自己的私人程序时，shell 已经给我们准备好了。我们所要做的事就是 把创建的目录叫做 bin，赶快行动吧。</p><p>Note: Many distributions provide this PATH setting by default. Some Debian based distributions, such as Ubuntu, test for the existence of the ~/bin directory at login, and dynamically add it to the PATH variable if the directory is found.</p><p>注意：很多发行版默认地提供了这个 PATH 设置。一些基于 Debian 的发行版，例如 Ubuntu，在登录 的时候，会检测目录 ~/bin 是否存在，若找到目录则把它动态地加到 PATH 变量中。</p><p>Lastly, we have:</p><p>最后，有下面一行代码：</p><pre><code>export PATH</code></pre><p>The export command tells the shell to make the contents of PATH available to child processes of this shell.</p><p>这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容。</p><h3 id="修改-shell-环境"><a href="#修改-shell-环境" class="headerlink" title="修改 shell 环境"></a>修改 shell 环境</h3><p>Since we know where the startup files are and what they contain, we can modify them to customize our environment.</p><p>既然我们知道了启动文件所在的位置和它们所包含的内容，我们就可以修改它们来定制自己的 shell 环境。</p><h3 id="我们应该修改哪个文件？"><a href="#我们应该修改哪个文件？" class="headerlink" title="我们应该修改哪个文件？"></a>我们应该修改哪个文件？</h3><p>As a general rule, to add directories to your PATH, or define additional environment variables, place those changes in .bash_profile (or equivalent, according to your distribution. For example, Ubuntu uses .profile.) For everything else, place the changes in .bashrc. Unless you are the system administrator and need to change the defaults for all users of the system, restrict your modifications to the files in your home directory. It is certainly possible to change the files in /etc such as profile, and in many cases it would be sensible to do so, but for now, let’s play it safe.</p><p>按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。除非你是系统管理员，需要为系统中的所有用户修改 默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改 /etc 目录中的 文件，比如说 profile 文件，而且在许多情况下，修改这些文件也是明智的，但是现在，我们要谨慎行事。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>To edit (i.e., modify) the shell’s startup files, as well as most of the other configuration files on the system, we use a program called a text editor. A text editor is a program that is, in some ways, like a word processor in that it allows you to edit the words on the screen with a moving cursor. It differs from a word processor by only supporting pure text, and often contains features designed for writing programs. Text editors are the central tool used by software developers to write code, and by system administrators to manage the configuration files that control the system.</p><p>为了编辑（例如，修改）shell 的启动文件以及系统中大多数其它配置文件，我们使用一个叫做文本编辑器的程序。 文本编辑器是一个在某些方面类似于文字处理器的程序，允许你使用移动光标在屏幕上编辑文字。 文本编辑器不同于文字处理器之处在于它只能支持纯文本，并且经常包含为便于写程序而设计的特性。 文本编辑器是软件开发人员用来写代码，以及系统管理员用来管理控制系统的配置文件的重要工具。</p><p>There are a lot of different text editors available for Linux; your system probably has several installed. Why so many different ones? Probably because programmers like writing them, and since programmers use them extensively, they write editors to express their own desires as to how they should work.</p><p>Linux 系统有许多不同类型的文本编辑器可用；你的系统中可能已经安装了几个。为什么会有这么 多种呢？可能因为程序员喜欢编写它们，又因为程序员们会频繁地使用它们，所以程序员编写编辑器让 它们按照程序员自己的愿望工作。</p><p>Text editors fall into two basic categories: graphical and text based. GNOME and KDE both include some popular graphical editors. GNOME ships with an editor called gedit, which is usually called “Text Editor” in the GNOME menu. KDE usually ships with three which are (in order of increasing complexity) kedit, kwrite, and kate.</p><p>文本编辑器分为两种基本类型：图形化的和基于文本的编辑器。GNOME 和 KDE 两者都包含一些流行的 图形化编辑器。GNOME 自带了一个叫做 gedit 的编辑器，这个编辑器通常在 GNOME 菜单中称为”文本编辑器”。 KDE 通常自带了三种编辑器，分别是（按照复杂度递增的顺序排列）kedit，kwrite，kate。</p><p>There are many text-based editors. The popular ones you will encounter are nano, vi, and emacs. The nano editor is a simple, easy-to-use editor designed as a replacement for the pico editor supplied with the PINE email suite. The vi editor (on most Linux systems replaced by a program named vim, which is short for “Vi IMproved”) is the traditional editor for Unix-like systems. It will be the subject of our next chapter. The emacs editor was originally written by Richard Stallman. It is a gigantic, all-purpose, does-everything programming environment. While readily available, it is seldom installed on most Linux systems by default.</p><p>有许多基于文本的编辑器。你将会遇到一些流行的编辑器，它们是 nano、vi和 emacs。 nano 编辑器 是一个简单易用的编辑器，用于替代随 PINE 邮件套件提供的 pico 编辑器。vi 编辑器 （在大多数 Linux 系统中被 vim 替代，vim 是 “Vi IMproved”的简写）是类 Unix 操作系统的传统编辑器。 vim 是我们下一章节的讨论对象。emacs 编辑器最初由 Richard Stallman 写成。它是一个庞大、多用途的， 可做任何事情的编程环境。虽然 emacs 很容易获取，但是大多数 Linux 系统很少默认安装它。</p><h3 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h3><p>All text editors can be invoked from the command line by typing the name of the editor followed by the name of the file you want to edit. If the file does not already exist, the editor will assume that you want to create a new file. Here is an example using gedit:</p><p>所有的文本编辑器都可以通过在命令行中输入编辑器的名字，加上你所想要编辑的文件来唤醒。如果所 输入的文件名不存在，编辑器则会假定你想要创建一个新文件。下面是一个使用 gedit 的例子：</p><pre><code>[me@linuxbox ~]$ gedit some_file</code></pre><p>This command will start the gedit text editor and load the file named “some_file”, if it exists.</p><p>这条命令将会启动 gedit 文本编辑器，同时加载名为 “some_file” 的文件，如果这个文件存在的话。</p><p>All graphical text editors are pretty self-explanatory, so we won’t cover them here. Instead, we will concentrate on our first text-based text editor, nano. Let’s fire up nano and edit the .bashrc file. But before we do that, let’s practice some “safe computing.” Whenever we edit an important configuration file, it is always a good idea to create a backup copy of the file first. This protects us in case we mess the file up while editing. To create a backup of the .bashrc file, do this:</p><p>所有的图形文本编辑器很大程度上都是不需要解释的，所以我们在这里不会介绍它们。反之，我们将集中精力在 我们第一个基于文本的文本编辑器，nano。让我们启动 nano，并且编辑文件 .bashrc。但是在我们这样 做之前，先练习一些”安全计算”。当我们编辑一个重要的配置文件时，首先创建一个这个文件的备份 总是一个不错的主意。这样能避免我们在编辑文件时弄乱文件。创建文件 .bashrc 的备份文件，这样做：</p><pre><code>[me@linuxbox ~]$ cp .bashrc .bashrc.bak</code></pre><p>It doesn’t matter what you call the backup file, just pick an understandable name. The extensions “.bak”, “.sav”, “.old”, and “.orig” are all popular ways of indicating a backup file. Oh, and remember that cp will overwrite existing files silently.</p><p>备份文件的名字无关紧要，只要选择一个容易理解的文件名。扩展名 “.bak”、”.sav”、 “.old”和 “.orig” 都是用来指示备份文件的流行方法。哦，记住 cp 命令会默默地覆盖已经存在的同名文件。</p><p>Now that we have a backup file, we’ll start the editor:</p><p>现在我们有了一个备份文件，我们启动 nano 编辑器吧：</p><pre><code>[me@linuxbox ~]$ nano .bashrc</code></pre><p>Once nano starts, we’ll get a screen like this:</p><p>一旦 nano 编辑器启动后，我们将会得到一个像下面一样的屏幕：</p><pre><code>GNU nano 2.0.3....</code></pre><p>Note: If your system does not have nano installed, you may use a graphical editor instead.</p><p>注意：如果你的系统中没有安装 nano 编辑器，你可以用一个图形化的编辑器代替。</p><p>The screen consists of a header at the top, the text of the file being edited in the middle and a menu of commands at the bottom. Since nano was designed to replace the text editor supplied with an email client, it is rather short on editing features. The first command you should learn in any text editor is how to exit the program. In the case of nano, you type Ctrl-x to exit. This is indicated in the menu at the bottom of the screen. The notation “^X” means Ctrl-x. This is a common notation for control characters used by many programs.</p><p>这个屏幕由上面的标头，中间正在编辑的文件文本和下面的命令菜单组成。因为设计 nano 是为了 代替由电子邮件客户端提供的编辑器的，所以它相当缺乏编辑特性。在任一款编辑器中，你应该 学习的第一个命令是怎样退出程序。以 nano 为例，你输入 Ctrl-x 来退出 nano。在屏幕底层的菜单中 说明了这个命令。”^X” 表示法意思是 Ctrl-x。这是控制字符的常见表示法，许多程序都使用它。</p><p>The second command we need to know is how to save our work. With nano it’s Ctrl- o. With this knowledge under our belts, we’re ready to do some editing. Using the down arrow key and / or the PageDown key, move the cursor to the end of the file, then add the following lines to the .bashrc file:</p><p>第二个我们需要知道的命令是怎样保存我们的劳动成果。对于 nano 来说是 Ctrl-o。既然我们 已经获得了这些知识，接下来我们准备做些编辑工作。使用下箭头按键和 / 或下翻页按键，移动 鼠标到文件的最后一行，然后添加以下几行到文件 .bashrc 中：</p><pre><code>umask 0002export HISTCONTROL=ignoredupsexport HISTSIZE=1000alias l.=&#39;ls -d .* --color=auto&#39;alias ll=&#39;ls -l --color=auto&#39;</code></pre><p>Note: Your distribution may already include some of these, but duplicates won’t hurt anything.</p><p>注意：你的发行版在这之前可能已经包含其中的一些行，出现重复的代码不会有其他影响。</p><p>Here is the meaning of our additions:</p><p>下表是所添加行的意义：</p><table><thead><tr><th align="left">Line</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">umask 0002</td><td align="left">Sets the umask to solve the problem with shared directories</td></tr><tr><td align="left">export HISTCONTROL=ignoredups</td><td align="left">Causes the shell’s history recording feature to ignore a command if the same command was just recorded.</td></tr><tr><td align="left">export HISTSIZE=1000</td><td align="left">Increases the size of the command history from the default of 500 lines to 1000 lines.</td></tr><tr><td align="left">alias l.=’ls -d .* –color=auto’</td><td align="left">Creates a new command called “l.” which displays all directory entries that begin with a dot.</td></tr><tr><td align="left">alias ll=’ls -l –color=auto’</td><td align="left">Creates a new command called “ll” which displays a long format directory listing.</td></tr></tbody></table><table><thead><tr><th align="left">文本行</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">umask 0002</td><td align="left">设置掩码来解决共享目录的问题。</td></tr><tr><td align="left">export HISTCONTROL=ignoredups</td><td align="left">使得 shell 的历史记录功能忽略一个命令，如果相同的命令已被记录。</td></tr><tr><td align="left">export HISTSIZE=1000</td><td align="left">增加命令历史的大小，从默认的 500 行扩大到 1000 行。</td></tr><tr><td align="left">alias l.=’ls -d .* –color=auto’</td><td align="left">创建一个新命令，叫做’l.’，这个命令会显示所有以点开头的目录项。</td></tr><tr><td align="left">alias ll=’ls -l –color=auto’</td><td align="left">创建一个叫做’ll’的命令，这个命令会显示长格式目录列表。</td></tr></tbody></table><p>As we can see, many of our additions are not intuitively obvious, so it would be a good idea to add some comments to our .bashrc file to help explain things to the humans. Using the editor, change our additions to look like this:</p><p>正如我们所看到的，我们添加的许多代码的意思直觉上并不是明显的，所以添加注释到我们的文件 .bashrc 中是 一个好主意，可以帮助人们理解。使用编辑器，更改我们添加的代码，让它们看起来像这样：</p><pre><code># Change umask to make directory sharing easierumask 0002 # Ignore duplicates in command history and increase # history size to 1000 linesexport HISTCONTROL=ignoredupsexport HISTSIZE=1000 # Add some helpful aliasesalias l.=&#39;ls -d .* --color=auto&#39;alias ll=&#39;ls -l --color=auto&#39;</code></pre><p>Ah, much better! With our changes complete, type Ctrl-o to save our modified .bashrc file, and Ctrl-x to exit nano.</p><p>啊，看起来好多了! 当我们完成修改后，输入 Ctrl-o 来保存我们修改的 .bashrc 文件，输入 Ctrl-x 退出 nano。</p><blockquote><p>Why Comments Are Important</p><p><em>为什么注释很重要？</em></p><p>Whenever you modify configuration files it’s a good idea to add some comments to document your changes. Sure, you will remember what you changed tomorrow, but what about six months from now? Do yourself a favor and add some comments. While you’re at it, it’s not a bad idea to keep a log of what changes you make.</p><p>不管什么时候你修改配置文件时，给你所做的更改加上注释都是一个好主意。的确，明天你会 记得你修改了的内容，但是六个月之后会怎样呢？帮自己一个忙，加上一些注释吧。当你意识 到这一点后，对你所做的修改做个日志是个不错的主意。</p><p>Shell scripts and bash startup files use a “#” symbol to begin a comment. Other configuration files may use other symbols. Most configuration files will have comments. Use them as a guide.</p><p>Shell 脚本和 bash 启动文件都使用 “#” 符号来开始注释。其它配置文件可能使用其它的符号。 大多数配置文件都有注释。把它们作为指南。</p><p>You will often see lines in configuration files that are commented out to prevent them from being used by the affected program. This is done to give the reader suggestions for possible configuration choices or examples of correct configuration syntax. For example, the .bashrc file of Ubuntu 8.04 contains these lines:</p><p>你会经常看到配置文件中的一些行被注释掉，以此防止它们被受影响的程序使用。这样做 是为了给读者在可能的配置选项方面一些建议，或者给出正确的配置语法实例。例如，Ubuntu 8.04 中的 .bashrc 文件包含这些行：</p><pre><code># some more ls aliases#alias ll=&#39;ls -l&#39;#alias la=&#39;ls -A&#39;#alias l=&#39;ls -CF&#39;</code></pre><p>The last three lines are valid alias definitions that have been commented out. If you remove the leading “#” symbols from these three lines, a technique called uncommenting, you will activate the aliases. Conversely, if you add a “#” symbol to the beginning of a line, you can deactivate a configuration line while preserving the information it contains.</p><p>最后三行是有效的被注释掉的别名定义。如果你删除这三行开头的 “#” 符号，此技术程称为 uncommenting (取消注释)，这样你就会激活这些别名。相反地，如果你在一行的开头加上 “#” 符号， 你可以注销掉这一行，但会保留它所包含的信息。</p></blockquote><h3 id="激活我们的修改"><a href="#激活我们的修改" class="headerlink" title="激活我们的修改"></a>激活我们的修改</h3><p>The changes we have made to our .bashrc will not take affect until we close our terminal session and start a new one, since the .bashrc file is only read at the beginning of a session. However, we can force bash to re-read the modified .bashrc file with the following command:</p><p>我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：</p><pre><code>[me@linuxbox ~]$ source .bashrc</code></pre><p>After doing this, we should be able to see the effect of our changes. Try out one of the new aliases:</p><p>运行上面命令之后，我们就应该能够看到所做修改的效果了。试试其中一个新的别名：</p><pre><code>[me@linuxbox ~]$ ll</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>In this chapter we learned an essential skill—editing configuration files with a text editor. Moving forward, as we read man pages for commands, take note of the environment variables that commands support. There may be a gem or two. In later chapters, we will learn about shell functions, a powerful feature that you can also include in the bash startup files to add to your arsenal of custom commands.</p><p>在这一章中，我们学到了用文本编辑器来编辑配置文件的基本技巧。随着学习的继续，当我们 浏览命令的手册页时，可以记录下该命令所支持的环境变量。这样或许我们能够收获一到两个特别好用的宝贝命令。 在随后的章节里面，我们将会学习 shell 函数，一个很强大的特性，你可以把它包含在 bash 启动文件里面， 以此来添加你自定制的命令宝库。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>The INVOCATION section of the bash man page covers the bash startup files in gory detail.</p><p>bash 手册页的 INVOCATION 部分非常详细地讨论了 bash 启动文件。</p>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git-简易指南</title>
      <link href="/2019/07/15/git-%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
      <url>/2019/07/15/git-%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>助你开始使用 git 的简易指南，木有高深内容，;)。</p><p><img src="https://www.bootcss.com/p/git-guide/img/arrow.png" alt="img"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://code.google.com/p/git-osx-installer/downloads/list?can=3" target="_blank" rel="noopener">下载 git OSX 版</a></p><p><a href="http://code.google.com/p/msysgit/downloads/list?can=3" target="_blank" rel="noopener">下载 git Windows 版</a></p><p><a href="http://book.git-scm.com/2_installing_git.html" target="_blank" rel="noopener">下载 git Linux 版</a></p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行<br><code>git init</code><br>以创建新的 git 仓库。</p><h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>执行如下命令以创建一个本地仓库的克隆版本：<br><code>git clone /path/to/repository</code><br>如果是远端服务器上的仓库，你的命令会是这个样子：<br><code>git clone username@host:/path/to/repository</code></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p><p><img src="https://www.bootcss.com/p/git-guide/img/trees.png" alt="img"></p><h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><p>你可以计划改动（把它们添加到缓存区），使用如下命令：<br><code>git add &lt;filename&gt;</code><br><code>git add *</code><br>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：<br><code>git commit -m &quot;代码提交信息&quot;</code><br>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。执行如下命令以将这些改动提交到远端仓库：<br><code>git push origin master</code><br>可以把 <em>master</em> 换成你想要推送的任何分支。 </p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><code>git remote add origin &lt;server&gt;</code><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><img src="https://www.bootcss.com/p/git-guide/img/branches.png" alt="img"></p><p>创建一个叫做“feature_x”的分支，并切换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉：<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是 <em>不为他人所见的</em>：<br><code>git push origin &lt;branch&gt;</code></p><h2 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h2><p>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><code>git merge &lt;branch&gt;</code><br>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <em>冲突（conflicts）*。 这时候就需要你修改这些文件来人肉合并这些 *冲突（conflicts）</em> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：<br><code>git add &lt;filename&gt;</code><br>在合并改动之前，也可以使用如下命令查看：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 <em>1.0.0</em> 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：<br><code>git log</code><br>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p><p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p><h2 id="有用的贴士"><a href="#有用的贴士" class="headerlink" title="有用的贴士"></a>有用的贴士</h2><p>内建的图形化 git：<br><code>gitk</code><br>彩色的 git 输出：<br><code>git config color.ui true</code><br>显示历史记录时，只显示一行注释信息：<br><code>git config format.pretty oneline</code><br>交互地添加文件至缓存区：<br><code>git add -i</code></p><h2 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h2><h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><ul><li><a href="http://gitx.laullon.com/" target="_blank" rel="noopener">GitX (L) (OSX, open source)</a></li><li><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower (OSX)</a></li><li><a href="http://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree (OSX, free)</a></li><li><a href="http://mac.github.com/" target="_blank" rel="noopener">GitHub for Mac (OSX, free)</a></li><li><a href="https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12" target="_blank" rel="noopener">GitBox (OSX)</a></li></ul><h3 id="指南与手册"><a href="#指南与手册" class="headerlink" title="指南与手册"></a>指南与手册</h3><ul><li><a href="http://book.git-scm.com/" target="_blank" rel="noopener">Git 社区参考书</a></li><li><a href="http://progit.org/book/" target="_blank" rel="noopener">专业 Git</a></li><li><a href="http://think-like-a-git.net/" target="_blank" rel="noopener">如 git 思考</a></li><li><a href="http://help.github.com/" target="_blank" rel="noopener">GitHub 帮助</a></li><li><a href="http://marklodato.github.com/visual-git-guide/index-en.html" target="_blank" rel="noopener">图形化的 Git 指南一则</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录C:Git命令</title>
      <link href="/2019/07/15/%E9%99%84%E5%BD%95C-Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/15/%E9%99%84%E5%BD%95C-Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="设置与配置"><a href="#设置与配置" class="headerlink" title="设置与配置"></a>设置与配置</h2><p>有两个命令使用得最多了，从第一次调用 Git 到每天的日常微调及参考，这个两个命令就是： <code>config</code> 和<code>help</code> 命令。</p><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>Git 做的很多工作都有一个默认方式。 对于绝大多数工作而言，你可以改变 Git 的默认方式，或者根据你的偏好来设置。 这些设置涵盖了所有的事，从告诉 Git 你的名字，到指定偏好的终端颜色，以及你使用的编辑器。 此命令会从几个特定的配置文件中读取和写入配置值，以便你可以从全局或者针对特定的仓库来进行设置。</p><p>本书的所有章节几乎都有用到 <code>git config</code> 命令。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_first_time" target="_blank" rel="noopener">初次运行 Git 前的配置</a> 一节中，在开始使用 Git 之前，我们用它来指定我们的名字，邮箱地址和编辑器偏好。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_aliases" target="_blank" rel="noopener">Git 别名</a> 一节中我们展示了如何创建可以展开为长选项序列的短命令，以便你不用每次都输入它们。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebasing" target="_blank" rel="noopener">变基</a> 一节中，执行 <code>git pull</code> 命令时，使用此命令来将 <code>--rebase</code> 作为默认选项。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching" target="_blank" rel="noopener">凭证存储</a> 一节中，我们使用它来为你的 HTTP 密码设置一个默认的存储区域。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_keyword_expansion" target="_blank" rel="noopener">关键字展开</a> 一节中我们展示了如何设置在 Git 的内容添加和减少时使用的 smudge 过滤器 和 clean 过滤器。</p><p>最后，基本上 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_config" target="_blank" rel="noopener">配置 Git</a> 整个章节都是针对此命令的。</p><h3 id="git-help"><a href="#git-help" class="headerlink" title="git help"></a>git help</h3><p><code>git help</code> 命令用来显示任何命令的 Git 自带文档。 但是我们仅会在此附录中提到大部分最常用的命令，对于每一个命令的完整的可选项及标志列表，你可以随时运行 <code>git help &lt;command&gt;</code> 命令来了解。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_help" target="_blank" rel="noopener">获取帮助</a> 一节中介绍了 <code>git help</code> 命令，同时在 <a href="https://git-scm.com/book/zh/v2/ch00/r_setting_up_server" target="_blank" rel="noopener">配置服务器</a> 一节中给你展示了如何使用它来查找更多关于 <code>git shell</code> 的信息。</p><h2 id="获取与创建项目"><a href="#获取与创建项目" class="headerlink" title="获取与创建项目"></a>获取与创建项目</h2><p>有几种方式获取一个 Git 仓库。 一种是从网络上或者其他地方拷贝一个现有的仓库，另一种就是在一个目录中创建一个新的仓库。</p><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>你只需要简单地运行 <code>git init</code> 就可以将一个目录转变成一个 Git 仓库，这样你就可以开始对它进行版本管理了。</p><p>我们一开始在 <a href="https://git-scm.com/book/zh/v2/ch00/r_getting_a_repo" target="_blank" rel="noopener">获取 Git 仓库</a> 一节中介绍了如何创建一个新的仓库来开始工作。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_remote_branches" target="_blank" rel="noopener">远程分支</a> 一节中我们简单的讨论了如何改变默认分支。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_bare_repo" target="_blank" rel="noopener">把裸仓库放到服务器上</a> 一节中我们使用此命令来为一个服务器创建一个空的祼仓库。</p><p>最后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_plumbing_porcelain" target="_blank" rel="noopener">底层命令和高层命令</a> 一节中介绍了此命令背后工作的原理的一些细节。</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone</code> 实际上是一个封装了其他几个命令的命令。 它创建了一个新目录，切换到新的目录，然后 <code>git init</code> 来初始化一个空的 Git 仓库， 然后为你指定的 URL 添加一个（默认名称为 <code>origin</code> 的）远程仓库（<code>git remote add</code>），再针对远程仓库执行 <code>git fetch</code>，最后通过 <code>git checkout</code> 将远程仓库的最新提交检出到本地的工作目录。</p><p><code>git clone</code> 命令在本书中多次用到，这里只列举几个有意思的地方。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_cloning" target="_blank" rel="noopener">克隆现有的仓库</a> 一节中我们通过几个示例详细介绍了此命令。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server" target="_blank" rel="noopener">在服务器上搭建 Git</a> 一节中，我们使用了 <code>--bare</code> 选项来创建一个没有任何工作目录的 Git 仓库副本。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_bundling" target="_blank" rel="noopener">打包</a> 一节中我们使用它来解包一个打包好的 Git 仓库。</p><p>最后，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_cloning_submodules" target="_blank" rel="noopener">克隆含有子模块的项目</a> 一节中我们学习了使用 <code>--recursive</code> 选项来让克隆一个带有子模块的仓库变得简单。</p><p>虽然在本书的其他地方都有用到此命令，但是上面这些用法是特例，或者使用方式有点特别。</p><h2 id="快照基础"><a href="#快照基础" class="headerlink" title="快照基础"></a>快照基础</h2><p>对于基本的暂存内容及提交到你的历史记录中的工作流，只有少数基本的命令。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add</code> 命令将内容从工作目录添加到暂存区（或称为索引（index）区），以备下次提交。 当 <code>git commit</code> 命令执行时，默认情况下它只会检查暂存区域，因此 <code>git add</code> 是用来确定下一次提交时快照的样子的。</p><p>这个命令对于 Git 来说特别的重要，所以在本书中被无数次的提及和使用。 我们将快速的过一遍一些可以看到的独特的用法。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tracking_files" target="_blank" rel="noopener">跟踪新文件</a> 一节中介绍并详细解释了 <code>git add</code> 命令。</p><p>然后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_merge_conflicts" target="_blank" rel="noopener">遇到冲突时的分支合并</a> 一节中提到了如何使用它来解决合并冲突。</p><p>接下来，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_interactive_staging" target="_blank" rel="noopener">交互式暂存</a> 一章中使用它来交互式的暂存一个已修改文件的特定部分。</p><p>最后，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tree_objects" target="_blank" rel="noopener">树对象</a> 一节中我们在一个低层次中模拟了它的用法，以便你可以了解在这背后发生了什么。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 命令将为你展示工作区及暂存区域中不同状态的文件。 这其中包含了已修改但未暂存，或已经暂存但没有提交的文件。 一般在它显示形式中，会给你展示一些关于如何在这些暂存区域之间移动文件的提示。</p><p>首先，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_checking_status" target="_blank" rel="noopener">检查当前文件状态</a> 一节中介绍了 <code>status</code> 的基本及简单的形式。 虽然我们在全书中都有用到它，但是绝大部分的你能用 <code>git status</code> 做的事情都在这一章讲到了。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>当需要查看任意两棵树的差异时你可以使用 <code>git diff</code> 命令。 此命令可以查看你工作环境与你的暂存区的差异（<code>git diff</code> 默认的做法），你暂存区域与你最后提交之间的差异（<code>git diff --staged</code>），或者比较两个提交记录的差异（<code>git diff master branchB</code>）。</p><p>首先，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_diff_staged" target="_blank" rel="noopener">查看已暂存和未暂存的修改</a> 一章中研究了 <code>git diff</code> 的基本用法，在此节中我们展示了如何查看哪些变化已经暂存了，哪些没有。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_guidelines" target="_blank" rel="noopener">提交准则</a> 一节中,我们在提交前使用 <code>--check</code> 选项来检查可能存在的空白字符问题。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_what_is_introduced" target="_blank" rel="noopener">确定引入了哪些东西</a> 一节中,了解了使用 <code>git diff A...B</code> 语法来更有效地比较不同分支之间的差异。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_advanced_merging" target="_blank" rel="noopener">高级合并</a> 一节中我们使用 <code>-b</code> 选项来过滤掉空白字符的差异，及通过 <code>--theirs</code>、<code>--ours</code> 和 <code>--base</code>选项来比较不同暂存区冲突文件的差异。</p><p>最后，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_starting_submodules" target="_blank" rel="noopener">开始使用子模块</a> 一节中,我们使用此命令合 <code>--submodule</code> 选项来有效地比较子模块的变化。</p><h3 id="git-difftool"><a href="#git-difftool" class="headerlink" title="git difftool"></a>git difftool</h3><p>当你不想使用内置的 <code>git diff</code> 命令时。<code>git difftool</code> 可以用来简单地启动一个外部工具来为你展示两棵树之间的差异。</p><p>我们只在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_diff_staged" target="_blank" rel="noopener">查看已暂存和未暂存的修改</a> 一节中简单的提到了此命令。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit</code> 命令将所有通过 <code>git add</code> 暂存的文件内容在数据库中创建一个持久的快照，然后将当前分支上的分支指针移到其之上。</p><p>首先，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_committing_changes" target="_blank" rel="noopener">提交更新</a> 一节中涉及了此命令的基本用法。 我们演示了如何在日常的工作流程中通过使用 <code>-a</code> 标志来跳过 <code>git add</code> 这一步，及如何使用 <code>-m</code> 标志通过命令行而不启动一个编辑器来传递提交信息。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_undoing" target="_blank" rel="noopener">撤消操作</a> 一节中我们介绍了使用 <code>--amend</code> 选项来重做最后的提交。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_branches_overview" target="_blank" rel="noopener">分支简介</a>，我们探讨了 <code>git commit</code> 的更多细节，及工作原理。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing_commits" target="_blank" rel="noopener">签署提交</a> 一节中我们探讨了如何使用 <code>-S</code> 标志来为提交签名加密。</p><p>最后，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_commit_objects" target="_blank" rel="noopener">提交对象</a> 一节中，我们了解了 <code>git commit</code> 在背后做了什么，及它是如何实现的。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 命令主要用来根据你传递给动作的参数来执行撤销操作。 它可以移动 <code>HEAD</code> 指针并且可选的改变 <code>index</code> 或者暂存区，如果你使用 <code>--hard</code> 参数的话你甚至可以改变工作区。 如果错误地为这个命令附加后面的参数，你可能会丢失你的工作，所以在使用前你要确定你已经完全理解了它。</p><p>首先，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_unstaging" target="_blank" rel="noopener">取消暂存的文件</a> 一节中介绍了 <code>git reset</code> 简单高效的用法，用来对执行过 <code>git add</code> 命令的文件取消暂存。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset" target="_blank" rel="noopener">重置揭密</a> 一节中我们详细介绍了此命令，几乎整节都在解释此命令。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_abort_merge" target="_blank" rel="noopener">中断一次合并</a> 一节中，我们使用 <code>git reset --hard</code> 来取消一个合并，同时我们也使用了 <code>git merge --abort</code> 命令，它是 <code>git reset</code> 的一个简单的封装。</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p><code>git rm</code> 是 Git 用来从工作区，或者暂存区移除文件的命令。 在为下一次提交暂存一个移除操作上，它与 <code>git add</code> 有一点类似。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_removing_files" target="_blank" rel="noopener">移除文件</a> 一节中提到了 <code>git rm</code> 的一些细节，包括递归地移除文件，和使用 <code>--cached</code> 选项来只移除暂存区域的文件但是保留工作区的文件。</p><p>在本书的 <a href="https://git-scm.com/book/zh/v2/ch00/r_removing_objects" target="_blank" rel="noopener">移除对象</a> 一节中，介绍了 <code>git rm</code> 仅有的几种不同用法，如在执行 <code>git filter-branch</code> 中使用和解释了 <code>--ignore-unmatch</code> 选项。 这对脚本来说很有用。</p><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p><code>git mv</code> 命令是一个便利命令，用于移到一个文件并且在新文件上执行<code>git add</code>命令及在老文件上执行<code>git rm</code>命令。</p><p>我们只是在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_mv" target="_blank" rel="noopener">移动文件</a> 一节中简单地提到了此命令。</p><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p><code>git clean</code> 是一个用来从工作区中移除不想要的文件的命令。 可以是编译的临时文件或者合并冲突的文件。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_clean" target="_blank" rel="noopener">清理工作目录</a> 一节中我们介绍了你可能会使用 <code>clean</code> 命令的大量选项及场景。</p><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><p>Git 有几个实现大部的分支及合并功能的实用命令。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git branch</code> 命令实际上是某种程度上的分支管理工具。 它可以列出你所有的分支、创建新分支、删除分支及重命名分支。</p><p><a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 一节主要是为 <code>branch</code> 命令来设计的，它贯穿了整个章节。 首先，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_create_new_branch" target="_blank" rel="noopener">分支创建</a> 一节中介绍了它，然后我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_branch_management" target="_blank" rel="noopener">分支管理</a> 一节中介绍了它的其它大部分特性（列举及删除）。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tracking_branches" target="_blank" rel="noopener">跟踪分支</a> 一节中，我们使用 <code>git branch -u</code> 选项来设置一个跟踪分支。</p><p>最后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_refs" target="_blank" rel="noopener">Git 引用</a> 一节中讲到了它在背后做一什么。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><code>git checkout</code> 命令用来切换分支，或者检出内容到工作目录。</p><p>我们是在 <a href="https://git-scm.com/book/zh/v2/ch00/r_switching_branches" target="_blank" rel="noopener">分支切换</a> 一节中第一次认识了命令及 <code>git branch</code> 命令。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tracking_branches" target="_blank" rel="noopener">跟踪分支</a> 一节中我们了解了如何使用 <code>--track</code> 标志来开始跟踪分支。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_checking_out_conflicts" target="_blank" rel="noopener">检出冲突</a> 一节中，我们用此命令和 <code>--conflict=diff3</code> 来重新介绍文件冲突。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset" target="_blank" rel="noopener">重置揭密</a> 一节中，我们进一步了解了其细节及与 <code>git reset</code> 的关系。</p><p>最后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_the_head" target="_blank" rel="noopener">HEAD 引用</a> 一节中介绍了此命令的一些实现细节。</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><code>git merge</code> 工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。</p><p>我们首先在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_branching" target="_blank" rel="noopener">新建分支</a> 一节中介绍了 <code>git merge</code> 命令。 虽然它在本书的各种地方都有用到，但是 <code>merge</code>命令只有几个变种，一般只是 <code>git merge &lt;branch&gt;</code> 带上一个你想合并进来的一个分支名称。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_public_project" target="_blank" rel="noopener">派生的公开项目</a> 的后面介绍了如何做一个 <code>squashed merge</code> （指 Git 合并时将其当作一个新的提交而不是记录你合并时的分支的历史记录。）</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_advanced_merging" target="_blank" rel="noopener">高级合并</a> 一节中，我们介绍了合并的过程及命令，包含 <code>-Xignore-space-change</code> 命令及 <code>--abort</code>选项来中止一个有问题的提交。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing_commits" target="_blank" rel="noopener">签署提交</a> 一节中我们学习了如何在合并前验证签名，如果你项目正在使用 GPG 签名的话。</p><p>最后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_subtree_merge" target="_blank" rel="noopener">子树合并</a> 一节中学习了子树合并。</p><h3 id="git-mergetool"><a href="#git-mergetool" class="headerlink" title="git mergetool"></a>git mergetool</h3><p>当你在 Git 的合并中遇到问题时，可以使用 <code>git mergetool</code> 来启动一个外部的合并帮助工具。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_merge_conflicts" target="_blank" rel="noopener">遇到冲突时的分支合并</a> 中快速介绍了一下它，然后在 <a href="https://git-scm.com/book/zh/v2/ch00/r_external_merge_tools" target="_blank" rel="noopener">外部的合并与比较工具</a> 一节中介绍了如何实现你自己的外部合并工具的细节。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log</code> 命令用来展示一个项目的可达历史记录，从最近的提交快照起。 默认情况下，它只显示你当前所在分支的历史记录，但是可以显示不同的甚至多个头记录或分支以供遍历。 此命令通常也用来在提交记录级别显示两个或多个分支之间的差异。</p><p>在本书的每一章几乎都有用到此命令来描述一个项目的历史。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_viewing_history" target="_blank" rel="noopener">查看提交历史</a> 一节中我们介绍了此命令，并深入做了研究。 研究了包括 <code>-p</code> 和 <code>--stat</code> 选项来了解每一个提交引入的变更，及使用<code>--pretty</code> 和 <code>--online</code> 选项来查看简洁的历史记录。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_create_new_branch" target="_blank" rel="noopener">分支创建</a> 一节中我们使用它加 <code>--decorate</code> 选项来简单的可视化我们分支的指针所在，同时我们使用 <code>--graph</code> 选项来查看分叉的历史记录是怎么样的。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_private_team" target="_blank" rel="noopener">私有小型团队</a> 和 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_ranges" target="_blank" rel="noopener">提交区间</a> 章节中，我们介绍了在使用 <code>git log</code> 命令时用 <code>branchA..branchB</code> 的语法来查看一个分支相对于另一个分支, 哪一些提交是唯一的。 在 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_ranges" target="_blank" rel="noopener">提交区间</a> 一节中我们作了更多介绍。</p><p>在 &lt;_merge_log&gt;&gt; 和 <a href="https://git-scm.com/book/zh/v2/ch00/r_triple_dot" target="_blank" rel="noopener">三点</a> 章节中，我们介绍了 <code>branchA...branchB</code> 格式和 <code>--left-right</code> 语法来查看哪些仅其中一个分支。 在 <a href="https://git-scm.com/book/zh/v2/ch00/r_merge_log" target="_blank" rel="noopener">合并日志</a> 一节中我们还研究了如何使用 <code>--merge</code> 选项来帮助合并冲突调试，同样也使用 <code>--cc</code> 选项来查看在你历史记录中的合并提交的冲突。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reflog" target="_blank" rel="noopener">引用日志</a> 一节中我们使用此工具和 <code>-g</code> 选项 而不是遍历分支来查看 Git 的 <code>reflog</code>。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_searching" target="_blank" rel="noopener">搜索</a> 一节中我们研究了<code>-S</code> 及 <code>-L</code> 选项来进行来在代码的历史变更中进行相当优雅地搜索，如一个函数的历史。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing_commits" target="_blank" rel="noopener">签署提交</a> 一节中，我们了解了如何使用 <code>--show-signature</code> 来为每一个提交的 <code>git log</code> 输出中，添加一个判断是否已经合法的签名的一个验证。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code> 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。</p><p><a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing" target="_blank" rel="noopener">储藏与清理</a> 一整个章节基本就是在讲这个命令。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p><code>git tag</code> 命令用来为代码历史记录中的某一个点指定一个永久的书签。 一般来说它用于发布相关事项。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_tagging" target="_blank" rel="noopener">打标签</a> 一节中介绍了此命令及相关细节，并在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tagging_releases" target="_blank" rel="noopener">为发布打标签</a> 一节实践了此命令。</p><p>我也在 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing" target="_blank" rel="noopener">签署工作</a> 一节中介绍了如何使用 <code>-s</code> 标志创建一个 GPG 签名的标签，然后使用 <code>-v</code> 选项来验证。</p><h2 id="项目分享与更新"><a href="#项目分享与更新" class="headerlink" title="项目分享与更新"></a>项目分享与更新</h2><p>在 Git 中没有多少访问网络的命令，几乎所以的命令都是在操作本地的数据库。 当你想要分享你的工作，或者从其他地方拉取变更时，这有几个处理远程仓库的命令。</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><code>git fetch</code> 命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中。</p><p>我们开始在 <a href="https://git-scm.com/book/zh/v2/ch00/r_fetching_and_pulling" target="_blank" rel="noopener">从远程仓库中抓取与拉取</a> 一节中介绍了此命令，然后我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_remote_branches" target="_blank" rel="noopener">远程分支</a> 中看到了几个使用示例。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_contributing_project" target="_blank" rel="noopener">向一个项目贡献</a> 一节中有几个示例中也都有使用此命令。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_refs" target="_blank" rel="noopener">合并请求引用</a> 我们用它来抓取一个在默认空间之外指定的引用，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_bundling" target="_blank" rel="noopener">打包</a> 中，我们了解了怎么从一个包中获取内容。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_refspec" target="_blank" rel="noopener">引用规格</a> 章节中我们设置了高度自定义的 <code>refspec</code> 以便 <code>git fetch</code> 可以做一些跟默认不同的事情。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code> 命令基本上就是 <code>git fetch</code> 和 <code>git merge</code> 命令的组合体，Git 从你指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_fetching_and_pulling" target="_blank" rel="noopener">从远程仓库中抓取与拉取</a> 一节中快速介绍了此命令，然后在 <a href="https://git-scm.com/book/zh/v2/ch00/r_inspecting_remote" target="_blank" rel="noopener">查看远程仓库</a> 一节中了解了如果你运行此命令的话，什么将会合并。</p><p>我们也在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_rebase" target="_blank" rel="noopener">用变基解决变基</a> 一节中了解了如何使用此命令来来处理变基的难题。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_checking_out_conflicts" target="_blank" rel="noopener">检出冲突</a> 一节中我们展示了使用此命令如何通过一个 URL 来一次性的拉取变更。</p><p>最后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing_commits" target="_blank" rel="noopener">签署提交</a> 一节中我们快速的介绍了你可以使用 <code>--verify-signatures</code> 选项来验证你正在拉取下来的经过 GPG 签名的提交。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code> 命令用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。 它需要有另一个仓库的写权限，因此这通常是需要验证的。</p><p>我们开始在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pushing_remotes" target="_blank" rel="noopener">推送到远程仓库</a> 一节中介绍了 <code>git push</code> 命令。 在这一节中主要介绍了推送一个分支到远程仓库的基本用法。 在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pushing_branches" target="_blank" rel="noopener">推送</a> 一节中，我们深入了解了如何推送指定分支，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_tracking_branches" target="_blank" rel="noopener">跟踪分支</a> 一节中我们了解了如何设置一个默认的推送的跟踪分支。 在 <a href="https://git-scm.com/book/zh/v2/ch00/r_delete_branches" target="_blank" rel="noopener">删除远程分支</a> 一节中我们使用 <code>--delete</code> 标志和 <code>git push</code> 命令来在删除一个在服务器上的分支。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_contributing_project" target="_blank" rel="noopener">向一个项目贡献</a> 一整节中，我们看到了几个使用 <code>git push</code> 在多个远程仓库分享分支中的工作的示例。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_sharing_tags" target="_blank" rel="noopener">共享标签</a> 一节中，我们知道了如何使用此命令加 <code>--tags</code> 选项来分享你打的标签。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_publishing_submodules" target="_blank" rel="noopener">发布子模块改动</a> 一节中，我们使用 <code>--recurse-submodules</code> 选项来检查是否我们所有的子模块的工作都已经在推送子项目之前已经推送出去了，当使用子模块时这真的很有帮助。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_other_client_hooks" target="_blank" rel="noopener">其它客户端钩子</a> 中我们简单的提到了 <code>pre-push</code> 挂钩（hook），它是一个可以用来设置成在一个推送完成之前运行的脚本，以检查推送是否被允许。</p><p>最后，在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pushing_refspecs" target="_blank" rel="noopener">引用规格推送</a> 一节中，我们知道了使用完整的 refspec 来推送，而不是通常使用的简写形式。 这对我们精确的指定要分享出去的工作很有帮助。</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p><code>git remote</code> 命令是一个是你远程仓库记录的管理工具。 它允许你将一个长的 URL 保存成一个简写的句柄，例如 <code>origin</code> ，这样你就可以不用每次都输入他们了。 你可以有多个这样的句柄，<code>git remote</code> 可以用来添加，修改，及删除它们。</p><p>此命令在 <a href="https://git-scm.com/book/zh/v2/ch00/r_remote_repos" target="_blank" rel="noopener">远程仓库的使用</a> 一节中做了详细的介绍，包括列举、添加、移除、重命名功能。</p><p>几乎在此书的后续章节中都有使用此命令，但是一般是以 <code>git remote add &lt;name&gt; &lt;url&gt;</code> 这样的标准格式。</p><h3 id="git-archive"><a href="#git-archive" class="headerlink" title="git archive"></a>git archive</h3><p><code>git archive</code> 命令用来创建项目一个指定快照的归档文件。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_preparing_release" target="_blank" rel="noopener">准备一次发布</a> 一节中，使用 <code>git archive</code> 命令来创建一个项目的归档文件用于分享。</p><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><p><code>git submodule</code> 命令用来管理一个仓库的其他外部仓库。 它可以被用在库或者其他类型的共享资源上。<code>submodule</code> 命令有几个子命令, 如（<code>add</code>、<code>update</code>、<code>sync</code> 等等）用来管理这些资源。</p><p>只在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_submodules" target="_blank" rel="noopener">子模块</a> 章节中提到和详细介绍了此命令。</p><h2 id="检查与比较"><a href="#检查与比较" class="headerlink" title="检查与比较"></a>检查与比较</h2><h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><p><code>git show</code> 命令可以以一种简单的人类可读的方式来显示一个 Git 对象。 你一般使用此命令来显示一个标签或一个提交的信息。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_annotated_tags" target="_blank" rel="noopener">附注标签</a> 一节中使用此命令来显示带注解标签的信息。</p><p>然后，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_revision_selection" target="_blank" rel="noopener">选择修订版本</a> 一节中，用了很多次来显示不同的版本选择将解析出来的提交。</p><p>我们使用 <code>git show</code> 做的最有意思的事情是在 <a href="https://git-scm.com/book/zh/v2/ch00/r_manual_remerge" target="_blank" rel="noopener">手动文件再合并</a> 一节中用来在合并冲突的多个暂存区域中提取指定文件的内容。</p><h3 id="git-shortlog"><a href="#git-shortlog" class="headerlink" title="git shortlog"></a>git shortlog</h3><p><code>git shortlog</code> 是一个用来归纳 <code>git log</code> 的输出的命令。 它可以接受很多与 <code>git log</code> 相同的选项，但是此命令并不会列出所有的提交，而是展示一个根据作者分组的提交记录的概括性信息</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_the_shortlog" target="_blank" rel="noopener">制作提交简报</a> 一节中展示了如何使用此命令来创建一个漂亮的 changelog 文件。</p><h3 id="git-describe"><a href="#git-describe" class="headerlink" title="git describe"></a>git describe</h3><p><code>git describe</code> 命令用来接受任何可以解析成一个提交的东西，然后生成一个人类可读的字符串且不可变。 这是一种获得一个提交的描述的方式，它跟一个提交的 SHA-1 值一样是无歧义，但是更具可读性。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_build_number" target="_blank" rel="noopener">生成一个构建号</a> 及 <a href="https://git-scm.com/book/zh/v2/ch00/r_preparing_release" target="_blank" rel="noopener">准备一次发布</a> 章节中使用 <code>git describe</code> 命令来获得一个字符串来命名我们发布的文件。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Git 有一些命令可以用来帮你调试你代码中的问题。 包括找出是什么时候，是谁引入的变更。</p><h3 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h3><p><code>git bisect</code> 工具是一个非常有用的调试工具，它通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。</p><p>仅在 <a href="https://git-scm.com/book/zh/v2/ch00/r_binary_search" target="_blank" rel="noopener">二分查找</a> 一节中完整的介绍了此命令。</p><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p><code>git blame</code> 命令标注任何文件的行，指出文件的每一行的最后的变更的提交及谁是那一个提交的作者。 当你要找那个人去询问关于这块特殊代码的信息时这会很有用。</p><p>只有 <a href="https://git-scm.com/book/zh/v2/ch00/r_file_annotation" target="_blank" rel="noopener">文件标注</a> 一节有中提到此命令。</p><h3 id="git-grep"><a href="#git-grep" class="headerlink" title="git grep"></a>git grep</h3><p><code>git grep</code> 命令可以帮助在源代码中，甚至是你项目的老版本中的任意文件中查找任何字符串或者正则表达式。</p><p>只有 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_grep" target="_blank" rel="noopener">Git Grep</a> 的章节中与提到此命令。</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>Git 中的一些命令是以引入的变更即提交这样的概念为中心的，这样一系列的提交，就是一系列的补丁。 这些命令以这样的方式来管理你的分支。</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p><code>git cherry-pick</code> 命令用来获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。 从一个分支单独一个或者两个提交而不是合并整个分支的所有变更是非常有用的。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_cherry_pick" target="_blank" rel="noopener">变基与拣选工作流</a> 一节中描述和演示了 <code>Cherry picking</code></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><code>git rebase</code> 命令基本是是一个自动化的 <code>cherry-pick</code> 命令。 它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 <code>cherry-picks</code> 出它们。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebasing" target="_blank" rel="noopener">变基</a> 一章中详细提到了此命令，包括与已经公开的分支的变基所涉及的协作问题。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_replace" target="_blank" rel="noopener">替换</a> 中我们在一个分离历史记录到两个单独的仓库的示例中实践了此命令，同时使用了 <code>--onto</code> 选项。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rerere" target="_blank" rel="noopener">Rerere</a> 一节中，我们研究了在变基时遇到的合并冲突的问题。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_changing_multiple" target="_blank" rel="noopener">修改多个提交信息</a> 一节中，我们也结合 <code>-i</code> 选项将其用于交互式的脚本模式。</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><code>git revert</code> 命令本质上就是一个逆向的 <code>git cherry-pick</code> 操作。 它将你提交中的变更的以完全相反的方式的应用到一个新创建的提交中，本质上就是撤销或者倒转。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_reverse_commit" target="_blank" rel="noopener">还原提交</a> 一节中使用此命令来撤销一个合并提交。</p><h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><p>很多 Git 项目，包括 Git 本身，基本是通过邮件列表来维护的。 从方便地生成邮件补丁到从一个邮箱中应用这些补丁,Git 都有工具来让这些操作变得简单。</p><h3 id="git-apply"><a href="#git-apply" class="headerlink" title="git apply"></a>git apply</h3><p><code>git apply</code> 命令应用一个通过 <code>git diff</code> 或者甚至使用 GNU diff 命令创建的补丁。 它跟补丁命令做了差不多的工作，但还是有一些小小的差别。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_patches_from_email" target="_blank" rel="noopener">应用来自邮件的补丁</a> 一节中演示了它的使用及什么环境下你可能会用到它。</p><h3 id="git-am"><a href="#git-am" class="headerlink" title="git am"></a>git am</h3><p><code>git am</code> 命令用来应用来自邮箱的补丁。特别是那些被 mbox 格式化过的。 这对于通过邮件接受补丁并将他们轻松地应用到你的项目中很有用。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_am" target="_blank" rel="noopener">使用 <code>am</code> 命令应用补丁</a> 命令中提到了它的用法及工作流，包括使用 <code>--resolved</code>、<code>-i</code> 及 <code>-3</code> 选项。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_hooks" target="_blank" rel="noopener">电子邮件工作流钩子</a> 也提到了几条 hooks，你可以用来辅助与 <code>git am</code> 相关工作流。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_notifications" target="_blank" rel="noopener">邮件通知</a> 一节中我们也将用此命令来应用 格式化的 GitHub的推送请求的变更。</p><h3 id="git-format-patch"><a href="#git-format-patch" class="headerlink" title="git format-patch"></a>git format-patch</h3><p><code>git format-patch</code> 命令用来以 mbox 的格式来生成一系列的补丁以便你可以发送到一个邮件列表中。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_project_over_email" target="_blank" rel="noopener">通过邮件的公开项目</a> 一节中研究了一个使用 <code>git format-patch</code> 工具为一个项目做贡献的示例。</p><h3 id="git-imap-send"><a href="#git-imap-send" class="headerlink" title="git imap-send"></a>git imap-send</h3><p><code>git imap-send</code> 将一个由 <code>git format-patch</code> 生成的邮箱上传至 IMAP 草稿文件夹。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_project_over_email" target="_blank" rel="noopener">通过邮件的公开项目</a> 一节中见过一个通过使用 <code>git imap-send</code> 工具向一个项目发送补丁进行贡献的例子。</p><h3 id="git-send-email"><a href="#git-send-email" class="headerlink" title="git send-email"></a>git send-email</h3><p><code>git send-mail</code> 命令用来通过邮件发送那些使用 <code>git format-patch</code> 生成的补丁。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_project_over_email" target="_blank" rel="noopener">通过邮件的公开项目</a> 一节中研究了一个使用 <code>git send-email</code> 工具发送补丁来为一个项目做贡献的示例。</p><h3 id="git-request-pull"><a href="#git-request-pull" class="headerlink" title="git request-pull"></a>git request-pull</h3><p><code>git request-pull</code> 命令只是简单的用来生成一个可通过邮件发送给某个人的示例信息体。 如果你在公共服务器上有一个分支，并且想让别人知道如何集成这些变更，而不用通过邮件发送补丁，你就可以执行此命令的输出发送给这个你想拉取变更的人。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_public_project" target="_blank" rel="noopener">派生的公开项目</a> 一节中演示了如何使用 <code>git request-pull</code> 来生成一个推送消息。</p><h2 id="外部系统"><a href="#外部系统" class="headerlink" title="外部系统"></a>外部系统</h2><p>Git 有一些可以与其他的版本控制系统集成的命令。</p><h3 id="git-svn"><a href="#git-svn" class="headerlink" title="git svn"></a>git svn</h3><p><code>git svn</code> 可以使 Git 作为一个客户端来与 Subversion 版本控制系统通信。 这意味着你可以使用 Git 来检出内容，或者提交到 Subversion 服务器。</p><p><a href="https://git-scm.com/book/zh/v2/ch00/r_git_svn" target="_blank" rel="noopener">Git 与 Subversion</a> 一章深入讲解了此命令。</p><h3 id="git-fast-import"><a href="#git-fast-import" class="headerlink" title="git fast-import"></a>git fast-import</h3><p>对于其他版本控制系统或者从其他任何的格式导入，你可以使用 <code>git fast-import</code> 快速地将其他格式映射到 Git 可以轻松记录的格式。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_custom_importer" target="_blank" rel="noopener">一个自定义的导入器</a> 一节中深入讲解了此命令。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>如果你正在管理一个 Git 仓库，或者需要通过一个复杂的方法来修复某些东西，Git 提供了一些管理命令来帮助你。</p><h3 id="git-gc"><a href="#git-gc" class="headerlink" title="git gc"></a>git gc</h3><p><code>git gc</code> 命令在你的仓库中执行 “garbage collection” ，删除数据库中不需要的文件和将其他文件打包成一种更有效的格式。</p><p>此命令一般在背后为你工作，虽然你可以手动执行它-如果你想的话。 我们在<a href="https://git-scm.com/book/zh/v2/ch00/r_git_gc" target="_blank" rel="noopener">维护</a> 一节中研究此命令的几个示例。</p><h3 id="git-fsck"><a href="#git-fsck" class="headerlink" title="git fsck"></a>git fsck</h3><p><code>git fsck</code> 命令用来检查内部数据库的问题或者不一致性。</p><p>我们只在 <a href="https://git-scm.com/book/zh/v2/ch00/r_data_recovery" target="_blank" rel="noopener">数据恢复</a> 这一节中快速使用了一次此命令来搜索所有的悬空对象（dangling object）。</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p><code>git reflog</code> 命令分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交。</p><p>我们主要在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reflog" target="_blank" rel="noopener">引用日志</a> 一节中提到了此命令，并在展示了一般用法，及如何使用 <code>git log -g</code> 来通过 <code>git log</code> 的输出来查看同样的信息。</p><p>我们同样在 <a href="https://git-scm.com/book/zh/v2/ch00/r_data_recovery" target="_blank" rel="noopener">数据恢复</a> 一节中研究了一个恢复丢失的分支的实例。</p><h3 id="git-filter-branch"><a href="#git-filter-branch" class="headerlink" title="git filter-branch"></a>git filter-branch</h3><p><code>git filter-branch</code> 命令用来根据某些规则来重写大量的提交记录，例如从任何地方删除文件，或者通过过滤一个仓库中的一个单独的子目录以提取出一个项目。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_removing_file_every_commit" target="_blank" rel="noopener">从每一个提交移除一个文件</a> 一节中，我们解释了此命令，并探究了其他几个选项，例如 <code>--commit-filter</code>，<code>--subdirectory-filter</code> 及 <code>--tree-filter</code> 。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_p4" target="_blank" rel="noopener">Git-p4</a> 和 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_tfs" target="_blank" rel="noopener">TFS</a> 的章节中我们使用它来修复已经导入的外部仓库。</p><h2 id="底层命令"><a href="#底层命令" class="headerlink" title="底层命令"></a>底层命令</h2><p>在本书中我们也遇到了不少底层的命令。</p><p>我们遇到的第一个底层命令是在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_refs" target="_blank" rel="noopener">合并请求引用</a> 中的 <code>ls-remote</code> 命令。我们用它来查看服务端的原始引用。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_manual_remerge" target="_blank" rel="noopener">手动文件再合并</a>、 <a href="https://git-scm.com/book/zh/v2/ch00/r_rerere" target="_blank" rel="noopener">Rerere</a> 及 <a href="https://git-scm.com/book/zh/v2/ch00/r_the_index" target="_blank" rel="noopener">索引</a> 章节中使用 <code>ls-files</code> 来查看暂存区的更原始的样子。</p><p>我们同样在 <a href="https://git-scm.com/book/zh/v2/ch00/r_branch_references" target="_blank" rel="noopener">分支引用</a> 一节中提到了 <code>rev-parse</code> 命令，它可以接受任意字符串，并将其转成一个对象的 SHA-1 值。</p><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 一章中对大部分的底层命令进行了介绍，这差不多正是这一章的重点所在。 我们尽量避免了在本书的其他部分使用这些命令。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录B:将Git嵌入你的应用</title>
      <link href="/2019/07/15/%E9%99%84%E5%BD%95B-%E5%B0%86Git%E5%B5%8C%E5%85%A5%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/07/15/%E9%99%84%E5%BD%95B-%E5%B0%86Git%E5%B5%8C%E5%85%A5%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>假设你的应用程序的目标人群是开发者，如果它能够被整合进一些源码控制的功能，那真真是极好的。 甚至对于一个例如文档编辑器之类的不是为开发者而设计的应用程序，它们也可能从版本控制系统中受益，并且 Git 的实现方式在很多情况下都表现得非常出色。</p><p>如果你想将 Git 整合进你的应用程序的话，一般来说你有三种可能的选择：启动一个 shell 来使用 Git 的命令行工具；使用 Libgit2；或者使用 JGit。</p><h2 id="命令行-Git-方式"><a href="#命令行-Git-方式" class="headerlink" title="命令行 Git 方式"></a>命令行 Git 方式</h2><p>一种方式就是启动一个 shell 进程并在里面使用 Git 的命令行工具来完成任务。 这种方式看起来很循规蹈矩，但是它的优点也因此而来，就是支持所有的 Git 的特性。 它也碰巧相当简单，因为几乎所有运行时环境都有一个相对简单的方式来调用一个带有命令行参数的进程。 然而，这种方式也有一些固有的缺点。</p><p>一个就是所有的输出都是纯文本格式。 这意味着你将被迫解析 Git 的有时会改变的输出格式，以随时了解它工作的进度和结果。更糟糕的是，这可能是无效率并且容易出错的。</p><p>另外一个就是令人捉急的错误修复能力。 如果一个版本库被莫名其妙地损毁，或者用户使用了一个奇奇怪怪的配置， Git 只会简单地拒绝表现自己的强大能力。</p><p>还有一个就是进程的管理。 Git 会要求你在一个独立的进程中维护一个 shell 环境，这可能会无谓地增加复杂性。 试图协调许许多多的类似的进程（尤其是在某些情况下，当不同的进程在访问相同的版本库时）是对你的能力的极大挑战。</p><h2 id="Libgit2"><a href="#Libgit2" class="headerlink" title="Libgit2"></a>Libgit2</h2><p>© 另外一种可以供你使用的是 Libgit2。 Libgit2 是一个 Git 的非依赖性的工具，它致力于为其他程序使用 Git 提供更好的 API。 你可以在 <a href="http://libgit2.github.com/" target="_blank" rel="noopener">http://libgit2.github.com</a> 找到它。</p><p>首先，让我们来看一下 C API 长啥样。 这是一个旋风式旅行。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 打开一个版本库</span>git_repository <span class="token operator">*</span>repo<span class="token punctuation">;</span><span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token function">git_repository_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>repo<span class="token punctuation">,</span> <span class="token string">"/path/to/repository"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 逆向引用 HEAD 到一个提交</span>git_object <span class="token operator">*</span>head_commit<span class="token punctuation">;</span>error <span class="token operator">=</span> <span class="token function">git_revparse_single</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head_commit<span class="token punctuation">,</span> repo<span class="token punctuation">,</span> <span class="token string">"HEAD^{commit}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>git_commit <span class="token operator">*</span>commit <span class="token operator">=</span> <span class="token punctuation">(</span>git_commit<span class="token operator">*</span><span class="token punctuation">)</span>head_commit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 显示这个提交的一些详情</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token function">git_commit_message</span><span class="token punctuation">(</span>commit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> git_signature <span class="token operator">*</span>author <span class="token operator">=</span> <span class="token function">git_commit_author</span><span class="token punctuation">(</span>commit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s &lt;%s>\n"</span><span class="token punctuation">,</span> author<span class="token operator">-></span>name<span class="token punctuation">,</span> author<span class="token operator">-></span>email<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> git_oid <span class="token operator">*</span>tree_id <span class="token operator">=</span> <span class="token function">git_commit_tree_id</span><span class="token punctuation">(</span>commit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 清理现场</span><span class="token function">git_commit_free</span><span class="token punctuation">(</span>commit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">git_repository_free</span><span class="token punctuation">(</span>repo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>前两行打开一个 Git 版本库。 这个 <code>git_repository</code> 类型代表了一个在内存中带有缓存的指向一个版本库的句柄。 这是最简单的方法，只是你必须知道一个版本库的工作目录或者一个 <code>.git</code> 文件夹的精确路径。 另外还有 <code>git_repository_open_ext</code> ，它包括了带选项的搜索， <code>git_clone</code> 及其同类可以用来做远程版本库的本地克隆， <code>git_repository_init</code> 则可以创建一个全新的版本库。</p><p>第二段代码使用了一种 rev-parse 语法（要了解更多，请看 <a href="https://git-scm.com/book/zh/v2/ch00/r_branch_references" target="_blank" rel="noopener">分支引用</a> ）来得到 HEAD 真正指向的提交。 返回类型是一个 <code>git_object</code> 指针，它指代位于版本库里的 Git 对象数据库中的某个东西。 <code>git_object</code>实际上是几种不同的对象的 “父” 类型，每个 “子” 类型的内存布局和 <code>git_object</code> 是一样的，所以你能安全地把它们转换为正确的类型。 在上面的例子中， <code>git_object_type(commit)</code> 会返回 <code>GIT_OBJ_COMMIT</code> ，所以转换成 <code>git_commit</code> 指针是安全的。</p><p>下一段展示了如何访问一个提交的详情。 最后一行使用了 <code>git_oid</code> 类型，这是 Libgit2 用来表示一个 SHA-1 哈希的方法。</p><p>从这个例子中，我们可以看到一些模式：</p><ul><li>如果你声明了一个指针，并在一个 Libgit2 调用中传递一个引用，那么这个调用可能返回一个 int 类型的错误码。 值 <code>0</code> 表示成功，比它小的则是一个错误。</li><li>如果 Libgit2 为你填入一个指针，那么你有责任释放它。</li><li>如果 Libgit2 在一个调用中返回一个 <code>const</code> 指针，你不需要释放它，但是当它所指向的对象被释放时它将不可用。</li><li>用 C 来写有点蛋疼。</li></ul><p>最后一点意味着你应该不会在使用 Libgit2 时编写 C 语言程序。 但幸运的是，有许多可用的各种语言的绑定，能让你在特定的语言和环境中更加容易的操作 Git 版本库。 我们来看一下下面这个用 Libgit2 的 Ruby 绑定写成的例子，它叫 Rugged，你可以在 <a href="https://github.com/libgit2/rugged" target="_blank" rel="noopener">https://github.com/libgit2/rugged</a> 找到它。</p><pre class=" language-ruby"><code class="language-ruby">repo <span class="token operator">=</span> <span class="token constant">Rugged</span><span class="token punctuation">:</span><span class="token symbol">:Repository</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'path/to/repository'</span><span class="token punctuation">)</span>commit <span class="token operator">=</span> repo<span class="token punctuation">.</span>head<span class="token punctuation">.</span>targetputs commit<span class="token punctuation">.</span>messageputs <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span>commit<span class="token punctuation">.</span>author<span class="token punctuation">[</span><span class="token punctuation">:</span>name<span class="token punctuation">]</span><span class="token delimiter tag">}</span></span> &lt;<span class="token interpolation"><span class="token delimiter tag">#{</span>commit<span class="token punctuation">.</span>author<span class="token punctuation">[</span><span class="token punctuation">:</span>email<span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>>"</span>tree <span class="token operator">=</span> commit<span class="token punctuation">.</span>tree</code></pre><p>你可以发现，代码看起来更加清晰了。 首先， Rugged 使用异常机制，它可以抛出类似于 <code>ConfigError</code>或者 <code>ObjectError</code> 之类的东西来告知错误的情况。 其次，不需要明确资源释放，因为 Ruby 是支持垃圾回收的。 我们来看一个稍微复杂一点的例子：从头开始制作一个提交。</p><pre class=" language-ruby"><code class="language-ruby">blob_id <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Blob contents"</span><span class="token punctuation">,</span> <span class="token symbol">:blob</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>index <span class="token operator">=</span> repo<span class="token punctuation">.</span>indexindex<span class="token punctuation">.</span><span class="token function">read_tree</span><span class="token punctuation">(</span>repo<span class="token punctuation">.</span>head<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tree<span class="token punctuation">)</span>index<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token symbol">:path</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'newfile.txt'</span><span class="token punctuation">,</span> <span class="token symbol">:oid</span> <span class="token operator">=</span><span class="token operator">></span> blob_id<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>sig <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token symbol">:email</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"bob@example.com"</span><span class="token punctuation">,</span>    <span class="token symbol">:name</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"Bob User"</span><span class="token punctuation">,</span>    <span class="token symbol">:time</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token builtin">Time</span><span class="token punctuation">.</span>now<span class="token punctuation">,</span><span class="token punctuation">}</span>commit_id <span class="token operator">=</span> <span class="token constant">Rugged</span><span class="token punctuation">:</span><span class="token symbol">:Commit</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>repo<span class="token punctuation">,</span>    <span class="token symbol">:tree</span> <span class="token operator">=</span><span class="token operator">></span> index<span class="token punctuation">.</span><span class="token function">write_tree</span><span class="token punctuation">(</span>repo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token symbol">:author</span> <span class="token operator">=</span><span class="token operator">></span> sig<span class="token punctuation">,</span>    <span class="token symbol">:committer</span> <span class="token operator">=</span><span class="token operator">></span> sig<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token symbol">:message</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"Add newfile.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token symbol">:parents</span> <span class="token operator">=</span><span class="token operator">></span> repo<span class="token punctuation">.</span>empty<span class="token operator">?</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span> repo<span class="token punctuation">.</span>head<span class="token punctuation">.</span>target <span class="token punctuation">]</span><span class="token punctuation">.</span>compact<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token symbol">:update_ref</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'HEAD'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>commit <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>commit_id<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span></code></pre><ol><li>创建一个新的 blob ，它包含了一个新文件的内容。</li><li>将 HEAD 提交树填入索引，并在路径 <code>newfile.txt</code> 增加新文件。</li><li>这就在 ODB 中创建了一个新的树，并在一个新的提交中使用它。</li><li>我们在 author 栏和 committer 栏使用相同的签名。</li><li>提交的信息。</li><li>当创建一个提交时，你必须指定这个新提交的父提交。 这里使用了 HEAD 的末尾作为单一的父提交。</li><li>在做一个提交的过程中， Rugged （和 Libgit2 ）能在需要时更新引用。</li><li>返回值是一个新提交对象的 SHA-1 哈希，你可以用它来获得一个 <code>Commit</code> 对象。</li></ol><p>Ruby 的代码很好很简洁，另一方面因为 Libgit2 做了大量工作，所以代码运行起来其实速度也不赖。 如果你不是一个 Ruby 程序员，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_libgit2_bindings" target="_blank" rel="noopener">其它绑定</a> 有提到其它的一些绑定。</p><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><p>Libgit2 有几个超过核心 Git 的能力。 例如它的可定制性：Libgit2 允许你为一些不同类型的操作自定义的`‘后端’’，让你得以使用与原生 Git 不同的方式存储东西。 Libgit2 允许为自定义后端指定配置、引用的存储以及对象数据库，</p><p>我们来看一下它究竟是怎么工作的。 下面的例子借用自 Libgit2 团队提供的后端样本集 （可以在 <a href="https://github.com/libgit2/libgit2-backends" target="_blank" rel="noopener">https://github.com/libgit2/libgit2-backends</a> 上找到）。 一个对象数据库的自定义后端是这样建立的：</p><pre class=" language-c"><code class="language-c">git_odb <span class="token operator">*</span>odb<span class="token punctuation">;</span><span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token function">git_odb_new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>odb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>git_odb_backend <span class="token operator">*</span>my_backend<span class="token punctuation">;</span>error <span class="token operator">=</span> <span class="token function">git_odb_backend_mine</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_backend<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/*…*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>error <span class="token operator">=</span> <span class="token function">git_odb_add_backend</span><span class="token punctuation">(</span>odb<span class="token punctuation">,</span> my_backend<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>git_repository <span class="token operator">*</span>repo<span class="token punctuation">;</span>error <span class="token operator">=</span> <span class="token function">git_repository_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>repo<span class="token punctuation">,</span> <span class="token string">"some-path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>error <span class="token operator">=</span> <span class="token function">git_repository_set_odb</span><span class="token punctuation">(</span>odb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p><em>(注意：这个错误被捕获了，但是没有被处理。我们希望你的代码比我们的更好。)</em></p><ol><li>初始化一个空的对象数据库（ ODB ） “前端”，它将被作为一个用来做真正的工作的 “后端” 的容器。</li><li>初始化一个自定义 ODB 后端。</li><li>为这个前端增加一个后端。</li><li>打开一个版本库，并让它使用我们的 ODB 来寻找对象。</li></ol><p>但是 <code>git_odb_backend_mine</code> 是个什么东西呢？ 嗯，那是一个你自己的 ODB 实现的构造器，并且你能在那里做任何你想做的事，前提是你能正确地填写 <code>git_odb_backend</code> 结构。 它看起来_应该_是这样的：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    git_odb_backend parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 其它的一些东西</span>    <span class="token keyword">void</span> <span class="token operator">*</span>custom_context<span class="token punctuation">;</span><span class="token punctuation">}</span> my_backend_struct<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">git_odb_backend_mine</span><span class="token punctuation">(</span>git_odb_backend <span class="token operator">*</span><span class="token operator">*</span>backend_out<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/*…*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    my_backend_struct <span class="token operator">*</span>backend<span class="token punctuation">;</span>    backend <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>my_backend_struct<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    backend<span class="token operator">-></span>custom_context <span class="token operator">=</span> …<span class="token punctuation">;</span>    backend<span class="token operator">-></span>parent<span class="token punctuation">.</span>read <span class="token operator">=</span> <span class="token operator">&amp;</span>my_backend__read<span class="token punctuation">;</span>    backend<span class="token operator">-></span>parent<span class="token punctuation">.</span>read_prefix <span class="token operator">=</span> <span class="token operator">&amp;</span>my_backend__read_prefix<span class="token punctuation">;</span>    backend<span class="token operator">-></span>parent<span class="token punctuation">.</span>read_header <span class="token operator">=</span> <span class="token operator">&amp;</span>my_backend__read_header<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ……</span>    <span class="token operator">*</span>backend_out <span class="token operator">=</span> <span class="token punctuation">(</span>git_odb_backend <span class="token operator">*</span><span class="token punctuation">)</span> backend<span class="token punctuation">;</span>    <span class="token keyword">return</span> GIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>my_backend_struct</code> 的第一个成员必须是一个 <code>git_odb_backend</code> 结构，这是一个微妙的限制：这样就能确保内存布局是 Libgit2 的代码所期望的样子。 其余都是随意的，这个结构的大小可以随心所欲。</p><p>这个初始化函数为该结构分配内存，设置自定义的上下文，然后填写它支持的 <code>parent</code> 结构的成员。 阅读 Libgit2 的 <code>include/git2/sys/odb_backend.h</code> 源码以了解全部调用签名，你特定的使用环境会帮你决定使用哪一种调用签名。</p><h3 id="其它绑定"><a href="#其它绑定" class="headerlink" title="其它绑定"></a>其它绑定</h3><p>Libgit2 有很多种语言的绑定。 在这篇文章中，我们展现了一个使用了几个更加完整的绑定包的小例子，这些库存在于许多种语言中，包括 C++、Go、Node.js、Erlang 以及 JVM ，它们的成熟度各不相同。 官方的绑定集合可以通过浏览这个版本库得到：<a href="https://github.com/libgit2[]" target="_blank" rel="noopener">https://github.com/libgit2[]</a> 。 我们写的代码将返回当前 HEAD 指向的提交的提交信息(就像 <code>git log -1</code> 那样)。</p><h4 id="LibGit2Sharp"><a href="#LibGit2Sharp" class="headerlink" title="LibGit2Sharp"></a>LibGit2Sharp</h4><p>如果你在编写一个 .NET 或者 Mono 应用，那么 LibGit2Sharp (<a href="https://github.com/libgit2/libgit2sharp" target="_blank" rel="noopener">https://github.com/libgit2/libgit2sharp</a>) 就是你所需要的。 这个绑定是用 C# 写成的，并且已经采取许多措施来用令人感到自然的 CLR API 包装原始的 Libgit2 的调用。 我们的例子看起来就像这样：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">new</span> <span class="token class-name">Repository</span><span class="token punctuation">(</span><span class="token string">@"C:\path\to\repo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Head<span class="token punctuation">.</span>Tip<span class="token punctuation">.</span>Message<span class="token punctuation">;</span></code></pre><p>对于 Windows 桌面应用，一个叫做 NuGet 的包会让你快速上手。</p><h4 id="objective-git"><a href="#objective-git" class="headerlink" title="objective-git"></a>objective-git</h4><p>如果你的应用运行在一个 Apple 平台上，你很有可能使用 Objective-C 作为实现语言。 Objective-Git (<a href="https://github.com/libgit2/objective-git" target="_blank" rel="noopener">https://github.com/libgit2/objective-git</a>) 是这个环境下的 Libgit2 绑定。 一个例子看起来类似这样：</p><pre class=" language-objc"><code class="language-objc">GTRepository *repo =    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];</code></pre><p>Objective-git 与 Swift 完美兼容，所以你把 Objective-C 落在一边的时候不用恐惧。</p><h4 id="pygit2"><a href="#pygit2" class="headerlink" title="pygit2"></a>pygit2</h4><p>Python 的 Libgit2 绑定叫做 Pygit2 ，你可以在 <a href="http://www.pygit2.org/" target="_blank" rel="noopener">http://www.pygit2.org/</a> 找到它。 我们的示例程序：</p><pre class=" language-python"><code class="language-python">pygit2<span class="token punctuation">.</span>Repository<span class="token punctuation">(</span><span class="token string">"/path/to/repo"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 打开版本库</span>    <span class="token punctuation">.</span>head                          <span class="token comment" spellcheck="true"># get the current branch</span>    <span class="token punctuation">.</span>peel<span class="token punctuation">(</span>pygit2<span class="token punctuation">.</span>Commit<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># walk down to the commit</span>    <span class="token punctuation">.</span>message                       <span class="token comment" spellcheck="true"># read the message</span></code></pre><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>当然，完全阐述 Libgit2 的能力已超出本书范围。 如果你想了解更多关于 Libgit2 的信息，可以浏览它的 API 文档： <a href="https://libgit2.github.com/libgit2" target="_blank" rel="noopener">https://libgit2.github.com/libgit2</a>, 以及一系列的指南： <a href="https://libgit2.github.com/docs" target="_blank" rel="noopener">https://libgit2.github.com/docs</a>. 对于其它的绑定，检查附带的 README 和测试文件，那里通常有简易教程，以及指向拓展阅读的链接。</p><h2 id="JGit"><a href="#JGit" class="headerlink" title="JGit"></a>JGit</h2><p>如果你想在一个 Java 程序中使用 Git ，有一个功能齐全的 Git 库，那就是 JGit 。 JGit 是一个用 Java 写成的功能相对健全的 Git 的实现，它在 Java 社区中被广泛使用。 JGit 项目由 Eclipse 维护，它的主页在 <a href="http://www.eclipse.org/jgit" target="_blank" rel="noopener">http://www.eclipse.org/jgit</a> 。</p><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>有很多种方式可以让 JGit 连接你的项目，并依靠它去写代码。 最简单的方式也许就是使用 Maven 。你可以通过在你的 pom.xml 文件里的 <code>&lt;dependencies&gt;</code> 标签中增加像下面这样的片段来完成这个整合。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.eclipse.jgit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>org.eclipse.jgit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.0.201409260305-r<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>在你读到这段文字时 <code>version</code> 很可能已经更新了，所以请浏览 <a href="http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit" target="_blank" rel="noopener">http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit</a> 以获取最新的仓库信息。 当这一步完成之后， Maven 就会自动获取并使用你所需要的 JGit 库。</p><p>如果你想自己管理二进制的依赖包，那么你可以从 <a href="http://www.eclipse.org/jgit/download" target="_blank" rel="noopener">http://www.eclipse.org/jgit/download</a> 获得预构建的 JGit 二进制文件。 你可以像下面这样执行一个命令来将它们构建进你的项目。</p><pre class=" language-console"><code class="language-console">javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.javajava -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App</code></pre><h3 id="底层命令"><a href="#底层命令" class="headerlink" title="底层命令"></a>底层命令</h3><p>JGit 的 API 有两种基本的层次：底层命令和高层命令。 这个两个术语都来自 Git ，并且 JGit 也被按照相同的方式粗略地划分：高层 API 是一个面向普通用户级别功能的友好的前端（一系列普通用户使用 Git 命令行工具时可能用到的东西），底层 API 则直接作用于低级的仓库对象。</p><p>大多数 JGit 会话会以 <code>Repository</code> 类作为起点，你首先要做的事就是创建一个它的实例。 对于一个基于文件系统的仓库来说（嗯， JGit 允许其它的存储模型），用 <code>FileRepositoryBuilder</code> 完成它。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建一个新仓库</span>Repository newlyCreatedRepo <span class="token operator">=</span> FileRepositoryBuilder<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>    <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/tmp/new_repo/.git"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newlyCreatedRepo<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 打开一个存在的仓库</span>Repository existingRepo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileRepositoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setGitDir</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"my_repo/.git"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>无论你的程序是否知道仓库的确切位置，builder 中的那个流畅的 API 都可以提供给它寻找仓库所需所有信息。 它可以使用环境变量 （<code>.readEnvironment()</code>） ，从工作目录的某处开始并搜索 （<code>.setWorkTree(…).findGitDir()</code>） , 或者仅仅只是像上面那样打开一个已知的 <code>.git</code> 目录。</p><p>当你拥有一个 <code>Repository</code> 实例后，你就能对它做各种各样的事。 下面是一个速览：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取引用</span>Ref master <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">getRef</span><span class="token punctuation">(</span><span class="token string">"master"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取该引用所指向的对象</span>ObjectId masterTip <span class="token operator">=</span> master<span class="token punctuation">.</span><span class="token function">getObjectId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Rev-parse</span>ObjectId obj <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"HEAD^{tree}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 装载对象原始内容</span>ObjectLoader loader <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>masterTip<span class="token punctuation">)</span><span class="token punctuation">;</span>loader<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建分支</span>RefUpdate createBranch1 <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">updateRef</span><span class="token punctuation">(</span><span class="token string">"refs/heads/branch1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>createBranch1<span class="token punctuation">.</span><span class="token function">setNewObjectId</span><span class="token punctuation">(</span>masterTip<span class="token punctuation">)</span><span class="token punctuation">;</span>createBranch1<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 删除分支</span>RefUpdate deleteBranch1 <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">updateRef</span><span class="token punctuation">(</span><span class="token string">"refs/heads/branch1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deleteBranch1<span class="token punctuation">.</span><span class="token function">setForceUpdate</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deleteBranch1<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 配置</span>Config cfg <span class="token operator">=</span> repo<span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String name <span class="token operator">=</span> cfg<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里完成了一大堆事情，所以我们还是一次理解一段的好。</p><p>第一行获取一个指向 <code>master</code> 引用的指针。 JGit 自动抓取位于 <code>refs/heads/master</code> 的 <em>真正的</em> master 引用，并返回一个允许你获取该引用的信息的对象。 你可以获取它的名字 （<code>.getName()</code>） ，或者一个直接引用的目标对象 （<code>.getObjectId()</code>） ，或者一个指向该引用的符号指针 （<code>.getTarget()</code>） 。 引用对象也经常被用来表示标签的引用和对象，所以你可以询问某个标签是否被 “削除” 了，或者说它指向一个标签对象的（也许很长的）字符串的最终目标。</p><p>第二行获得以 <code>master</code> 引用的目标，它返回一个 ObjectId 实例。 不管是否存在于一个 Git 对象的数据库，ObjectId 都会代表一个对象的 SHA-1 哈希。 第三行与此相似，但是它展示了 JGit 如何处理 rev-parse 语法（要了解更多，请看 <a href="https://git-scm.com/book/zh/v2/ch00/r_branch_references" target="_blank" rel="noopener">分支引用</a> ），你可以传入任何 Git 了解的对象说明符，然后 JGit 会返回该对象的一个有效的 ObjectId ，或者 <code>null</code> 。</p><p>接下来两行展示了如何装载一个对象的原始内容。 在这个例子中，我们调用 <code>ObjectLoader.copyTo()</code>直接向标准输出流输出对象的内容，除此之外 ObjectLoader 还带有读取对象的类型和长度并将它以字节数组返回的方法。 对于一个（ <code>.isLarge()</code> 返回 <code>true</code> 的）大的对象，你可以调用 <code>.openStream()</code> 来获得一个类似 InputStream 的对象，它可以在没有一次性将所有数据拉到内存的前提下读取对象的原始数据。</p><p>接下来几行展现了如何创建一个新的分支。 我们创建一个 RefUpdate 实例，配置一些参数，然后调用 <code>.update()</code> 来确认这个更改。 删除相同分支的代码就在这行下面。 记住必须先 <code>.setForceUpdate(true)</code> 才能让它工作，否则调用 <code>.delete()</code> 只会返回 <code>REJECTED</code> ，然后什么都没有发生。</p><p>最后一个例子展示了如何从 Git 配置文件中获取 <code>user.name</code> 的值。 这个 Config 实例使用我们先前打开的仓库做本地配置，但是它也会自动地检测并读取全局和系统的配置文件。</p><p>这只是底层 API 的冰山一角，另外还有许多可以使用的方法和类。 还有一个没有放在这里说明的，就是 JGit 是用异常机制来处理错误的。 JGit API 有时使用标准的 Java 异常（例如 <code>IOException</code> ），但是它也提供了大量 JGit 自己定义的异常类型（例如 <code>NoRemoteRepositoryException</code>、 <code>CorruptObjectException</code> 和 <code>NoMergeBaseException</code>）。</p><h3 id="高层命令"><a href="#高层命令" class="headerlink" title="高层命令"></a>高层命令</h3><p>底层 API 更加完善，但是有时将它们串起来以实现普通的目的非常困难，例如将一个文件添加到索引，或者创建一个新的提交。 为了解决这个问题， JGit 提供了一系列高层 API ，使用这些 API 的入口点就是 <code>Git</code>类：</p><pre class=" language-java"><code class="language-java">Repository repo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 构建仓库。。。</span>Git git <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Git</span><span class="token punctuation">(</span>repo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Git 类有一系列非常好的 <em>构建器</em> 风格的高层方法，它可以用来构造一些复杂的行为。 我们来看一个例子——做一件类似 <code>git ls-remote</code> 的事。</p><pre class=" language-java"><code class="language-java">CredentialsProvider cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordCredentialsProvider</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"p4ssw0rd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collection<span class="token operator">&lt;</span>Ref<span class="token operator">></span> remoteRefs <span class="token operator">=</span> git<span class="token punctuation">.</span><span class="token function">lsRemote</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setCredentialsProvider</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setRemote</span><span class="token punctuation">(</span><span class="token string">"origin"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setTags</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">setHeads</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Ref ref <span class="token operator">:</span> remoteRefs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> ref<span class="token punctuation">.</span><span class="token function">getObjectId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这是一个 Git 类的公共样式，这个方法返回一个可以让你串连若干方法调用来设置参数的命令对象，当你调用 <code>.call()</code> 时它们就会被执行。 在这情况下，我们只是请求了 <code>origin</code> 远程的标签，而不是头部。 还要注意用于验证的 <code>CredentialsProvider</code> 对象的使用。</p><p>在 Git 类中还可以使用许多其它的命令，包括但不限于 <code>add</code>、<code>blame</code>、<code>commit</code>、<code>clean</code>、<code>push</code>、<code>rebase</code>、<code>revert</code> 和 <code>reset</code>。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>这只是 JGit 的全部能力的冰山一角。 如果你对这有兴趣并且想深入学习，在下面可以找到一些信息和灵感。</p><ul><li>JGit API 在线官方文档： <a href="http://download.eclipse.org/jgit/docs/latest/apidocs" target="_blank" rel="noopener">http://download.eclipse.org/jgit/docs/latest/apidocs</a> 。 这是基本的 Javadoc ，所以你也可以在你最喜欢的 JVM IDE 上将它们安装它们到本地。</li><li>JGit Cookbook ： <a href="https://github.com/centic9/jgit-cookbook" target="_blank" rel="noopener">https://github.com/centic9/jgit-cookbook</a> 拥有许多如何利用 JGit 实现特定任务的例子。</li><li><a href="http://stackoverflow.com/questions/6861881" target="_blank" rel="noopener">http://stackoverflow.com/questions/6861881</a> 指出了几个好的资源。</li></ul><p>在这一整本书里我们介绍了大量的 Git 命令，并尽可能的通过讲故事的的方式来介绍它们，慢慢的介绍了越来越多的命令。 但是这导致这些命令的示例用法都散落在在全书的各处。</p><p>在此附录中，我们会将本书中所提到过的命令都过一遍，并根据其用途大致的分类。 我们会大致地讨论每个命的作用，指出其在本书中哪些章节使用过。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录A:其他环境中的Git</title>
      <link href="/2019/07/15/%E9%99%84%E5%BD%95A-%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84Git/"/>
      <url>/2019/07/15/%E9%99%84%E5%BD%95A-%E5%85%B6%E4%BB%96%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84Git/</url>
      
        <content type="html"><![CDATA[<p>从头至尾读到了这里，你肯定已经掌握了不少使用 Git 命令行操作的知识。 你学会了操作本地文件，通过网络连接你的仓库，以及与他人进行有效率的合作。 但是故事并未就此结束；Git 通常只是更大的生态圈的一部分，在某些情况下使用终端并不是最合适的方式。 现在就让我们来了解一下如何在其它类型的环境中更好地使用 Git，以及别的应用（包括你的）如何与 Git 进行协作。</p><h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><p>Git 的原生环境是终端。 在那里，你可以体验到最新的功能，也只有在那里，你才能尽情发挥 Git 的全部能力。 但是对于某些任务而言，纯文本并不是最佳的选择；有时候你确实需要一个可视化的展示方式，而且有些用户更习惯那种能点击的界面。</p><p>有一点请注意，不同的界面是为不同的工作流程设计的。 一些客户端的作者为了支持某种他认为高效的工作流程，经过精心挑选，只显示了 Git 功能的一个子集。 每种工具都有其特定的目的和意义，从这个角度来看，不能说某种工具比其它的`‘更好’’。 还有请注意，没有什么事情是图形界面客户端可以做而命令行客户端不能做的；命令行始终是你可以完全操控仓库并发挥出全部力量的地方。</p><h3 id="gitk-和-git-gui"><a href="#gitk-和-git-gui" class="headerlink" title="gitk 和 git-gui"></a><code>gitk</code> 和 <code>git-gui</code></h3><p>在安装 Git 的同时，你也装好了它提供的可视化工具，<code>gitk</code> 和 <code>git-gui</code>。</p><p><code>gitk</code> 是一个历史记录的图形化查看器。 你可以把它当作是基于 <code>git log</code> 和 <code>git grep</code> 命令的一个强大的图形操作界面。 当你需要查找过去发生的某次记录，或是可视化查看项目历史的时候，你将会用到这个工具。</p><p>使用 Gitk 的最简单方法就是从命令行打开。 只需 <code>cd</code> 到一个 Git 仓库，然后键入：</p><pre class=" language-console"><code class="language-console">$ gitk [git log options]</code></pre><p>Gitk 可以接受很多命令行选项，其中的大部分都直接传给底层的 <code>git log</code> 去执行了。 <code>--all</code> 可能是这其中最有用的一个, 它告诉 gitk 去尽可能地从 <em>任何</em> 引用查找提交并显示，而不仅仅是从 HEAD。 Gitk 的界面看起来长这样：</p><p><img src="https://git-scm.com/book/en/v2/images/gitk.png" alt="`gitk` 历史查看器。"></p><p>Figure 153. <code>gitk</code> 历史查看器。</p><p>这张图看起来就和执行 <code>git log --graph</code> 命令的输出差不多；每个点代表一次提交，线代表父子关系，而彩色的方块则用来标示一个个引用。 黄点表示 HEAD，红点表示尚未提交的本地变动。 下方的窗口用来显示当前选中的提交的具体信息；评论和补丁显示在左侧，摘要显示在右侧。 中间则是一组用来搜索历史的控件。</p><p>与之相比，<code>git-gui</code> 则主要是一个用来制作提交的工具。 打开它的最简单方法也是从命令行启动：</p><pre class=" language-console"><code class="language-console">$ git gui</code></pre><p>它的界面长这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/git-gui.png" alt="`git-gui` 提交工具。"></p><p>Figure 154. <code>git-gui</code> 提交工具。</p><p>左侧是索引区；未暂存的修改显示在上方，已暂存的修改显示在下方。 你可以通过点击文件名左侧的图标来将该文件在暂存状态与未暂存状态之间切换，你也可以通过选中一个文件名来查看它的详情。</p><p>右侧窗口的上方以 diff 格式来显示当前选中文件发生了变动的地方。 你可以通过右击某一区块或行从而将这一区块或行放入暂存区。</p><p>右侧窗口的下方是写日志和执行操作的地方。 在文本框中键入日志然后点击 “提交” 就和执行 <code>git commit</code> 的效果差不多。 如果你想要修订上一次提交, 可以选中`‘修订’’ 按钮，上次一提交的内容就会显示在 “暂存区”。 然后你就可以简单的对修改进行暂存和取消暂存操作，更新提交日志，然后再次点击 “提交” 用这个新的提交来覆盖上一次提交。</p><p><code>gitk</code> 和 <code>git-gui</code> 就是针对某种任务设计的工具的两个例子。 它们分别为了不同的目的（即查看历史和制作提交）而进行了精简，略去了用不到的功能。</p><h3 id="Mac-和-Windows-上的-GitHub-客户端"><a href="#Mac-和-Windows-上的-GitHub-客户端" class="headerlink" title="Mac 和 Windows 上的 GitHub 客户端"></a>Mac 和 Windows 上的 GitHub 客户端</h3><p>GitHub 发布了两个面向工作流程的 Git 客户端：Windows 版，和 Mac 版。 它们很好的展示了一个面向工作流程的工具应该是什么样子——专注于提升那些常用的功能及其协作的可用性，而不是实现 Git 的 <em>所有</em>功能. 它们看起来长这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/github_mac.png" alt="GitHub Mac 客户端。"></p><p>Figure 155. GitHub Mac 客户端。</p><p><img src="https://git-scm.com/book/en/v2/images/github_win.png" alt="GitHub Windows 客户端。"></p><p>Figure 156. GitHub Windows 客户端。</p><p>我们在设计的时候就努力将二者的外观和操作体验都保持一致，因此本章会把他们当做同一个产品来介绍。 我们并不会详细地介绍该工具的每一个功能（因为它们本身也有文档），但请快速了解一下 “变更” 窗口（你大部分时间都会花在使用该窗口上）的以下几点：</p><ul><li>左侧是正在追踪的仓库的列表；通过点击左上方的 “+” 图标，你可以添加一个需要追踪的仓库（既可以是通过 clone，也可以从本地添加）。</li><li>中间是输入-提交区，你可以在这里输入提交日志，以及选择哪些文件需要被提交。 （在 Windows 上，提交历史就显示在这个区域的下方；在 Mac 上，提交历史有一个单独的窗口）</li><li>右侧是修改查看区，它会告诉你工作目录里哪些东西被修改了（译注：修改模式），或选中的提交里包括了哪些修改（译注：历史模式）。</li><li>最后需要熟悉的是右上角的 “Sync” 按钮，你主要通过这个按钮来进行网络上的交互。</li></ul><table><thead><tr><th>Note</th><th>你不需要注册 GitHub 账号也可以使用这些工具。 尽管它们是按照 GitHub 推荐的工作流程来设计的，并突出提升了一些 GitHub 的服务体验，但它们可以在任何 Git 仓库上工作良好，也可以通过网络连接到任意 Git 主机。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>GitHub 的 Windows 客户端可以从 <a href="https://windows.github.com/" target="_blank" rel="noopener">https://windows.github.com</a> 下载，Mac 客户端可以从 <a href="https://mac.github.com/" target="_blank" rel="noopener">https://mac.github.com</a>下载。 第一次打开软件时，它会引导你进行一系列的首次使用设置，例如设置你的姓名和电子邮件，它还会智能地帮你调整一些常用的默认设置，例如凭证缓存和 CRLF 的处理方式。</p><p>它们都是`‘绿色软件’’——如果软件打开发现有更新，下载和安装升级包都是在后台完成的。 为方便起见它们还打包了一份 Git，也就是说你一旦安装好就再也无需劳心升级的事情了。 Windows 的客户端还提供了快捷方式，可以启动装了 Posh-git 插件的 Powershell，在本章的后面一节我们会详细介绍这方面的内容。</p><p>接下来我们给它设置一些工作仓库。 客户端会显示你在 GitHub 上有权限操作的仓库的列表，你可以选择一个然后一键克隆。 如果你本地已经建立了仓库，只需要用鼠标把它从 Finder 或 Windows 资源管理器拖进 GitHub 客户端窗口，就可以把该仓库添加到左侧的仓库列表里面去了。</p><h4 id="推荐的工作流程"><a href="#推荐的工作流程" class="headerlink" title="推荐的工作流程"></a>推荐的工作流程</h4><p>安装并配置好以后，你就可以使用 GitHub 客户端来执行一些常见的 Git 任务。 该工具所推荐的工作流程有时也被叫做 “GitHub 流”。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_github_flow" target="_blank" rel="noopener">GitHub 流程</a> 一节中对此有详细的介绍，其要点是 (a) 你会提交到一个分支；(b) 你需要经常与远程仓库保持同步。</p><p>两个平台上的客户端在分支管理上有所不同。 在 Mac 上，创建分支的按钮在窗口的上方：</p><p><img src="https://git-scm.com/book/en/v2/images/branch_widget_mac.png" alt="Mac 上的``创建分支&#39;&#39;按钮。"></p><p>Figure 157. Mac 上的`‘创建分支’’按钮。</p><p>在 Windows 上，你可以通过在分支切换挂件中输入新分支的名称来完成创建：</p><p><img src="https://git-scm.com/book/en/v2/images/branch_widget_win.png" alt="在 Windows 上创建分支。"></p><p>Figure 158. 在 Windows 上创建分支。</p><p>分支创建好以后，新建提交就变得非常简单直接了。 现在工作目录中做一些修改，然后切换到 GitHub 客户端窗口，你所做的修改就会显示在那里。 输入提交日志，选中那些需要被包含在本次提交中的文件，然后点击 “提交” 按钮（也可以在键盘上按 ctrl-enter 或 ⌘-enter）。</p><p>“同步” 功能是你在网络上和其它仓库交互的主要途径。 push，fetch，merge，和 rebase 在 Git 内部是一连串独立的操作, 而 GitHub 客户端将这些操作都合并成了单独一个功能。 你点击同步按钮时实际上会发生如下这些操作：</p><ol><li><code>git pull --rebase</code>。 如果上述命令由于存在合并冲突而失败，则会退而执行 <code>git pull --no-rebase</code>。</li><li><code>git push</code>。</li></ol><p>如果你遵循推荐的工作流程，以上就是最常用的一系列命令，因此将它们合并为一个让事情简单了很多。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这些工具是为其各自针对的工作流程所量身定做的。 开发者和非开发者可以轻松地在分分钟内就搭建起项目协作环境，它们还内置了其它辅助最佳实践的功能。 但是，如果你的工作流程有所不同，或者你需要在进行网络操作时有更多的控制，那么建议你考虑一下其它客户端或者使用命令行。</p><h3 id="其它图形界面"><a href="#其它图形界面" class="headerlink" title="其它图形界面"></a>其它图形界面</h3><p>除此之外，还有许许多多其它的图形化 Git 客户端，其中既有单一功能的定制工具，也有试图提供 Git 所有功能的复杂应用。 Git 的官方网站整理了一份时下最流行的客户端的清单 <a href="http://git-scm.com/downloads/guis。" target="_blank" rel="noopener">http://git-scm.com/downloads/guis。</a> 在 Git 的维基站点还可以看到一份更全的清单 <a href="https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces" target="_blank" rel="noopener">https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces</a>.</p><h2 id="Visual-Studio-中的-Git"><a href="#Visual-Studio-中的-Git" class="headerlink" title="Visual Studio 中的 Git"></a>Visual Studio 中的 Git</h2><p>从 Visual Studio 2013 Update 1 版本开始，Visual Studio 用户可以在他们的 IDE 中直接使用内嵌的 Git 客户端。 Visual Studio 集成源代码版本控制特性已经有很长一段时间，但面向的是集中式、文件锁定方式的系统，Git 并不能很好地符合这种工作流程。 Visual Studio 2013 中已经支持 Git，并独立于原有版本管理系统，这使得 Visual Studio 和 Git 能更好地相互适应。</p><p>想要找到这个特性，在 Visual Studio 中打开一个已经用 Git 管理的项目（或者直接在项目目录中 <code>git init</code> ），选择菜单 View &gt; Team Explorer。 你将看到 “Connect” 视图，大概如下图所示：</p><p><img src="https://git-scm.com/book/en/v2/images/vs-1.png" alt="从 Team Explorer 中连接 Git 仓库。"></p><p>Figure 159. 从 Team Explorer 中连接 Git 仓库。</p><p>Visual Studio 能够记住所有你打开过的用 Git 管理的项目，它们都在下方的列表中。 如果没看到你想要的项目，点击 “Add” 按钮，添加项目工作目录的路径。 双击其中一个本地的 Git 仓库会将你带入 “Home” 视图，大概如 <a href="https://git-scm.com/book/zh/v2/ch00/rvs_home" target="_blank" rel="noopener">Visual Studio 中的 Git 仓库的 “Home” 视图。</a> 所示。 这是一个执行 Git 操作的操作中心；当你 <em>正在编写</em> 代码的时候，你可能主要关注 “Changes” 视图，当需要拉取同伴的改动时，你将使用 “Unsynced Commits” 和 “Branches” 视图。</p><p><img src="https://git-scm.com/book/en/v2/images/vs-2.png" alt="Visual Studio 中的 Git 仓库的 “Home” 视图。"></p><p>Figure 160. Visual Studio 中的 Git 仓库的 “Home” 视图。</p><p>Visual Studio 现在拥有一套着眼于任务的强大 Git 操作界面。 它包括线性的历史视图、diff 视图、远程仓库操作命令，以及其它很多功能。 这个特性的完整文档（放在这里并不合适）请参阅 <a href="http://msdn.microsoft.com/en-us/library/hh850437.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/hh850437.aspx</a> 。</p><h2 id="Eclipse-中的-Git"><a href="#Eclipse-中的-Git" class="headerlink" title="Eclipse 中的 Git"></a>Eclipse 中的 Git</h2><p>Eclipse 附带了一个名为 Egit 的插件，它提供了一个非常完善的 Git 操作接口。 这个插件可以通过切换到 Git 视图来使用：(Window &gt; Open Perspective &gt; Other…， 然后选择 “Git”）。</p><p><img src="https://git-scm.com/book/en/v2/images/egit.png" alt="Eclipse 中 EGit 的界面环境。"></p><p>Figure 161. Eclipse 中 EGit 的界面环境。</p><p>EGit 提供了许多强大的帮助文档，你能通过下面的操作来访问它：单击菜单 Help &gt; Help Contents，然后从内容列表中选择 “EGit Documentation” 节点。</p><h2 id="Bash-中的-Git"><a href="#Bash-中的-Git" class="headerlink" title="Bash 中的 Git"></a>Bash 中的 Git</h2><p>如果你是一名 Bash 用户，你可以从中发掘出一些 Shell 的特性，让你在使用 Git 时更加随心所欲。 实际上 Git 附带了几个 Shell 的插件，但是这些插件并不是默认打开的。</p><p>首先，你需要从 Git 源代码中获得一份 <code>contrib/completion/git-completion.bash</code> 文件的拷贝。 将这个文件复制到一个相对便捷的目录，例如你的 Home 目录，并且将它的路径添加到 <code>.bashrc</code> 中：</p><pre class=" language-console"><code class="language-console">. ~/git-completion.bash</code></pre><p>做完这些之后，请将你当前的目录切换到某一个 Git 仓库，并且输入：</p><pre class=" language-console"><code class="language-console">$ git chec<tab></code></pre><p>……此时 Bash 将会把上面的命令自动补全为 <code>git checkout</code>。 在适当的情况下，这项功能适用于 Git 所有的子命令、命令行参数、以及远程仓库与引用名。</p><p>这项功能也可以用于你自己定义的提示符（<code>prompt</code>），显示当前目录下 Git 仓库的信息。 根据你的需要，这个信息可以简单或复杂，这里通常有大多数人想要的几个关键信息，比如当前分支信息和当前工作目录的状态信息。 要添加你自己的提示符（<code>prompt</code>），只需从 Git 源版本库复制 <code>contrib/completion/git-prompt.sh</code> 文件到你的 Home 目录(或其他便于你访问与管理的目录)， 并在 <code>.bashrc</code> 里添加这个文件路径，类似于下面这样：</p><pre class=" language-console"><code class="language-console">. ~/git-prompt.shexport GIT_PS1_SHOWDIRTYSTATE=1export PS1='\w$(__git_ps1 " (%s)")\$ '</code></pre><p><code>\w</code> 表示打印当前工作目录，<code>\$</code> 打印 <code>$</code> 部分的提示符（<code>prompt</code>），<code>__git_ps1 &quot; (%s)&quot;</code> 表示通过格式化参数符（<code>%s</code>）调用<code>git-prompt.sh</code>脚本中提供的函数。 因为有了这个自定义提示符，现在你的 <code>Bash</code>提示符（<code>prompt</code>）在 Git 仓库的任何子目录中都将显示成这样：</p><p><img src="https://git-scm.com/book/en/v2/images/git-bash.png" alt="自定义的 `bash` 提示符（`prompt`）."></p><p>Figure 162. 自定义的 <code>bash</code> 提示符（<code>prompt</code>）.</p><p>这两个脚本都提供了很有帮助的文档；浏览 <code>git-completion.bash</code> 和 <code>git-prompt.sh</code> 的内容以获得更多信息。</p><h2 id="Zsh-中的-Git"><a href="#Zsh-中的-Git" class="headerlink" title="Zsh 中的 Git"></a>Zsh 中的 Git</h2><p>Git 还为 Zsh 提供了一个 Tab 补全库。 复制 <code>contrib/completion/git-completion.zsh</code> 到你的 home 目录，然后在 <code>.zshrc</code> 中 source 即可。 相对于 Bash，Zsh 的接口更加强大：</p><pre class=" language-console"><code class="language-console">$ git che<Tab>check-attr        -- 显示 gitattributes 信息check-ref-format  -- 检查引用名称是否符合规范checkout          -- 从工作区中检出分支或路径checkout-index    -- 从暂存区拷贝文件至工作目录cherry            -- 查找没有被合并至上游的提交cherry-pick       -- 从一些已存在的提交中应用更改</code></pre><p>意义不明的 Tab 补全并不仅仅会被列出；它们还会有帮助性的描述，你可以通过不断敲击 Tab 以图形方式浏览补全列表。 该功能可用于 Git 命令、它们的参数和在仓库中内容的名称（例如 refs 和 remotes），还有文件名和其他所有 Zsh 知道如何去补全的项目。</p><p>在提示符自定义方面，Zsh 很好地兼容了Bash，并允许你同时使用一个右侧提示符。 把如下代码添加至你的 <code>~/.zshrc</code> 文件中，就可以在右侧显示分支名称：</p><pre class=" language-console"><code class="language-console">setopt prompt_subst. ~/git-prompt.shexport RPROMPT=$'$(__git_ps1 "%s")'</code></pre><p>当你的命令行位于一个 Git 仓库目录时，在任何时候，都可以在命令行窗口右侧显示当前分支。 它看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/zsh-prompt.png" alt="自定义 `zsh` 提示符."></p><p>Figure 163. 自定义 <code>zsh</code> 提示符.</p><p>Zsh 本身已足够强大，但还有一些专门为它打造的完整框架，使它更加完善。 其中之一名为 “oh-my-zsh”，你可以在 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a> 找到它。 oh-my-zsh 的扩展系统包含强大的 Git Tab 补全功能，且许多提示符 “主题” 可以展示版本控制数据。 <a href="https://git-scm.com/book/zh/v2/ch00/roh_my_zsh_git" target="_blank" rel="noopener">一个 oh-my-zsh 主题的示例.</a> 只是可以其中一个可以通过该系统实现的例子。</p><p><img src="https://git-scm.com/book/en/v2/images/zsh-oh-my.png" alt="一个 oh-my-zsh 主题的示例."></p><p>Figure 164. 一个 oh-my-zsh 主题的示例.</p><h2 id="Powershell-中的-Git"><a href="#Powershell-中的-Git" class="headerlink" title="Powershell 中的 Git"></a>Powershell 中的 Git</h2><p>Windows 中的普通命令行终端 (<code>cmd.exe</code>) 无法自定义 Git 使用体验，但是如果你正在使用 Powershell，那么你就十分幸运了。 一个名为 Posh-Git (<a href="https://github.com/dahlbyk/posh-git" target="_blank" rel="noopener">https://github.com/dahlbyk/posh-git</a>) 的扩展包提供了强大的 tab 补全功能， 并针对提示符进行了增强，以帮助你聚焦于你的仓库状态。 它看起来像：</p><p><img src="https://git-scm.com/book/en/v2/images/posh-git.png" alt="附带了 Posh-Git 扩展包的 Powershell。"></p><p>Figure 165. 附带了 Posh-Git 扩展包的 Powershell。</p><p>如果你已经在 Windows 上安装了 GitHub，Posh-Git 也会被安装，你只需要添加以下两行到你的 <code>profile.ps1</code> 文件 (文件位于 <code>C:\Users\&lt;username&gt;\Documents\WindowsPowerShell</code>):</p><pre class=" language-powershell"><code class="language-powershell"><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token function">Resolve-Path</span> <span class="token string">"<span class="token variable">$env</span>:LOCALAPPDATA\GitHub\shell.ps1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token variable">$env</span>:github_posh_git\profile<span class="token punctuation">.</span>example<span class="token punctuation">.</span>ps1</code></pre><p>如果你没有在 Windows 上安装 GitHub，只需要从 (<a href="https://github.com/dahlbyk/posh-git" target="_blank" rel="noopener">https://github.com/dahlbyk/posh-git</a>) 下载一份 Posh-Git 发行版，并且解压至 <code>WindowsPowershell</code> 目录。 然后以管理员权限打开 Powershell 提示符，并且执行下面的命令：</p><pre class=" language-powershell"><code class="language-powershell">> <span class="token function">Set</span><span class="token operator">-</span>ExecutionPolicy RemoteSigned <span class="token operator">-</span>Scope CurrentUser <span class="token operator">-</span>Confirm> cd ~\Documents\WindowsPowerShell\posh<span class="token operator">-</span>git> <span class="token punctuation">.</span>\install<span class="token punctuation">.</span>ps1</code></pre><p>它将会向你的 <code>profile.ps1</code> 文件添加适当的内容，Posh-Git 将会在下次打开提示符时被启用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你已经学会了如何从日常工具中发挥 Git 的强大力量，以及从自己的程序中访问 Git 仓库的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git内部原理</title>
      <link href="/2019/07/15/Git%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2019/07/15/Git%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。 我们发现学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。 因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。</p><p>无论如何，既然已经读到了这里，就让我们开始吧。 首先要弄明白一点，从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。 马上你就会学到这意味着什么。</p><p>早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。 不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。</p><p>内容寻址文件系统层是一套相当酷的东西，所以在本章我们会先讲解这部分内容。随后我们会学习传输机制和版本库管理任务——你迟早会和它们打交道。</p><h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p>本书旨在讨论如何通过 <code>checkout</code>、<code>branch</code>、<code>remote</code> 等大约 30 个诸如此类动词形式的命令来玩转 Git。 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“高层（porcelain）”命令。</p><p>本书前九章专注于探讨高层命令。 然而在本章，我们将主要面对底层命令。 因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。 多数底层命令并不面向最终用户：它们更适合作为新命令和自定义脚本的组成部分。</p><p>当在一个新目录或已有目录执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的对象。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 该目录的结构如下所示：</p><pre class=" language-console"><code class="language-console">$ ls -F1HEADconfig*descriptionhooks/info/objects/refs/</code></pre><p>该目录下可能还会包含其他文件，不过对于一个全新的 <code>git init</code> 版本库，这将是你看到的默认结构。<code>description</code> 文件仅供 GitWeb 程序使用，我们无需关心。 <code>config</code> 文件包含项目特有的配置选项。<code>info</code> 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。 <code>hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts），在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_hooks" target="_blank" rel="noopener">Git 钩子</a> 中这部分话题已被详细探讨过。</p><p>剩下的四个条目很重要：<code>HEAD</code> 文件、（尚待创建的）<code>index</code> 文件，和 <code>objects</code> 目录、<code>refs</code> 目录。 这些条目是 Git 的核心组成部分。 <code>objects</code> 目录存储所有数据内容；<code>refs</code> 目录存储指向数据（分支）的提交对象的指针；<code>HEAD</code> 文件指示目前被检出的分支；<code>index</code> 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p><h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统。 看起来很酷， 但这是什么意思呢？ 这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 可以通过底层命令 <code>hash-object</code> 来演示上述效果——该命令可将任意数据保存于 <code>.git</code> 目录，并返回相应的键值。 首先，我们需要初始化一个新的 Git 版本库，并确认 <code>objects</code> 目录为空：</p><pre class=" language-console"><code class="language-console">$ git init testInitialized empty Git repository in /tmp/test/.git/$ cd test$ find .git/objects.git/objects.git/objects/info.git/objects/pack$ find .git/objects -type f</code></pre><p>可以看到 Git 对 <code>objects</code> 目录进行了初始化，并创建了 <code>pack</code> 和 <code>info</code> 子目录，但均为空。 接着，往 Git 数据库存入一些文本：</p><pre class=" language-console"><code class="language-console">$ echo 'test content' | git hash-object -w --stdind670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p><code>-w</code> 选项指示 <code>hash-object</code> 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。 <code>--stdin</code> 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。 现在我们可以查看 Git 是如何存储数据的：</p><pre class=" language-console"><code class="language-console">$ find .git/objects -type f.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>可以在 <code>objects</code> 目录下看到一个文件。 这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4test content</code></pre><p>至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。 我们同样可以将这些操作应用于文件中的内容。 例如，可以对一个文件进行简单的版本控制。 首先，创建一个新文件并将其内容存入数据库：</p><pre class=" language-console"><code class="language-console">$ echo 'version 1' > test.txt$ git hash-object -w test.txt83baae61804e65cc73a7201a7252750c76066a30</code></pre><p>接着，向文件里写入新内容，并再次将其存入数据库：</p><pre class=" language-console"><code class="language-console">$ echo 'version 2' > test.txt$ git hash-object -w test.txt1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre><p>数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p><pre class=" language-console"><code class="language-console">$ find .git/objects -type f.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>现在可以把文件内容恢复到第一个版本：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt$ cat test.txtversion 1</code></pre><p>或者第二个版本：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt$ cat test.txtversion 2</code></pre><p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）。 利用 <code>cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p><pre class=" language-console"><code class="language-console">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3ablob</code></pre><h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>接下来要探讨的对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p master^{tree}100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre><p><code>master^{tree}</code> 语法表示 <code>master</code> 分支上最新的提交所指向的树对象。 请注意，<code>lib</code> 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre><p>从概念上讲，Git 内部存储的数据有点像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-1.png" alt="简化版的 Git 数据模型。"></p><p>Figure 149. 简化版的 Git 数据模型。</p><p>你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。 因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 <code>update-index</code> 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。 利用该命令，可以把 test.txt 文件的首个版本人为地加入一个新的暂存区。 必须为上述命令指定 <code>--add</code> 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；同样必需的还有 <code>--cacheinfo</code> 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名：</p><pre class=" language-console"><code class="language-console">$ git update-index --add --cacheinfo 100644 \  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre><p>本例中，我们指定的文件模式为 <code>100644</code>，表明这是一个普通文件。 其他选择包括：<code>100755</code>，表示一个可执行文件；<code>120000</code>，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p><p>现在，可以通过 <code>write-tree</code> 命令将暂存区内容写入一个树对象。 此处无需指定 <code>-w</code> 选项——如果某个树对象此前并不存在的话，当调用 <code>write-tree</code> 命令时，它会根据当前暂存区状态自动创建一个新的树对象：</p><pre class=" language-console"><code class="language-console">$ git write-treed8329fc1cc938780ffdd9f94e0d364e0ea74f579$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre><p>不妨验证一下它确实是一个树对象：</p><pre class=" language-console"><code class="language-console">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579tree</code></pre><p>接着我们来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</p><pre class=" language-console"><code class="language-console">$ echo 'new file' > new.txt$ git update-index --cacheinfo 100644 \  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt$ git update-index --add new.txt</code></pre><p>暂存区现在包含了 test.txt 文件的新版本，和一个新文件：new.txt。 记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：</p><pre class=" language-console"><code class="language-console">$ git write-tree0155eb4229851634a0f03eb265b69f5a2d56f341$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre><p>我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（<code>1f7a7a</code>）是先前值的“第二版”。 只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。 本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code>选项，将一个已有的树对象作为子树读入暂存区：</p><pre class=" language-console"><code class="language-console">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579$ git write-tree3c4e9cd789d88d8d89c1073707c3585e41b0e614$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code>的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-2.png" alt="当前 Git 的数据内容结构。"></p><p>Figure 150. 当前 Git 的数据内容结构。</p><h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>现在有三个树对象，分别代表了我们想要跟踪的不同项目快照。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><p>可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。 我们从之前创建的第一个树对象开始：</p><pre class=" language-console"><code class="language-console">$ echo 'first commit' | git commit-tree d8329ffdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre><p>现在可以通过 <code>cat-file</code> 命令查看这个新提交对象：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p fdf4fc3tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579author Scott Chacon <schacon@gmail.com> 1243040974 -0700committer Scott Chacon <schacon@gmail.com> 1243040974 -0700first commit</code></pre><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的 <code>user.name</code> 和 <code>user.email</code> 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p><p>接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：</p><pre class=" language-console"><code class="language-console">$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3cac0cab538b970a37ea1e769cbbde608743bc96d$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre><p>这三个提交对象分别指向之前创建的三个树对象快照中的一个。 现在，如果对最后一个提交的 SHA-1 值运行 <code>git log</code> 命令，会出乎意料的发现，你已有一个货真价实的、可由 <code>git log</code> 查看的 Git 提交历史了：</p><pre class=" language-console"><code class="language-console">$ git log --stat 1a410ecommit 1a410efbd13591db07496601ebc7a059dd55cfe9Author: Scott Chacon <schacon@gmail.com>Date:   Fri May 22 18:15:24 2009 -0700    third commit bak/test.txt | 1 + 1 file changed, 1 insertion(+)commit cac0cab538b970a37ea1e769cbbde608743bc96dAuthor: Scott Chacon <schacon@gmail.com>Date:   Fri May 22 18:14:29 2009 -0700    second commit new.txt  | 1 + test.txt | 2 +- 2 files changed, 2 insertions(+), 1 deletion(-)commit fdf4fc3344e67ab068f836878b6c4951e3b15f3dAuthor: Scott Chacon <schacon@gmail.com>Date:   Fri May 22 18:09:34 2009 -0700    first commit test.txt | 1 + 1 file changed, 1 insertion(+)</code></pre><p>太神奇了： 就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。 这就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下。 下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：</p><pre class=" language-console"><code class="language-console">$ find .git/objects -type f.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre><p>如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-3.png" alt="你的 Git 目录下的所有对象。"></p><p>Figure 151. 你的 Git 目录下的所有对象。</p><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>前文曾提及，在存储内容时，会有个头部信息一并被保存。 让我们略花些时间来看看 Git 是如何存储其对象的。 通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。</p><p>可以通过 <code>irb</code> 命令启动 Ruby 的交互模式：</p><pre class=" language-console"><code class="language-console">$ irb>> content = "what is up, doc?"=> "what is up, doc?"</code></pre><p>Git 以对象类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）：</p><pre class=" language-console"><code class="language-console">>> header = "blob #{content.length}\0"=> "blob 16\u0000"</code></pre><p>Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。 在 Ruby 中可以这样计算 SHA-1 值——先通过 <code>require</code> 命令导入 SHA-1 digest 库，然后对目标字符串调用 <code>Digest::SHA1.hexdigest()</code>：</p><pre class=" language-console"><code class="language-console">>> store = header + content=> "blob 16\u0000what is up, doc?">> require 'digest/sha1'=> true>> sha1 = Digest::SHA1.hexdigest(store)=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</code></pre><p>Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。 先导入相应的库，然后对目标内容调用 <code>Zlib::Deflate.deflate()</code>：</p><pre class=" language-console"><code class="language-console">>> require 'zlib'=> true>> zlib_content = Zlib::Deflate.deflate(store)=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</code></pre><p>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在，可以通过 Ruby 中的 <code>FileUtils.mkdir_p()</code> 函数来创建它。 接着，通过 <code>File.open()</code> 打开这个文件。最后，对上一步中得到的文件句柄调用 <code>write()</code> 函数，以向目标文件写入之前那条 zlib 压缩过的内容：</p><pre class=" language-console"><code class="language-console">>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37">> require 'fileutils'=> true>> FileUtils.mkdir_p(File.dirname(path))=> ".git/objects/bd">> File.open(path, 'w') { |f| f.write zlib_content }=> 32</code></pre><p>就是这样——你已创建了一个有效的 Git 数据对象。 所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p><h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>我们可以借助类似于 <code>git log 1a410e</code> 这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住 <code>1a410e</code> 是最后一个提交。 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><p>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 <code>.git/refs</code> 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：</p><pre class=" language-console"><code class="language-console">$ find .git/refs.git/refs.git/refs/heads.git/refs/tags$ find .git/refs -type f</code></pre><p>若要创建一个新引用来帮助记忆最新提交所在的位置，从技术上讲我们只需简单地做如下操作：</p><pre class=" language-console"><code class="language-console">$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" > .git/refs/heads/master</code></pre><p>现在，你就可以在 Git 命令中使用这个刚创建的新引用来代替 SHA-1 值了：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=oneline  master1a410efbd13591db07496601ebc7a059dd55cfe9 third commitcac0cab538b970a37ea1e769cbbde608743bc96d second commitfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre><p>我们不提倡直接编辑引用文件。 如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成此事：</p><pre class=" language-console"><code class="language-console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre><p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。 若想在第二个提交上创建一个分支，可以这么做：</p><pre class=" language-console"><code class="language-console">$ git update-ref refs/heads/test cac0ca</code></pre><p>这个分支将只包含从第二个提交开始往前追溯的记录：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=oneline testcac0cab538b970a37ea1e769cbbde608743bc96d second commitfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre><p>至此，我们的 Git 数据库从概念上看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/data-model-4.png" alt="包含分支引用的 Git 目录对象。"></p><p>Figure 152. 包含分支引用的 Git 目录对象。</p><p>当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</p><h3 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h3><p>现在的问题是，当你执行 <code>git branch (branchname)</code> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 如果查看 HEAD 文件的内容，一般而言我们看到的类似这样：</p><pre class=" language-console"><code class="language-console">$ cat .git/HEADref: refs/heads/master</code></pre><p>如果执行 <code>git checkout test</code>，Git 会像这样更新 HEAD 文件：</p><pre class=" language-console"><code class="language-console">$ cat .git/HEADref: refs/heads/test</code></pre><p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p><p>你也可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>symbolic-ref</code>。 可以借助此命令来查看 HEAD 引用对应的值：</p><pre class=" language-console"><code class="language-console">$ git symbolic-ref HEADrefs/heads/master</code></pre><p>同样可以设置 HEAD 引用的值：</p><pre class=" language-console"><code class="language-console">$ git symbolic-ref HEAD refs/heads/test$ cat .git/HEADref: refs/heads/test</code></pre><p>不能把符号引用设置为一个不符合引用格式的值：</p><pre class=" language-console"><code class="language-console">$ git symbolic-ref HEAD testfatal: Refusing to point HEAD outside of refs/</code></pre><h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。 标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><p>正如 <a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics" target="_blank" rel="noopener">Git 基础</a> 中所讨论的那样，存在两种类型的标签：附注标签和轻量标签。 可以像这样创建一个轻量标签：</p><pre class=" language-console"><code class="language-console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre><p>这就是轻量标签的全部内容——一个固定的引用。 然而，一个附注标签则更复杂一些。 若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。 可以通过创建一个附注标签来验证这个过程（<code>-a</code> 选项指定了要创建的是一个附注标签）：</p><pre class=" language-console"><code class="language-console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</code></pre><p>下面是上述过程所建标签对象的 SHA-1 值：</p><pre class=" language-console"><code class="language-console">$ cat .git/refs/tags/v1.19585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre><p>现在对该 SHA-1 值运行 <code>cat-file</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2object 1a410efbd13591db07496601ebc7a059dd55cfe9type committag v1.1tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700test tag</code></pre><p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。 例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。 可以克隆一个 Git 版本库，然后通过执行下面的命令来在这个版本库中查看上述公钥：</p><pre class=" language-console"><code class="language-console">$ git cat-file blob junio-gpg-pub</code></pre><p>Linux 内核版本库同样有一个不指向提交对象的标签对象——首个被创建的标签对象所指向的是最初被引入版本库的那份内核源码所对应的树对象。</p><h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>我们将看到的第三种引用类型是远程引用（remote reference）。 如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 <code>refs/remotes</code> 目录下。 例如，你可以添加一个叫做 <code>origin</code> 的远程版本库，然后把 <code>master</code> 分支推送上去：</p><pre class=" language-console"><code class="language-console">$ git remote add origin git@github.com:schacon/simplegit-progit.git$ git push origin masterCounting objects: 11, done.Compressing objects: 100% (5/5), done.Writing objects: 100% (7/7), 716 bytes, done.Total 7 (delta 2), reused 4 (delta 1)To git@github.com:schacon/simplegit-progit.git  a11bef0..ca82a6d  master -> master</code></pre><p>此时，如果查看 <code>refs/remotes/origin/master</code> 文件，可以发现 <code>origin</code> 远程版本库的 <code>master</code> 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 <code>master</code> 分支所对应的 SHA-1 值：</p><pre class=" language-console"><code class="language-console">$ cat .git/refs/remotes/origin/masterca82a6dff817ec66f44342007202690a93763949</code></pre><p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，远程引用是只读的。 虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p><h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>让我们重新回到示例 Git 版本库的对象数据库。 目前为止，可以看到有 11 个对象——4 个数据对象、3 个树对象、3 个提交对象和 1 个标签对象：</p><pre class=" language-console"><code class="language-console">$ find .git/objects -type f.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre><p>Git 使用 zlib 压缩这些文件的内容，而且我们并没有存储太多东西，所以上文中的文件一共只占用了 925 字节。 接下来，我们会指引你添加一些大文件到版本库中，以此展示 Git 的一个很有趣的功能。 为了便于展示，我们要把之前在 Grit 库中用到过的 <code>repo.rb</code> 文件添加进来——这是一个大小约为 22K 的源代码文件：</p><pre class=" language-console"><code class="language-console">$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb$ git add repo.rb$ git commit -m 'added repo.rb'[master 484a592] added repo.rb 3 files changed, 709 insertions(+), 2 deletions(-) delete mode 100644 bak/test.txt create mode 100644 repo.rb rewrite test.txt (100%)</code></pre><p>如果你查看生成的树对象，可以看到 repo.rb 文件对应的数据对象的 SHA-1 值：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p master^{tree}100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre><p>接下来你可以使用 <code>git cat-file</code> 命令查看这个对象有多大：</p><pre class=" language-console"><code class="language-console">$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d522044</code></pre><p>现在，稍微修改这个文件，然后看看会发生什么：</p><pre class=" language-console"><code class="language-console">$ echo '# testing' >> repo.rb$ git commit -am 'modified repo a bit'[master 2431da6] modified repo.rb a bit 1 file changed, 1 insertion(+)</code></pre><p>查看这个提交生成的树对象，你会看到一些有趣的东西：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p master^{tree}100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</code></pre><p>repo.rb 对应一个与之前完全不同的数据对象，这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p><pre class=" language-console"><code class="language-console">$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e22054</code></pre><p>你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？</p><p>事实上 Git 可以那样做。 Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，你可以手动执行 <code>git gc</code> 命令让 Git 对对象进行打包：</p><pre class=" language-console"><code class="language-console">$ git gcCounting objects: 18, done.Delta compression using up to 8 threads.Compressing objects: 100% (14/14), done.Writing objects: 100% (18/18), done.Total 18 (delta 3), reused 0 (delta 0)</code></pre><p>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件：</p><pre class=" language-console"><code class="language-console">$ find .git/objects -type f.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4.git/objects/info/packs.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</code></pre><p>仍保留着的几个对象是未被任何提交记录引用的数据对象——在此例中是你之前创建的“what is up, doc?”和“test content”这两个示例数据对象。 因为你从没将它们添加至任何提交记录中，所以 Git 认为它们是悬空（dangling）的，不会将它们打包进新生成的包文件中。</p><p>剩下的文件是新创建的包文件和一个索引。 包文件包含了刚才从文件系统中移除的所有对象的内容。 索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。 有意思的是运行 <code>gc</code>命令前磁盘上的对象大小约为 22K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了 ⅔ 的磁盘占用空间。</p><p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 <code>git verify-pack</code> 这个底层命令可以让你查看已打包的内容：</p><pre class=" language-console"><code class="language-console">$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 1269bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 16780d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 31943168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \  deef2e1b793907545e50a2ea2ddb5ba6c58c45063c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \  deef2e1b793907545e50a2ea2ddb5ba6c58c45060155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 135083baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \  b042a60ef7dff760008df33cee372b945b6e884e1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282non delta: 15 objectschain length = 1: 3 objects.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</code></pre><p>此处，<code>033b4</code> 这个数据对象（即 repo.rb 文件的第一个版本，如果你还记得的话）引用了数据对象 <code>b042a</code>，即该文件的第二个版本。 命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 <code>b042a</code> 占用了 22K 空间，而 <code>033b4</code> 仅占用 9 字节。 同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p><p>最妙之处是你可以随时重新打包。 Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 <code>git gc</code> 命令来这么做。</p><h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><p>纵观全书，我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。 假设你添加了这样一个远程版本库：</p><pre class=" language-console"><code class="language-console">$ git remote add origin https://github.com/schacon/simplegit-progit</code></pre><p>上述命令会在你的 <code>.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（<code>origin</code>）、URL 和一个用于获取操作的引用规格（refspec）：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[remote "origin"]</span><span class="token constant">    url</span> <span class="token attr-value"><span class="token punctuation">=</span> https://github.com/schacon/simplegit-progit</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/*:refs/remotes/origin/*</span></code></pre><p>引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。 <code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><p>默认情况下，引用规格由 <code>git remote add</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。 所以，如果服务器上有一个 <code>master</code> 分支，我们可以在本地通过下面这种方式来访问该分支上的提交记录：</p><pre class=" language-console"><code class="language-console">$ git log origin/master$ git log remotes/origin/master$ git log refs/remotes/origin/master</code></pre><p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p><p>如果想让 Git 每次只拉取远程的 <code>master</code> 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p><pre><code>fetch = +refs/heads/master:refs/remotes/origin/master</code></pre><p>这仅是针对该远程版本库的 <code>git fetch</code> 操作的默认引用规格。 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格。 若要将远程的 <code>master</code> 分支拉到本地的 <code>origin/mymaster</code> 分支，可以运行：</p><pre class=" language-console"><code class="language-console">$ git fetch origin master:refs/remotes/origin/mymaster</code></pre><p>你也可以指定多个引用规格。 在命令行中，你可以按照如下的方式拉取多个分支：</p><pre class=" language-console"><code class="language-console">$ git fetch origin master:refs/remotes/origin/mymaster \     topic:refs/remotes/origin/topicFrom git@github.com:schacon/simplegit ! [rejected]        master     -> origin/mymaster  (non fast forward) * [new branch]      topic      -> origin/topic</code></pre><p>在这个例子中，对 <code>master</code> 分支的拉取操作被拒绝，因为它不是一个可以快进的引用。 我们可以通过在引用规格之前指定 <code>+</code> 号来覆盖该规则。</p><p>你也可以在配置文件中指定多个用于获取操作的引用规格。 如果想在每次获取时都包括 <code>master</code> 和 <code>experiment</code> 分支，添加如下两行：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[remote "origin"]</span><span class="token constant">    url</span> <span class="token attr-value"><span class="token punctuation">=</span> https://github.com/schacon/simplegit-progit</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/master:refs/remotes/origin/master</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/experiment:refs/remotes/origin/experiment</span></code></pre><p>我们不能在模式中使用部分通配符，所以像下面这样的引用规格是不合法的：</p><pre><code>fetch = +refs/heads/qa*:refs/remotes/origin/qa*</code></pre><p>但我们可以使用命名空间（或目录）来达到类似目的。 假设你有一个 QA 团队，他们推送了一系列分支，同时你只想要获取 <code>master</code> 和 QA 团队的所有分支而不关心其他任何分支，那么可以使用如下配置：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[remote "origin"]</span><span class="token constant">    url</span> <span class="token attr-value"><span class="token punctuation">=</span> https://github.com/schacon/simplegit-progit</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/master:refs/remotes/origin/master</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/qa/*:refs/remotes/origin/qa/*</span></code></pre><p>如果项目的工作流很复杂，有 QA 团队推送分支、开发人员推送分支、集成团队推送并且在远程分支上展开协作，你就可以像这样（在本地）为这些分支创建各自的命名空间，非常方便。</p><h3 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h3><p>像上面这样从远程版本库获取已在命名空间中的引用当然很棒，但 QA 团队最初应该如何将他们的分支放入远程的 <code>qa/</code> 命名空间呢？ 我们可以通过引用规格推送来完成这个任务。</p><p>如果 QA 团队想把他们的 <code>master</code> 分支推送到远程服务器的 <code>qa/master</code> 分支上，可以运行：</p><pre class=" language-console"><code class="language-console">$ git push origin master:refs/heads/qa/master</code></pre><p>如果他们希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在他们的配置文件中添加一条 <code>push</code> 值：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[remote "origin"]</span><span class="token constant">    url</span> <span class="token attr-value"><span class="token punctuation">=</span> https://github.com/schacon/simplegit-progit</span><span class="token constant">    fetch</span> <span class="token attr-value"><span class="token punctuation">=</span> +refs/heads/*:refs/remotes/origin/*</span><span class="token constant">    push</span> <span class="token attr-value"><span class="token punctuation">=</span> refs/heads/master:refs/heads/qa/master</span></code></pre><p>正如刚才所指出的，这会让 <code>git push origin</code> 默认把本地 <code>master</code> 分支推送到远程 <code>qa/master</code> 分支。</p><h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：</p><pre class=" language-console"><code class="language-console">$ git push origin :topic</code></pre><p>因为引用规格（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 <code>topic</code> 分支定义为空值，也就是删除它。</p><p>或者你可以使用更新的语法（自Git v1.7.0以后可用）：</p><pre class=" language-console"><code class="language-console">$ git push origin --delete topic</code></pre><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。 本节将会带你快速浏览这两种协议的运作方式。</p><h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><table><thead><tr><th>Note</th><th>现在已经很少使用哑协议了。 使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。 一般情况下都建议使用智能协议，我们会在后面进行介绍。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>让我们通过 simplegit 版本库来看看 <code>http-fetch</code> 的过程：</p><pre class=" language-console"><code class="language-console">$ git clone http://server/simplegit-progit.git</code></pre><p>它做的第一件事就是拉取 <code>info/refs</code> 文件。 这个文件是通过 <code>update-server-info</code> 命令生成的，这也解释了在使用HTTP传输时，必须把它设置为 <code>post-receive</code> 钩子的原因：</p><pre><code>=&gt; GET info/refsca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre><p>现在，你得到了一个远程引用和 SHA-1 值的列表。 接下来，你要确定 HEAD 引用是什么，这样你就知道在完成后应该被检出到工作目录的内容：</p><pre><code>=&gt; GET HEADref: refs/heads/master</code></pre><p>这说明在完成抓取后，你需要检出 <code>master</code> 分支。 这时，你就可以开始遍历处理了。 因为你是从 <code>info/refs</code> 文件中所提到的 <code>ca82a6</code> 提交对象开始的，所以你的首要操作是获取它：</p><pre><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949(179 bytes of binary data)</code></pre><p>你取回了一个对象——这是一个在服务端以松散格式保存的对象，是你通过使用静态 HTTP GET 请求获取的。 你可以使用 zlib 解压缩它，去除其头部，查看提交记录的内容：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949tree cfda3bf379e4f8dba8717dee55aab78aef7f4dafparent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7author Scott Chacon <schacon@gmail.com> 1205815931 -0700committer Scott Chacon <schacon@gmail.com> 1240030591 -0700changed the version number</code></pre><p>接下来，你还要再获取两个对象，一个是树对象 <code>cfda3b</code>，它包含有我们刚刚获取的提交对象所指向的内容，另一个是它的父提交 <code>085bb3</code>：</p><pre><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7(179 bytes of data)</code></pre><p>这样就取得了你的下一个提交对象。 再抓取树对象：</p><pre><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf(404 - Not Found)</code></pre><p>噢——看起来这个树对象在服务端并不以松散格式对象存在，所以你得到了一个 404 响应，代表在 HTTP 服务端没有找到该对象。 这有好几个可能的原因——这个对象可能在替代版本库里面，或者在包文件里面。 Git 会首先检查所有列出的替代版本库：</p><pre><code>=&gt; GET objects/info/http-alternates(empty file)</code></pre><p>如果这返回了一个包含替代版本库 URL 的列表，那么 Git 就会去那些地址检查松散格式对象和文件——这是一种能让派生项目共享对象以节省磁盘的好方法。 然而，在这个例子中，没有列出可用的替代版本库。所以你所需要的对象肯定在某个包文件中。 要检查服务端有哪些可用的包文件，你需要获取 <code>objects/info/packs</code> 文件，这里面有一个包文件列表（它也是通过执行 <code>update-server-info</code> 所生成的）：</p><pre><code>=&gt; GET objects/info/packsP pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre><p>服务端只有一个包文件，所以你要的对象显然就在里面。但是你要先检查它的索引文件以确认。 即使服务端有多个包文件，这也是很有用的，因为这样你就可以知道你所需要的对象是在哪一个包文件里面：</p><pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx(4k of binary data)</code></pre><p>现在你有这个包文件的索引，你可以查看你要的对象是否在里面——因为索引文件列出了这个包文件所包含的所有对象的 SHA-1 值，和该对象存在于包文件中的偏移量。 你的对象就在这里，接下来就是获取整个包文件：</p><pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack(13k of binary data)</code></pre><p>现在你也有了你的树对象，你可以继续在提交记录上漫游。 它们全部都在这个你刚下载的包文件里面，所以你不用继续向服务端请求更多下载了。 Git 会将开始时下载的 HEAD 引用所指向的 <code>master</code> 分支检出到工作目录。</p><h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><h4 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h4><p>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</p><h6 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h6><p>举例来说，在项目中使用命令 <code>git push origin master</code> 时, <code>origin</code> 是由基于 SSH 协议的 URL 所定义的。 Git 会运行 <code>send-pack</code> 进程，它会通过 SSH 连接你的服务器。 它会尝试通过 SSH 在服务端执行命令，就像这样：</p><pre class=" language-console"><code class="language-console">$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \    delete-refs side-band-64k quiet ofs-delta \    agent=git/2:2.1.1+github-607-gfba4028 delete-refs0000</code></pre><p><code>git-receive-pack</code> 命令会立即为它所拥有的每一个引用发送一行响应——在这个例子中，就只有 <code>master</code> 分支和它的 SHA-1 值。 第一行响应中也包含了一个服务端能力的列表（这里是 <code>report-status</code>、<code>delete-refs</code> 和一些其它的，包括客户端的识别码）。</p><p>每一行以一个四位的十六进制值开始，用于指明本行的长度。 你看到第一行以 005b 开始，这在十六进制中表示 91，意味着第一行有 91 字节。 下一行以 003e 起始，也就是 62，所以下面需要读取 62 字节。 再下一行是 0000，表示服务端已完成了发送引用列表过程。</p><p>现在它知道了服务端的状态，你的 <code>send-pack</code> 进程会判断哪些提交记录是它所拥有但服务端没有的。<code>send-pack</code> 会告知 <code>receive-pack</code> 这次推送将会更新的各个引用。 举个例子，如果你正在更新 <code>master</code>分支，并且增加 <code>experiment</code> 分支，这个 <code>send-pack</code> 的响应将会是像这样：</p><pre><code>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \    refs/heads/master report-status006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \    refs/heads/experiment0000</code></pre><p>Git 会为每一个将要更新的引用发送一行数据，包括该行长度，旧 SHA-1 值，新 SHA-1 值和将要更新的引用。 第一行也包括了客户端的能力。 这里的全为 <em>0</em> 的 SHA-1 值表示之前没有过这个引用——因为你正要添加新的 experiment 引用。 删除引用时，将会看到相反的情况：右边的 SHA-1 值全为 <em>0</em>。</p><p>接下来，客户端会发送一个包文件，它包含了所有服务端还没有的对象。 最后，服务端会以成功（或失败）响应：</p><pre><code>000eunpack ok</code></pre><h6 id="HTTP-S"><a href="#HTTP-S" class="headerlink" title="HTTP(S)"></a>HTTP(S)</h6><p>HTTPS 与 HTTP 相比较，除了在“握手”过程略有不同外，其他基本相似。 连接是从下面这个请求开始的：</p><pre><code>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack001f# service=git-receive-pack00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \    delete-refs side-band-64k quiet ofs-delta \    agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e0000</code></pre><p>这完成了客户端和服务端的第一次数据交换。 接下来客户端发起另一个请求，这次是一个 <code>POST</code> 请求，这个请求中包含了 <code>git-upload-pack</code> 提供的数据。</p><pre><code>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</code></pre><p>这个 <code>POST</code> 请求的内容是 <code>send-pack</code> 的输出和相应的包文件。 服务端在收到请求后相应地作出成功或失败的 HTTP 响应。</p><h4 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h4><p>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</p><h6 id="SSH-1"><a href="#SSH-1" class="headerlink" title="SSH"></a>SSH</h6><p>如果你通过 SSH 使用抓取功能，<code>fetch-pack</code> 会像这样运行：</p><pre class=" language-console"><code class="language-console">$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"</code></pre><p>在 <code>fetch-pack</code> 连接后，<code>upload-pack</code> 会返回类似下面的内容：</p><pre><code>00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \    side-band side-band-64k ofs-delta shallow no-progress include-tag \    multi_ack_detailed symref=HEAD:refs/heads/master \    agent=git/2:2.1.1+github-607-gfba4028003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master0000</code></pre><p>这与 <code>receive-pack</code> 的响应很相似，但是这里所包含的能力是不同的。 而且它还包含 HEAD 引用所指向内容（<code>symref=HEAD:refs/heads/master</code>），这样如果客户端执行的是克隆，它就会知道要检出什么。</p><p>这时候，<code>fetch-pack</code> 进程查看它自己所拥有的对象，并响应 “want” 和它需要的对象的 SHA-1 值。 它还会发送“have”和所有它已拥有的对象的 SHA-1 值。 在列表的最后，它还会发送“done”以通知 <code>upload-pack</code> 进程可以开始发送它所需对象的包文件：</p><pre><code>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e70009done0000</code></pre><h6 id="HTTP-S-1"><a href="#HTTP-S-1" class="headerlink" title="HTTP(S)"></a>HTTP(S)</h6><p>抓取操作的握手需要两个 HTTP 请求。 第一个是向和哑协议中相同的端点发送 <code>GET</code> 请求：</p><pre><code>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack001e# service=git-upload-pack00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \    side-band side-band-64k ofs-delta shallow no-progress include-tag \    multi_ack_detailed no-done symref=HEAD:refs/heads/master \    agent=git/2:2.1.1+github-607-gfba4028003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master0000</code></pre><p>这和通过 SSH 使用 <code>git-upload-pack</code> 是非常相似的，但是第二个数据交换则是一个单独的请求：</p><pre><code>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.00032want 0a53e9ddeaddad63ad106860237bbf53411d11a70032have 441b40d833fdfa93eb2908e52742248faf0ee9930000</code></pre><p>这个输出格式还是和前面一样的。 这个请求的响应包含了所需要的包文件，并指明成功或失败。</p><h3 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h3><p>这一章节是传输协议的一个概貌。 传输协议还有很多其它的特性，像是 <code>multi_ack</code> 或 <code>side-band</code>，但是这些内容已经超出了本书的范围。 我们希望能给你展示客户端和服务端之间的基本交互过程；如果你需要更多的相关知识，你可以参阅 Git 的源代码。</p><h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><p>有的时候，你需要对仓库进行清理 - 使它的结构变得更紧凑，或是对导入的仓库进行清理，或是恢复丢失的内容。 这个小节将会介绍这些情况中的一部分。</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。 “gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p><p>可以像下面一样手动执行自动垃圾回收：</p><pre class=" language-console"><code class="language-console">$ git gc --auto</code></pre><p>就像上面提到的，这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。 你可以通过修改 <code>gc.auto</code> 与 <code>gc.autopacklimit</code> 的设置来改动这些数值。</p><p><code>gc</code> 将会做的另一件事是打包你的引用到一个单独的文件。 假设你的仓库包含以下分支与标签：</p><pre class=" language-console"><code class="language-console">$ find .git/refs -type f.git/refs/heads/experiment.git/refs/heads/master.git/refs/tags/v1.0.git/refs/tags/v1.1</code></pre><p>如果你执行了 <code>git gc</code> 命令，<code>refs</code> 目录中将不会再有这些文件。 为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中，就像这样：</p><pre class=" language-console"><code class="language-console">$ cat .git/packed-refs# pack-refs with: peeled fully-peeledcac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experimentab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/mastercac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.09585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre><p>如果你更新了引用，Git 并不会修改这个文件，而是向 <code>refs/heads</code> 创建一个新的文件。 为了获得指定引用的正确 SHA-1 值，Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找。 所以，如果你在 <code>refs</code> 目录中找不到一个引用，那么它或许在 <code>packed-refs</code> 文件中。</p><p>注意这个文件的最后一行，它会以 <code>^</code> 开头。 这个符号表示它上一行的标签是附注标签，<code>^</code> 所在的那一行是附注标签指向的那个提交。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？</p><p>下面的例子将硬重置你的测试仓库中的 master 分支到一个旧的提交，以此来恢复丢失的提交。 首先，让我们看看你的仓库现在在什么地方：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=onelineab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit484a59275031909e19aadb7c92262719cfcdf19a added repo.rb1a410efbd13591db07496601ebc7a059dd55cfe9 third commitcac0cab538b970a37ea1e769cbbde608743bc96d second commitfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre><p>现在，我们将 <code>master</code> 分支硬重置到第三次提交：</p><pre class=" language-console"><code class="language-console">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9HEAD is now at 1a410ef third commit$ git log --pretty=oneline1a410efbd13591db07496601ebc7a059dd55cfe9 third commitcac0cab538b970a37ea1e769cbbde608743bc96d second commitfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre><p>现在顶部的两个提交已经丢失了 - 没有分支指向这些提交。 你需要找出最后一次提交的 SHA-1 然后增加一个指向它的分支。 窍门就是找到最后一次的提交的 SHA-1 - 但是估计你记不起来了，对吗？</p><p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 <code>git update-ref</code> 命令更新，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_refs" target="_blank" rel="noopener">Git 引用</a> 有提到使用这个命令而不是是直接将 SHA-1 的值写入引用文件中的原因。 你可以在任何时候通过执行 <code>git reflog</code> 命令来了解你曾经做过什么：</p><pre class=" language-console"><code class="language-console">$ git reflog1a410ef HEAD@{0}: reset: moving to 1a410efab1afef HEAD@{1}: commit: modified repo.rb a bit484a592 HEAD@{2}: commit: added repo.rb</code></pre><p>这里可以看到我们已经检出的两次提交，然而并没有足够多的信息。 为了使显示的信息更加有用，我们可以执行 <code>git log -g</code>，这个命令会以标准日志的格式输出引用日志。</p><pre class=" language-console"><code class="language-console">$ git log -gcommit 1a410efbd13591db07496601ebc7a059dd55cfe9Reflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)Reflog message: updating HEADAuthor: Scott Chacon <schacon@gmail.com>Date:   Fri May 22 18:22:37 2009 -0700        third commitcommit ab1afef80fac8e34258ff41fc1b867c702daa24bReflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)Reflog message: updating HEADAuthor: Scott Chacon <schacon@gmail.com>Date:   Fri May 22 18:15:24 2009 -0700       modified repo.rb a bit</code></pre><p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。 例如，你可以创建一个名为 <code>recover-branch</code> 的分支指向这个提交（ab1afef）：</p><pre class=" language-console"><code class="language-console">$ git branch recover-branch ab1afef$ git log --pretty=oneline recover-branchab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit484a59275031909e19aadb7c92262719cfcdf19a added repo.rb1a410efbd13591db07496601ebc7a059dd55cfe9 third commitcac0cab538b970a37ea1e769cbbde608743bc96d second commitfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre><p>不错，现在有一个名为 <code>recover-branch</code> 的分支是你的 <code>master</code> 分支曾经指向的地方，再一次使得前两次提交可到达了。 接下来，假设你丢失的提交因为某些原因不在引用日志中 - 我们可以通过移除 <code>recover-branch</code> 分支并删除引用日志来模拟这种情况。 现在前两次提交又不被任何分支指向了：</p><pre class=" language-console"><code class="language-console">$ git branch -D recover-branch$ rm -Rf .git/logs/</code></pre><p>由于引用日志数据存放在 <code>.git/logs/</code> 目录中，现在你已经没有引用日志了。 这时该如何恢复那次提交？ 一种方式是使用 <code>git fsck</code> 实用工具，将会检查数据库的完整性。 如果使用一个 <code>--full</code> 选项运行它，它会向你显示出所有没有被其他对象指向的对象：</p><pre class=" language-console"><code class="language-console">$ git fsck --fullChecking object directories: 100% (256/256), done.Checking objects: 100% (18/18), done.dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24bdangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre><p>在这个例子中，你可以在 “dangling commit” 后看到你丢失的提交。 现在你可以用和之前相同的方法恢复这个提交，也就是添加一个指向这个提交的分支。</p><h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>Git 有很多很棒的功能，但是其中一个特性会导致问题，<code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。 如果所有的东西都是源代码那么这很好，因为 Git 被高度优化来有效地存储这种数据。 然而，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p><p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题。 因为这些版本控制系统并不下载所有的历史文件，所以这种文件所带来的问题比较少。 如果你从其他的版本控制系统迁移到 Git 时发现仓库比预期的大得多，那么你就需要找到并移除这些大文件。</p><p><strong>警告：这个操作对提交历史的修改是破坏性的。</strong> 它会从你必须修改或移除一个大文件引用最早的树对象开始重写每一次提交。 如果你在导入仓库后，在任何人开始基于这些提交工作前执行这个操作，那么将不会有任何问题 - 否则，你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上。</p><p>为了演示，我们将添加一个大文件到测试仓库中，并在下一次提交中删除它，现在我们需要找到它，并将它从仓库中永久删除。 首先，添加一个大文件到仓库中：</p><pre class=" language-console"><code class="language-console">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz > git.tgz$ git add git.tgz$ git commit -m 'add git tarball'[master 7b30847] add git tarball 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 git.tgz</code></pre><p>哎呀 - 其实这个项目并不需要这个巨大的压缩文件。 现在我们将它移除：</p><pre class=" language-console"><code class="language-console">$ git rm git.tgzrm 'git.tgz'$ git commit -m 'oops - removed large tarball'[master dadf725] oops - removed large tarball 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 git.tgz</code></pre><p>现在，我们执行 <code>gc</code> 来查看数据库占用了多少空间：</p><pre class=" language-console"><code class="language-console">$ git gcCounting objects: 17, done.Delta compression using up to 8 threads.Compressing objects: 100% (13/13), done.Writing objects: 100% (17/17), done.Total 17 (delta 1), reused 10 (delta 0)</code></pre><p>你也可以执行 <code>count-objects</code> 命令来快速的查看占用空间大小：</p><pre class=" language-console"><code class="language-console">$ git count-objects -vcount: 7size: 32in-pack: 17packs: 1size-pack: 4868prune-packable: 0garbage: 0size-garbage: 0</code></pre><p><code>size-pack</code> 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。 在最后一次提交前，使用了不到 2KB - 显然，从之前的提交中移除文件并不能从历史中移除它。 每一次有人克隆这个仓库时，他们将必须克隆所有的 5MB 来获得这个微型项目，只因为你意外地添加了一个大文件。 现在来让我们彻底的移除这个文件。</p><p>首先你必须找到它。 在本例中，你已经知道是哪个文件了。 但是假设你不知道；该如何找出哪个文件或哪些文件占用了如此多的空间？ 如果你执行 <code>git gc</code> 命令，所有的对象将被放入一个包文件中，你可以通过运行 <code>git verify-pack</code> 命令，然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。 你也可以将这个命令的执行结果通过管道传送给 <code>tail</code> 命令，因为你只需要找到列在最后的几个大对象。</p><pre class=" language-console"><code class="language-console">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \  | sort -k 3 -n \  | tail -3dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 497769682c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre><p>你可以看到这个大对象出现在返回结果的最底部：占用 5MB 空间。 为了找出具体是哪个文件，可以使用 <code>rev-list</code> 命令，我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_enforcing_commit_message_format" target="_blank" rel="noopener">指定特殊的提交信息格式</a> 中曾提到过。 如果你传递 <code>--objects</code> 参数给 <code>rev-list</code> 命令，它就会列出所有提交的 SHA-1、数据对象的 SHA-1 和与它们相关联的文件路径。 可以使用以下命令来找出你的数据对象的名字：</p><pre class=" language-console"><code class="language-console">$ git rev-list --objects --all | grep 82c99a382c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre><p>现在，你只需要从过去所有的树中移除这个文件。 使用以下命令可以轻松地查看哪些提交对这个文件产生改动：</p><pre class=" language-console"><code class="language-console">$ git log --oneline --branches -- git.tgzdadf725 oops - removed large tarball7b30847 add git tarball</code></pre><p>现在，你必须重写 <code>7b30847</code> 提交之后的所有提交来从 Git 历史中完全移除这个文件。 为了执行这个操作，我们要使用 <code>filter-branch</code> 命令，这个命令在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rewriting_history" target="_blank" rel="noopener">重写历史</a> 中也使用过：</p><pre class=" language-console"><code class="language-console">$ git filter-branch --index-filter \  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)Ref 'refs/heads/master' was rewritten</code></pre><p><code>--index-filter</code> 选项类似于在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rewriting_history" target="_blank" rel="noopener">重写历史</a> 中提到的的 <code>--tree-filter</code> 选项，不过这个选项并不会让命令将修改在硬盘上检出的文件，而只是修改在暂存区或索引中的文件。</p><p>你必须使用 <code>git rm --cached</code> 命令来移除文件，而不是通过类似 <code>rm file</code> 的命令 - 因为你需要从索引中移除它，而不是磁盘中。 还有一个原因是速度 - Git 在运行过滤器时，并不会检出每个修订版本到磁盘中，所以这个过程会非常快。 如果愿意的话，你也可以通过 <code>--tree-filter</code> 选项来完成同样的任务。<code>git rm</code> 命令的 <code>--ignore-unmatch</code> 选项告诉命令：如果尝试删除的模式不存在时，不提示错误。 最后，使用 <code>filter-branch</code> 选项来重写自 <code>7b30847</code> 提交以来的历史，也就是这个问题产生的地方。 否则，这个命令会从最旧的提交开始，这将会花费许多不必要的时间。</p><p>你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 <code>.git/refs/original</code> 通过 <code>filter-branch</code> 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据库。 在重新打包前需要移除任何包含指向那些旧提交的指针的文件：</p><pre class=" language-console"><code class="language-console">$ rm -Rf .git/refs/original$ rm -Rf .git/logs/$ git gcCounting objects: 15, done.Delta compression using up to 8 threads.Compressing objects: 100% (11/11), done.Writing objects: 100% (15/15), done.Total 15 (delta 1), reused 12 (delta 0)</code></pre><p>让我们看看你省了多少空间。</p><pre class=" language-console"><code class="language-console">$ git count-objects -vcount: 11size: 4904in-pack: 15packs: 1size-pack: 8prune-packable: 0garbage: 0size-garbage: 0</code></pre><p>打包的仓库大小下降到了 8K，比 5MB 好很多。 可以从 size 的值看出，这个大文件还在你的松散对象中，并没有消失；但是它不会在推送或接下来的克隆中出现，这才是最重要的。 如果真的想要删除它，可以通过有 <code>--expire</code> 选项的 <code>git prune</code> 命令来完全地移除那个对象：</p><pre class=" language-console"><code class="language-console">$ git prune --expire now$ git count-objects -vcount: 0size: 0in-pack: 15packs: 1size-pack: 8prune-packable: 0garbage: 0size-garbage: 0</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Git 总是在一个 <code>bash</code> shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。 有时候，知道它们是什么以及它们如何让 Git 按照你想要的方式去运行会很有用。 这里不会列出所有的 Git 环境变量，但我们会涉及最有的那部分。</p><h3 id="全局行为"><a href="#全局行为" class="headerlink" title="全局行为"></a>全局行为</h3><p>像通常的程序一样，Git 的常规行为依赖于环境变量。</p><p><strong>GIT_EXEC_PATH</strong> 决定 Git 到哪找它的子程序 （像 <code>git-commit</code>, <code>git-diff</code> 等等）。 你可以用 <code>git --exec-path</code> 来查看当前设置。</p><p>通常不会考虑修改 <strong>HOME</strong> 这个变量（太多其它东西都依赖它），这是 Git 查找全局配置文件的地方。 如果你想要一个包括全局配置的真正的便携版 Git， 你可以在便携版 Git 的 shell 配置中覆盖 <code>HOME</code> 设置。</p><p><strong>PREFIX</strong> 也类似，除了用于系统级别的配置。 Git 在 <code>$PREFIX/etc/gitconfig</code> 查找此文件。</p><p>如果设置了 <strong>GIT_CONFIG_NOSYSTEM</strong>，就禁用系统级别的配置文件。 这在系统配置影响了你的命令，而你又无权限修改的时候很有用。</p><p><strong>GIT_PAGER</strong> 控制在命令行上显示多页输出的程序。 如果这个没有设置，就会用 <code>PAGER</code> 。</p><p><strong>GIT_EDITOR</strong> 当用户需要编辑一些文本（比如提交信息）时， Git 会启动这个编辑器。 如果没设置，就会用 <code>EDITOR</code> 。</p><h3 id="版本库位置"><a href="#版本库位置" class="headerlink" title="版本库位置"></a>版本库位置</h3><p>Git 用了几个变量来确定它如何与当前版本库交互。</p><p><strong>GIT_DIR</strong> 是 <code>.git</code> 目录的位置。 如果这个没有设置， Git 会按照目录树逐层向上查找 <code>.git</code> 目录，直到到达 <code>~</code> 或 <code>/</code>。</p><p><strong>GIT_CEILING_DIRECTORIES</strong> 控制查找 <code>.git</code> 目录的行为。 如果你访问加载很慢的目录（如那些磁带机上的或通过网络连接访问的），你可能会想让 Git 早点停止尝试，尤其是 shell 构建时调用了 Git 。</p><p><strong>GIT_WORK_TREE</strong> 是非空版本库的工作目录的根路径。 如果没指定，就使用 <code>$GIT_DIR</code> 的父目录。</p><p><strong>GIT_INDEX_FILE</strong> 是索引文件的路径（只有非空版本库有）。</p><p><strong>GIT_OBJECT_DIRECTORY</strong> 用来指定 <code>.git/objects</code> 目录的位置。</p><p><strong>GIT_ALTERNATE_OBJECT_DIRECTORIES</strong> 一个冒号分割的列表 (格式类似 <code>/dir/one:/dir/two:…</code>) 用来告诉 Git 到哪里去找不在 <code>GIT_OBJECT_DIRECTORY</code> 目录中的对象。 如果你有很多项目有相同内容的大文件，这个可以用来避免存储过多备份。</p><h3 id="路径规则"><a href="#路径规则" class="headerlink" title="路径规则"></a>路径规则</h3><p>所谓 “pathspec” 是指你在 Git 中如何指定路径， 包括通配符的使用。 它们会在 <code>.gitignore</code> 文件中用到，命令行里也会用到 （<code>git add *.c</code>）。</p><p><strong>GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS</strong> 控制通配符在路径规则中的默认行为。 如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。意思是 <code>*.c</code> 只会匹配 <em>文件名是</em> “<em>.c” 的文件， 而不是以 <code>.c</code> 结尾的文件。 你可以在各个路径规格中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 `:(glob)</em>.c` 。</p><p><strong>GIT_LITERAL_PATHSPECS</strong> 禁用上面的两种行为；通配符将不能用，前缀覆盖也不能用。</p><p><strong>GIT_ICASE_PATHSPECS</strong> 让所有的路径规格忽略大小写。</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>Git 提交对象的创建通常最后是由 <code>git-commit-tree</code> 来完成， <code>git-commit-tree</code> 用这些环境变量作主要的信息源。 仅当这些值不存在才回退到预置的值。</p><p><strong>GIT_AUTHOR_NAME</strong> 是 “author” 字段的可读的名字。</p><p><strong>GIT_AUTHOR_EMAIL</strong> 是 “author” 字段的邮件。</p><p><strong>GIT_AUTHOR_DATE</strong> 是 “author” 字段的时间戳。</p><p><strong>GIT_COMMITTER_NAME</strong> 是 “committer” 字段的可读的名字。</p><p><strong>GIT_COMMITTER_EMAIL</strong> 是 “committer” 字段的邮件。</p><p><strong>GIT_COMMITTER_DATE</strong> 是 “committer” 字段的时间戳。</p><p>如果 <code>user.email</code> 没有配置， 就会用到 <strong>EMAIL</strong> 指定的邮件地址。 如果 <em>这个</em> 也没有设置， Git 继续回退使用系统用户和主机名。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Git 使用 <code>curl</code> 库通过 HTTP来完成网络操作， 所以 <strong>GIT_CURL_VERBOSE</strong> 告诉 Git 显示所有由那个库产生的消息。 这跟在命令行执行 <code>curl -v</code> 差不多。</p><p><strong>GIT_SSL_NO_VERIFY</strong> 告诉 Git 不用验证 SSL 证书。 这在有些时候是需要的， 例如你用一个自己签名的证书通过 HTTPS 来提供 Git 服务， 或者你正在搭建 Git 服务器，还没有安装完全的证书。</p><p>如果 Git 操作在网速低于 <strong>GIT_HTTP_LOW_SPEED_LIMIT</strong> 字节／秒，并且持续 <strong>GIT_HTTP_LOW_SPEED_TIME</strong> 秒以上的时间，Git 会终止那个操作。 这些值会覆盖 <code>http.lowSpeedLimit</code> 和 <code>http.lowSpeedTime</code> 配置的值。</p><p><strong>GIT_HTTP_USER_AGENT</strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。 默认值类似于 <code>git/2.0.0</code>。</p><h3 id="比较和合并"><a href="#比较和合并" class="headerlink" title="比较和合并"></a>比较和合并</h3><p><strong>GIT_DIFF_OPTS</strong> 这个有点起错名字了。 有效值仅支持 <code>-u&lt;n&gt;</code> 或 <code>--unified=&lt;n&gt;</code>，用来控制在 <code>git diff</code> 命令中显示的内容行数。</p><p><strong>GIT_EXTERNAL_DIFF</strong> 用来覆盖 <code>diff.external</code> 配置的值。 如果设置了这个值， 当执行 <code>git diff</code>时，Git 会调用该程序。</p><p><strong>GIT_DIFF_PATH_COUNTER</strong> 和 <strong>GIT_DIFF_PATH_TOTAL</strong> 对于 <code>GIT_EXTERNAL_DIFF</code> 或 <code>diff.external</code> 指定的程序有用。 前者表示在一系列文件中哪个是被比较的（从 1 开始），后者表示每批文件的总数。</p><p><strong>GIT_MERGE_VERBOSITY</strong> 控制递归合并策略的输出。 允许的值有下面这些：</p><ul><li>0 什么都不输出，除了可能会有一个错误信息。</li><li>1 只显示冲突。</li><li>2 还显示文件改变。</li><li>3 显示因为没有改变被跳过的文件。</li><li>4 显示处理的所有路径。</li><li>5 显示详细的调试信息。</li></ul><p>默认值是 2。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>想 <em>真正地</em> 知道 Git 正在做什么? Git 内置了相当完整的跟踪信息，你需要做的就是把它们打开。 这些变量的可用值如下：</p><ul><li>“true”, “1”, 或 “2” – 跟踪类别写到标准错误输出。</li><li>以 <code>/</code> 开头的绝对路径 – 跟踪输出会被写到那个文件。</li></ul><p><strong>GIT_TRACE</strong> 控制常规跟踪，它并不适用于特殊情况。 它跟踪的范围包括别名的展开和其他子程序的委托。</p><pre class=" language-console"><code class="language-console">$ GIT_TRACE=true git lga20:12:49.877982 git.c:554               trace: exec: 'git-lga'20:12:49.878369 run-command.c:341       trace: run_command: 'git-lga'20:12:49.879529 git.c:282               trace: alias expansion: lga => 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'20:12:49.879885 git.c:349               trace: built-in: git 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'20:12:49.899217 run-command.c:341       trace: run_command: 'less'20:12:49.899675 run-command.c:192       trace: exec: 'less'</code></pre><p><strong>GIT_TRACE_PACK_ACCESS</strong> 控制访问打包文件的跟踪信息。 第一个字段是被访问的打包文件，第二个是文件的偏移量：</p><pre class=" language-console"><code class="language-console">$ GIT_TRACE_PACK_ACCESS=true git status20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 1220:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 3466220:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175# […]20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 5691498320:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666On branch masterYour branch is up-to-date with 'origin/master'.nothing to commit, working directory clean</code></pre><p><strong>GIT_TRACE_PACKET</strong> 打开网络操作包级别的跟踪信息。</p><pre class=" language-console"><code class="language-console">$ GIT_TRACE_PACKET=true git ls-remote origin20:15:14.867043 pkt-line.c:46           packet:          git< # service=git-upload-pack20:15:14.867071 pkt-line.c:46           packet:          git< 000020:15:14.867079 pkt-line.c:46           packet:          git< 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.420:15:14.867088 pkt-line.c:46           packet:          git< 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name20:15:14.867094 pkt-line.c:46           packet:          git< 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config# […]</code></pre><p><strong>GIT_TRACE_PERFORMANCE</strong> 控制性能数据的日志打印。 输出显示了每个 Git 命令调用花费的时间。</p><pre class=" language-console"><code class="language-console">$ GIT_TRACE_PERFORMANCE=true git gc20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: 'git' 'pack-refs' '--all' '--prune'20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: 'git' 'reflog' 'expire' '--all'Counting objects: 170994, done.Delta compression using up to 8 threads.Compressing objects: 100% (43413/43413), done.Writing objects: 100% (170994/170994), done.Total 170994 (delta 126176), reused 170524 (delta 125706)20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: 'git' 'pack-objects' '--keep-true-parents' '--honor-pack-keep' '--non-empty' '--all' '--reflog' '--unpack-unreachable=2.weeks.ago' '--local' '--delta-base-offset' '.git/objects/pack/.tmp-49190-pack'20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: 'git' 'prune-packed'20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: 'git' 'update-server-info'20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: 'git' 'repack' '-d' '-l' '-A' '--unpack-unreachable=2.weeks.ago'Checking connectivity: 170994, done.20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: 'git' 'prune' '--expire' '2.weeks.ago'20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: 'git' 'rerere' 'gc'20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: 'git' 'gc'</code></pre><p><strong>GIT_TRACE_SETUP</strong> 显示 Git 发现的关于版本库和交互环境的信息。</p><pre class=" language-console"><code class="language-console">$ GIT_TRACE_SETUP=true git status20:19:47.086765 trace.c:315             setup: git_dir: .git20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git20:19:47.087194 trace.c:318             setup: prefix: (null)On branch masterYour branch is up-to-date with 'origin/master'.nothing to commit, working directory clean</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如果指定了 <strong>GIT_SSH</strong>， Git 连接 SSH 主机时会用指定的程序代替 <code>ssh</code> 。 它会被用 <code>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code> 的命令方式调用。 这不是配置定制 <code>ssh</code> 调用方式的最简单的方法; 它不支持额外的命令行参数， 所以你必须写一个封装脚本然后让 <code>GIT_SSH</code> 指向它。 可能用 <code>~/.ssh/config</code> 会更简单。</p><p><strong>GIT_ASKPASS</strong> 覆盖了 <code>core.askpass</code> 配置。 这是 Git 需要向用户请求验证时用到的程序，它接受一个文本提示作为命令行参数，并在 <code>stdout</code> 中返回应答。 (查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching" target="_blank" rel="noopener">凭证存储</a>_ 访问更多相关内容)</p><p><strong>GIT_NAMESPACE</strong> 控制有命令空间的引用的访问，与 <code>--namespace</code> 标志是相同的。 这主要在服务器端有用， 如果你想在一个版本库中存储单个版本库的多个 fork, 只要保持引用是隔离的就可以。</p><p><strong>GIT_FLUSH</strong> 强制 Git 在向标准输出增量写入时使用没有缓存的 I/O。 设置为 1 让 Git 刷新更多， 设置为 0 则使所有的输出被缓存。 默认值（若此变量未设置）是根据活动和输出模式的不同选择合适的缓存方案。</p><p><strong>GIT_REFLOG_ACTION</strong> 让你可以指定描述性的文字写到 reflog 中。 这有个例子：</p><pre class=" language-console"><code class="language-console">$ GIT_REFLOG_ACTION="my action" git commit --allow-empty -m 'my message'[master 9e3d55a] my message$ git reflog -19e3d55a HEAD@{0}: my action: my message</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，你应该相当了解 Git 在背后都做了些什么工作，并且在一定程度上也知道了 Git 是如何实现的。 本章讨论了很多底层命令，这些命令比我们在本书其余部分学到的高层命令来得更原始，也更简洁。 从底层了解 Git 的工作原理有助于更好地理解 Git 在内部是如何运作的，也方便你能够针对特定的工作流写出自己的工具和脚本。</p><p>作为一套内容寻址文件系统，Git 不仅仅是一个版本控制系统，它同时是一个非常强大且易用的工具。 我们希望你可以借助新学到的 Git 内部原理相关知识来实现出自己的应用，并且以更高级、更得心应手的方式来驾驭 Git。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与其他系统</title>
      <link href="/2019/07/15/Git%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/15/Git%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>现实并不总是尽如人意。 通常，你不能立刻就把接触到的每一个项目都切换到 Git。 有时候你被困在使用其他 VCS 的项目中，却希望使用 Git。 在本章的第一部分我们将会了解到，怎样在你的那些托管在不同系统的项目上使用 Git 客户端。</p><p>在某些时候，你可能想要将已有项目转换到 Git。 本章的第二部分涵盖了从几个特定系统将你的项目迁移至 Git 的方法，即使没有预先构建好的导入工具，我们也有办法手动导入。</p><h2 id="作为客户端的-Git"><a href="#作为客户端的-Git" class="headerlink" title="作为客户端的 Git"></a>作为客户端的 Git</h2><p>Git 为开发者提供了如此优秀的体验，许多人已经找到了在他们的工作站上使用 Git 的方法，即使他们团队其余的人使用的是完全不同的 VCS。 有许多这种可用的适配器，它们被叫做 “桥接”。 下面我们将要介绍几个很可能会在实际中用到的桥接。</p><h3 id="Git-与-Subversion"><a href="#Git-与-Subversion" class="headerlink" title="Git 与 Subversion"></a>Git 与 Subversion</h3><p>很大一部分开源项目与相当多的企业项目使用 Subversion 来管理它们的源代码。 而且在大多数时间里，它已经是开源项目VCS选择的 <em>事实标准</em>。 它在很多方面都与曾经是源代码管理世界的大人物的 CVS 相似。</p><p>Git 中最棒的特性就是有一个与 Subversion 的双向桥接，它被称作 <code>git svn</code>。 这个工具允许你使用 Git 作为连接到 Subversion 有效的客户端，这样你可以使用 Git 所有本地的功能然后如同正在本地使用 Subversion 一样推送到 Subversion 服务器。 这意味着你可以在本地做新建分支与合并分支、使用暂存区、使用变基与拣选等等的事情，同时协作者还在继续使用他们黑暗又古老的方式。 当你试图游说公司将基础设施修改为完全支持 Git 的过程中，一个好方法是将 Git 偷偷带入到公司环境，并帮助周围的开发者提升效率。 Subversion 桥接就是进入 DVCS 世界的诱饵。</p><h4 id="git-svn"><a href="#git-svn" class="headerlink" title="git svn"></a><code>git svn</code></h4><p>在 Git 中所有 Subversion 桥接命令的基础命令是 <code>git svn</code>。 它可以跟很多命令，所以我们会通过几个简单的工作流程来为你演示最常用的命令。</p><p>需要特别注意的是当你使用 <code>git svn</code> 时，就是在与 Subversion 打交道，一个与 Git 完全不同的系统。 尽管 <strong>可以</strong> 在本地新建分支与合并分支，但是你最好还是通过变基你的工作来保证你的历史尽可能是直线，并且避免做类似同时与 Git 远程服务器交互的事情。</p><p>不要重写你的历史然后尝试再次推送，同时也不要推送到一个平行的 Git 仓库来与其他使用 Git 的开发者协作。 Subversion 只能有一个线性的历史，弄乱它很容易。 如果你在一个团队中工作，其中有一些人使用 SVN 而另一些人使用 Git，你需要确保每个人都使用 SVN 服务器来协作 - 这样做会省去很多麻烦。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>为了演示这个功能，需要一个有写入权限的典型 SVN 仓库。 如果想要拷贝这些例子，你必须获得一份我的测试仓库的可写拷贝。 为了轻松地拷贝，可以使用 Subversion 自带的一个名为 <code>svnsync</code> 的工具。 为了这些测试，我们在 Google Code 上创建了一个 <code>protobuf</code> 项目部分拷贝的新 Subversion 仓库。<code>protobuf</code> 是一个将结构性数据编码用于网络传输的工具。</p><p>接下来，你需要先创建一个新的本地 Subversion 仓库：</p><pre class=" language-console"><code class="language-console">$ mkdir /tmp/test-svn$ svnadmin create /tmp/test-svn</code></pre><p>然后，允许所有用户改变版本属性 - 最容易的方式是添加一个返回值为 0 的 <code>pre-revprop-change</code> 脚本。</p><pre class=" language-console"><code class="language-console">$ cat /tmp/test-svn/hooks/pre-revprop-change#!/bin/shexit 0;$ chmod +x /tmp/test-svn/hooks/pre-revprop-change</code></pre><p>现在可以调用加入目标与来源仓库参数的 <code>svnsync init</code> 命令同步这个项目到本地的机器。</p><pre class=" language-console"><code class="language-console">$ svnsync init file:///tmp/test-svn \  http://progit-example.googlecode.com/svn/</code></pre><p>这样就设置好了同步所使用的属性。 可以通过运行下面的命令来克隆代码：</p><pre class=" language-console"><code class="language-console">$ svnsync sync file:///tmp/test-svnCommitted revision 1.Copied properties for revision 1.Transmitting file data .............................[...]Committed revision 2.Copied properties for revision 2.[…]</code></pre><p>虽然这个操作可能只会花费几分钟，但如果你尝试拷贝原始的仓库到另一个非本地的远程仓库时，即使只有不到 100 个的提交，这个过程也可能会花费将近一个小时。 Subversion 必须一次复制一个版本然后推送回另一个仓库 - 这低效得可笑，但却是做这件事唯一简单的方式。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>既然已经有了一个有写入权限的 Subversion 仓库，那么你可以开始一个典型的工作流程。 可以从 <code>git svn clone</code> 命令开始，它会将整个 Subversion 仓库导入到一个本地 Git 仓库。 需要牢记的一点是如果是从一个真正托管的 Subversion 仓库中导入，需要将 <code>file:///tmp/test-svn</code> 替换为你的 Subversion 仓库的 URL：</p><pre class=" language-console"><code class="language-console">$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tagsInitialized empty Git repository in /private/tmp/progit/test-svn/.git/r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)    A    m4/acx_pthread.m4    A    m4/stl_hash.m4    A    java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java    A    java/src/test/java/com/google/protobuf/WireFormatTest.java…r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86daeFollowing parent with do_switchSuccessfully followed parentr76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)Checked out HEAD:  file:///tmp/test-svn/trunk r75</code></pre><p>这相当于运行了两个命令 - <code>git svn init</code> 以及紧接着的 <code>git svn fetch</code> - 你提供的 URL 。 这会花费一些时间。 测试项目只有 75 个左右的提交并且代码库并不是很大，但是 Git 必须一次一个地检出一个版本同时单独地提交它。 对于有成百上千个提交的项目，这真的可能会花费几小时甚至几天来完成。</p><p><code>-T trunk -b branches -t tags</code> 部分告诉 Git Subversion 仓库遵循基本的分支与标签惯例。 如果你命名了不同的主干、分支或标签，可以修改这些参数。 因为这是如此地常见，所以能用 <code>-s</code> 来替代整个这部分，这表示标准布局并且指代所有那些选项。 下面的命令是相同的：</p><pre class=" language-console"><code class="language-console">$ git svn clone file:///tmp/test-svn -s</code></pre><p>至此，应该得到了一个已经导入了分支与标签的有效的 Git 仓库：</p><pre class=" language-console"><code class="language-console">$ git branch -a* master  remotes/origin/my-calc-branch  remotes/origin/tags/2.0.2  remotes/origin/tags/release-2.0.1  remotes/origin/tags/release-2.0.2  remotes/origin/tags/release-2.0.2rc1  remotes/origin/trunk</code></pre><p>注意这个工具是如何将 Subversion 标签作为远程引用来管理的。 让我们近距离看一下 Git 的底层命令 <code>show-ref</code>：</p><pre class=" language-console"><code class="language-console">$ git show-ref556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branchbfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre><p>Git 在从 Git 服务器克隆时并不这样做；下面是在刚刚克隆完成的有标签的仓库的样子：</p><pre class=" language-console"><code class="language-console">$ git show-refc3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-175f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-223f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.07064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.06dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre><p>Git 直接将标签抓取至 <code>refs/tags</code>，而不是将它们看作分支。</p><h4 id="提交回-Subversion"><a href="#提交回-Subversion" class="headerlink" title="提交回 Subversion"></a>提交回 Subversion</h4><p>现在你有了一个工作仓库，你可以在项目上做一些改动，然后高效地使用 Git 作为 SVN 客户端将你的提交推送到上游。 一旦编辑了一个文件并提交它，你就有了一个存在于本地 Git 仓库的提交，这提交在 Subversion 服务器上并不存在：</p><pre class=" language-console"><code class="language-console">$ git commit -am 'Adding git-svn instructions to the README'[master 4af61fd] Adding git-svn instructions to the README 1 file changed, 5 insertions(+)</code></pre><p>接下来，你需要将改动推送到上游。 注意这会怎样改变你使用 Subversion 的方式 - 你可以离线做几次提交然后一次性将它们推送到 Subversion 服务器。 要推送到一个 Subversion 服务器，运行 <code>git svn dcommit</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git svn dcommitCommitting to file:///tmp/test-svn/trunk ...    M    README.txtCommitted r77    M    README.txtr77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunkResetting to the latest refs/remotes/origin/trunk</code></pre><p>这会拿走你在 Subversion 服务器代码之上所做的所有提交，针对每一个做一个 Subversion 提交，然后重写你本地的 Git 提交来包含一个唯一的标识符。 这很重要因为这意味着所有你的提交的 SHA-1 校验和都改变了。 部分由于这个原因，同时使用一个基于 Git 的项目远程版本和一个 Subversion 服务器并不是一个好主意。 如果你查看最后一次提交，有新的 <code>git-svn-id</code> 被添加：</p><pre class=" language-console"><code class="language-console">$ git log -1commit 95e0222ba6399739834380eb10afcd73e0670bc5Author: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>Date:   Thu Jul 24 03:08:36 2014 +0000    Adding git-svn instructions to the README    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre><p>注意你原来提交的 SHA-1 校验和原来是以 <code>4af61fd</code> 开头，而现在是以 <code>95e0222</code> 开头。 如果想要既推送到一个 Git 服务器又推送到一个 Subversion 服务器，必须先推送（<code>dcommit</code>）到 Subversion 服务器，因为这个操作会改变你的提交数据。</p><h4 id="拉取新改动"><a href="#拉取新改动" class="headerlink" title="拉取新改动"></a>拉取新改动</h4><p>如果你和其他开发者一起工作，当在某一时刻你们其中之一推送时，另一人尝试推送修改会导致冲突。 那次修改会被拒绝直到你合并他们的工作。 在 <code>git svn</code> 中，它看起来是这样的：</p><pre class=" language-console"><code class="language-console">$ git svn dcommitCommitting to file:///tmp/test-svn/trunk ...ERROR from SVN:Transaction is out of date: File '/trunk/README.txt' is out of dateW: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase::100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M    README.txtCurrent branch master is up to date.ERROR: Not all changes have been committed into SVN, however the committedones (if any) seem to be successfully integrated into the working tree.Please see the above messages for details.</code></pre><p>为了解决这种情况，可以运行 <code>git svn rebase</code>，它会从服务器拉取任何你本地还没有的改动，并将你所有的工作变基到服务器的内容之上：</p><pre class=" language-console"><code class="language-console">$ git svn rebaseCommitting to file:///tmp/test-svn/trunk ...ERROR from SVN:Transaction is out of date: File '/trunk/README.txt' is out of dateW: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase::100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M    README.txtFirst, rewinding head to replay your work on top of it...Applying: update fooUsing index info to reconstruct a base tree...M    README.txtFalling back to patching base and 3-way merge...Auto-merging README.txtERROR: Not all changes have been committed into SVN, however the committedones (if any) seem to be successfully integrated into the working tree.Please see the above messages for details.</code></pre><p>现在，所有你的工作都已经在 Subversion 服务器的内容之上了，你就可以顺利地 <code>dcommit</code>：</p><pre class=" language-console"><code class="language-console">$ git svn dcommitCommitting to file:///tmp/test-svn/trunk ...    M    README.txtCommitted r85    M    README.txtr85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunkResetting to the latest refs/remotes/origin/trunk</code></pre><p>注意，和 Git 需要你在推送前合并本地还没有的上游工作不同的是，<code>git svn</code> 只会在修改发生冲突时要求你那样做（更像是 Subversion 工作的行为）。 如果其他人推送一个文件的修改然后你推送了另一个文件的修改，你的 <code>dcommit</code> 命令会正常工作：</p><pre class=" language-console"><code class="language-console">$ git svn dcommitCommitting to file:///tmp/test-svn/trunk ...    M    configure.acCommitted r87    M    autogen.shr86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)    M    configure.acr87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase::100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M    autogen.shFirst, rewinding head to replay your work on top of it...</code></pre><p>记住这一点很重要，因为结果是当你推送后项目的状态并不存在于你的电脑中。 如果修改并未冲突但却是不兼容的，可能会引起一些难以诊断的问题。 这与使用 Git 服务器并不同 - 在 Git 中，可以在发布前完全测试客户端系统的状态，然而在 SVN 中，你甚至不能立即确定在提交前与提交后的状态是相同的。</p><p>你也应该运行这个命令从 Subversion 服务器上拉取修改，即使你自己并不准备提交。 可以运行 <code>git svn fetch</code> 来抓取新数据，但是 <code>git svn rebase</code> 会抓取并更新你本地的提交。</p><pre class=" language-console"><code class="language-console">$ git svn rebase    M    autogen.shr88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)First, rewinding head to replay your work on top of it...Fast-forwarded master to refs/remotes/origin/trunk.</code></pre><p>每隔一会儿运行 <code>git svn rebase</code> 确保你的代码始终是最新的。 虽然需要保证当运行这个命令时工作目录是干净的。 如果有本地的修改，在运行 <code>git svn rebase</code> 之前要么储藏你的工作要么做一次临时的提交，不然，当变基会导致合并冲突时，命令会终止。</p><h4 id="Git-分支问题"><a href="#Git-分支问题" class="headerlink" title="Git 分支问题"></a>Git 分支问题</h4><p>当适应了 Git 的工作流程，你大概会想要创建特性分支，在上面做一些工作，然后将它们合并入主分支。 如果你正通过 <code>git svn</code> 推送到一个 Subversion 服务器，你可能想要把你的工作变基到一个单独的分支上，而不是将分支合并到一起。 比较喜欢变基的原因是因为 Subversion 有一个线性的历史并且无法像 Git 一样处理合并，所以 <code>git svn</code> 在将快照转换成 Subversion 提交时，只会保留第一父提交。</p><p>假设你的历史像下面这样：创建了一个 <code>experiment</code> 分支，做了两次提交，然后将它们合并回 <code>master</code>。 当 <code>dcommit</code> 时，你看到输出是这样的：</p><pre class=" language-console"><code class="language-console">$ git svn dcommitCommitting to file:///tmp/test-svn/trunk ...    M    CHANGES.txtCommitted r89    M    CHANGES.txtr89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)    M    COPYING.txt    M    INSTALL.txtCommitted r90    M    INSTALL.txt    M    COPYING.txtr90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunkResetting to the latest refs/remotes/origin/trunk</code></pre><p>在一个合并过历史提交的分支上 <code>dcommit</code> 命令工作得很好，除了当你查看你的 Git 项目历史时，它并没有重写所有你在 <code>experiment</code> 分支上所做的任意提交 - 相反，所有这些修改显示一个单独合并提交的 SVN 版本中。</p><p>当其他人克隆那些工作时，他们只会看到一个被塞入了所有改动的合并提交，就像运行了 <code>git merge --squash</code>；他们无法看到修改从哪来或何时提交的信息。</p><h4 id="Subversion-分支"><a href="#Subversion-分支" class="headerlink" title="Subversion 分支"></a>Subversion 分支</h4><p>在 Subversion 中新建分支与在 Git 中新建分支并不相同；如果你能不用它，那最好就不要用。 然而，你可以使用 git svn 在 Subversion 中创建分支并在分支上做提交。</p><h4 id="创建一个新的-SVN-分支"><a href="#创建一个新的-SVN-分支" class="headerlink" title="创建一个新的 SVN 分支"></a>创建一个新的 SVN 分支</h4><p>要在 Subversion 中创建一个新分支，运行 <code>git svn branch [branchname]</code>：</p><pre class=" language-console"><code class="language-console">$ git svn branch operaCopying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0Following parent with do_switchSuccessfully followed parentr91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre><p>这与 Subversion 中的 <code>svn copy trunk branches/opera</code> 命令作用相同并且是在 Subversion 服务器中操作。 需要重点注意的是它并不会检出到那个分支；如果你在这时提交，提交会进入服务器的 <code>trunk</code> 分支，而不是 <code>opera</code> 分支。</p><h4 id="切换活动分支"><a href="#切换活动分支" class="headerlink" title="切换活动分支"></a>切换活动分支</h4><p>Git 通过查找在历史中 Subversion 分支的头部来指出你的提交将会到哪一个分支 - 应该只有一个，并且它应该是在当前分支历史中最后一个有 <code>git-svn-id</code> 的。</p><p>如果想要同时在不止一个分支上工作，可以通过在导入的那个分支的 Subversion 提交开始来设置本地分支 <code>dcommit</code> 到特定的 Subversion 分支。 如果想要一个可以单独在上面工作的 <code>opera</code> 分支，可以运行</p><pre class=" language-console"><code class="language-console">$ git branch opera remotes/origin/opera</code></pre><p>现在，如果想要将你的 <code>opera</code> 分支合并入 <code>trunk</code>（你的 <code>master</code> 分支），可以用一个正常的 <code>git merge</code> 来这样做。 但是你需要通过 <code>-m</code> 来提供一个描述性的提交信息，否则合并信息会是没有用的 “Merge branch opera”。</p><p>记住尽管使用的是 <code>git merge</code> 来做这个操作，而且合并可能会比在 Subversion 中更容易一些（因为 Git 会为你自动地检测合适的合并基础），但这并不是一个普通的 Git 合并提交。 你不得不将这个数据推送回一个 Subversion 服务器，Subversion 服务器不支持那些跟踪多个父结点的提交；所以，当推送完成后，它看起来会是一个将其他分支的所有提交压缩在一起的单独提交。 在合并一个分支到另一个分支后，你并不能像 Git 中那样轻松地回到原来的分支继续工作。 你运行的 <code>dcommit</code> 命令会将哪个分支被合并进来的信息抹掉，所以后续的合并基础计算会是错的 - dcommit 会使你的 <code>git merge</code> 结果看起来像是运行了 <code>git merge --squash</code>。 不幸的是，没有一个好的方式来避免这种情形 - Subversion 无法存储这个信息，所以当使用它做为服务器时你总是会被它的限制打垮。 为了避免这些问题，应该在合并到主干后删除本地分支（本例中是 <code>opera</code>）。</p><h4 id="Subversion-命令"><a href="#Subversion-命令" class="headerlink" title="Subversion 命令"></a>Subversion 命令</h4><p><code>git svn</code> 工具集通过提供很多功能与 Subversion 中那些相似的命令来帮助简化转移到 Git 的过程。 下面是一些提供了 Subversion 中常用功能的命令。</p><h6 id="SVN-风格历史"><a href="#SVN-风格历史" class="headerlink" title="SVN 风格历史"></a>SVN 风格历史</h6><p>如果你习惯于使用 Subversion 并且想要看 SVN 输出风格的提交历史，可以运行 <code>git svn log</code> 来查看 SVN 格式的提交历史：</p><pre class=" language-console"><code class="language-console">$ git svn log------------------------------------------------------------------------r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 linesautogen change------------------------------------------------------------------------r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 linesMerge branch 'experiment'------------------------------------------------------------------------r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 linesupdated the changelog</code></pre><p>关于 <code>git svn log</code>，有两件重要的事你应该知道。 首先，它是离线工作的，并不像真正的 <code>svn log</code> 命令，会向 Subversion 服务器询问数据。 其次，它只会显示已经提交到 Subversion 服务器上的提交。 还未 dcommit 的本地 Git 提交并不会显示；同样也不会显示这段时间中其他人推送到 Subversion 服务器上的提交。 它更像是最后获取到的 Subversion 服务器上的提交状态。</p><h6 id="SVN-注解"><a href="#SVN-注解" class="headerlink" title="SVN 注解"></a>SVN 注解</h6><p>类似 <code>git svn log</code> 命令离线模拟了 <code>svn log</code> 命令，你可以认为 <code>git svn blame [FILE]</code> 离线模拟了 <code>svn annotate</code>。 输出看起来像这样：</p><pre class=" language-console"><code class="language-console">$ git svn blame README.txt 2   temporal Protocol Buffers - Google's data interchange format 2   temporal Copyright 2008 Google Inc. 2   temporal http://code.google.com/apis/protocolbuffers/ 2   temporal22   temporal C++ Installation - Unix22   temporal ======================= 2   temporal79    schacon Committing in git-svn.78    schacon 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol 2   temporal Buffer compiler (protoc) execute the following: 2   temporal</code></pre><p>重复一次，它并不显示你在 Git 中的本地提交，也不显示同一时间被推送到 Subversion 的其他提交。</p><h6 id="SVN-服务器信息"><a href="#SVN-服务器信息" class="headerlink" title="SVN 服务器信息"></a>SVN 服务器信息</h6><p>可以通过运行 <code>git svn info</code> 得到与 <code>svn info</code> 相同种类的信息。</p><pre class=" language-console"><code class="language-console">$ git svn infoPath: .URL: https://schacon-test.googlecode.com/svn/trunkRepository Root: https://schacon-test.googlecode.com/svnRepository UUID: 4c93b258-373f-11de-be05-5f7a86268029Revision: 87Node Kind: directorySchedule: normalLast Changed Author: schaconLast Changed Rev: 87Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre><p>这就像是在你上一次和 Subversion 服务器通讯时同步了之后，离线运行的 <code>blame</code> 与 <code>log</code> 命令。</p><h6 id="忽略-SUBVERSION-所忽略的"><a href="#忽略-SUBVERSION-所忽略的" class="headerlink" title="忽略 SUBVERSION 所忽略的"></a>忽略 SUBVERSION 所忽略的</h6><p>如果克隆一个在任意一处设置 <code>svn:ignore</code> 属性的 Subversion 仓库时，你也许会想要设置对应的 <code>.gitignore</code> 文件，这样就不会意外的提交那些不该提交的文件。 <code>git svn</code> 有两个命令来帮助解决这个问题。 第一个是 <code>git svn create-ignore</code>，它会为你自动地创建对应的 <code>.gitignore</code> 文件，这样你的下次提交就能包含它们。</p><p>第二个命令是 <code>git svn show-ignore</code>，它会将你需要放在 <code>.gitignore</code> 文件中的每行内容打印到标准输出，这样就可以将输出内容重定向到项目的例外文件中：</p><pre class=" language-console"><code class="language-console">$ git svn show-ignore > .git/info/exclude</code></pre><p>这样，你就不会由于 <code>.gitignore</code> 文件而把项目弄乱。 当你是 Subversion 团队中唯一的 Git 用户时这是一个好的选项，并且你的队友并不想要项目内存在 <code>.gitignore</code> 文件。</p><h4 id="Git-Svn-总结"><a href="#Git-Svn-总结" class="headerlink" title="Git-Svn 总结"></a>Git-Svn 总结</h4><p>当你不得不使用 Subversion 服务器或者其他必须运行一个 Subversion 服务器的开发环境时，<code>git svn</code>工具很有用。 你应该把它当做一个不完全的 Git，然而，你要是不用它的话，就会在做转换的过程中遇到很多麻烦的问题。 为了不惹麻烦，尽量遵守这些准则：</p><ul><li>保持一个线性的 Git 历史，其中不能有 <code>git merge</code> 生成的合并提交。 把你在主线分支外开发的全部工作变基到主线分支；而不要合并入主线分支。</li><li>不要建立一个单独的 Git 服务器，也不要在 Git 服务器上协作。 可以用一台 Git 服务器来帮助新来的开发者加速克隆，但是不要推送任何不包含 <code>git-svn-id</code> 条目的东西。 你可能会需要增加一个 <code>pre-receive</code> 钩子来检查每一个提交信息是否包含 <code>git-svn-id</code> 并且拒绝任何未包含的提交。</li></ul><p>如果你遵守了那些准则，忍受用一个 Subversion 服务器来工作可以更容易些。 然而，如果有可能迁移到一个真正的 Git 服务器，那么迁移过去能使你的团队获得更多好处。</p><h3 id="Git-与-Mercurial"><a href="#Git-与-Mercurial" class="headerlink" title="Git 与 Mercurial"></a>Git 与 Mercurial</h3><p>DVCS 的宇宙里不只有 Git。 实际上，在这个空间里有许多其他的系统。对于如何正确地进行分布式版本管理，每一个系统都有自己的视角。 除了 Git，最流行的就是 Mercurial，并且它们两个在很多方面都很相似。</p><p>好消息是，如果你更喜欢 Git 的客户端行为但是工作在源代码由 Mercurial 控制的项目中，有一种使用 Git 作为 Mercurial 托管仓库的客户端的方法。 由于 Git 与服务器仓库是使用远程交互的，那么由远程助手实现的桥接方法就不会让人很惊讶。 这个项目的名字是 git-remote-hg，可以在 <a href="https://github.com/felipec/git-remote-hg" target="_blank" rel="noopener">https://github.com/felipec/git-remote-hg</a> 找到。</p><h4 id="git-remote-hg"><a href="#git-remote-hg" class="headerlink" title="git-remote-hg"></a>git-remote-hg</h4><p>首先，需要安装 git-remote-hg。 实际上需要将它的文件放在 PATH 变量的某个目录中，像这样：</p><pre class=" language-console"><code class="language-console">$ curl -o ~/bin/git-remote-hg \  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg$ chmod +x ~/bin/git-remote-hg</code></pre><p>假定 <code>~/bin</code> 在 <code>$PATH</code> 变量中。 Git-remote-hg 有一个其他的依赖：<code>mercurial</code> Python 库。 如果已经安装了 Python，安装它就像这样简单：</p><pre class=" language-console"><code class="language-console">$ pip install mercurial</code></pre><p>（如果未安装 Python，访问 <a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a> 来获取它。）</p><p>需要做的最后一件事是安装 Mercurial 客户端。 如果还没有安装的话请访问 <a href="http://mercurial.selenic.com/" target="_blank" rel="noopener">http://mercurial.selenic.com/</a> 来安装。</p><p>现在已经准备好摇滚了。 你所需要的一切就是一个你可以推送的 Mercurial 仓库。 很幸运，每一个 Mercurial 仓库都可以这样做，所以我们只需要使用大家用来学习 Mercurial 的“hello world”仓库就可以了：</p><pre class=" language-console"><code class="language-console">$ hg clone http://selenic.com/repo/hello /tmp/hello</code></pre><h4 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h4><p>既然有一个可用的 “server-side” 仓库，我们可以通过一个典型的工作流来了解。 你将会看到，这两种系统非常相似，没有太多的出入。</p><p>和 Git 一样，首先我们克隆：</p><pre class=" language-console"><code class="language-console">$ git clone hg::/tmp/hello /tmp/hello-git$ cd /tmp/hello-git$ git log --oneline --graph --decorate* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile* 65bb417 Create a standard "hello, world" program</code></pre><p>你会注意到与 Mercurial 仓库工作时使用了标准的 <code>git clone</code> 命令。 那是因为 git-remote-hg 工作在相当低的底层，使用类似于 Git HTTP/S 协议的机制实现的（远程助手）。 由于 Git 与 Mercurial 都设计为每一个客户端有一个仓库的完整历史，所以这个命令做了一次完整的克隆，包括所有的项目历史，并且相当快地完成。</p><p>log 命令显示了两次提交，最后一次提交指向了一大堆引用。 那说明这其中的一部分实际上并没有在那儿。 让我们看看 <code>.git</code> 目录中实际上有什么：</p><pre class=" language-console"><code class="language-console">$ tree .git/refs.git/refs├── heads│   └── master├── hg│   └── origin│       ├── bookmarks│       │   └── master│       └── branches│           └── default├── notes│   └── hg├── remotes│   └── origin│       └── HEAD└── tags9 directories, 5 files</code></pre><p>Git-remote-hg 尝试让结构更有 Git 风格，但是在隐藏在下面的是它管理两个轻微不同系统之间概念的映射。 <code>refs/hg</code> 目录中存储了实际的远程引用。 例如，<code>refs/hg/origin/branches/default</code> 是一个包含以<code>‘ac7955c’&#39;开始的 SHA-1 值的 Git 引用文件，是</code>master<code>所指向的提交。 所以</code>refs/hg<code>目录是一种类似</code>refs/remotes/origin` 的替代品，但是它引入了书签与分支的区别。</p><p><code>notes/hg</code> 文件是 git-remote-hg 如何在 Git 的提交散列与 Mercurial 变更集 ID 之间建立映射的起点。 让我们来探索一下：</p><pre class=" language-console"><code class="language-console">$ cat notes/hgd4c10386...$ git cat-file -p d4c10386...tree 1781c96...author remote-hg <> 1408066400 -0800committer remote-hg <> 1408066400 -0800Notes for master$ git ls-tree 1781c96...100644 blob ac9117f...    65bb417...100644 blob 485e178...    ac7955c...$ git cat-file -p ac9117f0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre><p>所以 <code>refs/notes/hg</code> 指向了一个树，即在 Git 对象数据库中的一个有其他对象名字的列表。 <code>git ls-tree</code> 输出 tree 对象中所有项目的模式、类型、对象哈希与文件名。 如果深入挖掘 tree 对象中的一个项目，我们会发现在其中是一个名字为 “ac9117f” 的 blob 对象（<code>master</code> 所指向提交的 SHA-1 散列值），包含内容 “0a04b98”（是 <code>default</code> 分支指向的 Mercurial 变更集的 ID）。</p><p>好消息是大多数情况下我们不需要关心以上这些。 典型的工作流程与使用 Git 远程仓库并没有什么不同。</p><p>在我们继续之前，这里还有一件需要注意的事情：忽略。 Mercurial 与 Git 使用非常类似的机制实现这个功能，但是一般来说你不会想要把一个 <code>.gitignore</code> 文件提交到 Mercurial 仓库中。 幸运的是，Git 有一种方式可以忽略本地磁盘仓库的文件，而且 Mercurial 格式是与 Git 兼容的，所以你只需将这个文件拷贝过去：</p><pre class=" language-console"><code class="language-console">$ cp .hgignore .git/info/exclude</code></pre><p><code>.git/info/exclude</code> 文件的作用像是一个 <code>.gitignore</code>，但是它不包含在提交中。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>假设我们已经做了一些工作并且在 <code>master</code> 分支做了几次提交，而且已经准备将它们推送到远程仓库。 这是我们仓库现在的样子：</p><pre class=" language-console"><code class="language-console">$ git log --oneline --graph --decorate* ba04a2a (HEAD, master) Update makefile* d25d16f Goodbye* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile* 65bb417 Create a standard "hello, world" program</code></pre><p>我们的 <code>master</code> 分支领先 <code>origin/master</code> 分支两个提交，但是那两个提交只存在于我们的本地机器中。 让我们看看在同一时间有没有其他人做过什么重要的工作：</p><pre class=" language-console"><code class="language-console">$ git fetchFrom hg::/tmp/hello   ac7955c..df85e87  master     -> origin/master   ac7955c..df85e87  branches/default -> origin/branches/default$ git log --oneline --graph --decorate --all* 7b07969 (refs/notes/hg) Notes for default* d4c1038 Notes for master* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation| * ba04a2a (HEAD, master) Update makefile| * d25d16f Goodbye|/* ac7955c Create a makefile* 65bb417 Create a standard "hello, world" program</code></pre><p>因为使用了 <code>--all</code> 标记，我们看到被 git-remote-hg 内部使用的 “notes” 引用，但是可以忽略它们。 剩下的部分是我们期望的；<code>origin/master</code> 已经前进了一次提交，同时我们的历史现在分叉了。 Mercurial 和我们本章中讨论的其他系统不一样，它能够处理合并，所以我们不需要做任何其他事情。</p><pre class=" language-console"><code class="language-console">$ git merge origin/masterAuto-merging hello.cMerge made by the 'recursive' strategy. hello.c | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git log --oneline --graph --decorate*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'|\| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation* | ba04a2a Update makefile* | d25d16f Goodbye|/* ac7955c Create a makefile* 65bb417 Create a standard "hello, world" program</code></pre><p>完美。 运行测试然后所有测试都通过了，所以我们准备将工作共享给团队的其他成员。</p><pre class=" language-console"><code class="language-console">$ git pushTo hg::/tmp/hello   df85e87..0c64627  master -> master</code></pre><p>就是这样！ 如果你现在查看一下 Mercurial 仓库，你会发现这样实现了我们所期望的：</p><pre class=" language-console"><code class="language-console">$ hg log -G --style compacto    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben|\     Merge remote-tracking branch 'origin/master'| || o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben| |    Update makefile| || o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben| |    Goodbye| |@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben|/     Add some documentation|o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm|    Create a makefile|o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm     Create a standard "hello, world" program</code></pre><p>序号 <em>2</em> 的变更集是由 Mercurial 生成的，序号 <em>3</em> 与序号 <em>4</em> 的变更集是由 git-remote-hg 生成的，通过 Git 推送上来的提交。</p><h4 id="分支与书签"><a href="#分支与书签" class="headerlink" title="分支与书签"></a>分支与书签</h4><p>Git 只有一种类型的分支：当提交生成时移动的一个引用。 在 Mercurial 中，这种类型的引用叫作 “bookmark”，它的行为非常类似于 Git 分支。</p><p>Mercurial 的 “branch” 概念则更重量级一些。 变更集生成时的分支会记录 <em>在变更集中</em>，意味着它会永远地存在于仓库历史中。 这个例子描述了一个在 <code>develop</code> 分支上的提交：</p><pre class=" language-console"><code class="language-console">$ hg log -l 1changeset:   6:8f65e5e02793branch:      developtag:         tipuser:        Ben Straub <ben@straub.cc>date:        Thu Aug 14 20:06:38 2014 -0700summary:     More documentation</code></pre><p>注意开头为 “branch” 的那行。 Git 无法真正地模拟这种行为（并且也不需要这样做；两种类型的分支都可以表达为 Git 的一个引用），但是 git-remote-hg 需要了解其中的区别，因为 Mercurial 关心。</p><p>创建 Mercurial 书签与创建 Git 分支一样容易。 在 Git 这边：</p><pre class=" language-console"><code class="language-console">$ git checkout -b featureASwitched to a new branch 'featureA'$ git push origin featureATo hg::/tmp/hello * [new branch]      featureA -> featureA</code></pre><p>这就是所要做的全部。 在 Mercurial 这边，它看起来像这样：</p><pre class=" language-console"><code class="language-console">$ hg bookmarks   featureA                  5:bd5ac26f11f9$ hg log --style compact -G@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben|    More documentation|o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben|\     Merge remote-tracking branch 'origin/master'| || o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben| |    update makefile| || o  3:1   318914536c86   2014-08-14 20:00 -0700   ben| |    goodbye| |o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben|/     Add some documentation|o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm|    Create a makefile|o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm     Create a standard "hello, world" program</code></pre><p>注意在修订版本 5 上的新 <code>[featureA]</code> 标签。 在 Git 这边这些看起来像是 Git 分支，除了一点：不能从 Git 这边删除书签（这是远程助手的一个限制）。</p><p>你也可以工作在一个 “重量级” 的 Mercurial branch：只需要在 <code>branches</code> 命名空间内创建一个分支：</p><pre class=" language-console"><code class="language-console">$ git checkout -b branches/permanentSwitched to a new branch 'branches/permanent'$ vi Makefile$ git commit -am 'A permanent change'$ git push origin branches/permanentTo hg::/tmp/hello * [new branch]      branches/permanent -> branches/permanent</code></pre><p>下面是 Mercurial 这边的样子：</p><pre class=" language-console"><code class="language-console">$ hg branchespermanent                      7:a4529d07aad4develop                        6:8f65e5e02793default                        5:bd5ac26f11f9 (inactive)$ hg log -Go  changeset:   7:a4529d07aad4|  branch:      permanent|  tag:         tip|  parent:      5:bd5ac26f11f9|  user:        Ben Straub <ben@straub.cc>|  date:        Thu Aug 14 20:21:09 2014 -0700|  summary:     A permanent change|| @  changeset:   6:8f65e5e02793|/   branch:      develop|    user:        Ben Straub <ben@straub.cc>|    date:        Thu Aug 14 20:06:38 2014 -0700|    summary:     More documentation|o    changeset:   5:bd5ac26f11f9|\   bookmark:    featureA| |  parent:      4:0434aaa6b91f| |  parent:      2:f098c7f45c4f| |  user:        Ben Straub <ben@straub.cc>| |  date:        Thu Aug 14 20:02:21 2014 -0700| |  summary:     Merge remote-tracking branch 'origin/master'[...]</code></pre><p>分支名字 “permanent” 记录在序号 <em>7</em> 的变更集中。</p><p>在 Git 这边，对于其中任何一种风格的分支的工作都是相同的：仅仅是正常做的检出、提交、抓取、合并、拉取与推送。 还有需要知道的一件事情是 Mercurial 不支持重写历史，只允许添加历史。 下面是我们的 Mercurial 仓库在交互式的变基与强制推送后的样子：</p><pre class=" language-console"><code class="language-console">$ hg log --style compact -Go  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben|    A permanent change|o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben|    Add some documentation|o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben|    goodbye|| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben| |    A permanent change| || | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben| |/     More documentation| || o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben| |\     Merge remote-tracking branch 'origin/master'| | || | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben| | |    update makefile| | |+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben| |      goodbye| || o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben|/     Add some documentation|o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm|    Create a makefile|o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm     Create a standard "hello, world" program</code></pre><p>变更集 <em>8</em>、<em>9</em> 与 <em>10</em> 已经被创建出来并且属于 <code>permanent</code> 分支，但是旧的变更集依然在那里。 这会让使用 Mercurial 的团队成员非常困惑，所以要避免这种行为。</p><h4 id="Mercurial-总结"><a href="#Mercurial-总结" class="headerlink" title="Mercurial 总结"></a>Mercurial 总结</h4><p>Git 与 Mercurial 如此相似，以至于跨这两个系统进行工作十分流畅。 如果能注意避免改变在你机器上的历史（就像通常建议的那样），你甚至并不会察觉到另一端是 Mercurial。</p><h3 id="Git-与-Perforce"><a href="#Git-与-Perforce" class="headerlink" title="Git 与 Perforce"></a>Git 与 Perforce</h3><p>在企业环境中 Perforce 是非常流行的版本管理系统。 它大概起始于 1995 年，这使它成为了本章中介绍的最古老的系统。 就其本身而言，它设计时带有当时时代的局限性；它假定你始终连接到一个单独的中央服务器，本地磁盘只保存一个版本。 诚然，它的功能与限制适合几个特定的问题，但实际上，在很多情况下，将使用 Perforce 的项目换做使用 Git 会更好。</p><p>如果你决定混合使用 Perforce 与 Git 这里有两种选择。 第一个我们要介绍的是 Perforce 官方制作的 “Git Fusion” 桥接，它可以将 Perforce 仓库中的子树表示为一个可读写的 Git 仓库。 第二个是 git-p4，一个客户端桥接允许你将 Git 作为 Perforce 的客户端使用，而不用在 Perforce 服务器上做任何重新的配置。</p><h4 id="Git-Fusion"><a href="#Git-Fusion" class="headerlink" title="Git Fusion"></a>Git Fusion</h4><p>Perforce 提供了一个叫作 Git Fusion 的产品（可在 <a href="http://www.perforce.com/git-fusion" target="_blank" rel="noopener">http://www.perforce.com/git-fusion</a> 获得），它将会在服务器这边同步 Perforce 服务器与 Git 仓库。</p><h6 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h6><p>针对我们的例子，我们将会使用最简单的方式安装 Git Fusion：下载一个虚拟机来运行 Perforce 守护进程与 Git Fusion。 可以从 <a href="http://www.perforce.com/downloads/Perforce/20-User" target="_blank" rel="noopener">http://www.perforce.com/downloads/Perforce/20-User</a> 获得虚拟机镜像，下载完成后将它导入到你最爱的虚拟机软件中（我们将会使用 VirtualBox）。</p><p>在第一次启动机器后，它会询问你自定义三个 Linux 用户（<code>root</code>、<code>perforce</code> 与 <code>git</code>）的密码，并且提供一个实例名字来区分在同一网络下不同的安装。 当那些都完成后，将会看到这样：</p><p><img src="https://git-scm.com/book/en/v2/images/git-fusion-boot.png" alt="Git Fusion 虚拟机启动屏幕。"></p><p>Figure 146. Git Fusion 虚拟机启动屏幕。</p><p>应当注意显示在这儿的 IP 地址，我们将会在后面用到。 接下来，我们将会创建一个 Perforce 用户。 选择底部的 “Login” 选项并按下回车（或者用 SSH 连接到这台机器），然后登录为 <code>root</code>。 然后使用这些命令创建一个用户：</p><pre class=" language-console"><code class="language-console">$ p4 -p localhost:1666 -u super user -f john$ p4 -p localhost:1666 -u john passwd$ exit</code></pre><p>第一个命令将会打开一个 VI 编辑器来自定义用户，但是可以通过输入 <code>:wq</code> 并回车来接受默认选项。 第二个命令将会提示输入密码两次。 这就是所有我们要通过终端提示符做的事情，所以现在可以退出当前会话了。</p><p>接下来要做的事就是告诉 Git 不要验证 SSL 证书。 Git Fusion 镜像内置一个证书，但是域名并不匹配你的虚拟主机的 IP 地址，所以 Git 会拒绝 HTTPS 连接。 如果要进行永久安装，查阅 Perforce Git Fusion 手册来安装一个不同的证书；然而，对于我们这个例子来说，这已经足够了。</p><pre class=" language-console"><code class="language-console">$ export GIT_SSL_NO_VERIFY=true</code></pre><p>现在我们可以测试所有东西是不是正常工作。</p><pre class=" language-console"><code class="language-console">$ git clone https://10.0.1.254/TalkhouseCloning into 'Talkhouse'...Username for 'https://10.0.1.254': johnPassword for 'https://john@10.0.1.254':remote: Counting objects: 630, done.remote: Compressing objects: 100% (581/581), done.remote: Total 630 (delta 172), reused 0 (delta 0)Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.Resolving deltas: 100% (172/172), done.Checking connectivity... done.</code></pre><p>虚拟机镜像自带一个可以克隆的样例项目。 这里我们会使用之前创建的 <code>john</code> 用户，通过 HTTPS 进行克隆；Git 询问此次连接的凭证，但是凭证缓存会允许我们跳过这步之后的任意后续请求。</p><h6 id="FUSION-配置"><a href="#FUSION-配置" class="headerlink" title="FUSION 配置"></a>FUSION 配置</h6><p>一旦安装了 Git Fusion，你会想要调整配置。 使用你最爱的 Perforce 客户端做这件事实际上相当容易；只需要映射 Perforce 服务器上的 <code>//.git-fusion</code> 目录到你的工作空间。 文件结构看起来像这样：</p><pre class=" language-console"><code class="language-console">$ tree.├── objects│   ├── repos│   │   └── [...]│   └── trees│       └── [...]│├── p4gf_config├── repos│   └── Talkhouse│       └── p4gf_config└── users    └── p4gf_usermap498 directories, 287 files</code></pre><p><code>objects</code> 目录被 Git Fusion 内部用来双向映射 Perforce 对象与 Git 对象，你不必弄乱那儿的任何东西。 在这个目录中有一个全局的 <code>p4gf_config</code> 文件，每个仓库中也会有一份 - 这些配置文件决定了 Git Fusion 的行为。 让我们看一下根目录下的文件：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[repo-creation]</span><span class="token constant">charset</span> <span class="token attr-value"><span class="token punctuation">=</span> utf8</span><span class="token selector">[git-to-perforce]</span><span class="token constant">change-owner</span> <span class="token attr-value"><span class="token punctuation">=</span> author</span><span class="token constant">enable-git-branch-creation</span> <span class="token attr-value"><span class="token punctuation">=</span> yes</span><span class="token constant">enable-swarm-reviews</span> <span class="token attr-value"><span class="token punctuation">=</span> yes</span><span class="token constant">enable-git-merge-commits</span> <span class="token attr-value"><span class="token punctuation">=</span> yes</span><span class="token constant">enable-git-submodules</span> <span class="token attr-value"><span class="token punctuation">=</span> yes</span><span class="token constant">preflight-commit</span> <span class="token attr-value"><span class="token punctuation">=</span> none</span><span class="token constant">ignore-author-permissions</span> <span class="token attr-value"><span class="token punctuation">=</span> no</span><span class="token constant">read-permission-check</span> <span class="token attr-value"><span class="token punctuation">=</span> none</span><span class="token constant">git-merge-avoidance-after-change-num</span> <span class="token attr-value"><span class="token punctuation">=</span> 12107</span><span class="token selector">[perforce-to-git]</span><span class="token constant">http-url</span> <span class="token attr-value"><span class="token punctuation">=</span> none</span><span class="token constant">ssh-url</span> <span class="token attr-value"><span class="token punctuation">=</span> none</span><span class="token selector">[@features]</span><span class="token constant">imports</span> <span class="token attr-value"><span class="token punctuation">=</span> False</span><span class="token constant">chunked-push</span> <span class="token attr-value"><span class="token punctuation">=</span> False</span><span class="token constant">matrix2</span> <span class="token attr-value"><span class="token punctuation">=</span> False</span><span class="token constant">parallel-push</span> <span class="token attr-value"><span class="token punctuation">=</span> False</span><span class="token selector">[authentication]</span><span class="token constant">email-case-sensitivity</span> <span class="token attr-value"><span class="token punctuation">=</span> no</span></code></pre><p>这里我们并不会深入介绍这些选项的含义，但是要注意这是一个 INI 格式的文本文件，就像 Git 的配置。 这个文件指定了全局选项，但它可以被仓库特定的配置文件覆盖，像是 <code>repos/Talkhouse/p4gf_config</code>。 如果打开这个文件，你会看到有一些与全局默认不同设置的 <code>[@repo]</code> 区块。 你也会看到像下面这样的区块：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[Talkhouse-master]</span><span class="token constant">git-branch-name</span> <span class="token attr-value"><span class="token punctuation">=</span> master</span><span class="token constant">view</span> <span class="token attr-value"><span class="token punctuation">=</span> //depot/Talkhouse/main-dev/... ...</span></code></pre><p>这是一个 Perforce 分支与一个 Git 分支的映射。 这个区块可以被命名成你喜欢的名字，只要保证名字是唯一的即可。 <code>git-branch-name</code> 允许你将在 Git 下显得笨重的仓库路径转换为更友好的名字。 <code>view</code> 选项使用标准视图映射语法控制 Perforce 文件如何映射到 Git 仓库。 可以指定一个以上的映射，就像下面的例子：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[multi-project-mapping]</span><span class="token constant">git-branch-name</span> <span class="token attr-value"><span class="token punctuation">=</span> master</span><span class="token constant">view</span> <span class="token attr-value"><span class="token punctuation">=</span> //depot/project1/main/... project1/...</span>       //depot/project2/mainline/... project2/...</code></pre><p>通过这种方式，如果正常工作空间映射包含对目录结构的修改，可以将其复制为一个 Git 仓库。</p><p>最后一个我们讨论的文件是 <code>users/p4gf_usermap</code>，它将 Perforce 用户映射到 Git 用户，但你可能不会需要它。 当从一个 Perforce 变更集转换为一个 Git 提交时，Git Fusion 的默认行为是去查找 Perforce 用户，然后把邮箱地址与全名存储在 Git 的 author/commiter 字段中。 当反过来转换时，默认的行为是根据存储在 Git 提交中 author 字段中的邮箱地址来查找 Perforce 用户，然后以该用户提交变更集（以及权限的应用）。 大多数情况下，这个行为工作得很好，但是考虑下面的映射文件：</p><pre><code>john john@example.com &quot;John Doe&quot;john johnny@appleseed.net &quot;John Doe&quot;bob employeeX@example.com &quot;Anon X. Mouse&quot;joe employeeY@example.com &quot;Anon Y. Mouse&quot;</code></pre><p>每一行的格式都是 <code>&lt;user&gt; &lt;email&gt; &quot;&lt;full name&gt;&quot;</code>，创建了一个单独的用户映射。 前两行映射不同的邮箱地址到同一个 Perforce 用户账户。 当使用几个不同的邮箱地址（或改变邮箱地址）生成 Git 提交并且想要让他们映射到同一个 Perforce 用户时这会很有用。 当从一个 Perforce 变更集创建一个 Git 提交时，第一个匹配 Perforce 用户的行会被用作 Git 作者信息。</p><p>最后两行从创建的 Git 提交中掩盖了 Bob 与 Joe 的真实名字与邮箱地址。 当你想要将一个内部项目开源，但不想将你的雇员目录公布到全世界时这很不错。 注意邮箱地址与全名需要是唯一的，除非想要所有的 Git 提交都属于一个虚构的作者。</p><h6 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h6><p>Perforce Git Fusion 是在 Perforce 与 Git 版本控制间双向的桥接。 让我们看一下在 Git 这边工作是什么样的感觉。 假定我们在 “Jam” 项目中使用上述的配置文件映射了，可以这样克隆：</p><pre class=" language-console"><code class="language-console">$ git clone https://10.0.1.254/JamCloning into 'Jam'...Username for 'https://10.0.1.254': johnPassword for 'https://ben@10.0.1.254':remote: Counting objects: 2070, done.remote: Compressing objects: 100% (1704/1704), done.Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.remote: Total 2070 (delta 1242), reused 0 (delta 0)Resolving deltas: 100% (1242/1242), done.Checking connectivity... done.$ git branch -a* master  remotes/origin/HEAD -> origin/master  remotes/origin/master  remotes/origin/rel2.1$ git log --oneline --decorate --graph --all* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.| * bd2f54a Put in fix for jam's NT handle leak.| * c0f29e7 Fix URL in a jam doc| * cc644ac Radstone's lynx port.[...]</code></pre><p>当首次这样做时，会花费一些时间。 这里发生的是 Git Fusion 会将在 Perforce 历史中所有合适的变更集转换为 Git 提交。 这发生在服务器端本地，所以会相当快，但是如果有很多历史，那么它还是会花费一些时间。 后来的抓取会做增量转换，所以会感觉更像 Git 的本地速度。</p><p>如你所见，我们的仓库看起来像之前使用过的任何一个 Git 仓库了。 这里有三个分支，Git 已经帮助创建了一个跟踪 <code>origin/master</code> 的本地 <code>master</code> 分支。 让我们做一些工作，创建几个新提交：</p><pre class=" language-console"><code class="language-console"># ...$ git log --oneline --decorate --graph --all* cfd46ab (HEAD, master) Add documentation for new feature* a730d77 Whitespace* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.* bd2f54a Put in fix for jam's NT handle leak.[...]</code></pre><p>我们有两个新提交。 现在我们检查下是否有其他人在工作：</p><pre class=" language-console"><code class="language-console">$ git fetchremote: Counting objects: 5, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 2), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From https://10.0.1.254/Jam   d254865..6afeb15  master     -> origin/master$ git log --oneline --decorate --graph --all* 6afeb15 (origin/master, origin/HEAD) Update copyright| * cfd46ab (HEAD, master) Add documentation for new feature| * a730d77 Whitespace|/* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.* bd2f54a Put in fix for jam's NT handle leak.[...]</code></pre><p>看起来有人在工作！ 从这个视图来看你并不知道这点，但是 <code>6afeb15</code> 提交确实是使用 Perforce 客户端创建的。 从 Git 的视角看它仅仅只是另一个提交，准确地说是一个点。 让我们看看 Perforce 服务器如何处理一个合并提交：</p><pre class=" language-console"><code class="language-console">$ git merge origin/masterAuto-merging READMEMerge made by the 'recursive' strategy. README | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git pushCounting objects: 9, done.Delta compression using up to 8 threads.Compressing objects: 100% (9/9), done.Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.Total 9 (delta 6), reused 0 (delta 0)remote: Perforce: 100% (3/3) Loading commit tree into memory...remote: Perforce: 100% (5/5) Finding child commits...remote: Perforce: Running git fast-export...remote: Perforce: 100% (3/3) Checking commits...remote: Processing will continue even if connection is closed.remote: Perforce: 100% (3/3) Copying changelists...remote: Perforce: Submitting new Git commit objects to Perforce: 4To https://10.0.1.254/Jam   6afeb15..89cba2b  master -> master</code></pre><p>Git 认为它成功了。 让我们从 Perforce 的视角看一下 <code>README</code> 文件的历史，使用 <code>p4v</code> 的版本图功能。</p><p><img src="https://git-scm.com/book/en/v2/images/git-fusion-perforce-graph.png" alt="Git 推送后的 Perforce 版本图。"></p><p>Figure 147. Git 推送后的 Perforce 版本图</p><p>如果你在之前从未看过这个视图，它似乎让人困惑，但是它显示出了作为 Git 历史图形化查看器相同的概念。 我们正在查看 <code>README</code> 文件的历史，所以左上角的目录树只显示那个文件在不同分支的样子。 右上方，我们有不同版本文件关系的可视图，这个可视图的全局视图在右下方。 视图中剩余的部分显示出选择版本的详细信息（在这个例子中是 <code>2</code>）</p><p>还要注意的一件事是这个图看起来很像 Git 历史中的图。 Perforce 没有存储 <code>1</code> 和 <code>2</code> 提交的命名分支，所以它在 <code>.git-fusion</code> 目录中生成了一个 “anonymous” 分支来保存它。 这也会在 Git 命名分支不对应 Perforce 命名分支时发生（稍后你可以使用配置文件来映射它们到 Perforce 分支）。</p><p>这些大多数发生在后台，但是最终结果是团队中的一个人可以使用 Git，另一个可以使用 Perforce，而所有人都不知道其他人的选择。</p><h6 id="GIT-FUSION-总结"><a href="#GIT-FUSION-总结" class="headerlink" title="GIT-FUSION 总结"></a>GIT-FUSION 总结</h6><p>如果你有（或者能获得）接触你的 Perforce 服务器的权限，那么 Git Fusion 是使 Git 与 Perforce 互相交流的很好的方法。 这里包含了一点配置，但是学习曲线并不是很陡峭。 这是本章中其中一个不会出现无法使用 Git 全部能力的警告的章节。 这并不是说扔给 Perforce 任何东西都会高兴 - 如果你尝试重写已经推送的历史，Git Fusion 会拒绝它 - 虽然 Git Fusion 尽力让你感觉是原生的。 你甚至可以使用 Git 子模块（尽管它们对 Perforce 用户看起来很奇怪），合并分支（在 Perforce 这边会被记录了一次整合）。</p><p>如果不能说服你的服务器管理员设置 Git Fusion，依然有一种方式来一起使用这两个工具。</p><h4 id="Git-p4"><a href="#Git-p4" class="headerlink" title="Git-p4"></a>Git-p4</h4><p>Git-p4 是 Git 与 Perforce 之间的双向桥接。 它完全运行在你的 Git 仓库内，所以你不需要任何访问 Perforce 服务器的权限（当然除了用户验证）。 Git-p4 并不像 Git Fusion 一样灵活或完整，但是它允许你在无需修改服务器环境的情况下，做大部分想做的事情。</p><table><thead><tr><th>Note</th><th>为了与 git-p4 一起工作需要在你的 <code>PATH</code> 环境变量中的某个目录中有 <code>p4</code> 工具。 在写这篇文章的时候，它可以在 <a href="http://www.perforce.com/downloads/Perforce/20-User" target="_blank" rel="noopener">http://www.perforce.com/downloads/Perforce/20-User</a> 免费获得。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h6 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h6><p>出于演示的目的，我们将会从上面演示的 Git Fusion OVA 运行 Perforce 服务器，但是我们会绕过 Git Fusion 服务器然后直接进行 Perforce 版本管理。</p><p>为了使用 <code>p4</code> 命令行客户端（git-p4 依赖项），你需要设置两个环境变量：</p><pre class=" language-console"><code class="language-console">$ export P4PORT=10.0.1.254:1666$ export P4USER=john</code></pre><h6 id="开始-2"><a href="#开始-2" class="headerlink" title="开始"></a>开始</h6><p>像在 Git 中的任何事情一样，第一个命令就是克隆：</p><pre class=" language-console"><code class="language-console">$ git p4 clone //depot/www/live www-shallowImporting from //depot/www/live into www-shallowInitialized empty Git repository in /private/tmp/www-shallow/.git/Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre><p>这样会创建出一种在 Git 中名为 “shallow” 克隆；只有最新版本的 Perforce 被导入至 Git；记住，Perforce 并未被设计成给每一个用户一个版本。 使用 Git 作为 Perforce 客户端这样就足够了，但是为了其他目的的话这样可能不够。</p><p>完成之后，我们就有一个全功能的 Git 仓库：</p><pre class=" language-console"><code class="language-console">$ cd myproject$ git log --oneline --all --graph --decorate* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>注意有一个 “p4” 远程代表 Perforce 服务器，但是其他东西看起来就像是标准的克隆。 实际上，这有一点误导；其实远程仓库并不存在。</p><pre class=" language-console"><code class="language-console">$ git remote -v</code></pre><p>在当前仓库中并不存在任何远程仓库。 Git-p4 创建了一些引用来代表服务器的状态，它们看起来类似 <code>git log</code> 显示的远程引用，但是它们并不被 Git 本身管理，并且你无法推送它们。</p><h6 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h6><p>好了，让我们开始一些工作。 假设你已经在一个非常重要的功能上做了一些工作，然后准备好将它展示给团队中的其他人。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --all --graph --decorate* 018467c (HEAD, master) Change page title* c0fb617 Update link* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>我们已经生成了两次新提交并已准备好推送它们到 Perforce 服务器。 让我们检查一下今天其他人是否做了一些工作：</p><pre class=" language-console"><code class="language-console">$ git p4 syncgit p4 syncPerforming incremental import into refs/remotes/p4/master git branchDepot paths: //depot/www/live/Import destination: refs/remotes/p4/masterImporting revision 12142 (100%)$ git log --oneline --all --graph --decorate* 75cd059 (p4/master, p4/HEAD) Update copyright| * 018467c (HEAD, master) Change page title| * c0fb617 Update link|/* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>看起来他们做了，<code>master</code> 与 <code>p4/master</code> 已经分叉了。 Perforce 的分支系统一点也 <em>不</em> 像 Git 的，所以提交合并提交没有任何意义。 Git-p4 建议变基你的提交，它甚至提供了一个快捷方式来这样做：</p><pre class=" language-console"><code class="language-console">$ git p4 rebasePerforming incremental import into refs/remotes/p4/master git branchDepot paths: //depot/www/live/No changes to import!Rebasing the current branch onto remotes/p4/masterFirst, rewinding head to replay your work on top of it...Applying: Update linkApplying: Change page title index.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>从输出中可能大概得知，<code>git p4 rebase</code> 是 <code>git p4 sync</code> 接着 <code>git rebase p4/master</code> 的快捷方式。 它比那更聪明一些，特别是工作在多个分支时，但这是一个进步。</p><p>现在我们的历史再次是线性的，我们准备好我们的改动贡献回 Perforce。 <code>git p4 submit</code> 命令会尝试在 <code>p4/master</code> 与 <code>master</code> 之间的每一个 Git 提交创建一个新的 Perforce 修订版本。 运行它会带我们到最爱的编辑器，文件内容看起来像是这样：</p><pre class=" language-console"><code class="language-console"># A Perforce Change Specification.##  Change:      The change number. 'new' on a new changelist.#  Date:        The date this specification was last modified.#  Client:      The client on which the changelist was created.  Read-only.#  User:        The user who created the changelist.#  Status:      Either 'pending' or 'submitted'. Read-only.#  Type:        Either 'public' or 'restricted'. Default is 'public'.#  Description: Comments about the changelist.  Required.#  Jobs:        What opened jobs are to be closed by this changelist.#               You may delete jobs from this list.  (New changelists only.)#  Files:       What opened files from the default changelist are to be added#               to this changelist.  You may delete files from this list.#               (New changelists only.)Change:  newClient:  john_bens-mbp_8487User: johnStatus:  newDescription:   Update linkFiles:   //depot/www/live/index.html   # edit######## git author ben@straub.cc does not match your p4 account.######## Use option --preserve-user to modify authorship.######## Variable git-p4.skipUserNameCheck hides this message.######## everything below this line is just the diff #######--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000@@ -60,7 +60,7 @@ </td> <td valign=top> Source and documentation for-<a href="http://www.perforce.com/jam/jam.html">+<a href="jam.html"> Jam/MR</a>, a software build tool. </td></code></pre><p>除了结尾 git-p4 给我们的帮助性的提示，其它的与你运行 <code>p4 submit</code> 后看到的内容大多相同。 当提交或变更集需要一个名字时 git-p4 会分别尝试使用你的 Git 与 Perforce 设置，但是有些情况下你会想要覆盖默认行为。 例如，如果你正导入的提交是由没有 Perforce 用户账户的贡献者编写的，你还是会想要最终的变更集看起来像是他们写的（而不是你）。</p><p>Git-p4 帮助性地将 Git 的提交注释导入到 Perforce 变更集的内容，这样所有我们必须做的就是保存并退出，两次（每次一个提交）。 这会使 shell 输出看起来像这样：</p><pre class=" language-console"><code class="language-console">$ git p4 submitPerforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/Synchronizing p4 checkout...... - file(s) up-to-date.Applying dbac45b Update link//depot/www/live/index.html#4 - opened for editChange 12143 created with 1 open file(s).Submitting change 12143.Locking 1 files ...edit //depot/www/live/index.html#5Change 12143 submitted.Applying 905ec6a Change page title//depot/www/live/index.html#5 - opened for editChange 12144 created with 1 open file(s).Submitting change 12144.Locking 1 files ...edit //depot/www/live/index.html#6Change 12144 submitted.All commits applied!Performing incremental import into refs/remotes/p4/master git branchDepot paths: //depot/www/live/Import destination: refs/remotes/p4/masterImporting revision 12144 (100%)Rebasing the current branch onto remotes/p4/masterFirst, rewinding head to replay your work on top of it...$ git log --oneline --all --graph --decorate* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title* 05f1ade Update link* 75cd059 Update copyright* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>结果恰如我们只是做了一次 <code>git push</code>，就像是应当实际发生的最接近的类比。</p><p>注意在这个过程中每一个 Git 提交都会被转化为一个 Perforce 变更集；如果想要将它们压缩成为一个单独的提交，可以在运行 <code>git p4 submit</code> 前进行一次交互式变基。 同样注意的是所有被转化为变更集的提交的 SHA-1 校验和都改变了；这是因为 git-p4 在每一个转化的提交增加一行到提交注释结尾：</p><pre class=" language-console"><code class="language-console">$ git log -1commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145Author: John Doe <john@example.com>Date:   Sun Aug 31 10:31:44 2014 -0800    Change page title    [git-p4: depot-paths = "//depot/www/live/": change = 12144]</code></pre><p>当尝试提交一次合并提交时会发生什么？ 让我们尝试一下。 这是我们可能会遇到的一种情形：</p><pre class=" language-console"><code class="language-console">$ git log --oneline --all --graph --decorate* 3be6fd8 (HEAD, master) Correct email address*   1dcbf21 Merge remote-tracking branch 'p4/master'|\| * c4689fc (p4/master, p4/HEAD) Grammar fix* | cbacd0a Table borders: yes please* | b4959b6 Trademark|/* 775a46f Change page title* 05f1ade Update link* 75cd059 Update copyright* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>Git 与 Perforce 历史在 775a46f 后分叉了。 Git 这边有两次提交，然后一次与 Perforce 头部的合并提交，还有另一个提交。 我们将会尝试提交这些到 Perforce 那边单独的变更集之上。 让我们看看如果尝试这样提交会发生什么：</p><pre class=" language-console"><code class="language-console">$ git p4 submit -nPerforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/Would apply  b4959b6 Trademark  cbacd0a Table borders: yes please  3be6fd8 Correct email address</code></pre><p><code>-n</code> 标记是 <code>--dry-run</code> 的缩写，将会报告如果提交命令真的运行会发生什么。 这本例中，它看起来像是我们会创建三个 Perforce 变更集，对应着不在 Perforce 服务器端的三次非合并提交。 那听起来像是我们想要的，让我们看看它会如何做：</p><pre class=" language-console"><code class="language-console">$ git p4 submit[…]$ git log --oneline --all --graph --decorate* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address* 1b79a80 Table borders: yes please* 0097235 Trademark* c4689fc Grammar fix* 775a46f Change page title* 05f1ade Update link* 75cd059 Update copyright* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre><p>我们的历史变成线性了，就像在提交前刚刚变基过（实际上也是这样）。 这意味着你可以在 Git 这边自由地创建、工作、扔掉与合并分支而不用害怕你的历史会变得与 Perforce 不兼容。 如果你可以变基它，你就可以将它贡献到 Perforce 服务器。</p><h6 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h6><p>如果你的 Perforce 项目有多个分支，你并不会不走运；git-p4 可以以一种类似 Git 的方式来处理那种情况。 假定你的 Perforce 仓库平铺的时候像这样：</p><pre><code>//depot  └── project      ├── main      └── dev</code></pre><p>并且假定你有一个 <code>dev</code> 分支，有一个视图规格像下面这样：</p><pre><code>//depot/project/main/... //depot/project/dev/...</code></pre><p>Git-p4 可以自动地检测到这种情形并做正确的事情：</p><pre class=" language-console"><code class="language-console">$ git p4 clone --detect-branches //depot/project@allImporting from //depot/project@all into projectInitialized empty Git repository in /private/tmp/project/.git/Importing revision 20 (50%)    Importing new branch project/dev    Resuming with change 20Importing revision 22 (100%)Updated branches: main dev$ cd project; git log --oneline --all --graph --decorate* eae77ae (HEAD, p4/master, p4/HEAD, master) main| * 10d55fb (p4/project/dev) dev| * a43cfae Populate //depot/project/main/... //depot/project/dev/....|/* 2b83451 Project init</code></pre><p>注意在仓库路径中的 “@all” 说明符；那会告诉 git-p4 不仅仅只是克隆那个子树最新的变更集，更包括那些路径未接触的所有变更集。 这有点类似于 Git 的克隆概念，但是如果你工作在一个具有很长历史的项目，那么它会花费一段时间。</p><p><code>--detect-branches</code> 标记告诉 git-p4 使用 Perforce 的分支规范来映射到 Git 的引用中。 如果这些映射不在 Perforce 服务器中（使用 Perforce 的一种完美有效的方式），你可以告诉 git-p4 分支映射是什么，然后你会得到同样的结果：</p><pre class=" language-console"><code class="language-console">$ git init projectInitialized empty Git repository in /tmp/project/.git/$ cd project$ git config git-p4.branchList main:dev$ git clone --detect-branches //depot/project@all .</code></pre><p>设置 <code>git-p4.branchList</code> 配置选项为 <code>main:dev</code> 告诉 git-p4 那个 “main” 与 “dev” 都是分支，第二个是第一个的子分支。</p><p>如果我们现在运行 <code>git checkout -b dev p4/project/dev</code> 并且做一些提交，在运行 <code>git p4 submit</code> 时 git-p4 会聪明地选择正确的分支。 不幸的是，git-p4 不能混用 shallow 克隆与多个分支；如果你有一个巨型项目并且想要同时工作在不止一个分支上，可能不得不针对每一个你想要提交的分支运行一次 <code>git p4 clone</code>。</p><p>为了创建与整合分支，你不得不使用一个 Perforce 客户端。 Git-p4 只能同步或提交已有分支，并且它一次只能做一个线性的变更集。 如果你在 Git 中合并两个分支并尝试提交新的变更集，所有这些会被记录为一串文件修改；关于哪个分支参与的元数据在整合中会丢失。</p><h4 id="Git-与-Perforce-总结"><a href="#Git-与-Perforce-总结" class="headerlink" title="Git 与 Perforce 总结"></a>Git 与 Perforce 总结</h4><p>Git-p4 将与 Perforce 服务器工作时使用 Git 工作流成为可能，并且它非常擅长这点。 然而，需要记住的重要一点是 Perforce 负责源头，而你只是在本地使用 Git。 在共享 Git 提交时要相当小心：如果你有一个其他人使用的远程仓库，不要在提交到 Perforce 服务器前推送任何提交。</p><p>如果想要为源码管理自由地混合使用 Perforce 与 Git 作为客户端，可以说服服务器管理员安装 Git Fusion，Git Fusion 使 Git 作为 Perforce 服务器的首级版本管理客户端。</p><h3 id="Git-与-TFS"><a href="#Git-与-TFS" class="headerlink" title="Git 与 TFS"></a>Git 与 TFS</h3><p>Git 在 Windows 开发者当中变得流行起来，如果你正在 Windows 上编写代码并且正在使用 Microsoft 的 Team Foundation Server (TFS)，这会是个好机会。 TFS 是一个包含工作项目检测与跟踪、支持 Scrum 与其他流程管理方法、代码审核、版本控制的协作套件。 这里有一点困惑：<strong>TFS</strong> 是服务器，它支持通过 Git 与它们自定义的 VCS 来管理源代码，这被他们称为 <strong>TFVC</strong>（Team Foundation Version Control）。 Git 支持 TFS（自 2013 版本起）的部分新功能，所以在那之前所有工具都将版本控制部分称为 “TFS”，即使实际上他们大部分时间都在与 TFVC 工作。</p><p>如果发现你的团队在使用 TFVC 但是你更愿意使用 Git 作为版本控制客户端，这里为你准备了一个项目。</p><h4 id="选择哪个工具"><a href="#选择哪个工具" class="headerlink" title="选择哪个工具"></a>选择哪个工具</h4><p>实际上，这里有两个工具：git-tf 与 git-tfs。</p><p>Git-tfs （可以在 <a href="https://github.com/git-tfs/git-tfs" target="_blank" rel="noopener">https://github.com/git-tfs/git-tfs</a> 找到）是一个 .NET 项目，它只能运行在 Windows 上（截至文章完成时）。 为了操作 Git 仓库，它使用了 libgit2 的 .NET 绑定，一个可靠的面向库的 Git 实现，十分灵活且性能优越。 Libgit2 并不是一个完整的 Git 实现，为了弥补差距 git-tfs 实际上会调用 Git 命令行客户端来执行某些操作，因此在操作 Git 仓库时并没有任何功能限制。 因为它使用 Visual Studio 程序集对服务器进行操作，所以它对 TFVC 的支持非常成熟。 这并不意味着你需要接触那些程序集，但是意味着你需要安装 Visual Studio 的一个最近版本（2010 之后的任何版本，包括 2012 之后的 Express 版本），或者 Visual Studio SDK。</p><p>Git-tf（主页在 <a href="https://gittf.codeplex.com/" target="_blank" rel="noopener">https://gittf.codeplex.com</a>）是一个 Java 项目，因此它可以运行在任何一个有 Java 运行时环境的电脑上。 它通过 JGit（一个 Git 的 JVM 实现）来与 Git 仓库交互，这意味着事实上它没有 Git 功能上的限制。 然而，相对于 git-tfs 它对 TFVC 的支持是有限的 - 例如，它不支持分支。</p><p>所以每个工具都有优点和缺点，每个工具都有它适用的情况。 我们在本书中将会介绍它们两个的基本用法。</p><table><thead><tr><th>Note</th><th>你需要有一个基于 TFVC 的仓库来执行后续的指令。 现实中它们并没有 Git 或 Subversion 仓库那样多，所以你可能需要创建一个你自己的仓库。 Codeplex (<a href="https://www.codeplex.com/" target="_blank" rel="noopener">https://www.codeplex.com</a>) 或 Visual Studio Online (<a href="http://www.visualstudio.com/" target="_blank" rel="noopener">http://www.visualstudio.com</a>) 都是非常好的选择。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="使用：git-tf"><a href="#使用：git-tf" class="headerlink" title="使用：git-tf"></a>使用：<code>git-tf</code></h4><p>和其它任何 Git 项目一样，你要做的第一件事是克隆。 使用 <code>git-tf</code> 克隆看起来像这样：</p><pre class=" language-console"><code class="language-console">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git</code></pre><p>第一个参数是一个 TFVC 集的 URL，第二个参数类似于 <code>$/project/branch</code> 的形式，第三个参数是将要创建的本地 Git 仓库路径（最后一项可以省略）。 Git-tf 同一时间只能工作在一个分支上；如果你想要检入一个不同的 TFVC 分支，你需要从那个分支克隆一份新的。</p><p>这会创建一个完整功能的 Git 仓库：</p><pre class=" language-console"><code class="language-console">$ cd project_git$ git log --all --oneline --decorate512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</code></pre><p>这叫做 <em>浅</em> 克隆，意味着只下载了最新的变更集。 TFVC 并未设计成为每一个客户端提供一份全部历史记录的拷贝，所以 git-tf 默认行为是获得最新的版本，这样更快一些。</p><p>如果愿意多花一些时间，使用 <code>--deep</code> 选项克隆整个项目历史可能更有价值。</p><pre class=" language-console"><code class="language-console">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \  project_git --deepUsername: domain\userPassword:Connecting to TFS...Cloning $/myproject into /tmp/project_git: 100%, done.Cloned 4 changesets. Cloned last changeset 35190 as d44b17a$ cd project_git$ git log --all --oneline --decorated44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye126aa7b (tag: TFS_C35189)8f77431 (tag: TFS_C35178) FIRST0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \        Team Project Creation Wizard</code></pre><p>注意名字类似 <code>TFS_C35189</code> 的标签；这是一个帮助你知道 Git 提交与 TFVC 变更集关联的功能。 这是一种优雅的表示方式，因为通过一个简单的 log 命令就可以看到你的提交是如何与 TFVC 中已存在快照关联起来的。 它们并不是必须的（并且实际上可以使用 <code>git config git-tf.tag false</code> 来关闭它们）- git-tf 会在 <code>.git/git-tf</code> 文件中保存真正的提交与变更集的映射。</p><h4 id="使用：git-tfs"><a href="#使用：git-tfs" class="headerlink" title="使用：git-tfs"></a>使用：<code>git-tfs</code></h4><p>Git-tfs 克隆行为略为不同。 观察：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs clone <span class="token operator">--</span>with<span class="token operator">-</span>branches \    https:<span class="token operator">/</span><span class="token operator">/</span>username<span class="token punctuation">.</span>visualstudio<span class="token punctuation">.</span>com<span class="token operator">/</span>DefaultCollection \    $<span class="token operator">/</span>project<span class="token operator">/</span>Trunk project_gitInitialized empty Git repository in C:<span class="token operator">/</span>Users<span class="token operator">/</span>ben<span class="token operator">/</span>project_git<span class="token operator">/</span><span class="token punctuation">.</span>git<span class="token operator">/</span>C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9C16 = c403405f4989d73a2c3c119e79021cb2104ce44aTfs branches found:<span class="token operator">-</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>featureAThe name of the local branch will be : featureAC17 = d202b53f67bde32171d5078968c644e562f1c439C18 = 44cd729d8df868a8be20438fdeeefb961958b674</code></pre><p>注意 <code>--with-branches</code> 选项。 Git-tfs 能够映射 TFVC 分支到 Git 分支，这个标记告诉它为每一个 TFVC 分支建立一个本地的 Git 分支。 强烈推荐曾经在 TFS 中新建过分支或合并过分支的仓库使用这个标记，但是如果使用的服务器的版本比 TFS 2010 更老 - 在那个版本前，“分支” 只是文件夹，所以 git-tfs 无法将它们与普通文件夹区分开。</p><p>让我们看一下最终的 Git 仓库：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git log <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>decorate <span class="token operator">--</span>all<span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token operator">*</span> c403405 <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> tfs<span class="token operator">/</span>default<span class="token punctuation">,</span> master<span class="token punctuation">)</span> Hello<span class="token operator">*</span> b75da1a New project<span class="token function">PS</span>> git log <span class="token operator">-</span>1commit c403405f4989d73a2c3c119e79021cb2104ce44aAuthor: Ben Straub &lt;ben@straub<span class="token punctuation">.</span>cc>Date:   Fri Aug 1 03:41:59 2014 <span class="token operator">+</span>0000    Hello    git<span class="token operator">-</span>tfs<span class="token operator">-</span>id: <span class="token namespace">[https://username.visualstudio.com/DefaultCollection]</span>$<span class="token operator">/</span>myproject<span class="token operator">/</span>Trunk<span class="token punctuation">;</span>C16</code></pre><p>有两个本地分支，<code>master</code> 与 <code>featureA</code>，分别代表着克隆（TFVC 中的 <code>Trunk</code>）与子分支（TFVC 中的 <code>featureA</code>）的初始状态。 也可以看到 <code>tfs</code> “remote” 也有一对引用：<code>default</code> 与 <code>featureA</code>，代表 TFVC 分支。 Git-tfs 映射从 <code>tfs/default</code> 克隆的分支，其他的会有它们自己的名字。</p><p>另一件需要注意的事情是在提交信息中的 <code>git-tfs-id:</code> 行。 Git-tfs 使用这些标记而不是标签来关联 TFVC 变更集与 Git 提交。 有一个潜在的问题是 Git 提交在推送到 TFVC 前后会有不同的 SHA-1 校验和。</p><h4 id="Git-tf-s-工作流程"><a href="#Git-tf-s-工作流程" class="headerlink" title="Git-tf[s] 工作流程"></a>Git-tf[s] 工作流程</h4><table><thead><tr><th>Note</th><th>无论你使用哪个工具，都需要先设置几个 Git 配置选项来避免一些问题。<code>$ git config set --local core.ignorecase=true $ git config set --local core.autocrlf=false</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>显然，接下来要做的事情就是要在项目中做一些工作。 TFVC 与 TFS 有几个功能可能会增加你的工作流程的复杂性：</p><ol><li>TFVC 无法表示特性分支，这会增加一点复杂度。 这会导致需要以 <strong>非常</strong> 不同的方式使用 TFVC 与 Git 表示的分支。</li><li>要意识到 TFVC 允许用户从服务器上 “检出” 文件并锁定它们，这样其他人就无法编辑了。 显然它不会阻止你在本地仓库中编辑它们，但是当推送你的修改到 TFVC 服务器时会出现问题。</li><li>TFS 有一个 “封闭” 检入的概念，TFS 构建-测试循环必须在检入被允许前成功完成。 这使用了 TFVC 的 “shelve” 功能，我们不会在这里详述。 可以通过 git-tf 手动地模拟这个功能，并且 git-tfs 提供了封闭敏感的 <code>checkintool</code> 命令。</li></ol><p>出于简洁性的原因，我们这里介绍的是一种轻松的方式，回避并避免了大部分问题。</p><h4 id="工作流程：git-tf"><a href="#工作流程：git-tf" class="headerlink" title="工作流程：git-tf"></a>工作流程：<code>git-tf</code></h4><p>假定你完成了一些工作，在 <code>master</code> 中做了几次 Git 提交，然后准备将你的进度共享到服务器。 这是我们的 Git 仓库：</p><pre class=" language-console"><code class="language-console">$ git log --oneline --graph --decorate --all* 4178a82 (HEAD, master) update code* 9df2ae3 update readme* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye* 126aa7b (tag: TFS_C35189)* 8f77431 (tag: TFS_C35178) FIRST* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \          Team Project Creation Wizard</code></pre><p>我们想要拿到在 <code>4178a82</code> 提交的快照并将其推送到 TFVC 服务器。 先说重要的：让我们看看自从上次连接后我们的队友是否进行过改动：</p><pre class=" language-console"><code class="language-console">$ git tf fetchUsername: domain\userPassword:Connecting to TFS...Fetching $/myproject at latest changeset: 100%, done.Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.$ git log --oneline --graph --decorate --all* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text| * 4178a82 (HEAD, master) update code| * 9df2ae3 update readme|/* d44b17a (tag: TFS_C35190) Goodbye* 126aa7b (tag: TFS_C35189)* 8f77431 (tag: TFS_C35178) FIRST* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \          Team Project Creation Wizard</code></pre><p>看起来其他人也做了一些改动，现在我们有一个分叉的历史。 这就是 Git 的优势，但是我们现在有两种处理的方式：</p><ol><li>像一名 Git 用户一样自然的生成一个合并提交（毕竟，那也是 <code>git pull</code> 做的），git-tf 可以通过一个简单的 <code>git tf pull</code> 来帮你完成。 然而，我们要注意的是，TFVC 却并不这样想，如果你推送合并提交那么你的历史在两边看起来都不一样，这会造成困惑。 其次，如果你计划将所有你的改动提交为一次变更集，这可能是最简单的选择。</li><li>变基使我们的提交历史变成直线，这意味着我们有个选项可以将我们的每一个 Git 提交转换为一个 TFVC 变更集。 因为这种方式为其他选项留下了可能，所以我们推荐你这样做；git-tf 可以很简单地通过 <code>git tf pull --rebase</code> 帮你达成目标。</li></ol><p>这是你的选择。 在本例中，我们会进行变基：</p><pre class=" language-console"><code class="language-console">$ git rebase FETCH_HEADFirst, rewinding head to replay your work on top of it...Applying: update readmeApplying: update code$ git log --oneline --graph --decorate --all* 5a0e25e (HEAD, master) update code* 6eb3eb5 update readme* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text* d44b17a (tag: TFS_C35190) Goodbye* 126aa7b (tag: TFS_C35189)* 8f77431 (tag: TFS_C35178) FIRST* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \          Team Project Creation Wizard</code></pre><p>现在我们准备好生成一个检入来推送到 TFVC 服务器上了。 Git-tf 给你一个将自上次修改（即 <code>--shallow</code>选项，默认启用）以来所有的修改生成的一个单独的变更集以及为每一个 Git 提交（<code>--deep</code>）生成的一个新的变更集。 在本例中，我们将会创建一个变更集：</p><pre class=" language-console"><code class="language-console">$ git tf checkin -m 'Updating readme and code'Username: domain\userPassword:Connecting to TFS...Checking in to $/myproject: 100%, done.Checked commit 5a0e25e in as changeset 35348$ git log --oneline --graph --decorate --all* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code* 6eb3eb5 update readme* 8ef06a8 (tag: TFS_C35320) just some text* d44b17a (tag: TFS_C35190) Goodbye* 126aa7b (tag: TFS_C35189)* 8f77431 (tag: TFS_C35178) FIRST* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \          Team Project Creation Wizard</code></pre><p>那有一个新标签 <code>TFS_C35348</code>，表明 TFVC 已经存储了一个相当于 <code>5a0e25e</code> 提交的快照。 要重点注意的是，不是每一个 Git 提交都需要在 TFVC 中存在一个相同的副本；例如 <code>6eb3eb5</code> 提交，在服务器上并不存在。</p><p>这就是主要的工作流程。 有一些你需要考虑的其他注意事项：</p><ul><li>没有分支。 Git-tf 同一时间只能从一个 TFVC 分支创建一个 Git 仓库。</li><li>协作时使用 TFVC 或 Git，而不是两者同时使用。 同一个 TFVC 仓库的不同 git-tf 克隆会有不同的 SHA-1 校验和，这会导致无尽的头痛问题。</li><li>如果你的团队的工作流程包括在 Git 中协作并定期与 TFVC 同步，只能使用其中的一个 Git 仓库连接到 TFVC。</li></ul><h4 id="工作流程：git-tfs"><a href="#工作流程：git-tfs" class="headerlink" title="工作流程：git-tfs"></a>工作流程：<code>git-tfs</code></h4><p>让我们使用 git-tfs 来走一遍同样的情景。 这是我们在 Git 仓库中 <code>master</code> 分支上生成的几个新提交：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git log <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>all <span class="token operator">--</span>decorate<span class="token operator">*</span> c3bd3ae <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> master<span class="token punctuation">)</span> update code<span class="token operator">*</span> d85e5a2 update readme<span class="token punctuation">|</span> <span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token punctuation">|</span> <span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token punctuation">|</span><span class="token operator">/</span><span class="token operator">*</span> c403405 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>default<span class="token punctuation">)</span> Hello<span class="token operator">*</span> b75da1a New project</code></pre><p>让我们看一下在我们工作时有没有人完成一些其它的工作：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs fetchC19 = aea74a0313de0a391940c999e51c5c15c381d91d<span class="token function">PS</span>> git log <span class="token operator">--</span>all <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>decorate<span class="token operator">*</span> aea74a0 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>default<span class="token punctuation">)</span> update documentation<span class="token punctuation">|</span> <span class="token operator">*</span> c3bd3ae <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> master<span class="token punctuation">)</span> update code<span class="token punctuation">|</span> <span class="token operator">*</span> d85e5a2 update readme<span class="token punctuation">|</span><span class="token operator">/</span><span class="token punctuation">|</span> <span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token punctuation">|</span> <span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token punctuation">|</span><span class="token operator">/</span><span class="token operator">*</span> c403405 Hello<span class="token operator">*</span> b75da1a New project</code></pre><p>是的，那说明我们的同事增加了一个新的 TFVC 变更集，显示为新的 <code>aea74a0</code> 提交，而 <code>tfs/default</code> 远程分支已经被移除了。</p><p>与 git-tf 相同，我们有两种基础选项来解决这个分叉历史问题：</p><ol><li>通过变基来保持历史是线性的。</li><li>通过合并来保留改动。</li></ol><p>在本例中，我们将要做一个 “深” 检入，也就是说每一个 Git 提交会变成一个 TFVC 变更集，所以我们想要变基。</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git rebase tfs<span class="token operator">/</span>defaultFirst<span class="token punctuation">,</span> rewinding head to replay your work on top of it<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Applying: update readmeApplying: update code<span class="token function">PS</span>> git log <span class="token operator">--</span>all <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>decorate<span class="token operator">*</span> 10a75ac <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> master<span class="token punctuation">)</span> update code<span class="token operator">*</span> 5cec4ab update readme<span class="token operator">*</span> aea74a0 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>default<span class="token punctuation">)</span> update documentation<span class="token punctuation">|</span> <span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token punctuation">|</span> <span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token punctuation">|</span><span class="token operator">/</span><span class="token operator">*</span> c403405 Hello<span class="token operator">*</span> b75da1a New project</code></pre><p>现在已经准备好通过检入我们的代码到 TFVC 服务器来完成贡献。 我们这里将会使用 <code>rcheckin</code> 命令将 HEAD 到第一个 <code>tfs</code> 远程分支间的每一个 Git 提交转换为一个 TFVC 变更集（<code>checkin</code> 命令只会创建一个变更集，有些类似于压缩 Git 提交）。</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs rcheckinWorking with tfs remote: defaultFetching changes <span class="token keyword">from</span> TFS to minimize possibility of late conflict<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Starting checkin of 5cec4ab4 <span class="token string">'update readme'</span> add README<span class="token punctuation">.</span>mdC20 = 71a5ddce274c19f8fdc322b4f165d93d89121017Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed<span class="token punctuation">,</span> rebasing tail onto new TFS<span class="token operator">-</span>commit<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Rebase done successfully<span class="token punctuation">.</span>Starting checkin of b1bf0f99 <span class="token string">'update code'</span> edit <span class="token punctuation">.</span>git\tfs\default\workspace\ConsoleApplication1<span class="token operator">/</span>ConsoleApplication1<span class="token operator">/</span>Program<span class="token punctuation">.</span>csC21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103bDone with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d<span class="token punctuation">,</span> rebasing tail onto new TFS<span class="token operator">-</span>commit<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Rebase done successfully<span class="token punctuation">.</span>No more to rcheckin<span class="token punctuation">.</span><span class="token function">PS</span>> git log <span class="token operator">--</span>all <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>decorate<span class="token operator">*</span> ff04e7c <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> tfs<span class="token operator">/</span>default<span class="token punctuation">,</span> master<span class="token punctuation">)</span> update code<span class="token operator">*</span> 71a5ddc update readme<span class="token operator">*</span> aea74a0 update documentation<span class="token punctuation">|</span> <span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token punctuation">|</span> <span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token punctuation">|</span><span class="token operator">/</span><span class="token operator">*</span> c403405 Hello<span class="token operator">*</span> b75da1a New project</code></pre><p>注意在每次成功检入到 TFVC 服务器后，git-tfs 是如何将剩余的工作变基到服务器上。 这是因为它将 <code>git-tfs-id</code> 属性加入到提交信息的底部，这将会改变 SHA-1 校验和。 这恰恰是有意设计的，没有什么事情可以担心了，但是你应该意识到发生了什么，特别是当你想要与其他人共享 Git 提交时。</p><p>TFS 有许多与它的版本管理系统整合的功能，比如工作项目、指定审核者、封闭检入等等。 仅仅通过命令行工具使用这些功能来工作是很笨重的，但是幸运的是 git-tfs 允许你轻松地运行一个图形化的检入工具：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs checkintool<span class="token function">PS</span>> git tfs ct</code></pre><p>它看起来有点像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/git-tfs-ct.png" alt="git-tfs 检入工具。"></p><p>Figure 148. git-tfs 检入工具。</p><p>对 TFS 用户来说这看起来很熟悉，因为它就是从 Visual Studio 中运行的同一个窗口。</p><p>Git-tfs 同样允许你从你的 Git 仓库控制 TFVC 分支。 如同这个例子，让我们创建一个：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs branch $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>featureBeeThe name of the local branch will be : featureBeeC26 = 1d54865c397608c004a2cadce7296f5edc22a7e5<span class="token function">PS</span>> git log <span class="token operator">--</span>oneline <span class="token operator">--</span>graph <span class="token operator">--</span>decorate <span class="token operator">--</span>all<span class="token operator">*</span> 1d54865 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureBee<span class="token punctuation">)</span> Creation branch $<span class="token operator">/</span>myproject<span class="token operator">/</span>featureBee<span class="token operator">*</span> ff04e7c <span class="token punctuation">(</span>HEAD<span class="token punctuation">,</span> tfs<span class="token operator">/</span>default<span class="token punctuation">,</span> master<span class="token punctuation">)</span> update code<span class="token operator">*</span> 71a5ddc update readme<span class="token operator">*</span> aea74a0 update documentation<span class="token punctuation">|</span> <span class="token operator">*</span> 44cd729 <span class="token punctuation">(</span>tfs<span class="token operator">/</span>featureA<span class="token punctuation">,</span> featureA<span class="token punctuation">)</span> Goodbye<span class="token punctuation">|</span> <span class="token operator">*</span> d202b53 Branched <span class="token keyword">from</span> $<span class="token operator">/</span>tfvc<span class="token operator">-</span>test<span class="token operator">/</span>Trunk<span class="token punctuation">|</span><span class="token operator">/</span><span class="token operator">*</span> c403405 Hello<span class="token operator">*</span> b75da1a New project</code></pre><p>在 TFVC 中创建一个分支意味着增加一个使分支存在的变更集，这会映射为一个 Git 提交。 也要注意的是 git-tfs <strong>创建</strong> 了 <code>tfs/featureBee</code> 远程分支，但是 <code>HEAD</code> 始终指向 <code>master</code>。 如果你想要在新生成的分支上工作，那你也许应该通过从那次提交创建一个特性分支的方式使你新的提交基于 <code>1d54865</code> 提交。</p><h4 id="Git-与-TFS-总结"><a href="#Git-与-TFS-总结" class="headerlink" title="Git 与 TFS 总结"></a>Git 与 TFS 总结</h4><p>Git-tf 与 Git-tfs 都是与 TFVC 服务器交互的很好的工具。 它们允许你在本地使用 Git 的能力，避免与中央 TFVC 服务器频繁交流，使你做为一个开发者的生活更轻松，而不用强制整个团队迁移到 Git。 如果你在 Windows 上工作（那很有可能你的团队正在使用 TFS），你可能会想要使用 git-tfs，因为它的功能更完整，但是如果你在其他平台工作，你只能使用略有限制的 git-tf。 像本章中大多数工具一样，你应当使用其中的一个版本系统作为主要的，而使用另一个做为次要的 - 不管是 Git 还是 TFVC 都可以做为协作中心，但不是两者都用。</p><h2 id="迁移到-Git"><a href="#迁移到-Git" class="headerlink" title="迁移到 Git"></a>迁移到 Git</h2><p>如果你现在有一个正在使用其他 VCS 的代码库，但是你已经决定开始使用 Git，必须通过某种方式将你的项目迁移至 Git。 这一部分会介绍一些通用系统的导入器，然后演示如何开发你自己定制的导入器。 你将会学习如何从几个大型专业应用的 SCM 系统中导入数据，不仅因为它们是大多数想要转换的用户正在使用的系统，也因为获取针对它们的高质量工具很容易。</p><h3 id="Subversion"><a href="#Subversion" class="headerlink" title="Subversion"></a>Subversion</h3><p>如果你阅读过前面关于 <code>git svn</code> 的章节，可以轻松地使用那些指令来 <code>git svn clone</code> 一个仓库，停止使用 Subversion 服务器，推送到一个新的 Git 服务器，然后就可以开始使用了。 如果你想要历史，可以从 Subversion 服务器上尽可能快地拉取数据来完成这件事（这可能会花费一些时间）。</p><p>然而，导入并不完美；因为花费太长时间了，你可能早已用其他方法完成导入操作。 导入产生的第一个问题就是作者信息。 在 Subversion 中，每一个人提交时都需要在系统中有一个用户，它会被记录在提交信息内。 在之前章节的例子中几个地方显示了 <code>schacon</code>，比如 <code>blame</code> 输出与 <code>git svn log</code>。 如果想要将上面的 Subversion 用户映射到一个更好的 Git 作者数据中，你需要一个 Subversion 用户到 Git 用户的映射。 创建一个 <code>users.txt</code> 的文件包含像下面这种格式的映射：</p><pre><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre><p>为了获得 SVN 使用的作者名字列表，可以运行这个：</p><pre class=" language-console"><code class="language-console">$ svn log --xml | grep author | sort -u | \  perl -pe 's/.*>(.*?)<.*/$1 = /'</code></pre><p>这会将日志输出为 XML 格式，然后保留作者信息行、去除重复、去除 XML 标记。 （很显然这只会在安装了 <code>grep</code>、<code>sort</code> 与 <code>perl</code> 的机器上运行。） 然后，将输出重定向到你的 users.txt 文件中，这样就可以在每一个记录后面加入对应的 Git 用户数据。</p><p>你可以将此文件提供给 <code>git svn</code> 来帮助它更加精确地映射作者数据。 也可以通过传递 <code>--no-metadata</code>给 <code>clone</code> 与 <code>init</code> 命令，告诉 <code>git svn</code> 不要包括 Subversion 通常会导入的元数据。 这会使你的 <code>import</code> 命令看起来像这样：</p><pre class=" language-console"><code class="language-console">$ git svn clone http://my-project.googlecode.com/svn/ \      --authors-file=users.txt --no-metadata -s my_project</code></pre><p>现在在 <code>my_project</code> 目录中应当有了一个更好的 Subversion 导入。 并不像是下面这样的提交：</p><pre><code>commit 37efa680e8473b615de980fa935944215428a35aAuthor: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;Date:   Sun May 3 00:12:22 2009 +0000    fixed install - go to trunk    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-    be05-5f7a86268029</code></pre><p>反而它们看起来像是这样：</p><pre><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2Author: Scott Chacon &lt;schacon@geemail.com&gt;Date:   Sun May 3 00:12:22 2009 +0000    fixed install - go to trunk</code></pre><p>不仅是 Author 字段更好看了，<code>git-svn-id</code> 也不在了。</p><p>之后，你应当做一些导入后的清理工作。 第一步，你应当清理 <code>git svn</code> 设置的奇怪的引用。 首先移动标签，这样它们就是标签而不是奇怪的远程引用，然后你会移动剩余的分支这样它们就是本地的了。</p><p>为了将标签变为合适的 Git 标签，运行</p><pre class=" language-console"><code class="language-console">$ cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/$ rm -Rf .git/refs/remotes/origin/tags</code></pre><p>这会使原来在 <code>remotes/origin/tags/</code> 里的远程分支引用变成真正的（轻量）标签。</p><p>接下来，将 <code>refs/remotes</code> 下剩余的引用移动为本地分支：</p><pre class=" language-console"><code class="language-console">$ cp -Rf .git/refs/remotes/* .git/refs/heads/$ rm -Rf .git/refs/remotes</code></pre><p>现在所有的旧分支都是真正的 Git 分支，并且所有的旧标签都是真正的 Git 标签。 最后一件要做的事情是，将你的新 Git 服务器添加为远程仓库并推送到上面。 下面是一个将你的服务器添加为远程仓库的例子：</p><pre class=" language-console"><code class="language-console">$ git remote add origin git@my-git-server:myrepository.git</code></pre><p>因为想要上传所有分支与标签，你现在可以运行：</p><pre class=" language-console"><code class="language-console">$ git push origin --all</code></pre><p>通过以上漂亮、干净地导入操作，你的所有分支与标签都应该在新 Git 服务器上。</p><h3 id="Mercurial"><a href="#Mercurial" class="headerlink" title="Mercurial"></a>Mercurial</h3><p>因为 Mercurial 与 Git 在表示版本时有着非常相似的模型，也因为 Git 拥有更加强大的灵活性，将一个仓库从 Mercurial 转换到 Git 是相当直接的，使用一个叫作“hg-fast-export”的工具，需要从这里拷贝一份：</p><pre class=" language-console"><code class="language-console">$ git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</code></pre><p>转换的第一步就是要先得到想要转换的 Mercurial 仓库的完整克隆：</p><pre class=" language-console"><code class="language-console">$ hg clone <remote repo URL> /tmp/hg-repo</code></pre><p>下一步就是创建一个作者映射文件。 Mercurial 对放入到变更集作者字段的内容比 Git 更宽容一些，所以这是一个清理的好机会。 只需要用到 <code>bash</code> 终端下的一行命令：</p><pre class=" language-console"><code class="language-console">$ cd /tmp/hg-repo$ hg log | grep user: | sort | uniq | sed 's/user: *//' > ../authors</code></pre><p>这会花费几秒钟，具体要看项目提交历史有多少，最终 <code>/tmp/authors</code> 文件看起来会像这样：</p><pre><code>bobbob@localhostbob &lt;bob@company.com&gt;bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;Bob Jones &lt;bob@company.com&gt;Joe Smith &lt;joe@company.com&gt;</code></pre><p>在这个例子中，同一个人（Bob）使用不同的名字创建变更集，其中一个实际上是正确的，另一个完全不符合 Git 提交的规范。 Hg-fast-export 通过向我们想要修改的行尾添加 <code>={new name and email address}</code> 来修正这个问题，移除任何我们想要保留的用户名所在的行。 如果所有的用户名看起来都是正确的，那我们根本就不需要这个文件。 在本例中，我们会使文件看起来像这样：</p><pre><code>bob=Bob Jones &lt;bob@company.com&gt;bob@localhost=Bob Jones &lt;bob@company.com&gt;bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;</code></pre><p>下一步是创建一个新的 Git 仓库，然后运行导出脚本：</p><pre class=" language-console"><code class="language-console">$ git init /tmp/converted$ cd /tmp/converted$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre><p><code>-r</code> 选项告诉 hg-fast-export 去哪里寻找我们想要转换的 Mercurial 仓库，<code>-A</code> 标记告诉它在哪找到作者映射文件。 这个脚本会分析 Mercurial 变更集然后将它们转换成 Git“fast-import”功能（我们将在之后详细讨论）需要的脚本。 这会花一点时间（尽管它比通过网格 <em>更</em> 快），输出相当的冗长：</p><pre class=" language-console"><code class="language-console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authorsLoaded 4 authorsmaster: Exporting full revision 1/22208 with 13/0/0 added/changed/removed filesmaster: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed filesmaster: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files[…]master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed filesmaster: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed filesmaster: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed filesExporting tag [0.4c] at [hg r9] [git :10]Exporting tag [0.4d] at [hg r16] [git :17][…]Exporting tag [3.1-rc] at [hg r21926] [git :21927]Exporting tag [3.1] at [hg r21973] [git :21974]Issued 22315 commandsgit-fast-import statistics:---------------------------------------------------------------------Alloc'd objects:     120000Total objects:       115032 (    208171 duplicates                  )      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)Total branches:         109 (         2 loads     )      marks:        1048576 (     22208 unique    )      atoms:           1952Memory total:          7860 KiB       pools:          2235 KiB     objects:          5625 KiB---------------------------------------------------------------------pack_report: getpagesize()            =       4096pack_report: core.packedGitWindowSize = 1073741824pack_report: core.packedGitLimit      = 8589934592pack_report: pack_used_ctr            =      90430pack_report: pack_mmap_calls          =      46771pack_report: pack_open_windows        =          1 /          1pack_report: pack_mapped              =  340852700 /  340852700---------------------------------------------------------------------$ git shortlog -sn   369  Bob Jones   365  Joe Smith</code></pre><p>那看起来非常好。 所有 Mercurial 标签都已被转换成 Git 标签，Mercurial 分支与书签都被转换成 Git 分支。 现在已经准备好将仓库推送到新的服务器那边：</p><pre class=" language-console"><code class="language-console">$ git remote add origin git@my-git-server:myrepository.git$ git push origin --all</code></pre><h3 id="Perforce"><a href="#Perforce" class="headerlink" title="Perforce"></a>Perforce</h3><p>下一个将要看到导入的系统是 Perforce。 就像我们之前讨论过的，有两种方式让 Git 与 Perforce 互相通信：git-p4 与 Perforce Git Fusion。</p><h4 id="Perforce-Git-Fusion"><a href="#Perforce-Git-Fusion" class="headerlink" title="Perforce Git Fusion"></a>Perforce Git Fusion</h4><p>Git Fusion 使这个过程毫无痛苦。 只需要使用在 <a href="https://git-scm.com/book/zh/v2/ch00/r_p4_git_fusion" target="_blank" rel="noopener">Git Fusion</a> 中讨论过的配置文件来配置你的项目设置、用户映射与分支，然后克隆整个仓库。 Git Fusion 让你处在一个看起来像是原生 Git 仓库的环境中，如果愿意的话你可以随时将它推送到一个原生 Git 托管中。 如果你喜欢的话甚至可以使用 Perforce 作为你的 Git 托管。</p><h4 id="Git-p4-1"><a href="#Git-p4-1" class="headerlink" title="Git-p4"></a>Git-p4</h4><p>Git-p4 也可以作为一个导入工具。 作为例子，我们将从 Perforce 公开仓库中导入 Jam 项目。 为了设置客户端，必须导出 P4PORT 环境变量指向 Perforce 仓库：</p><pre class=" language-console"><code class="language-console">$ export P4PORT=public.perforce.com:1666</code></pre><table><thead><tr><th>Note</th><th>为了继续后续步骤，需要连接到 Perforce 仓库。 在我们的例子中将会使用在 public.perforce.com 的公开仓库，但是你可以使用任何你有权限的仓库。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>运行 <code>git p4 clone</code> 命令从 Perforce 服务器导入 Jam 项目，提供仓库、项目路径与你想要存放导入项目的路径：</p><pre class=" language-console"><code class="language-console">$ git-p4 clone //guest/perforce_software/jam@all p4importImporting from //guest/perforce_software/jam@all into p4importInitialized empty Git repository in /private/tmp/p4import/.git/Import destination: refs/remotes/p4/masterImporting revision 9957 (100%)</code></pre><p>这个特定的项目只有一个分支，但是如果你在分支视图（或者说一些目录）中配置了一些分支，你可以将 <code>--detect-branches</code> 选项传递给 <code>git p4 clone</code> 来导入项目的所有分支。 查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_p4_branches" target="_blank" rel="noopener">分支</a> 来了解关于这点的更多信息。</p><p>此时你几乎已经完成了。 如果进入 <code>p4import</code> 目录中并运行 <code>git log</code>，可以看到你的导入工作：</p><pre class=" language-console"><code class="language-console">$ git log -2commit e5da1c909e5db3036475419f6379f2c73710c4e6Author: giles <giles@giles@perforce.com>Date:   Wed Feb 8 03:13:27 2012 -0800    Correction to line 355; change </UL> to </OL>.    [git-p4: depot-paths = "//public/jam/src/": change = 8068]commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98Author: kwirth <kwirth@perforce.com>Date:   Tue Jul 7 01:35:51 2009 -0800    Fix spelling error on Jam doc page (cummulative -> cumulative).    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre><p>你可以看到 <code>git-p4</code> 在每一个提交里都留下了一个标识符。 如果之后想要引用 Perforce 的修改序号的话，标识符保留在那里也是可以的。 然而，如果想要移除标识符，现在正是这么做的时候 - 在你开始在新仓库中工作之前。 可以使用 <code>git filter-branch</code> 将全部标识符移除。</p><pre class=" language-console"><code class="language-console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)Ref 'refs/heads/master' was rewritten</code></pre><p>如果运行 <code>git log</code>，你会看到所有提交的 SHA-1 校验和都改变了，但是提交信息中不再有 <code>git-p4</code> 字符串了：</p><pre class=" language-console"><code class="language-console">$ git log -2commit b17341801ed838d97f7800a54a6f9b95750839b7Author: giles <giles@giles@perforce.com>Date:   Wed Feb 8 03:13:27 2012 -0800    Correction to line 355; change </UL> to </OL>.commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fffAuthor: kwirth <kwirth@perforce.com>Date:   Tue Jul 7 01:35:51 2009 -0800    Fix spelling error on Jam doc page (cummulative -> cumulative).</code></pre><p>现在导入已经准备好推送到你的新 Git 服务器上了。</p><h3 id="TFS"><a href="#TFS" class="headerlink" title="TFS"></a>TFS</h3><p>如果你的团队正在将他们的源代码管理从 TFVC 转换为 Git，你们会想要最高程度的无损转换。 这意味着，虽然我们在之前的交互章节介绍了 git-tfs 与 git-tf 两种工具，但是我们在本部分只能介绍 git-tfs，因为 git-tfs 支持分支，而使用 git-tf 代价太大。</p><table><thead><tr><th>Note</th><th>这是一个单向转换。 这意味着 Git 仓库无法连接到原始的 TFVC 项目。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>第一件事是映射用户名。 TFVC 对待变更集作者字段的内容相当宽容，但是 Git 需要人类可读的名字与邮箱地址。 可以通过 <code>tf</code> 命令行客户端来获取这个信息，像这样：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> tf history $<span class="token operator">/</span>myproject <span class="token operator">-</span>recursive > AUTHORS_TMP</code></pre><p>这会将历史中的所有变更集抓取下来并放到 AUTHORS_TMP 文件中，然后我们将会将 <code>User</code> 列（第二个）取出来。 打开文件找到列开始与结束的字符并替换，在下面的命令行中，<code>cut</code> 命令的参数 <code>11-20</code> 就是我们找到的：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> <span class="token function">cat</span> AUTHORS_TMP <span class="token punctuation">|</span> cut <span class="token operator">-</span>b 11<span class="token operator">-</span>20 <span class="token punctuation">|</span> tail <span class="token operator">-</span>n<span class="token operator">+</span>3 <span class="token punctuation">|</span> uniq <span class="token punctuation">|</span> <span class="token function">sort</span> > AUTHORS</code></pre><p><code>cut</code> 命令只会保留每行中第 11 个到第 22 个字符。 <code>tail</code> 命令会跳过前两行，就是字段表头与 ASCII 风格的下划线。 所有这些的结果通过管道送到 <code>uniq</code> 来去除重复，然后保存到 <code>AUTOHRS</code> 文件中。 下一步是手动的；为了让 git-tfs 有效地使用这个文件，每一行必须是这种格式：</p><pre class=" language-text"><code class="language-text">DOMAIN\username = User Name <email@address.com></code></pre><p>左边的部分是 TFVC 中的 “User” 字段，等号右边的部分是将被用作 Git 提交的用户名。</p><p>一旦有了这个文件，下一件事就是生成一个你需要的 TFVC 项目的完整克隆：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git tfs clone <span class="token operator">--</span>with<span class="token operator">-</span>branches <span class="token operator">--</span>authors=AUTHORS https:<span class="token operator">/</span><span class="token operator">/</span>username<span class="token punctuation">.</span>visualstudio<span class="token punctuation">.</span>com<span class="token operator">/</span>DefaultCollection $<span class="token operator">/</span>project<span class="token operator">/</span>Trunk project_git</code></pre><p>接下来要从提交信息底部清理 <code>git-tfs-id</code> 区块。 下面的命令会完成这个任务：</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">PS</span>> git <span class="token keyword">filter</span><span class="token operator">-</span>branch <span class="token operator">-</span>f <span class="token operator">--</span>msg<span class="token operator">-</span><span class="token keyword">filter</span> <span class="token string">'sed "s/^git-tfs-id:.*$//g"'</span> <span class="token operator">--</span> <span class="token operator">--</span>all</code></pre><p>那会使用 Git 终端环境中的 <code>sed</code> 命令来将所有以 “git-tfs-id:” 开头的行替换为 Git 会忽略的空白。</p><p>全部完成后，你就已经准备好去增加一个新的远程仓库，推送你所有的分支上去，然后你的团队就可以开始用 Git 工作了。</p><h3 id="一个自定义的导入器"><a href="#一个自定义的导入器" class="headerlink" title="一个自定义的导入器"></a>一个自定义的导入器</h3><p>如果你的系统不是上述中的任何一个，你需要在线查找一个导入器 - 针对许多其他系统有很多高质量的导入器，包括 CVS、Clear Case、Visual Source Safe，甚至是一个档案目录。 如果没有一个工具适合你，需要一个不知名的工具，或者需要更大自由度的自定义导入过程，应当使用 <code>git fast-import</code>。 这个命令从标准输入中读取简单指令来写入特定的 Git 数据。 通过这种方式创建 Git 对象比运行原始 Git 命令或直接写入原始对象（查看 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 了解更多内容）更容易些。 通过这种方式你可以编写导入脚本，从你要导入的系统中读取必要数据，然后直接打印指令到标准输出。 然后可以运行这个程序并通过 <code>git fast-import</code> 重定向管道输出。</p><p>为了快速演示，我们会写一个简单的导入器。 假设你在 <code>current</code> 工作，有时候会备份你的项目到时间标签 <code>back_YYYY_MM_DD</code> 备份目录中，你想要将这些导入到 Git 中。 目录结构看起来是这样：</p><pre class=" language-console"><code class="language-console">$ ls /opt/import_fromback_2014_01_02back_2014_01_04back_2014_01_14back_2014_02_03current</code></pre><p>为了导入一个 Git 目录，需要了解 Git 如何存储它的数据。 你可能记得，Git 在底层存储指向内容快照的提交对象的链表。 所有要做的就是告诉 <code>fast-import</code> 哪些内容是快照，哪个提交数据指向它们，以及它们进入的顺序。 你的策略是一次访问一个快照，然后用每个目录中的内容创建提交，并且将每一个提交与前一个连接起来。</p><p>如同我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_an_example_git_enforced_policy" target="_blank" rel="noopener">使用强制策略的一个例子</a> 里做的，我们将会使用 Ruby 写这个，因为它是我们平常工作中使用的并且它很容易读懂。 可以使用任何你熟悉的东西来非常轻松地写这个例子 - 它只需要将合适的信息打印到 <code>标准输出</code>。 然而，如果你在 Windows 上，这意味着需要特别注意不要引入回车符到行尾 - git fast-import 非常特别地只接受换行符（LF）而不是 Windows 使用的回车换行符（CRLF）。</p><p>现在开始，需要进入目标目录中并识别每一个子目录，每一个都是你要导入为提交的快照。 要进入到每个子目录中并为导出它打印必要的命令。 基本主循环像这个样子：</p><pre class=" language-ruby"><code class="language-ruby">last_mark <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token comment" spellcheck="true"># loop through the directories</span><span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">do</span>  <span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>dir<span class="token operator">|</span>    <span class="token keyword">next</span> <span class="token keyword">if</span> <span class="token builtin">File</span><span class="token punctuation">.</span>file<span class="token operator">?</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># move into the target directory</span>    <span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">chdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token keyword">do</span>      last_mark <span class="token operator">=</span> <span class="token function">print_export</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> last_mark<span class="token punctuation">)</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>在每个目录内运行 <code>print_export</code>，将会拿到清单并标记之前的快照，然后返回清单并标记现在的快照；通过这种方式，可以将它们合适地连接在一起。 “标记” 是一个给提交标识符的 <code>fast-import</code> 术语；当你创建提交，为每一个提交赋予一个标记来将它与其他提交连接在一起。 这样，在你的 <code>print_export</code>方法中第一件要做的事就是从目录名字生成一个标记：</p><pre class=" language-ruby"><code class="language-ruby">mark <span class="token operator">=</span> <span class="token function">convert_dir_to_mark</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span></code></pre><p>可以创建一个目录的数组并使用索引做为标记，因为标记必须是一个整数。 方法类似这样：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$marks</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">convert_dir_to_mark</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">$marks</span><span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token variable">$marks</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> dir  <span class="token keyword">end</span>  <span class="token punctuation">(</span><span class="token variable">$marks</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_s<span class="token keyword">end</span></code></pre><p>既然有一个整数代表你的提交，那还要给提交元数据一个日期。 因为目录名字表达了日期，所以你将会从中解析出日期。 你的 <code>print_export</code> 文件的下一行是</p><pre class=" language-ruby"><code class="language-ruby">date <span class="token operator">=</span> <span class="token function">convert_dir_to_date</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span></code></pre><p><code>convert_dir_to_date</code> 定义为</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token function">convert_dir_to_date</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>  <span class="token keyword">if</span> dir <span class="token operator">==</span> <span class="token string">'current'</span>    <span class="token keyword">return</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_i  <span class="token keyword">else</span>    dir <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span><span class="token string">'back_'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span> <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token function">local</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">.</span>to_i  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>那会返回每一个目录日期的整数。 最后一项每个提交需要的元数据是提交者信息，它将会被硬编码在全局变量中：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$author</span> <span class="token operator">=</span> <span class="token string">'John Doe &lt;john@example.com>'</span></code></pre><p>现在准备开始为你的导入器打印出提交数据。 初始信息声明定义了一个提交对象与它所在的分支，紧接着一个你生成的标记、提交者信息与提交信息、然后是一个之前的提交，如果它存在的话。 代码看起来像这样：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># print the import information</span>puts <span class="token string">'commit refs/heads/master'</span>puts <span class="token string">'mark :'</span> <span class="token operator">+</span> markputs <span class="token string">"committer <span class="token interpolation"><span class="token delimiter tag">#{</span>$author<span class="token delimiter tag">}</span></span> <span class="token interpolation"><span class="token delimiter tag">#{</span>date<span class="token delimiter tag">}</span></span> -0700"</span><span class="token function">export_data</span><span class="token punctuation">(</span><span class="token string">'imported from '</span> <span class="token operator">+</span> dir<span class="token punctuation">)</span>puts <span class="token string">'from :'</span> <span class="token operator">+</span> last_mark <span class="token keyword">if</span> last_mark</code></pre><p>我们将硬编码时区信息（-0700），因为这样很容易。 如果从其他系统导入，必须指定为一个偏移的时区。 提交信息必须指定为特殊的格式：</p><pre><code>data (size)\n(contents)</code></pre><p>这个格式包括文本数据、将要读取数据的大小、一个换行符、最终的数据。 因为之后还需要为文件内容指定相同的数据格式，你需要创建一个帮助函数，<code>export_data</code>：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token function">export_data</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>  print <span class="token string">"data <span class="token interpolation"><span class="token delimiter tag">#{</span>string<span class="token punctuation">.</span>size<span class="token delimiter tag">}</span></span>\n<span class="token interpolation"><span class="token delimiter tag">#{</span>string<span class="token delimiter tag">}</span></span>"</span><span class="token keyword">end</span></code></pre><p>剩下的工作就是指定每一个快照的文件内容。 这很轻松，因为每一个目录都是一个快照 - 可以在目录中的每一个文件内容后打印 <code>deleteall</code> 命令。 Git 将会适当地记录每一个快照：</p><pre class=" language-ruby"><code class="language-ruby">puts <span class="token string">'deleteall'</span><span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"**/*"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>file<span class="token operator">|</span>  <span class="token keyword">next</span> <span class="token keyword">if</span> <span class="token operator">!</span><span class="token builtin">File</span><span class="token punctuation">.</span>file<span class="token operator">?</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>  <span class="token function">inline_data</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">end</span></code></pre><p>注意：因为大多数系统认为他们的版本是从一个提交变化到另一个提交，fast-import 也可以为每一个提交执行命令来指定哪些文件是添加的、删除的或修改的与新内容是哪些。 可以计算快照间的不同并只提供这些数据，但是这样做会很复杂 - 也可以把所有数据给 Git 然后让它为你指出来。 如果这更适合你的数据，查阅 <code>fast-import</code> man 帮助页来了解如何以这种方式提供你的数据。</p><p>这种列出新文件内容或用新内容指定修改文件的格式如同下面的内容：</p><pre><code>M 644 inline path/to/filedata (size)(file contents)</code></pre><p>这里，644 是模式（如果你有可执行文件，反而你需要检测并指定 755），inline 表示将会立即把内容放在本行之后。 你的 <code>inline_data</code> 方法看起来像这样：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token function">inline_data</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> code <span class="token operator">=</span> <span class="token string">'M'</span><span class="token punctuation">,</span> mode <span class="token operator">=</span> <span class="token string">'644'</span><span class="token punctuation">)</span>  content <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>  puts <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span>code<span class="token delimiter tag">}</span></span> <span class="token interpolation"><span class="token delimiter tag">#{</span>mode<span class="token delimiter tag">}</span></span> inline <span class="token interpolation"><span class="token delimiter tag">#{</span>file<span class="token delimiter tag">}</span></span>"</span>  <span class="token function">export_data</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">end</span></code></pre><p>可以重用之前定义的 <code>export_data</code> 方法，因为它与你定义的提交信息数据的方法一样。</p><p>最后一件你需要做的是返回当前的标记以便它可以传给下一个迭代：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">return</span> mark</code></pre><table><thead><tr><th>Note</th><th>如果在 Windows 上还需要确保增加一个额外步骤。 正如之前提到的，Windows 使用 CRLF 作为换行符而 git fast-import 只接受 LF。 为了修正这个问题使 git fast-import 正常工作，你需要告诉 ruby 使用 LF 代替 CRLF：<code>$stdout.binmode</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>就是这样。 这是全部的脚本：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span><span class="token variable">$stdout</span><span class="token punctuation">.</span>binmode<span class="token variable">$author</span> <span class="token operator">=</span> <span class="token string">"John Doe &lt;john@example.com>"</span><span class="token variable">$marks</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">convert_dir_to_mark</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">$marks</span><span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>        <span class="token variable">$marks</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> dir    <span class="token keyword">end</span>    <span class="token punctuation">(</span><span class="token variable">$marks</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_s<span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">convert_dir_to_date</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token keyword">if</span> dir <span class="token operator">==</span> <span class="token string">'current'</span>        <span class="token keyword">return</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_i    <span class="token keyword">else</span>        dir <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span><span class="token string">'back_'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span> <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token function">local</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">.</span>to_i    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">export_data</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>    print <span class="token string">"data <span class="token interpolation"><span class="token delimiter tag">#{</span>string<span class="token punctuation">.</span>size<span class="token delimiter tag">}</span></span>\n<span class="token interpolation"><span class="token delimiter tag">#{</span>string<span class="token delimiter tag">}</span></span>"</span><span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">inline_data</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> code<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'644'</span><span class="token punctuation">)</span>    content <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>    puts <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span>code<span class="token delimiter tag">}</span></span> <span class="token interpolation"><span class="token delimiter tag">#{</span>mode<span class="token delimiter tag">}</span></span> inline <span class="token interpolation"><span class="token delimiter tag">#{</span>file<span class="token delimiter tag">}</span></span>"</span>    <span class="token function">export_data</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">def</span> <span class="token function">print_export</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> last_mark<span class="token punctuation">)</span>    date <span class="token operator">=</span> <span class="token function">convert_dir_to_date</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    mark <span class="token operator">=</span> <span class="token function">convert_dir_to_mark</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    puts <span class="token string">'commit refs/heads/master'</span>    puts <span class="token string">"mark :<span class="token interpolation"><span class="token delimiter tag">#{</span>mark<span class="token delimiter tag">}</span></span>"</span>    puts <span class="token string">"committer <span class="token interpolation"><span class="token delimiter tag">#{</span>$author<span class="token delimiter tag">}</span></span> <span class="token interpolation"><span class="token delimiter tag">#{</span>date<span class="token delimiter tag">}</span></span> -0700"</span>    <span class="token function">export_data</span><span class="token punctuation">(</span><span class="token string">"imported from <span class="token interpolation"><span class="token delimiter tag">#{</span>dir<span class="token delimiter tag">}</span></span>"</span><span class="token punctuation">)</span>    puts <span class="token string">"from :<span class="token interpolation"><span class="token delimiter tag">#{</span>last_mark<span class="token delimiter tag">}</span></span>"</span> <span class="token keyword">if</span> last_mark    puts <span class="token string">'deleteall'</span>    <span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"**/*"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>file<span class="token operator">|</span>        <span class="token keyword">next</span> <span class="token keyword">if</span> <span class="token operator">!</span><span class="token builtin">File</span><span class="token punctuation">.</span>file<span class="token operator">?</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>        <span class="token function">inline_data</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>    <span class="token keyword">end</span>    mark<span class="token keyword">end</span><span class="token comment" spellcheck="true"># Loop through the directories</span>last_mark <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">do</span>    <span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">glob</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>dir<span class="token operator">|</span>        <span class="token keyword">next</span> <span class="token keyword">if</span> <span class="token builtin">File</span><span class="token punctuation">.</span>file<span class="token operator">?</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># move into the target directory</span>        <span class="token builtin">Dir</span><span class="token punctuation">.</span><span class="token function">chdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token keyword">do</span>            last_mark <span class="token operator">=</span> <span class="token function">print_export</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> last_mark<span class="token punctuation">)</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>如果运行这个脚本，你会得到类似下面的内容：</p><pre class=" language-console"><code class="language-console">$ ruby import.rb /opt/import_fromcommit refs/heads/mastermark :1committer John Doe <john@example.com> 1388649600 -0700data 29imported from back_2014_01_02deleteallM 644 inline README.mddata 28# HelloThis is my readme.commit refs/heads/mastermark :2committer John Doe <john@example.com> 1388822400 -0700data 29imported from back_2014_01_04from :1deleteallM 644 inline main.rbdata 34#!/bin/env rubyputs "Hey there"M 644 inline README.md(...)</code></pre><p>为了运行导入器，将这些输出用管道重定向到你想要导入的 Git 目录中的 <code>git fast-import</code>。 可以创建一个新的目录并在其中运行 <code>git init</code> 作为开始，然后运行你的脚本：</p><pre class=" language-console"><code class="language-console">$ git initInitialized empty Git repository in /opt/import_to/.git/$ ruby import.rb /opt/import_from | git fast-importgit-fast-import statistics:---------------------------------------------------------------------Alloc'd objects:       5000Total objects:           13 (         6 duplicates                  )      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)      commits:            4 (         1 duplicates          0 deltas of          0 attempts)      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)Total branches:           1 (         1 loads     )      marks:           1024 (         5 unique    )      atoms:              2Memory total:          2344 KiB       pools:          2110 KiB     objects:           234 KiB---------------------------------------------------------------------pack_report: getpagesize()            =       4096pack_report: core.packedGitWindowSize = 1073741824pack_report: core.packedGitLimit      = 8589934592pack_report: pack_used_ctr            =         10pack_report: pack_mmap_calls          =          5pack_report: pack_open_windows        =          2 /          2pack_report: pack_mapped              =       1457 /       1457---------------------------------------------------------------------</code></pre><p>正如你所看到的，当它成功完成时，它会给你一串关于它完成内容的统计。 这本例中，一共导入了 13 个对象、4 次提交到 1 个分支。 现在，可以运行 <code>git log</code> 来看一下你的新历史：</p><pre class=" language-console"><code class="language-console">$ git log -2commit 3caa046d4aac682a55867132ccdfbe0d3fdee498Author: John Doe <john@example.com>Date:   Tue Jul 29 19:39:04 2014 -0700    imported from currentcommit 4afc2b945d0d3c8cd00556fbe2e8224569dc9defAuthor: John Doe <john@example.com>Date:   Mon Feb 3 01:00:00 2014 -0700    imported from back_2014_02_03</code></pre><p>做得很好 - 一个漂亮、干净的 Git 仓库。 要注意的一点是并没有检出任何东西 - 一开始你的工作目录内并没有任何文件。 为了得到他们，你必须将分支重置到 <code>master</code> 所在的地方：</p><pre class=" language-console"><code class="language-console">$ ls$ git reset --hard masterHEAD is now at 3caa046 imported from current$ lsREADME.md main.rb</code></pre><p>可以通过 <code>fast-import</code> 工具做很多事情 - 处理不同模式、二进制数据、多个分支与合并、标签、进度指示等等。 一些更复杂情形下的例子可以在 Git 源代码目录中的 <code>contrib/fast-import</code> 目录中找到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你会觉得将 Git 作为其他版本控制系统的客户端，或者在数据无损的情况下将几乎任何一个现有的仓库导入到 Git，都是一件很惬意的事。 在下一章，我们将要讲解 Git 的原始内部数据，如果需要的话你就可以加工每一个字节。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义Git</title>
      <link href="/2019/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89Git/"/>
      <url>/2019/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89Git/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们已经阐述了 Git 基本的运作机制和使用方式，介绍了许多 Git 提供的工具来帮助你简单且有效地使用它。 在本章，我们将演示如何借助 Git 的一些重要的配置方法和钩子机制，来满足自定义的需求。 通过这些工具，它会和你、你的公司或你的团队配合得天衣无缝。</p><h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><p>你在 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction" target="_blank" rel="noopener">起步</a> 中看到，可以用 <code>git config</code> 配置 Git。 首先要做的事情就是设置你的名字和邮件地址：</p><pre class=" language-console"><code class="language-console">$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com</code></pre><p>现在，你会了解到许多更有趣的选项，并用类似的方式来定制 Git。</p><p>首先，快速回忆下：Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该版本库有效。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><table><thead><tr><th>Note</th><th>Git 的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行 <code>git config</code> 命令会更简单些。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><p>Git 能够识别的配置项分为两大类：客户端和服务器端。 其中大部分属于客户端配置 —— 可以依你个人的工作偏好进行配置。 尽管 Git 支持的选项 <em>繁多</em>，但其中大部分仅仅在某些罕见的情况下有意义。 我们只讲述最平常和最有用的选项。 如果想得到你当前版本的 Git 支持的选项列表，请运行</p><pre class=" language-console"><code class="language-console">$ man git-config</code></pre><p>这个命令列出了所有可用的选项，以及与之相关的介绍。 你也可以在 <a href="http://git-scm.com/docs/git-config.html" target="_blank" rel="noopener">http://git-scm.com/docs/git-config.html</a> 找到同样的内容。</p><h4 id="core-editor"><a href="#core-editor" class="headerlink" title="core.editor"></a><code>core.editor</code></h4><p>默认情况下，Git 会调用环境变量（<code>$VISUAL</code> 或 <code>$EDITOR</code>）设置的任意文本编辑器，如果没有设置，会调用 <code>vi</code> 来创建和编辑你的提交以及标签信息。 你可以使用 <code>core.editor</code> 选项来修改默认的编辑器：</p><pre class=" language-console"><code class="language-console">$ git config --global core.editor emacs</code></pre><p>现在，无论你定义了什么终端编辑器，Git 都会调用 Emacs 编辑信息。</p><h4 id="commit-template"><a href="#commit-template" class="headerlink" title="commit.template"></a><code>commit.template</code></h4><p>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认信息。 例如：假设你创建了一个叫 <code>~/.gitmessage.txt</code> 的模板文件，类似这样：</p><pre><code>subject linewhat happened[ticket: X]</code></pre><p>要想让 Git 把它作为运行 <code>git commit</code> 时显示在你的编辑器中的默认信息， 如下设置 <code>commit.template</code>：</p><pre class=" language-console"><code class="language-console">$ git config --global commit.template ~/.gitmessage.txt$ git commit</code></pre><p>然后当你提交时，编辑器中就会显示如下的提交信息占位符：</p><pre><code>subject linewhat happened[ticket: X]# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified:   lib/test.rb#~~&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</code></pre><p>如果你的团队对提交信息有格式要求，可以在系统上创建一个文件，并配置 Git 把它作为默认的模板，这样可以更加容易地使提交信息遵循格式。</p><h4 id="core-pager"><a href="#core-pager" class="headerlink" title="core.pager"></a><code>core.pager</code></h4><p>该配置项指定 Git 运行诸如 <code>log</code> 和 <code>diff</code> 等命令所使用的分页器。 你可以把它设置成用 <code>more</code> 或者任何你喜欢的分页器（默认用的是 <code>less</code>），当然也可以设置成空字符串，关闭该选项：</p><pre class=" language-console"><code class="language-console">$ git config --global core.pager ''</code></pre><p>这样不管命令的输出量多少，Git 都会在一页显示所有内容。</p><h4 id="user-signingkey"><a href="#user-signingkey" class="headerlink" title="user.signingkey"></a><code>user.signingkey</code></h4><p>如果你要创建经签署的含附注的标签（正如 <a href="https://git-scm.com/book/zh/v2/ch00/r_signing" target="_blank" rel="noopener">签署工作</a> 所述），那么把你的 GPG 签署密钥设置为配置项会更好。 如下设置你的密钥 ID：</p><pre class=" language-console"><code class="language-console">$ git config --global user.signingkey <gpg-key-id></code></pre><p>现在，你每次运行 <code>git tag</code> 命令时，即可直接签署标签，而无需定义密钥：</p><pre class=" language-console"><code class="language-console">$ git tag -s <tag-name></code></pre><h4 id="core-excludesfile"><a href="#core-excludesfile" class="headerlink" title="core.excludesfile"></a><code>core.excludesfile</code></h4><p>正如 <a href="https://git-scm.com/book/zh/v2/ch00/r_ignoring" target="_blank" rel="noopener">忽略文件</a> 所述，你可以在你的项目的 <code>.gitignore</code> 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表，也不会在你运行 <code>git add</code> 后被暂存。</p><p>不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。 如果你的操作系统是 OS X，很可能就是指 <code>.DS_Store</code>。 如果你把 Emacs 或 Vim 作为首选的编辑器，你肯定知道以 <code>~</code> 结尾的临时文件。</p><p>这个配置允许你设置类似于全局生效的 <code>.gitignore</code> 文件。 如果你按照下面的内容创建一个 <code>~/.gitignore_global</code> 文件：</p><pre><code>*~.DS_Store</code></pre><p>……然后运行 <code>git config --global core.excludesfile ~/.gitignore_global</code>，Git 将把那些文件永远地拒之门外。</p><h4 id="help-autocorrect"><a href="#help-autocorrect" class="headerlink" title="help.autocorrect"></a><code>help.autocorrect</code></h4><p>假如你打错了一条命令，会显示：</p><pre class=" language-console"><code class="language-console">$ git chekcout mastergit：'chekcout' 不是一个 git 命令。参见 'git --help'。您指的是这个么？  checkout</code></pre><p>Git 会尝试猜测你的意图，但是它不会越俎代庖。 如果你把 <code>help.autocorrect</code> 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p><pre class=" language-console"><code class="language-console">$ git chekcout master警告：您运行一个不存在的 Git 命令 'chekcout'。继续执行假定您要要运行的是 'checkout'在 0.1 秒钟后自动运行...</code></pre><p>注意提示信息中的“0.1 秒”。<code>help.autocorrect</code> 接受一个代表十分之一秒的整数。 所以如果你把它设置为 50, Git 将在自动执行命令前给你 5 秒的时间改变主意。</p><h3 id="Git-中的着色"><a href="#Git-中的着色" class="headerlink" title="Git 中的着色"></a>Git 中的着色</h3><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。 你可以设置许多的相关选项来满足自己的偏好。</p><h4 id="color-ui"><a href="#color-ui" class="headerlink" title="color.ui"></a><code>color.ui</code></h4><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><pre class=" language-console"><code class="language-console">$ git config --global color.ui false</code></pre><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><h4 id="color"><a href="#color" class="headerlink" title="color.*"></a><code>color.*</code></h4><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><pre><code>color.branchcolor.diffcolor.interactivecolor.status</code></pre><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><pre><code>$ git config --global color.diff.meta &quot;blue black bold&quot;</code></pre><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h3 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h3><p>虽然 Git 自己内置了一个 <code>diff</code> 实现，而且到目前为止我们一直在使用它，但你能够用一个外部的工具替代它。 除此以外，你还能设置一个图形化的工具来合并和解决冲突，从而不必自己手动解决。 这里我们以一个不错且免费的工具 —— Perforce 图形化合并工具（P4Merge） —— 来展示如何用一个外部的工具来合并和解决冲突。</p><p>P4Merge 可以在所有主流平台上运行，所以安装上应该没有什么困难。 在这个例子中，我们使用的路径名可以直接应用在 Mac 和 Linux 上；在 Windows 上，<code>/usr/local/bin</code> 需要被改为你的环境中可执行文件所在的目录路径。</p><p>首先， 从 <a href="http://www.perforce.com/downloads/Perforce/" target="_blank" rel="noopener">http://www.perforce.com/downloads/Perforce/</a> 下载 P4Merge。 接下来，你要编写一个全局包装脚本来运行你的命令。 我们会使用 Mac 上的路径来指定该脚本的位置，在其他系统上，它将是 <code>p4merge</code> 二进制文件所在的目录。 创建一个名为 <code>extMerge</code> 的脚本包装 merge 命令，让它把参数转发给 p4merge 二进制文件：</p><pre class=" language-console"><code class="language-console">$ cat /usr/local/bin/extMerge#!/bin/sh/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre><p>包装 diff 命令的脚本首先确保传递了七个参数过来，随后把其中两个转发给包装了 merge 的脚本。 默认情况下， Git 传递以下参数给 <code>diff</code>：</p><pre><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre><p>由于你仅仅需要 <code>old-file</code> 和 <code>new-file</code> 参数，由包装 diff 的脚本来转发它们吧。</p><pre class=" language-console"><code class="language-console">$ cat /usr/local/bin/extDiff#!/bin/sh[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"</code></pre><p>你也需要确保这些脚本具有可执行权限：</p><pre class=" language-console"><code class="language-console">$ sudo chmod +x /usr/local/bin/extMerge$ sudo chmod +x /usr/local/bin/extDiff</code></pre><p>现在你可以修改配置文件来使用你自定义的合并和比较工具了。 这将涉及许多自定义设置：<code>merge.tool</code>通知 Git 该使用哪个合并工具， <code>mergetool.&lt;tool&gt;.cmd</code> 规定命令运行的方式，<code>mergetool.&lt;tool&gt;.trustExitCode</code> 会通知 Git 程序的返回值是否表示合并操作成功，<code>diff.external</code> 通知 Git 该用什么命令做比较。 因此，你可以运行以下四条配置命令：</p><pre class=" language-console"><code class="language-console">$ git config --global merge.tool extMerge$ git config --global mergetool.extMerge.cmd \  'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"'$ git config --global mergetool.extMerge.trustExitCode false$ git config --global diff.external extDiff</code></pre><p>或编辑你的 <code>~/.gitconfig</code> 文件，添加以下各行：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[merge]</span><span class="token constant">  tool</span> <span class="token attr-value"><span class="token punctuation">=</span> extMerge</span><span class="token selector">[mergetool "extMerge"]</span><span class="token constant">  cmd</span> <span class="token attr-value"><span class="token punctuation">=</span> extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"</span><span class="token constant">  trustExitCode</span> <span class="token attr-value"><span class="token punctuation">=</span> false</span><span class="token selector">[diff]</span><span class="token constant">  external</span> <span class="token attr-value"><span class="token punctuation">=</span> extDiff</span></code></pre><p>待一切设置妥当后，如果你像这样运行 diff 命令：</p><pre class=" language-console"><code class="language-console">$ git diff 32d1776b1^ 32d1776b1</code></pre><p>Git 将启动 P4Merge，而不是在命令行输出比较的结果，就像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/p4merge.png" alt="P4Merge."></p><p>Figure 143. P4Merge.</p><p>如果你尝试合并两个分支，随后遇到了合并冲突，运行 <code>git mergetool</code>，Git 会调用 P4Merge 让你通过图形界面来解决冲突。</p><p>设置包装脚本的好处在于大大降低了改变 diff 和 merge 工具的工作量。 举个例子，想把 <code>extDiff</code> 和 <code>extMerge</code> 的工具改成 KDiff3，你要做的仅仅是编辑 <code>extMerge</code> 脚本文件：</p><pre class=" language-console"><code class="language-console">$ cat /usr/local/bin/extMerge#!/bin/sh/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre><p>现在，Git 将使用 KDiff3 作为查看比较和解决合并冲突的工具。</p><p>Git 预设了许多其他的合并和解决冲突的工具，无需特别的设置你就能用上它们。 要想看到它支持的工具列表，试一下这个：</p><pre class=" language-console"><code class="language-console">$ git mergetool --tool-help'git mergetool --tool=<tool>' may be set to one of the following:        emerge        gvimdiff        gvimdiff2        opendiff        p4merge        vimdiff        vimdiff2The following tools are valid, but not currently available:        araxis        bc3        codecompare        deltawalker        diffmerge        diffuse        ecmerge        kdiff3        meld        tkdiff        tortoisemerge        xxdiffSome of the tools listed above only work in a windowedenvironment. If run in a terminal-only session, they will fail.</code></pre><p>如果你不想用到 KDiff3 的所有功能，只是想用它来合并，那么 kdiff3 正符合你的要求，运行：</p><pre class=" language-console"><code class="language-console">$ git config --global merge.tool kdiff3</code></pre><p>如果运行了以上命令，而没有设置 <code>extMerge</code> 和 <code>extDiff</code> 文件，Git 会用 KDiff3 做合并，让内置的 <code>diff</code>来做比较。</p><h3 id="格式化与多余的空白字符"><a href="#格式化与多余的空白字符" class="headerlink" title="格式化与多余的空白字符"></a>格式化与多余的空白字符</h3><p>格式化与多余的空白字符是许多开发人员在协作时，特别是在跨平台情况下，不时会遇到的令人头疼的琐碎的问题。 由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交的补丁或其它协作成果中。 不用怕，Git 提供了一些配置项来帮助你解决这些问题。</p><h4 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a><code>core.autocrlf</code></h4><p>假如你正在 Windows 上写程序，而你的同伴用的是其他系统（或相反），你可能会遇到 CRLF 问题。 这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 Mac 和 Linux 只使用换行（LF）一个字符。 虽然这是小问题，但它会极大地扰乱跨平台协作。许多 Windows 上的编辑器会悄悄把行尾的换行字符转换成回车和换行，或在用户按下 Enter 键时，插入回车和换行两个字符。</p><p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。 你可以用 <code>core.autocrlf</code> 来打开此项功能。 如果是在 Windows 系统上，把它设置成 <code>true</code>，这样在检出代码时，换行会被转换成回车和换行：</p><pre class=" language-console"><code class="language-console">$ git config --global core.autocrlf true</code></pre><p>如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 你可以把 <code>core.autocrlf</code> 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p><pre class=" language-console"><code class="language-console">$ git config --global core.autocrlf input</code></pre><p>这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。</p><p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 <code>false</code> 取消此功能，把回车保留在版本库中：</p><pre class=" language-console"><code class="language-console">$ git config --global core.autocrlf false</code></pre><h4 id="core-whitespace"><a href="#core-whitespace" class="headerlink" title="core.whitespace"></a><code>core.whitespace</code></h4><p>Git 预先设置了一些选项来探测和修正多余空白字符问题。 它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p><p>默认被打开的三个选项是：<code>blank-at-eol</code>，查找行尾的空格；<code>blank-at-eof</code>，盯住文件底部的空行；<code>space-before-tab</code>，警惕行头 tab 前面的空格。</p><p>默认被关闭的三个选项是：<code>indent-with-non-tab</code>，揪出以空格而非 tab 开头的行（你可以用 <code>tabwidth</code> 选项控制它）；<code>tab-in-indent</code>，监视在行头表示缩进的 tab；<code>cr-at-eol</code>，告诉 Git 忽略行尾的回车。</p><p>通过设置 <code>core.whitespace</code>，你可以让 Git 按照你的意图来打开或关闭以逗号分割的选项。 要想关闭某个选项，你可以在输入设置选项时不指定它或在它前面加个 <code>-</code>。 例如，如果你想要打开除 <code>cr-at-eol</code> 之外的所有选项：</p><pre class=" language-console"><code class="language-console">$ git config --global core.whitespace \    trailing-space,space-before-tab,indent-with-non-tab</code></pre><p>当你运行 <code>git diff</code> 命令并尝试给输出着色时，Git 将探测到这些问题，因此你在提交前就能修复它们。 用 <code>git apply</code> 打补丁时你也会从中受益。 如果正准备应用的补丁存有特定的空白问题，你可以让 Git 在应用补丁时发出警告：</p><pre class=" language-console"><code class="language-console">$ git apply --whitespace=warn <patch></code></pre><p>或者让 Git 在打上补丁前自动修正此问题：</p><pre class=" language-console"><code class="language-console">$ git apply --whitespace=fix <patch></code></pre><p>这些选项也能运用于 <code>git rebase</code>。 如果提交了有空白问题的文件，但还没推送到上游，你可以运行 <code>git rebase --whitespace=fix</code> 来让 Git 在重写补丁时自动修正它们。</p><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>Git 服务器端的配置项相对来说并不多，但仍有一些饶有生趣的选项值得你一看。</p><h4 id="receive-fsckObjects"><a href="#receive-fsckObjects" class="headerlink" title="receive.fsckObjects"></a><code>receive.fsckObjects</code></h4><p>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。 但 Git 不会在每次推送时都这么做。这个操作很耗时间，很有可能会拖慢提交的过程，特别是当库或推送的文件很大的情况下。 如果想在每次推送时都要求 Git 检查一致性，设置 <code>receive.fsckObjects</code> 为 true 来强迫它这么做：</p><pre class=" language-console"><code class="language-console">$ git config --system receive.fsckObjects true</code></pre><p>现在 Git 会在每次推送生效前检查库的完整性，确保没有被有问题的客户端引入破坏性数据。</p><h4 id="receive-denyNonFastForwards"><a href="#receive-denyNonFastForwards" class="headerlink" title="receive.denyNonFastForwards"></a><code>receive.denyNonFastForwards</code></h4><p>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。 这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 push 命令后加 <code>-f</code> 标志来强制更新（force-update）。</p><p>要禁用这样的强制更新推送（force-pushes），可以设置 <code>receive.denyNonFastForwards</code>：</p><pre class=" language-console"><code class="language-console">$ git config --system receive.denyNonFastForwards true</code></pre><p>稍后我们会提到，用服务器端的接收钩子也能达到同样的目的。 那种方法可以做到更细致的控制，例如禁止某一类用户做非快进（non-fast-forwards）推送。</p><h4 id="receive-denyDeletes"><a href="#receive-denyDeletes" class="headerlink" title="receive.denyDeletes"></a><code>receive.denyDeletes</code></h4><p>有一些方法可以绕过 <code>denyNonFastForwards</code> 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。 把 <code>receive.denyDeletes</code> 设置为 true 可以把这个漏洞补上：</p><pre class=" language-console"><code class="language-console">$ git config --system receive.denyDeletes true</code></pre><p>这样会禁止通过推送删除分支和标签 — 没有用户可以这么做。 要删除远程分支，必须从服务器手动删除引用文件。 通过用户访问控制列表（ACL）也能够在用户级的粒度上实现同样的功能，你将在 <a href="https://git-scm.com/book/zh/v2/ch00/r_an_example_git_enforced_policy" target="_blank" rel="noopener">使用强制策略的一个例子</a> 一节学到具体的做法。</p><h2 id="Git-属性"><a href="#Git-属性" class="headerlink" title="Git 属性"></a>Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。 这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 <code>.gitattributes</code> 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 <code>.git/info/attributes</code> 文件中进行设置。</p><p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。 在本节，你将学习到一些能在自己的项目中用到的属性，并看到几个实际的例子。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>你可以用 Git 属性让 Git 知道哪些是二进制文件（以防它没有识别出来），并指示其如何处理这些文件。 例如，一些文本文件是由机器产生的，没有办法进行比较，但是一些二进制文件可以比较。 你将了解到怎样让 Git 区分这些文件。</p><h4 id="识别二进制文件"><a href="#识别二进制文件" class="headerlink" title="识别二进制文件"></a>识别二进制文件</h4><p>有些文件表面上是文本文件，实质上应被作为二进制文件处理。 例如，Mac 平台上的 Xcode 项目会包含一个以 <code>.pbxproj</code> 结尾的文件，它通常是一个记录项目构建配置等信息的 JSON（纯文本 Javascript 数据类型）数据集，由 IDE 写入磁盘。 虽然技术上看它是由 UTF-8 编码的文本文件，但你并不会希望将它当作文本文件来处理，因为它其实是一个轻量级数据库——如果有两个人修改了它，你通常无法合并内容，diff 的输出也帮不上什么忙。 它本应被机器处理。 因此，你想把它当成二进制文件。</p><p>要让 Git 把所有 <code>pbxproj</code> 文件当成二进制文件，在 <code>.gitattributes</code> 文件中如下设置：</p><pre><code>*.pbxproj binary</code></pre><p>现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 <code>git show</code> 或 <code>git diff</code> 时，Git 也不会比较或打印该文件的变化。</p><h4 id="比较二进制文件"><a href="#比较二进制文件" class="headerlink" title="比较二进制文件"></a>比较二进制文件</h4><p>你也可以使用 Git 属性来有效地比较两个二进制文件。 秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。</p><p>首先，让我们尝试用这个技术解决世人最头疼的问题之一：对 Microsoft Word 文档进行版本控制。 大家都知道，Microsoft Word 几乎是世上最难缠的编辑器，尽管如此，大家还是在用它。 如果想对 Word 文档进行版本控制，你可以把文件加入到 Git 库中，每次修改后提交即可。但这样做有什么实际意义呢？ 毕竟运行 <code>git diff</code> 命令后，你只能得到如下的结果：</p><pre class=" language-console"><code class="language-console">$ git diffdiff --git a/chapter1.docx b/chapter1.docxindex 88839c4..4afcb7c 100644Binary files a/chapter1.docx and b/chapter1.docx differ</code></pre><p>除了检出之后睁大眼睛逐行扫描，就真的没有办法直接比较两个不同版本的 Word 文档吗？ Git 属性能很好地解决此问题。 把下面这行文本加到你的 <code>.gitattributes</code> 文件中：</p><pre><code>*.docx diff=word</code></pre><p>这告诉 Git 当你尝试查看包含变更的比较结果时，所有匹配 <code>.docx</code> 模式的文件都应该使用“word”过滤器。 “word”过滤器是什么？ 我们现在就来设置它。 我们会对 Git 进行配置，令其能够借助 <code>docx2txt</code>程序将 Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。</p><p>首先，你需要安装 <code>docx2txt</code>；它可以从 <a href="http://docx2txt.sourceforge.net/" target="_blank" rel="noopener">http://docx2txt.sourceforge.net</a> 下载。 按照 <code>INSTALL</code> 文件的说明，把它放到你的可执行路径下。 接下来，你还需要写一个脚本把输出结果包装成 Git 支持的格式。 在你的可执行路径下创建一个叫 <code>docx2txt</code> 文件，添加这些内容：</p><pre class=" language-console"><code class="language-console">#!/bin/bashdocx2txt.pl $1 -</code></pre><p>别忘了用 <code>chmod a+x</code> 给这个文件加上可执行权限。 最后，你需要配置 Git 来使用这个脚本：</p><pre class=" language-console"><code class="language-console">$ git config diff.word.textconv docx2txt</code></pre><p>现在如果在两个快照之间进行比较，Git 就会对那些以 <code>.docx</code> 结尾的文件应用“word”过滤器，即 <code>docx2txt</code>。 这样你的 Word 文件就能被高效地转换成文本文件并进行比较了。</p><p>作为例子，我把本书的第一章另存为 Word 文件，并提交到 Git 版本库。 接着，往其中加入一个新的段落。 运行 <code>git diff</code>，输出如下：</p><pre class=" language-console"><code class="language-console">$ git diffdiff --git a/chapter1.docx b/chapter1.docxindex 0b013ca..ba25db5 100644--- a/chapter1.docx+++ b/chapter1.docx@@ -2,6 +2,7 @@ This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so. 1.1. About Version Control What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.+Testing: 1, 2, 3. If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead. 1.1.1. Local Version Control Systems Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.</code></pre><p>Git 成功地挑出了我们添加的那句话“Testing: 1, 2, 3.”，一字不差。 还算不上完美——格式上的变动显示不出来——但已经足够了。</p><p>你还能用这个方法比较图像文件。 其中一个办法是，在比较时对图像文件运用一个过滤器，提炼出 EXIF 信息——这是在大部分图像格式中都有记录的一种元数据。 如果你下载并安装了 <code>exiftool</code> 程序，可以利用它将图像转换为关于元数据的文本信息，这样比较时至少能以文本的形式显示发生过的变动：</p><pre class=" language-console"><code class="language-console">$ echo '*.png diff=exif' >> .gitattributes$ git config diff.exif.textconv exiftool</code></pre><p>如果在项目中替换了一个图像文件，运行 <code>git diff</code> 命令的结果如下：</p><pre><code>diff --git a/image.png b/image.pngindex 88839c4..4afcb7c 100644--- a/image.png+++ b/image.png@@ -1,12 +1,12 @@ ExifTool Version Number         : 7.74-File Size                       : 70 kB-File Modification Date/Time     : 2009:04:21 07:02:45-07:00+File Size                       : 94 kB+File Modification Date/Time     : 2009:04:21 07:02:43-07:00 File Type                       : PNG MIME Type                       : image/png-Image Width                     : 1058-Image Height                    : 889+Image Width                     : 1056+Image Height                    : 827 Bit Depth                       : 8 Color Type                      : RGB with Alpha</code></pre><p>你一眼就能看出文件大小和图像尺寸发生了变化。</p><h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p>SVN 或 CVS 风格的关键字展开（keyword expansion）功能经常会被习惯于上述系统的开发者使用到。 在 Git 中，这项功能有一个主要问题，就是你无法利用它往文件中加入其关联提交的相关信息，因为 Git 总是先对文件做校验和运算（译者注：Git 中提交对象的校验依赖于文件的校验和，而 Git 属性针对特定文件或路径，因此基于 Git 属性的关键字展开无法仅根据文件反推出对应的提交）。 不过，我们可以在检出某个文件后对其注入文本，并在再次提交前删除这些文本。 Git 属性提供了两种方法来达到这一目的。</p><p>一种方法是，你可以把文件所对应数据对象的 SHA-1 校验和自动注入到文件中的 <code>$Id$</code> 字段。 如果在一个或多个文件上设置了该属性，下次当你检出相关分支的时候，Git 会用相应数据对象的 SHA-1 值替换上述字段。 注意，这不是提交对象的 SHA-1 校验和，而是数据对象本身的校验和：</p><pre class=" language-console"><code class="language-console">$ echo '*.txt ident' >> .gitattributes$ echo '$Id$' > test.txt</code></pre><p>当你下次检出文件时，Git 将注入数据对象的 SHA-1 校验和：</p><pre class=" language-console"><code class="language-console">$ rm test.txt$ git checkout -- test.txt$ cat test.txt$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre><p>然而，这个结果的用途比较有限。 如果用过 CVS 或 Subversion 的关键字替换功能，我们会想加上一个时间戳信息——光有 SHA-1 校验和用途不大，它仅仅是个随机字符串，你无法凭字面值来区分不同 SHA-1 时间上的先后。</p><p>因此 Git 属性提供了另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。 一个过滤器由“clean”和“smudge”两个子过滤器组成。 在 <code>.gitattributes</code> 文件中，你能对特定的路径设置一个过滤器，然后设置文件检出前的处理脚本（“smudge”，见 <a href="https://git-scm.com/book/zh/v2/ch00/rfilters_a" target="_blank" rel="noopener">“smudge”过滤器会在文件被检出时触发</a>）和文件暂存前的处理脚本（“clean”，见 <a href="https://git-scm.com/book/zh/v2/ch00/rfilters_b" target="_blank" rel="noopener">“clean”过滤器会在文件被暂存时触发</a>）。 这两个过滤器能够被用来做各种有趣的事。</p><p><img src="https://git-scm.com/book/en/v2/images/smudge.png" alt="“smudge”过滤器会在文件被检出时触发。"></p><p>Figure 144. “smudge”过滤器会在文件被检出时触发</p><p><img src="https://git-scm.com/book/en/v2/images/clean.png" alt="“clean”过滤器会在文件被暂存时触发。"></p><p>Figure 145. “clean”过滤器会在文件被暂存时触发</p><p>在（Git 源码中）实现这个特性的原始提交信息里给出了一个简单的例子：在提交前，用 <code>indent</code> 程序过滤所有 C 源码。 你可以在 <code>.gitattributes</code> 文件中对 filter 属性设置“indent”过滤器来过滤 <code>*.c</code> 文件</p><pre><code>*.c filter=indent</code></pre><p>然后，通过以下配置，让 Git 知道“indent”过滤器在 smudge 和 clean 时分别该做什么：</p><pre class=" language-console"><code class="language-console">$ git config --global filter.indent.clean indent$ git config --global filter.indent.smudge cat</code></pre><p>在这个例子中，当你暂存 <code>*.c</code> 文件时，<code>indent</code> 程序会先被触发；在把它们检出回硬盘时，<code>cat</code> 程序会先被触发。 <code>cat</code> 在这里没什么实际作用：它仅仅把输入的数据重新输出。 这样的组合可以有效地在暂存前用 <code>indent</code> 过滤所有的 C 源码。</p><p>另一个有趣的例子是实现 RCS 风格的 <code>$Date$</code> 关键字展开。 要想演示这个例子，我们需要实现这样的一个小脚本：接受文件名参数，得到项目的最新提交日期，并把日期写入该文件。 下面是一个实现了该功能的 Ruby 小脚本：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#! /usr/bin/env ruby</span>data <span class="token operator">=</span> <span class="token constant">STDIN</span><span class="token punctuation">.</span>readlast_date <span class="token operator">=</span> `git log <span class="token operator">--</span>pretty<span class="token operator">=</span>format<span class="token punctuation">:</span><span class="token string">"%ad"</span> <span class="token operator">-</span><span class="token number">1</span>`puts data<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span><span class="token string">'$Date$'</span><span class="token punctuation">,</span> <span class="token string">'$Date: '</span> <span class="token operator">+</span> last_date<span class="token punctuation">.</span>to_s <span class="token operator">+</span> <span class="token string">'$'</span><span class="token punctuation">)</span></code></pre><p>这个脚本从 <code>git log</code> 中得到最新提交日期，将其注入所有输入文件的 <code>$Date$</code> 字段，并输出结果——你可以使用最顺手的语言轻松实现一个类似的脚本。 把该脚本命名为 <code>expand_date</code>，放到你的可执行路径中。 现在，你需要在 Git 中设置一个过滤器（就叫它 <code>dater</code> 吧），让它在检出文件时调用你的 <code>expand_date</code> 来注入时间戳，完成 smudge 操作。 暂存文件时的 clean 操作则是用一行 Perl 表达式清除注入的内容：</p><pre class=" language-console"><code class="language-console">$ git config filter.dater.smudge expand_date$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'</code></pre><p>这段 Perl 代码会删除 <code>$Date$</code> 后面注入的内容，恢复它的原貌。 过滤器终于准备完成了，是时候测试一下。创建一个带有 <code>$Date$</code> 关键字的文件，然后给它设置一个 Git 属性，关联我们的新过滤器：</p><pre class=" language-console"><code class="language-console">$ echo '# $Date$' > date_test.txt$ echo 'date*.txt filter=dater' >> .gitattributes</code></pre><p>提交该文件，并再次检出，你会发现关键字如期被替换了：</p><pre class=" language-console"><code class="language-console">$ git add date_test.txt .gitattributes$ git commit -m "Testing date expansion in Git"$ rm date_test.txt$ git checkout date_test.txt$ cat date_test.txt# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre><p>自定义过滤器真的很强大。 不过你需要注意的是，因为 <code>.gitattributes</code> 文件会随着项目一起提交，而过滤器（例如这里的 <code>dater</code>）不会，所以过滤器有可能会失效。 当你在设计这些过滤器时，要注重容错性——它们在出错时应该能优雅地退出，从而不至于影响项目的正常运行。</p><h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>Git 属性在导出项目归档（archive）时也能发挥作用。</p><h4 id="export-ignore"><a href="#export-ignore" class="headerlink" title="export-ignore"></a><code>export-ignore</code></h4><p>当归档的时候，可以设置 Git 不导出某些文件和目录。 如果你不想在归档中包含某个子目录或文件，但想把它们纳入项目的版本管理中，你可以在 <code>export-ignore</code> 属性中指定它们。</p><p>例如，假设你在 <code>test/</code> 子目录下有一些测试文件，不希望它们被包含在项目导出的压缩包（tarball）中。 你可以增加下面这行到 Git 属性文件中：</p><pre><code>test/ export-ignore</code></pre><p>现在，当你运行 <code>git archive</code> 来创建项目的压缩包时，那个目录不会被包括在归档中。</p><h4 id="export-subst"><a href="#export-subst" class="headerlink" title="export-subst"></a><code>export-subst</code></h4><p>在导出文件进行部署的时候，你可以将 <code>git log</code> 的格式化和关键字展开处理应用于被 <code>export-subst</code> 属性标记的部分文件。</p><p>举个例子，如果你想在项目中包含一个叫做 <code>LAST_COMMIT</code> 的文件，并在运行 <code>git archive</code> 的时候自动向它注入最新提交的元数据，可以像这样设置该文件：</p><pre class=" language-console"><code class="language-console">$ echo 'Last commit date: $Format:%cd by %aN$' > LAST_COMMIT$ echo "LAST_COMMIT export-subst" >> .gitattributes$ git add LAST_COMMIT .gitattributes$ git commit -am 'adding LAST_COMMIT file for archives'</code></pre><p>运行 <code>git archive</code> 之后，该文件被归档后的内容会被替换成这样：</p><pre class=" language-console"><code class="language-console">$ git archive HEAD | tar xCf ../deployment-testing -$ cat ../deployment-testing/LAST_COMMITLast commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</code></pre><p>你也可以用诸如提交信息或者任意的 git 注解进行替换，并且 git log 还能做简单的字词包装：</p><pre><code>$ echo &#39;$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$&#39; &gt; LAST_COMMIT$ git commit -am &#39;export-subst 使用 git log 的自定义格式化工具git archive 直接使用 git log 的 `pretty=format:`处理器，并在输出中移除两侧的 `$Format:` 和 `$`标记。&#39;$ git archive @ | tar xfO - LAST_COMMITLast commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700       export-subst 使用 git log 的自定义格式化工具         git archive 直接使用 git log 的 `pretty=format:` 处理器，并         在输出中移除两侧的 `$Format:` 和 `$` 标记。</code></pre><p>由此得到的归档适用于（当前的）部署工作。然而和其他的导出归档一样，它并不适用于后继的部署工作。</p><h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>通过 Git 属性，你还能对项目中的特定文件指定不同的合并策略。 一个非常有用的选项就是，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容。</p><p>考虑如下场景：项目中有一个分叉的或者定制过的特性分支，你希望该分支上的更改能合并回你的主干分支，同时需要忽略其中某些文件。此时这个合并策略就能派上用场。 假设你有一个数据库设置文件 <code>database.xml</code>，在两个分支中它是不同的，而你想合并另一个分支到你的分支上，又不想弄乱该数据库文件。 你可以设置属性如下：</p><pre><code>database.xml merge=ours</code></pre><p>然后定义一个虚拟的合并策略，叫做 <code>ours</code>：</p><pre class=" language-console"><code class="language-console">$ git config --global merge.ours.driver true</code></pre><p>如果你合并了另一个分支，<code>database.xml</code> 文件不会有合并冲突，相反会显示如下信息：</p><pre class=" language-console"><code class="language-console">$ git merge topicAuto-merging database.xmlMerge made by recursive.</code></pre><p>这里，<code>database.xml</code> 保持了主干分支中的原始版本。</p><h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>和其它版本控制系统一样，Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。</p><h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><p>钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。 当你用 <code>git init</code> 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 这些示例的名字都是以 <code>.sample</code> 结尾，如果你想启用它们，得先移除这个后缀。</p><p>把一个正确命名且可执行的文件放入 Git 目录下的 <code>hooks</code> 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用。 接下来，我们会讲解常用的钩子脚本类型。</p><h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>客户端钩子分为很多种。 下面把它们分为：提交工作流钩子、电子邮件工作流钩子和其它钩子。</p><table><thead><tr><th>Note</th><th>需要注意的是，克隆某个版本库时，它的客户端钩子 <strong>并不</strong> 随同复制。 如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。（请参照 <a href="https://git-scm.com/book/zh/v2/ch00/r_an_example_git_enforced_policy" target="_blank" rel="noopener">使用强制策略的一个例子</a> 中的例子。）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p>前四个钩子涉及提交的过程。</p><p><code>pre-commit</code> 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 <code>lint</code> 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p><p><code>prepare-commit-msg</code> 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</p><p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p><p><code>post-commit</code> 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</p><h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>你可以给电子邮件工作流设置三个客户端钩子。 它们都是由 <code>git am</code> 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。 如果你需要通过电子邮件接收由 <code>git format-patch</code> 产生的补丁，这些钩子也许用得上。</p><p>第一个运行的钩子是 <code>applypatch-msg</code> 。 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p><p>下一个在 <code>git am</code> 运行期间被调用的是 <code>pre-applypatch</code> 。 有些难以理解的是，它正好运行于应用补丁 <em>之后</em>，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 <code>git am</code> 的运行，这样补丁就不会被提交。</p><p><code>post-applypatch</code> 运行于提交产生之后，是在 <code>git am</code> 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程。</p><h4 id="其它客户端钩子"><a href="#其它客户端钩子" class="headerlink" title="其它客户端钩子"></a>其它客户端钩子</h4><p><code>pre-rebase</code> 钩子运行于变基之前，以非零值退出可以中止变基的过程。 你可以使用这个钩子来禁止对已经推送的提交变基。 Git 自带的 <code>pre-rebase</code> 钩子示例就是这么做的，不过它所做的一些假设可能与你的工作流程不匹配。</p><p><code>post-rewrite</code> 钩子被那些会替换提交记录的命令调用，比如 <code>git commit --amend</code> 和 <code>git rebase</code>（不过不包括 <code>git filter-branch</code>）。 它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。 这个钩子的用途很大程度上跟 <code>post-checkout</code> 和 <code>post-merge</code> 差不多。</p><p>在 <code>git checkout</code> 成功运行后，<code>post-checkout</code> 钩子会被调用。你可以根据你的项目环境用它调整你的工作目录。 其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。</p><p>在 <code>git merge</code> 成功运行后，<code>post-merge</code> 钩子会被调用。 你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。 这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。</p><p><code>pre-push</code> 钩子会在 <code>git push</code> 运行期间， 更新了远程引用但尚未传送对象时被调用。 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</p><p>Git 的一些日常操作在运行时，偶尔会调用 <code>git gc --auto</code> 进行垃圾回收。 <code>pre-auto-gc</code> 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。</p><h3 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h3><p>除了客户端钩子，作为系统管理员，你还可以使用若干服务器端的钩子对项目强制执行各种类型的策略。 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。</p><h4 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a><code>pre-receive</code></h4><p>处理来自客户端的推送操作时，最先被调用的脚本是 <code>pre-receive</code>。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p><h4 id="update"><a href="#update" class="headerlink" title="update"></a><code>update</code></h4><p><code>update</code> 脚本和 <code>pre-receive</code> 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，<code>pre-receive</code> 只运行一次，相比之下 <code>update</code> 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。</p><h4 id="post-receive"><a href="#post-receive" class="headerlink" title="post-receive"></a><code>post-receive</code></h4><p><code>post-receive</code> 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 <code>pre-receive</code> 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p><h2 id="使用强制策略的一个例子"><a href="#使用强制策略的一个例子" class="headerlink" title="使用强制策略的一个例子"></a>使用强制策略的一个例子</h2><p>在本节中，你将应用前面学到的知识建立这样一个 Git 工作流程：检查提交信息的格式，并且指定只能由特定用户修改项目中特定的子目录。 你将编写一个客户端脚本来提示开发人员他们的推送是否会被拒绝，以及一个服务器端脚本来实际执行这些策略。</p><p>我们待会展示的脚本是用 Ruby 写的，部分是由于我习惯用它写脚本，另外也因为 Ruby 简单易懂，即便你没写过它也能看明白。 不过任何其他语言也一样适用。所有 Git 自带的示例钩子脚本都是用 Perl 或 Bash 写的，所以你能从它们中找到相当多的这两种语言的钩子示例。</p><h3 id="服务器端钩子-1"><a href="#服务器端钩子-1" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h3><p>所有服务器端的工作都将在你的 <code>hooks</code> 目录下的 <code>update</code> 脚本中完成。 <code>update</code> 脚本会为每一个提交的分支各运行一次，它接受三个参数：</p><ul><li>被推送的引用的名字</li><li>推送前分支的修订版本（revision）</li><li>用户准备推送的修订版本（revision）</li></ul><p>如果推送是通过 SSH 进行的，还可以获知进行此次推送的用户的信息。 如果你允许所有操作都通过公匙授权的单一帐号（比如“git”）进行，就有必要通过一个 shell 包装脚本依据公匙来判断用户的身份，并且相应地设定环境变量来表示该用户的身份。 下面就假设 <code>$USER</code> 环境变量里存储了当前连接的用户的身份，你的 update 脚本首先搜集一切需要的信息：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span><span class="token variable">$refname</span> <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token variable">$oldrev</span>  <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token variable">$newrev</span>  <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token variable">$user</span>    <span class="token operator">=</span> <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">'USER'</span><span class="token punctuation">]</span>puts <span class="token string">"Enforcing Policies..."</span>puts <span class="token string">"(<span class="token interpolation"><span class="token delimiter tag">#{</span>$refname<span class="token delimiter tag">}</span></span>) (<span class="token interpolation"><span class="token delimiter tag">#{</span>$oldrev<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>) (<span class="token interpolation"><span class="token delimiter tag">#{</span>$newrev<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>)"</span></code></pre><p>是的，我们这里用的都是全局变量。 请勿在此吐槽——这样做只是为了方便展示而已。</p><h4 id="指定特殊的提交信息格式"><a href="#指定特殊的提交信息格式" class="headerlink" title="指定特殊的提交信息格式"></a>指定特殊的提交信息格式</h4><p>你的第一项任务是要求每一条提交信息都必须遵循某种特殊的格式。 作为目标，假定每一条信息必须包含一条形似“ref: 1234”的字符串，因为你想把每一次提交对应到问题追踪系统（ticketing system）中的某个事项。 你要逐一检查每一条推送上来的提交内容，看看提交信息是否包含这么一个字符串，然后，如果某个提交里不包含这个字符串，以非零返回值退出从而拒绝此次推送。</p><p>把 <code>$newrev</code> 和 <code>$oldrev</code> 变量的值传给一个叫做 <code>git rev-list</code> 的 Git 底层命令，你可以获取所有提交的 SHA-1 值列表。 <code>git rev-list</code> 基本类似 <code>git log</code> 命令，但它默认只输出 SHA-1 值而已，没有其他信息。 所以要获取由一次提交到另一次提交之间的所有 SHA-1 值，可以像这样运行：</p><pre class=" language-console"><code class="language-console">$ git rev-list 538c33..d14fc7d14fc7c847ab946ec39590d87783c69b031bdfb79f585da4401b0a3999e84113824d15245c13f0be234071a1be950e2a8d078e6141f5cd20c1e61ad3dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</code></pre><p>你可以截取这些输出内容，循环遍历其中每一个 SHA-1 值，找出与之对应的提交信息，然后用正则表达式来测试该信息包含的内容。</p><p>下一步要实现从每个提交中提取出提交信息。 使用另一个叫做 <code>git cat-file</code> 的底层命令来获得原始的提交数据。 我们将在 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 了解到这些底层命令的细节；现在暂时先看一下这条命令的输出：</p><pre class=" language-console"><code class="language-console">$ git cat-file commit ca82a6tree cfda3bf379e4f8dba8717dee55aab78aef7f4dafparent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7author Scott Chacon <schacon@gmail.com> 1205815931 -0700committer Scott Chacon <schacon@gmail.com> 1240030591 -0700changed the version number</code></pre><p>通过 SHA-1 值获得提交中的提交信息的一个简单办法是找到提交的第一个空行，然后取从它往后的所有内容。 可以使用 Unix 系统的 <code>sed</code> 命令来实现该效果：</p><pre class=" language-console"><code class="language-console">$ git cat-file commit ca82a6 | sed '1,/^$/d'changed the version number</code></pre><p>你可以用这条咒语从每一个待推送的提交里提取提交信息，然后在提取的内容不符合要求时退出。 为了退出脚本和拒绝此次推送，返回非零值。 整个脚本大致如下：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$regex</span> <span class="token operator">=</span> <span class="token regex">/\[ref: (\d+)\]/</span><span class="token comment" spellcheck="true"># 指定自定义的提交信息格式</span><span class="token keyword">def</span> check_message_format  missed_revs <span class="token operator">=</span> `git rev<span class="token operator">-</span>list #<span class="token punctuation">{</span><span class="token variable">$oldrev</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span>#<span class="token punctuation">{</span><span class="token variable">$newrev</span><span class="token punctuation">}</span>`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>  missed_revs<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>rev<span class="token operator">|</span>    message <span class="token operator">=</span> `git cat<span class="token operator">-</span>file commit #<span class="token punctuation">{</span>rev<span class="token punctuation">}</span> <span class="token operator">|</span> sed <span class="token string">'1,/^$/d'</span>`    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">$regex</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>      puts <span class="token string">"[POLICY] Your message is not formatted correctly"</span>      exit <span class="token number">1</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span>check_message_format</code></pre><p>把这一段放在 <code>update</code> 脚本里，所有包含不符合指定规则的提交都会遭到拒绝。</p><h4 id="指定基于用户的访问权限控制列表（ACL）系统"><a href="#指定基于用户的访问权限控制列表（ACL）系统" class="headerlink" title="指定基于用户的访问权限控制列表（ACL）系统"></a>指定基于用户的访问权限控制列表（ACL）系统</h4><p>假设你需要添加一个使用访问权限控制列表的机制，来指定哪些用户对项目的哪些部分有推送权限。 某些用户具有全部的访问权，其他人只对某些子目录或者特定的文件具有推送权限。 为了实现这一点，你要把相关的规则写入位于服务器原始 Git 仓库的 acl 文件中。 你还需要让 <code>update</code> 钩子检阅这些规则，审视推送的提交内容中被修改的所有文件，然后决定执行推送的用户是否对所有这些文件都有权限。</p><p>先从写一个 ACL 文件开始吧。 这里使用的格式和 CVS 的 ACL 机制十分类似：它由若干行构成，第一项内容是 <code>avail</code> 或者 <code>unavail</code>，接着是逗号分隔的适用该规则的用户列表，最后一项是适用该规则的路径（该项空缺表示没有路径限制）。 各项由管道符 <code>|</code> 隔开。</p><p>在本例中，你会有几个管理员，一些对 <code>doc</code> 目录具有权限的文档作者，以及一位仅对 <code>lib</code> 和 <code>tests</code> 目录具有权限的开发人员，相应的 ACL 文件如下：</p><pre><code>avail|nickh,pjhyett,defunkt,tpwavail|usinclair,cdickens,ebronte|docavail|schacon|libavail|schacon|tests</code></pre><p>首先把这些数据读入你要用到的数据结构里。 在本例中，为保持简洁，我们暂时只实现 <code>avail</code> 的规则。 下面这个方法生成一个关联数组，它的键是用户名，值是一个由该用户有写权限的所有目录组成的数组：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token function">get_acl_access_data</span><span class="token punctuation">(</span>acl_file<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 读取ACL数据</span>  acl_file <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>acl_file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reject <span class="token punctuation">{</span> <span class="token operator">|</span>line<span class="token operator">|</span> line <span class="token operator">==</span> <span class="token string">''</span> <span class="token punctuation">}</span>  access <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  acl_file<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>line<span class="token operator">|</span>    avail<span class="token punctuation">,</span> users<span class="token punctuation">,</span> path <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span>    <span class="token keyword">next</span> <span class="token keyword">unless</span> avail <span class="token operator">==</span> <span class="token string">'avail'</span>    users<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>user<span class="token operator">|</span>      access<span class="token punctuation">[</span>user<span class="token punctuation">]</span> <span class="token operator">||</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      access<span class="token punctuation">[</span>user<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> path    <span class="token keyword">end</span>  <span class="token keyword">end</span>  access<span class="token keyword">end</span></code></pre><p>对于之前给出的 ACL 规则文件，这个 <code>get_acl_access_data</code> 方法返回的数据结构如下：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">{</span><span class="token string">"defunkt"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">nil</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"tpw"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">nil</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"nickh"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">nil</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"pjhyett"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">nil</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"schacon"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"lib"</span><span class="token punctuation">,</span> <span class="token string">"tests"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"cdickens"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"doc"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"usinclair"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"doc"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"ebronte"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">"doc"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>既然拿到了用户权限的数据，接下来你需要找出提交都修改了哪些路径，从而才能保证推送者对所有这些路径都有权限。</p><p>使用 <code>git log</code> 的 <code>--name-only</code> 选项（在第二章里简单地提过），我们可以轻而易举的找出一次提交里修改的文件：</p><pre class=" language-console"><code class="language-console">$ git log -1 --name-only --pretty=format:'' 9f585dREADMElib/test.rb</code></pre><p>使用 <code>get_acl_access_data</code> 返回的 ACL 结构来一一核对每次提交修改的文件列表，就能找出该用户是否有权限推送所有的提交内容:</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># 仅允许特定用户修改项目中的特定子目录</span><span class="token keyword">def</span> check_directory_perms  access <span class="token operator">=</span> <span class="token function">get_acl_access_data</span><span class="token punctuation">(</span><span class="token string">'acl'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 检查是否有人在向他没有权限的地方推送内容</span>  new_commits <span class="token operator">=</span> `git rev<span class="token operator">-</span>list #<span class="token punctuation">{</span><span class="token variable">$oldrev</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span>#<span class="token punctuation">{</span><span class="token variable">$newrev</span><span class="token punctuation">}</span>`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>  new_commits<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>rev<span class="token operator">|</span>    files_modified <span class="token operator">=</span> `git log <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">--</span>name<span class="token operator">-</span>only <span class="token operator">--</span>pretty<span class="token operator">=</span>format<span class="token punctuation">:</span><span class="token string">''</span> #<span class="token punctuation">{</span>rev<span class="token punctuation">}</span>`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>    files_modified<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>path<span class="token operator">|</span>      <span class="token keyword">next</span> <span class="token keyword">if</span> path<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span>      has_file_access <span class="token operator">=</span> <span class="token keyword">false</span>      access<span class="token punctuation">[</span><span class="token variable">$user</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>access_path<span class="token operator">|</span>        <span class="token keyword">if</span> <span class="token operator">!</span>access_path  <span class="token comment" spellcheck="true"># 用户拥有完全访问权限</span>           <span class="token operator">||</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span>start_with<span class="token operator">?</span> access_path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 或者对此路径有访问权限</span>          has_file_access <span class="token operator">=</span> <span class="token keyword">true</span>        <span class="token keyword">end</span>      <span class="token keyword">end</span>      <span class="token keyword">if</span> <span class="token operator">!</span>has_file_access        puts <span class="token string">"[POLICY] You do not have access to push to <span class="token interpolation"><span class="token delimiter tag">#{</span>path<span class="token delimiter tag">}</span></span>"</span>        exit <span class="token number">1</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span>check_directory_perms</code></pre><p>通过 <code>git rev-list</code> 获取推送到服务器的所有提交。 接着，对于每一个提交，找出它修改的文件，然后确保推送者具有这些文件的推送权限。</p><p>现在你的用户没法推送带有不正确的提交信息的内容，也不能在准许他们访问范围之外的位置做出修改。</p><h4 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h4><p>如果已经把上面的代码放到 <code>.git/hooks/update</code> 文件里了，运行 <code>chmod u+x .git/hooks/update</code>，然后尝试推送一个不符合格式的提交，你会得到以下的提示：</p><pre class=" language-console"><code class="language-console">$ git push -f origin masterCounting objects: 5, done.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 323 bytes, done.Total 3 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.Enforcing Policies...(refs/heads/master) (8338c5) (c5b616)[POLICY] Your message is not formatted correctlyerror: hooks/update exited with error code 1error: hook declined to update refs/heads/masterTo git@gitserver:project.git ! [remote rejected] master -> master (hook declined)error: failed to push some refs to 'git@gitserver:project.git'</code></pre><p>这里有几个有趣的信息。 首先，我们可以看到钩子运行的起点。</p><pre><code>Enforcing Policies...(refs/heads/master) (fb8c72) (c56860)</code></pre><p>注意这是从 update 脚本开头输出到标准输出的。 所有从脚本输出到标准输出的内容都会转发给客户端。</p><p>下一个值得注意的部分是错误信息。</p><pre><code>[POLICY] Your message is not formatted correctlyerror: hooks/update exited with error code 1error: hook declined to update refs/heads/master</code></pre><p>第一行是我们的脚本输出的，剩下两行是 Git 在告诉我们 update 脚本退出时返回了非零值因而推送遭到了拒绝。 最后一点：</p><pre><code>To git@gitserver:project.git ! [remote rejected] master -&gt; master (hook declined)error: failed to push some refs to &#39;git@gitserver:project.git&#39;</code></pre><p>你会看到每个被你的钩子拒之门外的引用都收到了一个 remote rejected 信息，它告诉你正是钩子无法成功运行导致了推送的拒绝。</p><p>又或者某人想修改一个自己不具备权限的文件然后推送了一个包含它的提交，他将看到类似的提示。 比如，一个文档作者尝试推送一个修改到 <code>lib</code> 目录的提交，他会看到</p><pre><code>[POLICY] You do not have access to push to lib/test.rb</code></pre><p>从今以后，只要 <code>update</code> 脚本存在并且可执行，我们的版本库中永远都不会包含不符合格式的提交信息，并且用户都会待在沙箱里面。</p><h3 id="客户端钩子-1"><a href="#客户端钩子-1" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>这种方法的缺点在于，用户推送的提交遭到拒绝后无法避免的抱怨。 辛辛苦苦写成的代码在最后时刻惨遭拒绝是十分让人沮丧且具有迷惑性的；更可怜的是他们不得不修改提交历史来解决问题，这个方法并不能让每一个人满意。</p><p>逃离这种两难境地的法宝是给用户一些客户端的钩子，在他们犯错的时候给以警告。 然后呢，用户们就能趁问题尚未变得更难修复，在提交前消除这个隐患。 由于钩子本身不跟随克隆的项目副本分发，所以你必须通过其他途径把这些钩子分发到用户的 <code>.git/hooks</code> 目录并设为可执行文件。 虽然你可以在相同或单独的项目里加入并分发这些钩子，但是 Git 不会自动替你设置它。</p><p>首先，你应该在每次提交前核查你的提交信息，这样才能确保服务器不会因为不合条件的提交信息而拒绝你的更改。 为了达到这个目的，你可以增加 <code>commit-msg</code> 钩子。 如果你使用该钩子来读取作为第一个参数传递的提交信息，然后与规定的格式作比较，你就可以使 Git 在提交信息格式不对的情况下拒绝提交。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span>message_file <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>message <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>message_file<span class="token punctuation">)</span><span class="token variable">$regex</span> <span class="token operator">=</span> <span class="token regex">/\[ref: (\d+)\]/</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">$regex</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>  puts <span class="token string">"[POLICY] Your message is not formatted correctly"</span>  exit <span class="token number">1</span><span class="token keyword">end</span></code></pre><p>如果这个脚本位于正确的位置 (<code>.git/hooks/commit-msg</code>) 并且是可执行的，你提交信息的格式又是不正确的，你会看到：</p><pre class=" language-console"><code class="language-console">$ git commit -am 'test'[POLICY] Your message is not formatted correctly</code></pre><p>在这个示例中，提交没有成功。 然而如果你的提交注释信息是符合要求的，Git 会允许你提交：</p><pre class=" language-console"><code class="language-console">$ git commit -am 'test [ref: 132]'[master e05c914] test [ref: 132] 1 file changed, 1 insertions(+), 0 deletions(-)</code></pre><p>接下来我们要保证没有修改到 ACL 允许范围之外的文件。 假如你的 <code>.git</code> 目录下有前面使用过的那份 ACL 文件，那么以下的 <code>pre-commit</code> 脚本将把里面的规定执行起来：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span><span class="token variable">$user</span>    <span class="token operator">=</span> <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">'USER'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># [ 插入上文中的 get_acl_access_data 方法 ]</span><span class="token comment" spellcheck="true"># 仅允许特定用户修改项目中的特定子目录</span><span class="token keyword">def</span> check_directory_perms  access <span class="token operator">=</span> <span class="token function">get_acl_access_data</span><span class="token punctuation">(</span><span class="token string">'.git/acl'</span><span class="token punctuation">)</span>  files_modified <span class="token operator">=</span> `git diff<span class="token operator">-</span>index <span class="token operator">--</span>cached <span class="token operator">--</span>name<span class="token operator">-</span>only <span class="token constant">HEAD</span>`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>  files_modified<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>path<span class="token operator">|</span>    <span class="token keyword">next</span> <span class="token keyword">if</span> path<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span>    has_file_access <span class="token operator">=</span> <span class="token keyword">false</span>    access<span class="token punctuation">[</span><span class="token variable">$user</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>access_path<span class="token operator">|</span>    <span class="token keyword">if</span> <span class="token operator">!</span>access_path <span class="token operator">||</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>access_path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      has_file_access <span class="token operator">=</span> <span class="token keyword">true</span>    <span class="token keyword">end</span>    <span class="token keyword">if</span> <span class="token operator">!</span>has_file_access      puts <span class="token string">"[POLICY] You do not have access to push to <span class="token interpolation"><span class="token delimiter tag">#{</span>path<span class="token delimiter tag">}</span></span>"</span>      exit <span class="token number">1</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span>check_directory_perms</code></pre><p>这和服务器端的脚本几乎一样，除了两个重要区别。 第一，ACL 文件的位置不同，因为这个脚本在当前工作目录运行，而非 <code>.git</code> 目录。 ACL 文件的路径必须从</p><pre class=" language-ruby"><code class="language-ruby">access <span class="token operator">=</span> <span class="token function">get_acl_access_data</span><span class="token punctuation">(</span><span class="token string">'acl'</span><span class="token punctuation">)</span></code></pre><p>修改成：</p><pre class=" language-ruby"><code class="language-ruby">access <span class="token operator">=</span> <span class="token function">get_acl_access_data</span><span class="token punctuation">(</span><span class="token string">'.git/acl'</span><span class="token punctuation">)</span></code></pre><p>另一个重要区别是获取被修改文件列表的方式。 在服务器端的时候使用了查看提交纪录的方式，可是目前的提交都还没被记录下来呢，所以这个列表只能从暂存区域获取。 和原来的</p><pre class=" language-ruby"><code class="language-ruby">files_modified <span class="token operator">=</span> `git log <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">--</span>name<span class="token operator">-</span>only <span class="token operator">--</span>pretty<span class="token operator">=</span>format<span class="token punctuation">:</span><span class="token string">''</span> #<span class="token punctuation">{</span>ref<span class="token punctuation">}</span>`</code></pre><p>不同，现在要用</p><pre class=" language-ruby"><code class="language-ruby">files_modified <span class="token operator">=</span> `git diff<span class="token operator">-</span>index <span class="token operator">--</span>cached <span class="token operator">--</span>name<span class="token operator">-</span>only <span class="token constant">HEAD</span>`</code></pre><p>不同的就只有这两个——除此之外，该脚本完全相同。 有一点要注意的是，它假定在本地运行的用户和推送到远程服务器端的相同。 如果这二者不一样，则需要手动设置一下 <code>$user</code> 变量。</p><p>在这里，我们还可以确保推送内容中不包含非快进（non-fast-forward）的引用。 出现一个不是快进（fast-forward）的引用有两种情形，要么是在某个已经推送过的提交上作变基，要么是从本地推送一个错误的分支到远程分支上。</p><p>假定为了执行这个策略，你已经在服务器上配置好了 <code>receive.denyDeletes</code> 和 <code>receive.denyNonFastForwards</code>，因而唯一还需要避免的是在某个已经推送过的提交上作变基。</p><p>下面是一个检查这个问题的 <code>pre-rebase</code> 脚本示例。 它获取所有待重写的提交的列表，然后检查它们是否存在于远程引用中。 一旦发现其中一个提交是在某个远程引用中可达的（reachable），它就终止此次变基：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span>base_branch <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  topic_branch <span class="token operator">=</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">else</span>  topic_branch <span class="token operator">=</span> <span class="token string">"HEAD"</span><span class="token keyword">end</span>target_shas <span class="token operator">=</span> `git rev<span class="token operator">-</span>list #<span class="token punctuation">{</span>base_branch<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span>#<span class="token punctuation">{</span>topic_branch<span class="token punctuation">}</span>`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>remote_refs <span class="token operator">=</span> `git branch <span class="token operator">-</span>r`<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map <span class="token punctuation">{</span> <span class="token operator">|</span>r<span class="token operator">|</span> r<span class="token punctuation">.</span>strip <span class="token punctuation">}</span>target_shas<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>sha<span class="token operator">|</span>  remote_refs<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>remote_ref<span class="token operator">|</span>    shas_pushed <span class="token operator">=</span> `git rev<span class="token operator">-</span>list <span class="token operator">^</span>#<span class="token punctuation">{</span>sha<span class="token punctuation">}</span><span class="token operator">^</span>@ refs<span class="token operator">/</span>remotes<span class="token operator">/</span>#<span class="token punctuation">{</span>remote_ref<span class="token punctuation">}</span>`    <span class="token keyword">if</span> shas_pushed<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span>sha<span class="token punctuation">)</span>      puts <span class="token string">"[POLICY] Commit <span class="token interpolation"><span class="token delimiter tag">#{</span>sha<span class="token delimiter tag">}</span></span> has already been pushed to <span class="token interpolation"><span class="token delimiter tag">#{</span>remote_ref<span class="token delimiter tag">}</span></span>"</span>      exit <span class="token number">1</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>这个脚本利用了一个第六章“修订版本选择”一节中不曾提到的语法。通过运行这个命令可以获得一系列之前推送过的提交：</p><pre class=" language-ruby"><code class="language-ruby">`git rev<span class="token operator">-</span>list <span class="token operator">^</span>#<span class="token punctuation">{</span>sha<span class="token punctuation">}</span><span class="token operator">^</span>@ refs<span class="token operator">/</span>remotes<span class="token operator">/</span>#<span class="token punctuation">{</span>remote_ref<span class="token punctuation">}</span>`</code></pre><p><code>SHA^@</code> 语法会被解析成该提交的所有父提交。 该命令会列出在远程分支最新的提交中可达的，却在所有我们尝试推送的提交的 SHA-1 值的所有父提交中不可达的提交——也就是快进的提交。</p><p>这个解决方案主要的问题在于它有可能很慢而且常常没有必要——只要你不用 <code>-f</code> 来强制推送，服务器就会自动给出警告并且拒绝接受推送。 然而，这是个不错的练习，而且理论上能帮助你避免一次以后可能不得不回头修补的变基。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经阐述了大部分通过自定义 Git 客户端和服务端来适应自己工作流程和项目内容的方式。 你已经学到各种各样的设置项、基于文件的选项和事件钩子，还建立了一个示例用的强制策略服务器。 无论创造出了什么样的工作流程，你都能使 Git 与它珠联璧合。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git工具</title>
      <link href="/2019/07/15/Git%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/07/15/Git%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。 你已经尝试了跟踪和提交文件的基本操作，并且发挥了暂存区和轻量级的分支及合并的威力。</p><p>接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。</p><h2 id="选择修订版本"><a href="#选择修订版本" class="headerlink" title="选择修订版本"></a>选择修订版本</h2><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。</p><h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>你可以通过 Git 给出的 SHA-1 值来获取一次提交，不过还有很多更人性化的方式来做同样的事情。 本节将会介绍获取单个提交的多种方法。</p><h3 id="简短的-SHA-1"><a href="#简短的-SHA-1" class="headerlink" title="简短的 SHA-1"></a>简短的 SHA-1</h3><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。</p><p>例如查看一次指定的提交，假设你执行 <code>git log</code> 命令来查看之前新增一个功能的那次提交:</p><pre class=" language-console"><code class="language-console">$ git logcommit 734713bc047d87bf7eac9674765ae793478c50d3Author: Scott Chacon <schacon@gmail.com>Date:   Fri Jan 2 18:32:33 2009 -0800    fixed refs handling, added gc auto, updated testscommit d921970aadf03b3cf0e71becdaab3147ba71cdefMerge: 1c002dd... 35cfb2b...Author: Scott Chacon <schacon@gmail.com>Date:   Thu Dec 11 15:08:43 2008 -0800    Merge commit 'phedders/rdocs'commit 1c002dd4b536e7479fe34593e72e6c6c1819e53bAuthor: Scott Chacon <schacon@gmail.com>Date:   Thu Dec 11 14:58:32 2008 -0800    added some blame and merge stuff</code></pre><p>假设这个提交是 <code>1c002dd....</code>，如果你想 <code>git show</code> 这个提交，下面的命令是等价的（假设简短的版本没有歧义）：</p><pre class=" language-console"><code class="language-console">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b$ git show 1c002dd4b536e7479f$ git show 1c002d</code></pre><p>Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 <code>git log</code> 后加上 <code>--abbrev-commit</code> 参数，输出结果里就会显示简短且唯一的值；默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：</p><pre class=" language-console"><code class="language-console">$ git log --abbrev-commit --pretty=onelineca82a6d changed the version number085bb3b removed unnecessary test codea11bef0 first commit</code></pre><p>通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。</p><p>比如 Linux 内核这个相当大的 Git 项目，目前有超过 45 万个提交，包含 360 万个对象，也只需要前 11 个字符就能保证唯一性。</p><table><thead><tr><th>Note</th><th>关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个 SHA-1 值相同的对象。 然后呢？如果你真的向仓库里提交了一个跟之前的某个对象具有相同 SHA-1 值的对象，Git 发现仓库里已经存在了拥有相同 HASH 值的对象，就会认为这个新的提交是已经被写入仓库的。 如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20 字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 <code>p = (n(n-1)/2) * (1/2^160))</code> ）。2^80 是 1.2 x 10^24 也就是一亿亿亿。 那是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。 如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（360 万个 Git 对象）的代码，并将之提交到一个巨大的 Git 仓库里面，这样持续两年的时间才会产生足够的对象，使其拥有 50% 的概率产生一次 SHA-1 对象冲突。 这要比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h3><p>指明一次提交最直接的方法是有一个指向它的分支引用。 这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。 例如，你想要查看一个分支的最后一次提交的对象，假设 <code>topic1</code> 分支指向 <code>ca82a6d</code> ，那么以下的命令是等价的:</p><pre class=" language-console"><code class="language-console">$ git show ca82a6dff817ec66f44342007202690a93763949$ git show topic1</code></pre><p>如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1 ，你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。 你可以在 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 中查看更多关于探测工具的信息。简单来说，<code>rev-parse</code> 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 <code>rev-parse</code></p><pre class=" language-console"><code class="language-console">$ git rev-parse topic1ca82a6dff817ec66f44342007202690a93763949</code></pre><h3 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h3><p>当你在工作时， Git 会在后台保存一个引用日志(reflog)，引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p><p>你可以使用 <code>git reflog</code> 来查看引用日志</p><pre class=" language-console"><code class="language-console">$ git reflog734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updatedd921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.1c002dd HEAD@{2}: commit: added some blame and merge stuff1c36188 HEAD@{3}: rebase -i (squash): updating HEAD95df984 HEAD@{4}: commit: # This is a combination of two commits.1c36188 HEAD@{5}: rebase -i (squash): updating HEAD7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD</code></pre><p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 通过这些数据，你可以很方便地获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 <code>@{n}</code> 来引用 reflog 中输出的提交记录。</p><pre class=" language-console"><code class="language-console">$ git show HEAD@{5}</code></pre><p>你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 <code>master</code> 分支在昨天的时候指向了哪个提交，你可以输入</p><pre class=" language-console"><code class="language-console">$ git show master@{yesterday}</code></pre><p>就会显示昨天该分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</p><p>可以运行 <code>git log -g</code> 来查看类似于 <code>git log</code> 输出格式的引用日志信息：</p><pre class=" language-console"><code class="language-console">$ git log -g mastercommit 734713bc047d87bf7eac9674765ae793478c50d3Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)Reflog message: commit: fixed refs handling, added gc auto, updatedAuthor: Scott Chacon <schacon@gmail.com>Date:   Fri Jan 2 18:32:33 2009 -0800    fixed refs handling, added gc auto, updated testscommit d921970aadf03b3cf0e71becdaab3147ba71cdefReflog: master@{1} (Scott Chacon <schacon@gmail.com>)Reflog message: merge phedders/rdocs: Merge made by recursive.Author: Scott Chacon <schacon@gmail.com>Date:   Thu Dec 11 15:08:43 2008 -0800    Merge commit 'phedders/rdocs'</code></pre><p>值得注意的是，引用日志只存在于本地仓库，一个记录你在你自己的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 <code>git show HEAD@{2.months.ago}</code> 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。</p><table><thead><tr><th>Tip</th><th>将引用日志想作 Git 版的 shell 历史记录如果你有 UNIX 或者 Linux 的背景，你不妨将引用日志想作 Git 版的 shell 历史记录，重点在于仅与你和你的会话相关，而与他人无关。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h3><p>祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 <code>^</code>， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=format:'%h %s' --graph* 734713b fixed refs handling, added gc auto, updated tests*   d921970 Merge commit 'phedders/rdocs'|\| * 35cfb2b Some rdoc changes* | 1c002dd added some blame and merge stuff|/* 1c36188 ignore *.gem* 9b29157 add open3_detach to gemspec file list</code></pre><p>你可以使用 <code>HEAD^</code> 来查看上一个提交，也就是 “HEAD 的父提交”：</p><pre class=" language-console"><code class="language-console">$ git show HEAD^commit d921970aadf03b3cf0e71becdaab3147ba71cdefMerge: 1c002dd... 35cfb2b...Author: Scott Chacon <schacon@gmail.com>Date:   Thu Dec 11 15:08:43 2008 -0800    Merge commit 'phedders/rdocs'</code></pre><p>你也可以在 <code>^</code> 后面添加一个数字——例如 <code>d921970^2</code> 代表 “d921970 的第二父提交” 这个语法只适用于合并(merge)的提交，因为合并提交会有多个父提交。 第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p><pre class=" language-console"><code class="language-console">$ git show d921970^commit 1c002dd4b536e7479fe34593e72e6c6c1819e53bAuthor: Scott Chacon <schacon@gmail.com>Date:   Thu Dec 11 14:58:32 2008 -0800    added some blame and merge stuff$ git show d921970^2commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548Author: Paul Hedderly <paul+git@mjr.org>Date:   Wed Dec 10 22:22:03 2008 +0000    Some rdoc changes</code></pre><p>另一种指明祖先提交的方法是 <code>~</code>。 同样是指向第一父提交，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。 而区别在于你在后面加数字的时候。 <code>HEAD~2</code> 代表 “第一父提交的第一父提交”，也就是 “祖父提交” —— Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，<code>HEAD~3</code> 就是</p><pre class=" language-console"><code class="language-console">$ git show HEAD~3commit 1c3618887afb5fbcbea25b7c013f4e2114448b8dAuthor: Tom Preston-Werner <tom@mojombo.com>Date:   Fri Nov 7 13:47:59 2008 -0500    ignore *.gem</code></pre><p>也可以写成 <code>HEAD^^^</code>，也是第一父提交的第一父提交的第一父提交：</p><pre class=" language-console"><code class="language-console">$ git show HEAD^^^commit 1c3618887afb5fbcbea25b7c013f4e2114448b8dAuthor: Tom Preston-Werner <tom@mojombo.com>Date:   Fri Nov 7 13:47:59 2008 -0500    ignore *.gem</code></pre><p>你也可以组合使用这两个语法 —— 你可以通过 <code>HEAD~3^2</code> 来取得之前引用的第二父提交（假设它是一个合并提交）。</p><h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><p>你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用，你可以用提交区间来解决 “这个分支还有哪些提交尚未合并到主分支？” 的问题</p><h4 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h4><p>最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 <a href="https://git-scm.com/book/zh/v2/ch00/rdouble_dot" target="_blank" rel="noopener">Example history for range selection.</a></p><p><img src="https://git-scm.com/book/en/v2/images/double-dot.png" alt="Example history for range selection."></p><p>Figure 137. Example history for range selection.</p><p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 <code>master..experiment</code> 来让 Git 显示这些提交。也就是 “在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：</p><pre class=" language-console"><code class="language-console">$ git log master..experimentDC</code></pre><p>反过来，如果你想查看在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交，你只要交换分支名即可。<code>experiment..master</code> 会显示在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交：</p><pre class=" language-console"><code class="language-console">$ git log experiment..masterFE</code></pre><p>这可以让你保持 <code>experiment</code> 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：</p><pre class=" language-console"><code class="language-console">$ git log origin/master..HEAD</code></pre><p>这个命令会输出在你当前分支中而不在远程 <code>origin</code> 中的提交。 如果你执行 <code>git push</code> 并且你的当前分支正在跟踪 <code>origin/master</code>，由 <code>git log origin/master..HEAD</code> 所输出的提交就是会被传输到远端服务器的提交。 如果你留空了其中的一边， Git 会默认为 HEAD。 例如， <code>git log origin/master..</code>将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。</p><h4 id="多点"><a href="#多点" class="headerlink" title="多点"></a>多点</h4><p>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 <code>^</code> 字符或者 <code>--not</code> 来指明你不希望提交被包含其中的分支。 因此下列3个命令是等价的：</p><pre class=" language-console"><code class="language-console">$ git log refA..refB$ git log ^refA refB$ git log refB --not refA</code></pre><p>这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交，你可以输入下面中的任意一个命令</p><pre class=" language-console"><code class="language-console">$ git log refA refB ^refC$ git log refA refB --not refC</code></pre><p>这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。</p><h4 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h4><p>最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交，你可以执行</p><pre class=" language-console"><code class="language-console">$ git log master...experimentFEDC</code></pre><p>这和通常 <code>log</code> 按日期排序的输出一样，仅仅给出了4个提交的信息。</p><p>这种情形下，<code>log</code> 命令的一个常用参数是 <code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。</p><pre class=" language-console"><code class="language-console">$ git log --left-right master...experiment< F< E> D> C</code></pre><p>有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。</p><h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个交互命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 <code>git add</code> 时使用 <code>-i</code> 或者 <code>--interactive</code> 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：</p><pre class=" language-console"><code class="language-console">$ git add -i           staged     unstaged path  1:    unchanged        +0/-1 TODO  2:    unchanged        +1/-1 index.html  3:    unchanged        +5/-1 lib/simplegit.rb*** Commands ***  1: status     2: update      3: revert     4: add untracked  5: patch      6: diff        7: quit       8: helpWhat now></code></pre><p>可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p><p>在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。</p><h3 id="暂存与取消暂存文件"><a href="#暂存与取消暂存文件" class="headerlink" title="暂存与取消暂存文件"></a>暂存与取消暂存文件</h3><p>如果在 <code>What now&gt;</code> 提示符后键入 <code>2</code> 或 <code>u</code>，脚本将会提示想要暂存哪个文件：</p><pre class=" language-console"><code class="language-console">What now> 2           staged     unstaged path  1:    unchanged        +0/-1 TODO  2:    unchanged        +1/-1 index.html  3:    unchanged        +5/-1 lib/simplegit.rbUpdate>></code></pre><p>要暂存 TODO 与 index.html 文件，可以输入数字：</p><pre class=" language-console"><code class="language-console">Update>> 1,2           staged     unstaged path* 1:    unchanged        +0/-1 TODO* 2:    unchanged        +1/-1 index.html  3:    unchanged        +5/-1 lib/simplegit.rbUpdate>></code></pre><p>每个文件前面的 <code>*</code> 意味着选中的文件将会被暂存。 如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：</p><pre class=" language-console"><code class="language-console">Update>>updated 2 paths*** Commands ***  1: status     2: update      3: revert     4: add untracked  5: patch      6: diff        7: quit       8: helpWhat now> 1           staged     unstaged path  1:        +0/-1      nothing TODO  2:        +1/-1      nothing index.html  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre><p>现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 <code>3</code> 或 <code>r</code>（撤消）选项：</p><pre class=" language-console"><code class="language-console">*** Commands ***  1: status     2: update      3: revert     4: add untracked  5: patch      6: diff        7: quit       8: helpWhat now> 3           staged     unstaged path  1:        +0/-1      nothing TODO  2:        +1/-1      nothing index.html  3:    unchanged        +5/-1 lib/simplegit.rbRevert>> 1           staged     unstaged path* 1:        +0/-1      nothing TODO  2:        +1/-1      nothing index.html  3:    unchanged        +5/-1 lib/simplegit.rbRevert>> [enter]reverted one path</code></pre><p>再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：</p><pre class=" language-console"><code class="language-console">*** Commands ***  1: status     2: update      3: revert     4: add untracked  5: patch      6: diff        7: quit       8: helpWhat now> 1           staged     unstaged path  1:    unchanged        +0/-1 TODO  2:        +1/-1      nothing index.html  3:    unchanged        +5/-1 lib/simplegit.rb</code></pre><p>如果想要查看已暂存内容的区别，可以使用 <code>6</code> 或 <code>d</code>（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 <code>git diff --cached</code> 非常相似：</p><pre class=" language-console"><code class="language-console">*** Commands ***  1: status     2: update      3: revert     4: add untracked  5: patch      6: diff        7: quit       8: helpWhat now> 6           staged     unstaged path  1:        +1/-1      nothing index.htmlReview diff>> 1diff --git a/index.html b/index.htmlindex 4d07108..4335f49 100644--- a/index.html+++ b/index.html@@ -16,7 +16,7 @@ Date Finder <p id="out">...</p>-<div id="footer">contact : support@github.com</div>+<div id="footer">contact : email.support@github.com</div> <script type="text/javascript"></code></pre><p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p><h3 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h3><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 <code>5</code> 或 <code>p</code>（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：</p><pre class=" language-console"><code class="language-console">diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex dd5ecc4..57399e0 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -22,7 +22,7 @@ class SimpleGit   end   def log(treeish = 'master')-    command("git log -n 25 #{treeish}")+    command("git log -n 30 #{treeish}")   end   def blame(path)Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</code></pre><p>这时有很多选项。 输入 <code>?</code> 显示所有可以使用的命令列表：</p><pre class=" language-console"><code class="language-console">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?y - stage this hunkn - do not stage this hunka - stage this and all the remaining hunks in the filed - do not stage this hunk nor any of the remaining hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help</code></pre><p>通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：</p><pre class=" language-console"><code class="language-console">What now> 1           staged     unstaged path  1:    unchanged        +0/-1 TODO  2:        +1/-1      nothing index.html  3:        +1/-1        +4/-0 lib/simplegit.rb</code></pre><p>simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 <code>git commit</code> 来提交部分暂存的文件。</p><p>也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code> 来启动同样的脚本。</p><p>更进一步地，可以使用 <code>reset --patch</code> 命令的补丁模式来部分重置文件，通过 <code>checkout --patch</code> 命令来部分检出文件与 <code>stash save --patch</code> 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p><h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p><p>储藏会处理工作目录的脏的状态 - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。</p><h3 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h3><p>为了演示，进入项目并改动几个文件，然后可能暂存其中的一个改动。 如果运行 <code>git status</code>，可以看到有改动的状态：</p><pre class=" language-console"><code class="language-console">$ git statusChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    modified:   index.htmlChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   lib/simplegit.rb</code></pre><p>现在想要切换分支，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 <code>git stash</code> 或 <code>git stash save</code>：</p><pre class=" language-console"><code class="language-console">$ git stashSaved working directory and index state \  "WIP on master: 049d078 added the index file"HEAD is now at 049d078 added the index file(To restore them type "git stash apply")</code></pre><p>工作目录是干净的了：</p><pre class=" language-console"><code class="language-console">$ git status# On branch masternothing to commit, working directory clean</code></pre><p>在这时，你能够轻易地切换分支并在其他地方工作；你的修改被存储在栈上。 要查看储藏的东西，可以使用 <code>git stash list</code>：</p><pre class=" language-console"><code class="language-console">$ git stash liststash@{0}: WIP on master: 049d078 added the index filestash@{1}: WIP on master: c264051 Revert "added file_size"stash@{2}: WIP on master: 21d80a5 added number to log</code></pre><p>在本例中，有两个之前做的储藏，所以你接触到了三个不同的储藏工作。 可以通过原来 stash 命令的帮助提示中的命令将你刚刚储藏的工作重新应用：<code>git stash apply</code>。 如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：<code>git stash apply stash@{2}</code>。 如果不指定一个储藏，Git 认为指定的是最近的储藏：</p><pre class=" language-console"><code class="language-console">$ git stash apply# On branch master# Changed but not updated:#   (use "git add <file>..." to update what will be committed)##      modified:   index.html#      modified:   lib/simplegit.rb#</code></pre><p>可以看到 Git 重新修改了当你保存储藏时撤消的文件。 在本例中，当尝试应用储藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支；但是有一个干净的工作目录与应用在同一分支并不是成功应用储藏的充分必要条件。 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用储藏时工作目录中也可以有修改与未提交的文件 - 如果有任何东西不能干净地应用，Git 会产生合并冲突。</p><p>文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 <code>--index</code> 选项来运行 <code>git stash apply</code> 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：</p><pre class=" language-console"><code class="language-console">$ git stash apply --index# On branch master# Changes to be committed:#   (use "git reset HEAD <file>..." to unstage)##      modified:   index.html## Changed but not updated:#   (use "git add <file>..." to update what will be committed)##      modified:   lib/simplegit.rb#</code></pre><p>应用选项只会尝试应用暂存的工作 - 在堆栈上还有它。 可以运行 <code>git stash drop</code> 加上将要移除的储藏的名字来移除它：</p><pre class=" language-console"><code class="language-console">$ git stash liststash@{0}: WIP on master: 049d078 added the index filestash@{1}: WIP on master: c264051 Revert "added file_size"stash@{2}: WIP on master: 21d80a5 added number to log$ git stash drop stash@{0}Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</code></pre><p>也可以运行 <code>git stash pop</code> 来应用储藏然后立即从栈上扔掉它。</p><h3 id="创造性的储藏"><a href="#创造性的储藏" class="headerlink" title="创造性的储藏"></a>创造性的储藏</h3><p>有几个储藏的变种可能也很有用。 第一个非常流行的选项是 <code>stash save</code> 命令的 <code>--keep-index</code> 选项。 它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西。</p><p>当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。</p><pre class=" language-console"><code class="language-console">$ git status -sM  index.html M lib/simplegit.rb$ git stash --keep-indexSaved working directory and index state WIP on master: 1b65b17 added the index fileHEAD is now at 1b65b17 added the index file$ git status -sM  index.html</code></pre><p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。 默认情况下，<code>git stash</code> 只会储藏已经在索引中的文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 标记，Git 也会储藏任何创建的未跟踪文件。</p><pre class=" language-console"><code class="language-console">$ git status -sM  index.html M lib/simplegit.rb?? new-file.txt$ git stash -uSaved working directory and index state WIP on master: 1b65b17 added the index fileHEAD is now at 1b65b17 added the index file$ git status -s$</code></pre><p>最终，如果指定了 <code>--patch</code> 标记，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。</p><pre class=" language-console"><code class="language-console">$ git stash --patchdiff --git a/lib/simplegit.rb b/lib/simplegit.rbindex 66d332e..8bb5674 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -16,6 +16,10 @@ class SimpleGit         return `#{git_cmd} 2>&1`.chomp       end     end++    def show(treeish = 'master')+      command("git show #{treeish}")+    end end testStash this hunk [y,n,q,a,d,/,e,?]? ySaved working directory and index state WIP on master: 1b65b17 added the index file</code></pre><h3 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h3><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏：</p><pre class=" language-console"><code class="language-console">$ git stash branch testchangesSwitched to a new branch "testchanges"# On branch testchanges# Changes to be committed:#   (use "git reset HEAD <file>..." to unstage)##      modified:   index.html## Changed but not updated:#   (use "git add <file>..." to update what will be committed)##      modified:   lib/simplegit.rb#Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</code></pre><p>这是在新分支轻松恢复储藏工作并继续工作的一个很不错的途径。</p><h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。 <code>git clean</code> 命令会帮你做这些事。</p><p>有一些通用的原因比如说为了移除由合并或外部工具生成的东西，或是为了运行一个干净的构建而移除之前构建的残留。</p><p>你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。</p><p>你可以使用 <code>git clean</code> 命令去除冗余文件或者清理工作目录。 使用 <code>git clean -f -d</code> 命令来移除工作目录中所有未追踪的文件以及空的子目录。 <code>-f</code> 意味着 <em>强制</em> 或 “确定移除”。</p><p>如果只是想要看看它会做什么，可以使用 <code>-n</code> 选项来运行命令，这意味着 “做一次演习然后告诉你 <em>将要</em> 移除什么”。</p><pre class=" language-console"><code class="language-console">$ git clean -d -nWould remove test.oWould remove tmp/</code></pre><p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件，可以给 clean 命令增加一个 <code>-x</code> 选项。</p><pre class=" language-console"><code class="language-console">$ git status -s M lib/simplegit.rb?? build.TMP?? tmp/$ git clean -n -dWould remove build.TMPWould remove tmp/$ git clean -n -d -xWould remove build.TMPWould remove test.oWould remove tmp/</code></pre><p>如果不知道 <code>git clean</code> 命令将会做什么，在将 <code>-n</code> 改为 <code>-f</code> 来真正做之前总是先用 <code>-n</code> 来运行它做双重检查。 另一个小心处理过程的方式是使用 <code>-i</code> 或 “interactive” 标记来运行它。</p><p>这将会以交互模式运行 clean 命令。</p><pre class=" language-console"><code class="language-console">$ git clean -x -iWould remove the following items:  build.TMP  test.o*** Commands ***    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit    6: helpWhat now></code></pre><p>这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。</p><h2 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p><h3 id="GPG-介绍"><a href="#GPG-介绍" class="headerlink" title="GPG 介绍"></a>GPG 介绍</h3><p>首先，在开始签名之前你需要先配置 GPG 并安装个人密钥。</p><pre class=" language-console"><code class="language-console">$ gpg --list-keys/Users/schacon/.gnupg/pubring.gpg---------------------------------pub   2048R/0A46826A 2014-06-04uid                  Scott Chacon (Git signing key) <schacon@gmail.com>sub   2048R/874529A9 2014-06-04</code></pre><p>如果你还没有安装一个密钥，可以使用 <code>gpg --gen-key</code> 生成一个。</p><pre class=" language-console"><code class="language-console">gpg --gen-key</code></pre><p>一旦你有一个可以签署的私钥，可以通过设置 Git 的 <code>user.signingkey</code> 选项来签署。</p><pre class=" language-console"><code class="language-console">git config --global user.signingkey 0A46826A</code></pre><p>现在 Git 默认使用你的密钥来签署标签与提交。</p><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果已经设置好一个 GPG 私钥，可以使用它来签署新的标签。 所有需要做的只是使用 <code>-s</code> 代替 <code>-a</code> 即可：</p><pre class=" language-console"><code class="language-console">$ git tag -s v1.5 -m 'my signed 1.5 tag'You need a passphrase to unlock the secret key foruser: "Ben Straub <ben@straub.cc>"2048-bit RSA key, ID 800430EB, created 2014-05-04</code></pre><p>如果在那个标签上运行 <code>git show</code>，会看到你的 GPG 签名附属在后面：</p><pre class=" language-console"><code class="language-console">$ git show v1.5tag v1.5Tagger: Ben Straub <ben@straub.cc>Date:   Sat May 3 20:29:41 2014 -0700my signed 1.5 tag-----BEGIN PGP SIGNATURE-----Version: GnuPG v1iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/UtLQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85bhM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbmecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxViRUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk==EFTF-----END PGP SIGNATURE-----commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version number</code></pre><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><p>要验证一个签署的标签，可以运行 <code>git tag -v [tag-name]</code>。 这个命令使用 GPG 来验证签名。 为了验证能正常工作，签署者的公钥需要在你的钥匙链中。</p><pre class=" language-console"><code class="language-console">$ git tag -v v1.4.2.1object 883653babd8ee7ea23e6a5c392bb739348b1eb61type committag v1.4.2.1tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700GIT 1.4.2.1Minor fixes since 1.4.2, including git-mv and git-http with alternates.gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Good signature from "Junio C Hamano <junkio@cox.net>"gpg:                 aka "[jpeg image of size 1513]"Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</code></pre><p>如果没有签署者的公钥，那么你将会得到类似下面的东西：</p><pre class=" language-console"><code class="language-console">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9Agpg: Can't check signature: public key not founderror: could not verify the tag 'v1.4.2.1'</code></pre><h3 id="签署提交"><a href="#签署提交" class="headerlink" title="签署提交"></a>签署提交</h3><p>在最新版本的 Git 中（v1.7.9 及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个 <code>-S</code> 到 <code>git commit</code> 命令。</p><pre class=" language-console"><code class="language-console">$ git commit -a -S -m 'signed commit'You need a passphrase to unlock the secret key foruser: "Scott Chacon (Git signing key) <schacon@gmail.com>"2048-bit RSA key, ID 0A46826A, created 2014-06-04[master 5c3386c] signed commit 4 files changed, 4 insertions(+), 24 deletions(-) rewrite Rakefile (100%) create mode 100644 lib/git.rb</code></pre><p><code>git log</code> 也有一个 <code>--show-signature</code> 选项来查看及验证这些签名。</p><pre class=" language-console"><code class="language-console">$ git log --show-signature -1commit 5c3386cf54bba0a33a32da706aa52bc0155503c2gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826Agpg: Good signature from "Scott Chacon (Git signing key) <schacon@gmail.com>"Author: Scott Chacon <schacon@gmail.com>Date:   Wed Jun 4 19:49:17 2014 -0700    signed commit</code></pre><p>另外，也可以配置 <code>git log</code> 来验证任何找到的签名并将它们以 <code>%G?</code> 格式列在输出中。</p><pre class=" language-console"><code class="language-console">$ git log --pretty="format:%h %G? %aN  %s"5c3386c G Scott Chacon  signed commitca82a6d N Scott Chacon  changed the version number085bb3b N Scott Chacon  removed unnecessary test codea11bef0 N Scott Chacon  first commit</code></pre><p>这里我们可以看到只有最后一次提交是签署并有效的，而之前的提交都不是。</p><p>在 Git 1.8.3 及以后的版本中，“git merge” 与“git pull” 可以使用 <code>--verify-signatures</code> 选项来检查并拒绝没有携带可信 GPG 签名的提交。</p><p>如果使用这个选项来合并一个包含未签名或有效的提交的分支时，合并不会生效。</p><pre class=" language-console"><code class="language-console">$ git merge --verify-signatures non-verifyfatal: Commit ab06180 does not have a GPG signature.</code></pre><p>如果合并包含的只有有效的签名的提交，合并命令会提示所有的签名它已经检查过了然后会继续向前。</p><pre class=" language-console"><code class="language-console">$ git merge --verify-signatures signed-branchCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>Updating 5c3386c..13ad65eFast-forward README | 2 ++ 1 file changed, 2 insertions(+)</code></pre><p>也可以给 <code>git merge</code> 命令附加 <code>-S</code> 选项来签署自己生成的合并提交。 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交。</p><pre class=" language-console"><code class="language-console">$ git merge --verify-signatures -S  signed-branchCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>You need a passphrase to unlock the secret key foruser: "Scott Chacon (Git signing key) <schacon@gmail.com>"2048-bit RSA key, ID 0A46826A, created 2014-06-04Merge made by the 'recursive' strategy. README | 2 ++ 1 file changed, 2 insertions(+)</code></pre><h3 id="每个人必须签署"><a href="#每个人必须签署" class="headerlink" title="每个人必须签署"></a>每个人必须签署</h3><p>签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。</p><h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>Git 提供了一个 <code>grep</code> 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。</p><p>默认情况下 Git 会查找你工作目录的文件。 你可以传入 <code>-n</code> 参数来输出 Git 所找到的匹配行行号。</p><pre class=" language-console"><code class="language-console">$ git grep -n gmtime_rcompat/gmtime.c:3:#undef gmtime_rcompat/gmtime.c:8:      return git_gmtime_r(timep, &result);compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)compat/gmtime.c:16:     ret = gmtime_r(timep, result);compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm *result)compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm *result);date.c:429:             if (gmtime_r(&now, &now_tm))date.c:492:             if (gmtime_r(&time, tm)) {git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm *);git-compat-util.h:723:#define gmtime_r git_gmtime_r</code></pre><p><code>grep</code> 命令有一些有趣的选项。</p><p>例如，你可以使用 <code>--count</code> 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。</p><pre class=" language-console"><code class="language-console">$ git grep --count gmtime_rcompat/gmtime.c:4compat/mingw.c:1compat/mingw.h:1date.c:2git-compat-util.h:2</code></pre><p>如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 <code>-p</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git grep -p gmtime_r *.cdate.c=static int match_multi_number(unsigned long num, char c, const char *date, char *end, struct tm *tm)date.c:         if (gmtime_r(&now, &now_tm))date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)date.c:         if (gmtime_r(&time, tm)) {</code></pre><p>在这里我们可以看到在 date.c 文件中有 <code>match_multi_number</code> 和 <code>match_digit</code> 两个函数调用了 <code>gmtime_r</code>。</p><p>你还可以使用 <code>--and</code> 标志来查看复杂的字符串组合，也就是在同一行同时包含多个匹配。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串所在的行。</p><p>这里我们也用到了 <code>--break</code> 和 <code>--heading</code> 选项来使输出更加容易阅读。</p><pre class=" language-console"><code class="language-console">$ git grep --break --heading \    -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0v1.8.0:builtin/index-pack.c62:#define FLAG_LINK (1u<<20)v1.8.0:cache.h73:#define S_IFGITLINK  016000074:#define S_ISGITLINK(m)       (((m) & S_IFMT) == S_IFGITLINK)v1.8.0:environment.c54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKSv1.8.0:strbuf.c326:#define STRBUF_MAXLINK (2*PATH_MAX)v1.8.0:symlinks.c53:#define FL_SYMLINK  (1 << 2)v1.8.0:zlib.c30:/* #define ZLIB_BUF_MAX ((uInt)-1) */31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</code></pre><p>相比于一些常用的搜索命令比如 <code>grep</code> 和 <code>ack</code>，<code>git grep</code> 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。</p><h3 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h3><p>或许你不想知道某一项在 <strong>哪里</strong> ，而是想知道是什么 <strong>时候</strong> 存在或者引入的。 <code>git log</code> 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p><p>例如，如果我们想找到 <code>ZLIB_BUF_MAX</code> 常量是什么时候引入的，我们可以使用 <code>-S</code> 选项来显示新增和删除该字符串的提交。</p><pre class=" language-console"><code class="language-console">$ git log -SZLIB_BUF_MAX --onelinee01503b zlib: allow feeding more than 4GB in one goef49a7a zlib: zlib can only process 4GB at a time</code></pre><p>如果我们查看这些提交的 diff，我们可以看到在 <code>ef49a7a</code> 这个提交引入了常量，并且在 <code>e01503b</code> 这个提交中被修改了。</p><p>如果你希望得到更精确的结果，你可以使用 <code>-G</code> 选项来使用正则表达式搜索。</p><h4 id="行日志搜索"><a href="#行日志搜索" class="headerlink" title="行日志搜索"></a>行日志搜索</h4><p>行日志搜索是另一个相当高级并且有用的日志搜索功能。 这是一个最近新增的不太知名的功能，但却是十分有用。 在 <code>git log</code> 后加上 <code>-L</code> 选项即可调用，它可以展示代码中一行或者一个函数的历史。</p><p>例如，假设我们想查看 <code>zlib.c</code> 文件中<code>git_deflate_bound</code> 函数的每一次变更，我们可以执行 <code>git log -L :git_deflate_bound:zlib.c</code>。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。</p><pre class=" language-console"><code class="language-console">$ git log -L :git_deflate_bound:zlib.ccommit ef49a7a0126d64359c974b4b3b71d7ad42ee3bcaAuthor: Junio C Hamano <gitster@pobox.com>Date:   Fri Jun 10 11:52:15 2011 -0700    zlib: zlib can only process 4GB at a timediff --git a/zlib.c b/zlib.c--- a/zlib.c+++ b/zlib.c@@ -85,5 +130,5 @@-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size) {-       return deflateBound(strm, size);+       return deflateBound(&strm->z, size); }commit 225a6f1068f71723a910e8565db4e252b3ca21faAuthor: Junio C Hamano <gitster@pobox.com>Date:   Fri Jun 10 11:18:17 2011 -0700    zlib: wrap deflateBound() toodiff --git a/zlib.c b/zlib.c--- a/zlib.c+++ b/zlib.c@@ -81,0 +85,5 @@+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)+{+       return deflateBound(strm, size);+}+</code></pre><p>如果 Git 无法计算出如何匹配你代码中的函数或者方法，你可以提供一个正则表达式。 例如，这个命令和上面的是等同的：<code>git log -L &#39;/unsigned long git_deflate_bound/&#39;,/^}/:zlib.c</code>。 你也可以提供单行或者一个范围的行号来获得相同的输出。</p><h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交 - 在将你的工作成果与他人共享之前。</p><p>在本节中，你可以学到如何完成这些非常有用的工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。</p><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p><p>如果，你只是想修改最近一次提交的提交信息，那么很简单：</p><pre class=" language-console"><code class="language-console">$ git commit --amend</code></pre><p>这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。 当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。</p><p>如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行 <code>git add</code> 或 <code>git rm</code> 一个已追踪的文件，随后运行 <code>git commit --amend</code> 拿走当前的暂存区域并使其做为新提交的快照。</p><p>使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基 - 如果已经推送了最后一次提交就不要修正它。</p><h3 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h3><p>为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</p><p>例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父提交作为参数传递给 <code>git rebase -i</code> 命令，即 <code>HEAD~2^</code> 或 <code>HEAD~3</code>。 记住 <code>~3</code> 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：</p><pre class=" language-console"><code class="language-console">$ git rebase -i HEAD~3</code></pre><p>再次记住这是一个变基命令 - 在 <code>HEAD~3..HEAD</code> 范围内的每一个提交都会被重写，无论你是否修改信息。 不要涉及任何已经推送到中央服务器的提交 - 这样做会产生一次变更的两个版本，因而使他人困惑。</p><p>运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：</p><pre class=" language-console"><code class="language-console">pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file# Rebase 710f0f8..a5f4a0d onto 710f0f8## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like "squash", but discard this commit's log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>需要重点注意的是相对于正常使用的 <code>log</code> 命令，这些提交显示的顺序是相反的。 运行一次 <em>log</em> 命令，会看到类似这样的东西：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=format:"%h %s" HEAD~3..HEADa5f4a0d added cat-file310154e updated README formatting and added blamef7f3f6d changed my name a bit</code></pre><p>注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（<code>HEAD~3</code>）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。</p><p>你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：</p><pre class=" language-console"><code class="language-console">edit f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file</code></pre><p>当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：</p><pre class=" language-console"><code class="language-console">$ git rebase -i HEAD~3Stopped at f7f3f6d... changed my name a bitYou can amend the commit now, with       git commit --amendOnce you’re satisfied with your changes, run       git rebase --continue</code></pre><p>这些指令准确地告诉你该做什么。 输入</p><pre class=" language-console"><code class="language-console">$ git commit --amend</code></pre><p>修改提交信息，然后退出编辑器。 然后，运行</p><pre class=" language-console"><code class="language-console">$ git rebase --continue</code></pre><p>这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。</p><h3 id="重新排序提交"><a href="#重新排序提交" class="headerlink" title="重新排序提交"></a>重新排序提交</h3><p>也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：</p><pre class=" language-console"><code class="language-console">pick f7f3f6d changed my name a bitpick 310154e updated README formatting and added blamepick a5f4a0d added cat-file</code></pre><p>改为这样：</p><pre class=" language-console"><code class="language-console">pick 310154e updated README formatting and added blamepick f7f3f6d changed my name a bit</code></pre><p>当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 <code>310154e</code> 然后应用 <code>f7f3f6d</code>，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。</p><h3 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h3><p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：</p><pre class=" language-console"><code class="language-console">## Commands:#  p, pick = use commit#  r, reword = use commit, but edit the commit message#  e, edit = use commit, but stop for amending#  s, squash = use commit, but meld into previous commit#  f, fixup = like "squash", but discard this commit's log message#  x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out</code></pre><p>如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：</p><pre class=" language-console"><code class="language-console">pick f7f3f6d changed my name a bitsquash 310154e updated README formatting and added blamesquash a5f4a0d added cat-file</code></pre><p>当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：</p><pre class=" language-console"><code class="language-console"># This is a combination of 3 commits.# The first commit's message is:changed my name a bit# This is the 2nd commit message:updated README formatting and added blame# This is the 3rd commit message:added cat-file</code></pre><p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。</p><h3 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h3><p>拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 <code>rebase -i</code> 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：</p><pre class=" language-console"><code class="language-console">pick f7f3f6d changed my name a bitedit 310154e updated README formatting and added blamepick a5f4a0d added cat-file</code></pre><p>然后，当脚本将你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（<code>f7f3f6d</code>），应用第二个提交（<code>310154e</code>），然后让你进入命令行。 那里，可以通过 <code>git reset HEAD^</code> 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件未暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 <code>git rebase --continue</code>：</p><pre class=" language-console"><code class="language-console">$ git reset HEAD^$ git add README$ git commit -m 'updated README formatting'$ git add lib/simplegit.rb$ git commit -m 'added blame'$ git rebase --continue</code></pre><p>Git 在脚本中应用最后一次提交（<code>a5f4a0d</code>），历史记录看起来像这样：</p><pre class=" language-console"><code class="language-console">$ git log -4 --pretty=format:"%h %s"1c002dd added cat-file9b29157 added blame35cfb2b updated README formattingf3cc40e changed my name a bit</code></pre><p>再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。</p><h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 <code>filter-branch</code>，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。</p><h4 id="从每一个提交移除一个文件"><a href="#从每一个提交移除一个文件" class="headerlink" title="从每一个提交移除一个文件"></a>从每一个提交移除一个文件</h4><p>这经常发生。 有人粗心地通过 <code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除它。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 <code>filter-branch</code> 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 <code>--tree-filter</code> 选项给 <code>filter-branch</code>：</p><pre class=" language-console"><code class="language-console">$ git filter-branch --tree-filter 'rm -f passwords.txt' HEADRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)Ref 'refs/heads/master' was rewritten</code></pre><p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 <code>git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD</code> 的命令。</p><p>最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 <code>filter-branch</code> 在所有分支上运行，可以给命令传递 <code>--all</code> 选项。</p><h4 id="使一个子目录做为新的根目录"><a href="#使一个子目录做为新的根目录" class="headerlink" title="使一个子目录做为新的根目录"></a>使一个子目录做为新的根目录</h4><p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 <code>trunk</code> 子目录作为每一个提交的新的项目根目录，<code>filter-branch</code> 也可以帮助你那么做：</p><pre class=" language-console"><code class="language-console">$ git filter-branch --subdirectory-filter trunk HEADRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)Ref 'refs/heads/master' was rewritten</code></pre><p>现在新项目根目录是 <code>trunk</code> 子目录了。 Git 会自动移除所有不影响子目录的提交。</p><h4 id="全局修改邮箱地址"><a href="#全局修改邮箱地址" class="headerlink" title="全局修改邮箱地址"></a>全局修改邮箱地址</h4><p>另一个常见的情形是在你开始工作时忘记运行 <code>git config</code> 来设置你的名字与邮箱地址，或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 <code>filter-branch</code> 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 <code>--commit-filter</code>：</p><pre class=" language-console"><code class="language-console">$ git filter-branch --commit-filter '        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];        then                GIT_AUTHOR_NAME="Scott Chacon";                GIT_AUTHOR_EMAIL="schacon@example.com";                git commit-tree "$@";        else                git commit-tree "$@";        fi' HEAD</code></pre><p>这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和，而不仅仅只是那些匹配邮箱地址的提交。</p><h2 id="重置揭密"><a href="#重置揭密" class="headerlink" title="重置揭密"></a>重置揭密</h2><p>在继续了解更专业的工具前，我们先讨论一下 <code>reset</code> 与 <code>checkout</code>。 在你初次遇到的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。</p><h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>理解 <code>reset</code> 和 <code>checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p><p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p><table><thead><tr><th align="left">树</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">HEAD</td><td align="left">上一次提交的快照，下一次提交的父结点</td></tr><tr><td align="left">Index</td><td align="left">预期的下一次提交的快照</td></tr><tr><td align="left">Working Directory</td><td align="left">沙盒</td></tr></tbody></table><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 <strong>你的上一次提交</strong> 的快照。</p><p>其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p HEADtree cfda3bf379e4f8dba8717dee55aab78aef7f4dafauthor Scott Chacon  1301511835 -0700committer Scott Chacon  1301511835 -0700initial commit$ git ls-tree -r HEAD100644 blob a906cb2a4a904a152...   README100644 blob 8f94139338f9404f2...   Rakefile040000 tree 99f1a6d12cb4b6f19...   lib</code></pre><p><code>cat-file</code> 与 <code>ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是你的 <strong>预期的下一次提交</strong>。 我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子。</p><p>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 <code>git commit</code> 将它们转换为树来用作新的提交。</p><pre class=" language-console"><code class="language-console">$ git ls-files -s100644 a906cb2a4a904a152e80877d4088654daad0c859 0    README100644 8f94139338f9404f26296befa88755fc2598c289 0    Rakefile100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0    lib/simplegit.rb</code></pre><p>再说一次，我们在这里又用到了 <code>ls-files</code> 这个幕后的命令，它会显示出索引当前的样子。</p><p>确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。</p><h4 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h4><p>最后，你就有了自己的工作目录。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code>.git</code>文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 <strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p><pre class=" language-console"><code class="language-console">$ tree.├── README├── Rakefile└── lib    └── simplegit.rb1 directory, 3 files</code></pre><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>Git 主要的目的是通过操纵这三棵树来以更加连续的状态记录项目的快照。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-workflow.png" alt="reset workflow"></p><p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 <strong>v1</strong> 版本，将它标记为蓝色。 现在运行 <code>git init</code>，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（<code>master</code> 还不存在）。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex1.png" alt="reset ex1"></p><p>此时，只有工作目录有内容。</p><p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex2.png" alt="reset ex2"></p><p>接着运行 <code>git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex3.png" alt="reset ex3"></p><p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p><p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex4.png" alt="reset ex4"></p><p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex5.png" alt="reset ex5"></p><p>此时，由于索引和 HEAD 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code>来完成提交。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-ex6.png" alt="reset ex6"></p><p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p><p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照，然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</p><h3 id="重置的作用"><a href="#重置的作用" class="headerlink" title="重置的作用"></a>重置的作用</h3><p>在以下情景中观察 <code>reset</code> 命令会更有意义。</p><p>为了演示这些例子，假设我们再次修改了 <code>file.txt</code> 文件并第三次提交它。 现在的历史看起来是这样的：</p><p><img src="https://git-scm.com/book/en/v2/images/reset-start.png" alt="reset start"></p><p>让我们跟着 <code>reset</code> 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。</p><h4 id="第-1-步：移动-HEAD"><a href="#第-1-步：移动-HEAD" class="headerlink" title="第 1 步：移动 HEAD"></a>第 1 步：移动 HEAD</h4><p><code>reset</code> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（<code>checkout</code> 所做的）；<code>reset</code> 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 <code>master</code> 分支（例如，你正在 <code>master</code> 分支上），运行 <code>git reset 9e5e64a</code> 将会使 <code>master</code> 指向 <code>9e5e64a</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-soft.png" alt="reset soft"></p><p>无论你调用了何种形式的带有一个提交的 <code>reset</code>，它首先都会尝试这样做。 使用 <code>reset --soft</code>，它将仅仅停在那儿。</p><p>现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit</code> 命令。 当你在运行 <code>git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 <code>reset</code>回 <code>HEAD~</code>（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend</code> 所要做的事情了（见 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_amend" target="_blank" rel="noopener">修改最后一次提交</a>）。</p><h4 id="第-2-步：更新索引（–mixed）"><a href="#第-2-步：更新索引（–mixed）" class="headerlink" title="第 2 步：更新索引（–mixed）"></a>第 2 步：更新索引（–mixed）</h4><p>注意，如果你现在运行 <code>git status</code> 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。</p><p>接下来，<code>reset</code> 会用 HEAD 指向的当前快照的内容来更新索引。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-mixed.png" alt="reset mixed"></p><p>如果指定 <code>--mixed</code> 选项，<code>reset</code> 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 <code>git reset HEAD~</code>），这就是命令将会停止的地方。</p><p>现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 <code>提交</code>，但还会 <em>取消暂存</em> 所有的东西。 于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。</p><h4 id="第-3-步：更新工作目录（–hard）"><a href="#第-3-步：更新工作目录（–hard）" class="headerlink" title="第 3 步：更新工作目录（–hard）"></a>第 3 步：更新工作目录（–hard）</h4><p><code>reset</code> 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 <code>--hard</code> 选项，它将会继续这一步。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-hard.png" alt="reset hard"></p><p>现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、<code>git add</code> 和 <code>git commit</code> 命令<strong>以及</strong>工作目录中的所有工作。</p><p>必须注意，<code>--hard</code> 标记是 <code>reset</code> 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 <code>reset</code> 调用都可以轻松撤消，但是 <code>--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本，我们可以通过 <code>reflog</code> 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p><ol><li>移动 HEAD 分支的指向 <em>（若指定了 –soft，则到此停止）</em></li><li>使索引看起来像 HEAD <em>（若未指定 –hard，则到此停止）</em></li><li>使工作目录看起来像索引</li></ol><h3 id="通过路径来重置"><a href="#通过路径来重置" class="headerlink" title="通过路径来重置"></a>通过路径来重置</h3><p>前面讲述了 <code>reset</code> 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，<code>reset</code>将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 <em>可以部分更新</em>，所以重置会继续进行第 2、3 步。</p><p>现在，假如我们运行 <code>git reset file.txt</code> （这其实是 <code>git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 <code>--soft</code> 或 <code>--hard</code>），它会：</p><ol><li>移动 HEAD 分支的指向 <em>（已跳过）</em></li><li>让索引看起来像 HEAD <em>（到此处停止）</em></li></ol><p>所以它本质上只是将 <code>file.txt</code> 从 HEAD 复制到索引中。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-path1.png" alt="reset path1"></p><p>它还有 <em>取消暂存文件</em> 的实际效果。 如果我们查看该命令的示意图，然后再想想 <code>git add</code> 所做的事，就会发现它们正好相反。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-path2.png" alt="reset path2"></p><p>这就是为什么 <code>git status</code> 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_unstaging" target="_blank" rel="noopener">取消暂存的文件</a>来了解更多。）</p><p>我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 <code>git reset eb43bf file.txt</code> 的命令即可。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-path3.png" alt="reset path3"></p><p>它其实做了同样的事情，也就是把工作目录中的文件恢复到 <strong>v1</strong> 版本，运行 <code>git add</code> 添加它，然后再将它恢复到 <strong>v3</strong> 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 <code>git commit</code>，它就会记录一条“将该文件恢复到 <strong>v1</strong> 版本”的更改，尽管我们并未在工作目录中真正地再次拥有它。</p><p>还有一点同 <code>git add</code> 一样，就是 <code>reset</code> 命令也可以接受一个 <code>--patch</code> 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交。</p><p>假设你的一系列提交信息中有 “oops.”、“WIP” 和 “forgot this file”， 聪明的你就能使用 <code>reset</code> 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （<a href="https://git-scm.com/book/zh/v2/ch00/r_squashing" target="_blank" rel="noopener">压缩提交</a> 展示了另一种方式，不过在本例中用 <code>reset</code> 更简单。）</p><p>假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-squash-r1.png" alt="reset squash r1"></p><p>那么可以运行 <code>git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的第一个提交）：</p><p><img src="https://git-scm.com/book/en/v2/images/reset-squash-r2.png" alt="reset squash r2"></p><p>然后只需再次运行 <code>git commit</code>：</p><p><img src="https://git-scm.com/book/en/v2/images/reset-squash-r3.png" alt="reset squash r3"></p><p>现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 <code>file-a.txt</code> 的提交，接着第二个提交将 <code>file-a.txt</code> 修改成了 v3 版并增加了 <code>file-b.txt</code>。 包含 v2 版本的文件已经不在历史中了。</p><h3 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h3><p>最后，你大概还想知道 <code>checkout</code> 和 <code>reset</code> 之间的区别。 和 <code>reset</code> 一样，<code>checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p><h4 id="不带路径"><a href="#不带路径" class="headerlink" title="不带路径"></a>不带路径</h4><p>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，不过有两点重要的区别。</p><p>首先不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p><p>第二个重要的区别是如何更新 HEAD。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p><p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 HEAD 指向它）。 如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交。 而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 <code>master</code>。</p><p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 则移动 HEAD 自身。</p><p><img src="https://git-scm.com/book/en/v2/images/reset-checkout.png" alt="reset checkout"></p><h4 id="带路径"><a href="#带路径" class="headerlink" title="带路径"></a>带路径</h4><p>运行 <code>checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code>reset</code> 一样不会移动 HEAD。 它就像 <code>git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。</p><p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望你现在熟悉并理解了 <code>reset</code> 命令，不过关于它和 <code>checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p><p>下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而`‘HEAD’’ 则表示只移动了 HEAD 自身。 特别注意 <em>WD Safe?</em> 一列 - 如果它标记为 <strong>NO</strong>，那么运行该命令之前请考虑一下。</p><table><thead><tr><th align="left"></th><th align="left">HEAD</th><th align="left">Index</th><th align="left">Workdir</th><th align="left">WD Safe?</th></tr></thead><tbody><tr><td align="left"><strong>Commit Level</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>reset --soft [commit]</code></td><td align="left">REF</td><td align="left">NO</td><td align="left">NO</td><td align="left">YES</td></tr><tr><td align="left"><code>reset [commit]</code></td><td align="left">REF</td><td align="left">YES</td><td align="left">NO</td><td align="left">YES</td></tr><tr><td align="left"><code>reset --hard [commit]</code></td><td align="left">REF</td><td align="left">YES</td><td align="left">YES</td><td align="left"><strong>NO</strong></td></tr><tr><td align="left"><code>checkout [commit]</code></td><td align="left">HEAD</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left"><strong>File Level</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>reset (commit) [file]</code></td><td align="left">NO</td><td align="left">YES</td><td align="left">NO</td><td align="left">YES</td></tr><tr><td align="left"><code>checkout (commit) [file]</code></td><td align="left">NO</td><td align="left">YES</td><td align="left">YES</td><td align="left"><strong>NO</strong></td></tr></tbody></table><h2 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h2><p>在 Git 中合并是相当容易的。 因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支，经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。</p><p>然而，有时也会有棘手的冲突。 不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。 Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。 因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。</p><p>在本节中，我们将会仔细查看那些问题是什么以及 Git 给了我们什么工具来帮助我们处理这些更难办的情形。我们也会了解你可以做的不同的、非标准类型的合并，也会看到如何后退到合并之前。</p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_merge_conflicts" target="_blank" rel="noopener">遇到冲突时的分支合并</a> 介绍了解决合并冲突的一些基础知识，对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。</p><p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。 如果你有正在做的工作，要么提交到一个临时分支要么储藏它。 这使你可以撤消在这里尝试做的 <strong>任何事情</strong> 。 如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。</p><p>让我们通过一个非常简单的例子来了解一下。 我们有一个超级简单的打印 <em>hello world</em> 的 Ruby 文件。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#! /usr/bin/env ruby</span><span class="token keyword">def</span> hello  puts <span class="token string">'hello world'</span><span class="token keyword">end</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在我们的仓库中，创建一个名为 <code>whitespace</code> 的新分支并将所有 Unix 换行符修改为 DOS 换行符，实质上虽然改变了文件的每一行，但改变的都只是空白字符。 然后我们修改行 “hello world” 为 “hello mundo”。</p><pre class=" language-console"><code class="language-console">$ git checkout -b whitespaceSwitched to a new branch 'whitespace'$ unix2dos hello.rbunix2dos: converting file hello.rb to DOS format ...$ git commit -am 'converted hello.rb to DOS'[whitespace 3270f76] converted hello.rb to DOS 1 file changed, 7 insertions(+), 7 deletions(-)$ vim hello.rb$ git diff -bdiff --git a/hello.rb b/hello.rbindex ac51efd..e85207e 100755--- a/hello.rb+++ b/hello.rb@@ -1,7 +1,7 @@ #! /usr/bin/env ruby def hello-  puts 'hello world'+  puts 'hello mundo'^M end hello()$ git commit -am 'hello mundo change'[whitespace 6d338d2] hello mundo change 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>现在我们切换回我们的 <code>master</code> 分支并为函数增加一些注释。</p><pre class=" language-console"><code class="language-console">$ git checkout masterSwitched to branch 'master'$ vim hello.rb$ git diffdiff --git a/hello.rb b/hello.rbindex ac51efd..36c06c8 100755--- a/hello.rb+++ b/hello.rb@@ -1,5 +1,6 @@ #! /usr/bin/env ruby+# prints out a greeting def hello   puts 'hello world' end$ git commit -am 'document the function'[master bec6336] document the function 1 file changed, 1 insertion(+)</code></pre><p>现在我们尝试合并入我们的 <code>whitespace</code> 分支，因为修改了空白字符，所以合并会出现冲突。</p><pre class=" language-console"><code class="language-console">$ git merge whitespaceAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbAutomatic merge failed; fix conflicts and then commit the result.</code></pre><h4 id="中断一次合并"><a href="#中断一次合并" class="headerlink" title="中断一次合并"></a>中断一次合并</h4><p>我们现在有几个选项。 首先，让我们介绍如何摆脱这个情况。 你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。</p><pre class=" language-console"><code class="language-console">$ git status -sb## masterUU hello.rb$ git merge --abort$ git status -sb## master</code></pre><p><code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p><p>如果因为某些原因你发现自己处在一个混乱的状态中然后只是想要重来一次，也可以运行 <code>git reset --hard HEAD</code> 回到之前的状态或其他你想要恢复的状态。 请牢记这会将清除工作目录中的所有内容，所以确保你不需要保存这里的任意改动。</p><h4 id="忽略空白"><a href="#忽略空白" class="headerlink" title="忽略空白"></a>忽略空白</h4><p>在这个特定的例子中，冲突与空白有关。 我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易，因为每一行都被移除而在另一边每一行又被加回来了。 默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。</p><p>默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用 <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。 第一个选项忽略任意 <strong>数量</strong> 的已有空白的修改，第二个选项忽略所有空白修改。</p><pre class=" language-console"><code class="language-console">$ git merge -Xignore-space-change whitespaceAuto-merging hello.rbMerge made by the 'recursive' strategy. hello.rb | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre><p>因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。</p><p>如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。</p><h4 id="手动文件再合并"><a href="#手动文件再合并" class="headerlink" title="手动文件再合并"></a>手动文件再合并</h4><p>虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。 例如，假设 Git 无法处理空白修改因此我们需要手动处理。</p><p>我们真正想要做的是对将要合并入的文件在真正合并前运行 <code>dos2unix</code> 程序。 所以如果那样的话，我们该如何做？</p><p>首先，我们进入到了合并冲突状态。 然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。 然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。</p><p>获得这三个文件版本实际上相当容易。 Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。 Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 <code>MERGE_HEAD</code>，即你将要合并入的版本（“theirs”）。</p><p>通过 <code>git show</code> 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。</p><pre class=" language-console"><code class="language-console">$ git show :1:hello.rb > hello.common.rb$ git show :2:hello.rb > hello.ours.rb$ git show :3:hello.rb > hello.theirs.rb</code></pre><p>如果你想要更专业一点，也可以使用 <code>ls-files -u</code> 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。</p><pre class=" language-console"><code class="language-console">$ git ls-files -u100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1    hello.rb100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2    hello.rb100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3    hello.rb</code></pre><p><code>:1:hello.rb</code> 只是查找那个 blob 对象 SHA-1 值的简写。</p><p>既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。</p><pre class=" language-console"><code class="language-console">$ dos2unix hello.theirs.rbdos2unix: converting file hello.theirs.rb to Unix format ...$ git merge-file -p \    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb$ git diff -bdiff --cc hello.rbindex 36c06c8,e85207e..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,8 -1,7 +1,8 @@@  #! /usr/bin/env ruby +# prints out a greeting  def hello-   puts 'hello world'+   puts 'hello mundo'  end  hello()</code></pre><p>在这时我们已经漂亮地合并了那个文件。 实际上，这比使用 <code>ignore-space-change</code> 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。 在使用 <code>ignore-space-change</code> 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。</p><p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code> 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。</p><p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code></p><pre class=" language-console"><code class="language-console">$ git diff --ours* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex 36c06c8..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -2,7 +2,7 @@ # prints out a greeting def hello-  puts 'hello world'+  puts 'hello mundo' end hello()</code></pre><p>这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。</p><p>如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code>。 在本例及后续的例子中，我们会使用 <code>-b</code> 来去除空白，因为我们将它与 Git 中的，而不是我们清理过的 <code>hello.theirs.rb</code> 文件比较。</p><pre class=" language-console"><code class="language-console">$ git diff --theirs -b* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex e85207e..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -1,5 +1,6 @@ #! /usr/bin/env ruby+# prints out a greeting def hello   puts 'hello mundo' end</code></pre><p>最终，你可以通过 <code>git diff --base</code> 来查看文件在两边是如何改动的。</p><pre class=" language-console"><code class="language-console">$ git diff --base -b* Unmerged path hello.rbdiff --git a/hello.rb b/hello.rbindex ac51efd..44d0a25 100755--- a/hello.rb+++ b/hello.rb@@ -1,7 +1,8 @@ #! /usr/bin/env ruby+# prints out a greeting def hello-  puts 'hello world'+  puts 'hello mundo' end hello()</code></pre><p>在这时我们可以使用 <code>git clean</code> 命令来清理我们为手动合并而创建但不再有用的额外文件。</p><pre class=" language-console"><code class="language-console">$ git clean -fRemoving hello.common.rbRemoving hello.ours.rbRemoving hello.theirs.rb</code></pre><h4 id="检出冲突"><a href="#检出冲突" class="headerlink" title="检出冲突"></a>检出冲突</h4><p>也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。</p><p>让我们来稍微改动下例子。 对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。</p><pre class=" language-console"><code class="language-console">$ git log --graph --oneline --decorate --all* f1270f7 (HEAD, master) update README* 9af9d3b add a README* 694971d update phrase to hola world| * e3eb223 (mundo) add more tests| * 7cff591 add testing script| * c3ffff1 changed text to hello mundo|/* b7dcc89 initial hello world code</code></pre><p>现在有只在 <code>master</code> 分支上的三次单独提交，还有其他三次提交在 <code>mundo</code> 分支上。 如果我们尝试将 <code>mundo</code> 分支合并入 <code>master</code> 分支，我们得到一个冲突。</p><pre class=" language-console"><code class="language-console">$ git merge mundoAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>我们想要看一下合并冲突是什么。 如果我们打开这个文件，我们将会看到类似下面的内容：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#! /usr/bin/env ruby</span><span class="token keyword">def</span> hello<span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token constant">HEAD</span>  puts <span class="token string">'hola world'</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">=</span>  puts <span class="token string">'hello mundo'</span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span> mundo<span class="token keyword">end</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。</p><p>让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。 应该如何修复这个冲突看起来或许并不明显。 这时你需要更多上下文。</p><p>一个很有用的工具是带 <code>--conflict</code> 选项的 <code>git checkout</code>。 这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。</p><p>可以传递给 <code>--conflict</code> 参数 <code>diff3</code> 或 <code>merge</code>（默认选项）。 如果传给它 <code>diff3</code>，Git 会使用一个略微不同版本的冲突标记：不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。</p><pre class=" language-console"><code class="language-console">$ git checkout --conflict=diff3 hello.rb</code></pre><p>一旦我们运行它，文件看起来会像下面这样：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#! /usr/bin/env ruby</span><span class="token keyword">def</span> hello<span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span> ours  puts <span class="token string">'hola world'</span><span class="token operator">||</span><span class="token operator">||</span><span class="token operator">||</span><span class="token operator">|</span> base  puts <span class="token string">'hello world'</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">=</span>  puts <span class="token string">'hello mundo'</span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span> theirs<span class="token keyword">end</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>如果你喜欢这种格式，可以通过设置 <code>merge.conflictstyle</code> 选项为 <code>diff3</code> 来做为以后合并冲突的默认选项。</p><pre class=" language-console"><code class="language-console">$ git config --global merge.conflictstyle diff3</code></pre><p><code>git checkout</code> 命令也可以使用 <code>--ours</code> 和 <code>--theirs</code> 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。</p><p>当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件 - 可以做一次合并然后在提交前检出一边或另一边的特定文件。</p><h4 id="合并日志"><a href="#合并日志" class="headerlink" title="合并日志"></a>合并日志</h4><p>另一个解决合并冲突有用的工具是 <code>git log</code>。 这可以帮助你得到那些对冲突有影响的上下文。 回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。</p><p>为了得到此次合并中包含的每一个分支的所有独立提交的列表，我们可以使用之前在 <a href="https://git-scm.com/book/zh/v2/ch00/r_triple_dot" target="_blank" rel="noopener">三点</a> 学习的 “三点” 语法。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --left-right HEAD...MERGE_HEAD< f1270f7 update README< 9af9d3b add a README< 694971d update phrase to hola world> e3eb223 add more tests> 7cff591 add testing script> c3ffff1 changed text to hello mundo</code></pre><p>这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。</p><p>我们可以通过更加特定的上下文来进一步简化这个列表。 如果我们添加 <code>--merge</code> 选项到 <code>git log</code> 中，它会只显示任何一边接触了合并冲突文件的提交。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --left-right --merge< 694971d update phrase to hola world> c3ffff1 changed text to hello mundo</code></pre><p>如果你运行命令时用 <code>-p</code> 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 <strong>非常</strong> 有用。</p><h4 id="组合式差异格式"><a href="#组合式差异格式" class="headerlink" title="组合式差异格式"></a>组合式差异格式</h4><p>因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 <code>git diff</code> 时，只会得到现在还在冲突状态的区别。 当需要查看你还需要解决哪些冲突时这很有用。</p><p>在合并冲突后直接运行的 <code>git diff</code> 会给你一个相当独特的输出格式。</p><pre class=" language-console"><code class="language-console">$ git diffdiff --cc hello.rbindex 0399cd5,59727f0..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,11 @@@  #! /usr/bin/env ruby  def hello++<<<<<<< HEAD +  puts 'hola world'++=======+   puts 'hello mundo'++>>>>>>> mundo  end  hello()</code></pre><p>这种叫作 “组合式差异” 的格式会在每一行给你两列数据。 第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），第二列显示 “theirs” 分支与工作目录的拷贝区别。</p><p>所以在上面的例子中可以看到 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 与 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 行在工作拷贝中但是并不在合并的任意一边中。 这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。</p><p>如果我们解决冲突再次运行 <code>git diff</code>，我们将会看到同样的事情，但是它有一点帮助。</p><pre class=" language-console"><code class="language-console">$ vim hello.rb$ git diffdiff --cc hello.rbindex 0399cd5,59727f0..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@  #! /usr/bin/env ruby  def hello-   puts 'hola world' -  puts 'hello mundo'++  puts 'hola mundo'  end  hello()</code></pre><p>这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中，最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。 在提交解决方案前这对审核很有用。</p><p>也可以在合并后通过 <code>git log</code> 来获取相同信息，并查看冲突是如何解决的。 如果你对一个合并提交运行 <code>git show</code> 命令 Git 将会输出这种格式，或者你也可以在 <code>git log -p</code>（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 <code>--cc</code> 选项。</p><pre class=" language-console"><code class="language-console">$ git log --cc -p -1commit 14f41939956d80b9e17bb8721354c33f8d5b5a79Merge: f1270f7 e3eb223Author: Scott Chacon <schacon@gmail.com>Date:   Fri Sep 19 18:14:49 2014 +0200    Merge branch 'mundo'    Conflicts:        hello.rbdiff --cc hello.rbindex 0399cd5,59727f0..e1d0799--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@  #! /usr/bin/env ruby  def hello-   puts 'hola world' -  puts 'hello mundo'++  puts 'hola mundo'  end  hello()</code></pre><h3 id="撤消合并"><a href="#撤消合并" class="headerlink" title="撤消合并"></a>撤消合并</h3><p>虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。 使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。</p><p>合并提交并无不同。 假设现在在一个特性分支上工作，不小心将其合并到 <code>master</code> 中，现在提交历史看起来是这样：</p><p><img src="https://git-scm.com/book/en/v2/images/undomerge-start.png" alt="意外的合并提交"></p><p>Figure 138. 意外的合并提交</p><p>有两种方法来解决这个问题，这取决于你想要的结果是什么。</p><h4 id="修复引用"><a href="#修复引用" class="headerlink" title="修复引用"></a>修复引用</h4><p>如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 <code>git merge</code> 后运行 <code>git reset --hard HEAD~</code>，这会重置分支指向所以它们看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/undomerge-reset.png" alt="在 `git reset --hard HEAD~` 之后的历史"></p><p>Figure 139. 在 <code>git reset --hard HEAD~</code> 之后的历史</p><p>我们之前在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset" target="_blank" rel="noopener">重置揭密</a> 已经介绍了 <code>reset</code>，所以现在指出这里发生了什么并不是很困难。 让我们快速复习下：<code>reset --hard</code> 通常会经历三步：</p><ol><li>移动 HEAD 指向的分支。 在本例中，我们想要移动 <code>master</code> 到合并提交（<code>C6</code>）之前所在的位置。</li><li>使索引看起来像 HEAD。</li><li>使工作目录看起来像索引。</li></ol><p>这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_peril" target="_blank" rel="noopener">变基的风险</a> 来了解更多可能发生的事情；用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 <code>reset</code>。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。</p><h4 id="还原提交"><a href="#还原提交" class="headerlink" title="还原提交"></a>还原提交</h4><p>如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为 “还原”，在这个特定的场景下，你可以像这样调用它：</p><pre class=" language-console"><code class="language-console">$ git revert -m 1 HEAD[master b1d8379] Revert "Merge branch 'topic'"</code></pre><p><code>-m 1</code> 标记指出 “mainline” 需要被保留下来的父结点。 当你引入一个合并到 <code>HEAD</code>（<code>git merge topic</code>），新提交有两个父结点：第一个是 <code>HEAD</code>（<code>C6</code>），第二个是将要合并入分支的最新提交（<code>C4</code>）。 在本例中，我们想要撤消所有由父结点 #2（<code>C4</code>）合并引入的修改，同时保留从父结点 #1（<code>C4</code>）开始的所有内容。</p><p>有还原提交的历史看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/undomerge-revert.png" alt="在 `git revert -m 1` 后的历史"></p><p>Figure 140. 在 <code>git revert -m 1</code> 后的历史</p><p>新的提交 <code>^M</code> 与 <code>C6</code> 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 <code>HEAD</code> 的历史中。 如果你尝试再次合并 <code>topic</code> 到 <code>master</code> Git 会感到困惑：</p><pre class=" language-console"><code class="language-console">$ git merge topicAlready up-to-date.</code></pre><p><code>topic</code> 中并没有东西不能从 <code>master</code> 中追踪到达。 更糟的是，如果你在 <code>topic</code> 中增加工作然后再次合并，Git 只会引入被还原的合并 <em>之后</em> 的修改。</p><p><img src="https://git-scm.com/book/en/v2/images/undomerge-revert2.png" alt="含有坏掉合并的历史"></p><p>Figure 141. 含有坏掉合并的历史</p><p>解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，<strong>然后</strong> 创建一个新的合并提交：</p><pre class=" language-console"><code class="language-console">$ git revert ^M[master 09f0126] Revert "Revert "Merge branch 'topic'""$ git merge topic</code></pre><p><img src="https://git-scm.com/book/en/v2/images/undomerge-revert3.png" alt="在重新合并一个还原合并后的历史"></p><p>Figure 142. 在重新合并一个还原合并后的历史</p><p>在本例中，<code>M</code> 与 <code>^M</code> 抵消了。 <code>^^M</code> 事实上合并入了 <code>C3</code> 与 <code>C4</code> 的修改，<code>C8</code> 合并了 <code>C7</code> 的修改，所以现在 <code>topic</code> 已经完全被合并了。</p><h3 id="其他类型的合并"><a href="#其他类型的合并" class="headerlink" title="其他类型的合并"></a>其他类型的合并</h3><p>到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。 然而还有其他方式来合并两个分支到一起。 让我们来快速介绍其中的几个。</p><h4 id="我们的或他们的偏好"><a href="#我们的或他们的偏好" class="headerlink" title="我们的或他们的偏好"></a>我们的或他们的偏好</h4><p>首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。 我们之前已经看到传递给 <code>-X</code> 的 <code>ignore-all-space</code> 与 <code>ignore-space-change</code> 选项，但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。</p><p>默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。 如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动合并冲突，你可以传递给 <code>merge</code> 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。</p><p>如果 Git 看到这个，它并不会增加冲突标记。 任何可以合并的区别，它会直接合并。 任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。</p><p>如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。</p><pre class=" language-console"><code class="language-console">$ git merge mundoAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbResolved 'hello.rb' using previous resolution.Automatic merge failed; fix conflicts and then commit the result.</code></pre><p>然而如果我们运行时增加 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数就不会有冲突。</p><pre class=" language-console"><code class="language-console">$ git merge -Xours mundoAuto-merging hello.rbMerge made by the 'recursive' strategy. hello.rb | 2 +- test.sh  | 2 ++ 2 files changed, 3 insertions(+), 1 deletion(-) create mode 100644 test.sh</code></pre><p>在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。 然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。</p><p>这个选项也可以传递给我们之前看到的 <code>git merge-file</code> 命令，通过运行类似 <code>git merge-file --ours</code> 的命令来合并单个文件。</p><p>如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改，有一个更严格的选项，它是 “ours” 合并 <em>策略*。 这与 “ours” recursive 合并 *选项</em> 不同。</p><p>这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来。</p><pre class=" language-console"><code class="language-console">$ git merge -s ours mundoMerge made by the 'ours' strategy.$ git diff HEAD HEAD~$</code></pre><p>你可以看到合并后与合并前我们的分支并没有任何区别。</p><p>当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 例如，假设你有一个分叉的 <code>release</code> 分支并且在上面做了一些你想要在未来某个时候合并回 <code>master</code> 的工作。 与此同时 <code>master</code> 分支上的某些 bugfix 需要向后移植回 <code>release</code> 分支。 你可以合并 bugfix 分支进入 <code>release</code> 分支同时也 <code>merge -s ours</code> 合并进入你的 <code>master</code> 分支（即使那个修复已经在那儿了）这样当你之后再次合并 <code>release</code> 分支时，就不会有来自 bugfix 的冲突。</p><h4 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h4><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。 当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。</p><p>我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。</p><p>首先，我们将 Rack 应用添加到你的项目里。 我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。</p><pre class=" language-console"><code class="language-console">$ git remote add rack_remote https://github.com/rack/rack$ git fetch rack_remotewarning: no common commitsremote: Counting objects: 3184, done.remote: Compressing objects: 100% (1465/1465), done.remote: Total 3184 (delta 1952), reused 2770 (delta 1675)Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.Resolving deltas: 100% (1952/1952), done.From https://github.com/rack/rack * [new branch]      build      -> rack_remote/build * [new branch]      master     -> rack_remote/master * [new branch]      rack-0.4   -> rack_remote/rack-0.4 * [new branch]      rack-0.9   -> rack_remote/rack-0.9$ git checkout -b rack_branch rack_remote/masterBranch rack_branch set up to track remote branch refs/remotes/rack_remote/master.Switched to a new branch "rack_branch"</code></pre><p>现在在我们的 <code>rack_branch</code> 分支里就有 Rack 项目的根目录，而我们的项目则在 <code>master</code> 分支里。 如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：</p><pre class=" language-console"><code class="language-console">$ lsAUTHORS         KNOWN-ISSUES   Rakefile      contrib         libCOPYING         README         bin           example         test$ git checkout masterSwitched to branch "master"$ lsREADME</code></pre><p>这个是一个比较奇怪的概念。 并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。</p><p>在这个例子中，我们希望将 Rack 项目拉到 <code>master</code> 项目中作为一个子目录。 我们可以在 Git 中执行 <code>git read-tree</code> 来实现。 你可以在 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 中查看更多 <code>read-tree</code> 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。 先切回你的 <code>master</code> 分支，将 <code>rack_back</code> 分支拉取到我们项目的 <code>master</code> 分支中的 <code>rack</code> 子目录。</p><pre class=" language-console"><code class="language-console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre><p>当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。 有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。 所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。</p><pre class=" language-console"><code class="language-console">$ git checkout rack_branch$ git pull</code></pre><p>接着，我们可以将这些变更合并回我们的 <code>master</code> 分支。 使用 <code>--squash</code> 选项和使用 <code>-Xsubtree</code> 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。 （递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）</p><pre class=" language-console"><code class="language-console">$ git checkout master$ git merge --squash -s recursive -Xsubtree=rack rack_branchSquash commit -- not updating HEADAutomatic merge went well; stopped before committing as requested</code></pre><p>Rack 项目中所有的改动都被合并了，等待被提交到本地。 你也可以用相反的方法——在 master 分支上的 <code>rack</code> 子目录中做改动然后将它们合并入你的 <code>rack_branch</code> 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。</p><p>这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块（有关子模块的内容我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_submodules" target="_blank" rel="noopener">子模块</a> 中介绍）。 我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。 某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。 然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。</p><p>另外一个有点奇怪的地方是，当你想查看 <code>rack</code> 子目录和 <code>rack_branch</code> 分支的差异——来确定你是否需要合并它们——你不能使用普通的 <code>diff</code> 命令。 取而代之的是，你必须使用 <code>git diff-tree</code> 来和你的目标分支做比较：</p><pre class=" language-console"><code class="language-console">$ git diff-tree -p rack_branch</code></pre><p>或者，将你的 <code>rack</code> 子目和最近一次从服务器上抓取的 <code>master</code> 分支进行比较，你可以运行：</p><pre class=" language-console"><code class="language-console">$ git diff-tree -p rack_remote/master</code></pre><h2 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h2><p><code>git rerere</code> 功能是一个隐藏的功能。 正如它的名字 “reuse recorded resolution” 所指，它允许你让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它。</p><p>有几种情形下这个功能会非常有用。 在文档中提到的一个例子是如果你想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。 将 <code>rerere</code> 功能打开后偶尔合并，解决冲突，然后返回到合并前。 如果你持续这样做，那么最终的合并会很容易，因为 <code>rerere</code> 可以为你自动做所有的事情。</p><p>可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。 或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并 - 你可能并不想要再次解决相同的冲突。</p><p>另一个情形是当你偶尔将一堆正在改进的特性分支合并到一个可测试的头时，就像 Git 项目自身经常做的。 如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个特性分支后重做合并，而不用再次重新解决所有的冲突。</p><p>为了启用 <code>rerere</code> 功能，仅仅需要运行这个配置选项：</p><pre class=" language-console"><code class="language-console">$ git config --global rerere.enabled true</code></pre><p>也通过在特定的仓库中创建 <code>.git/rr-cache</code> 目录来开启它，但是设置选项更干净并且可以应用到全局。</p><p>现在我们看一个简单的例子，类似之前的那个。 假设有一个像这样的文件：</p><pre class=" language-console"><code class="language-console">#! /usr/bin/env rubydef hello  puts 'hello world'end</code></pre><p>在一个分支中修改单词 “hello” 为 “hola”，然后在另一个分支中修改 “world” 为 “mundo”，就像之前一样。</p><p><img src="https://git-scm.com/book/en/v2/images/rerere1.png" alt="rerere1"></p><p>当合并两个分支到一起时，我们将会得到一个合并冲突：</p><pre class=" language-console"><code class="language-console">$ git merge i18n-worldAuto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbRecorded preimage for 'hello.rb'Automatic merge failed; fix conflicts and then commit the result.</code></pre><p>你会注意到那个新行 <code>Recorded preimage for FILE</code>。 除此之外它应该看起来就像一个普通的合并冲突。 在这个时候，<code>rerere</code> 可以告诉我们几件事。 和往常一样，在这个时候你可以运行 <code>git status</code> 来查看所有冲突的内容：</p><pre class=" language-console"><code class="language-console">$ git status# On branch master# Unmerged paths:#   (use "git reset HEAD <file>..." to unstage)#   (use "git add <file>..." to mark resolution)##    both modified:      hello.rb#</code></pre><p>然而，<code>git rerere</code> 也会通过 <code>git rerere status</code> 告诉你它记录的合并前状态。</p><pre class=" language-console"><code class="language-console">$ git rerere statushello.rb</code></pre><p>并且 <code>git rerere diff</code> 将会显示解决方案的当前状态 - 开始解决前与解决后的样子。</p><pre class=" language-console"><code class="language-console">$ git rerere diff--- a/hello.rb+++ b/hello.rb@@ -1,11 +1,11 @@ #! /usr/bin/env ruby def hello-<<<<<<<-  puts 'hello mundo'-=======+<<<<<<< HEAD   puts 'hola world'->>>>>>>+=======+  puts 'hello mundo'+>>>>>>> i18n-world end</code></pre><p>同样（这并不是真的与 <code>rerere</code> 有关系），可以使用 <code>ls-files -u</code> 来查看冲突文件的之前、左边与右边版本：</p><pre class=" language-console"><code class="language-console">$ git ls-files -u100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1    hello.rb100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2    hello.rb100644 54336ba847c3758ab604876419607e9443848474 3    hello.rb</code></pre><p>现在可以通过改为 <code>puts &#39;hola mundo&#39;</code> 来解决它，可以再次运行 <code>rerere diff</code> 命令来查看 rerere 将会记住的内容：</p><pre class=" language-console"><code class="language-console">$ git rerere diff--- a/hello.rb+++ b/hello.rb@@ -1,11 +1,7 @@ #! /usr/bin/env ruby def hello-<<<<<<<-  puts 'hello mundo'-=======-  puts 'hola world'->>>>>>>+  puts 'hola mundo' end</code></pre><p>所以从本质上说，当 Git 看到一个 <code>hello.rb</code> 文件的一个块冲突中有 “hello mundo” 在一边与 “hola world” 在另一边，它会将其解决为 “hola mundo”。</p><p>现在我们可以将它标记为已解决并提交它：</p><pre class=" language-console"><code class="language-console">$ git add hello.rb$ git commitRecorded resolution for 'hello.rb'.[master 68e16e5] Merge branch 'i18n'</code></pre><p>可以看到它 “Recorded resolution for FILE”。</p><p><img src="https://git-scm.com/book/en/v2/images/rerere2.png" alt="rerere2"></p><p>现在，让我们撤消那个合并然后将它变基到 master 分支顶部来替代它。可以通过使用之前在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset" target="_blank" rel="noopener">重置揭密</a> 看到的 <code>reset</code> 来回滚分支。</p><pre class=" language-console"><code class="language-console">$ git reset --hard HEAD^HEAD is now at ad63f15 i18n the hello</code></pre><p>我们的合并被撤消了。 现在让我们变基特性分支。</p><pre class=" language-console"><code class="language-console">$ git checkout i18n-worldSwitched to branch 'i18n-world'$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: i18n one wordUsing index info to reconstruct a base tree...Falling back to patching base and 3-way merge...Auto-merging hello.rbCONFLICT (content): Merge conflict in hello.rbResolved 'hello.rb' using previous resolution.Failed to merge in the changes.Patch failed at 0001 i18n one word</code></pre><p>现在，正像我们期望的一样，得到了相同的合并冲突，但是看一下 <code>Resolved FILE using previous resolution</code> 这行。 如果我们看这个文件，会发现它已经被解决了，而且在它里面没有合并冲突标记。</p><pre class=" language-console"><code class="language-console">$ cat hello.rb#! /usr/bin/env rubydef hello  puts 'hola mundo'end</code></pre><p>同样，<code>git diff</code> 将会显示出它是如何自动地重新解决的：</p><pre class=" language-console"><code class="language-console">$ git diffdiff --cc hello.rbindex a440db6,54336ba..0000000--- a/hello.rb+++ b/hello.rb@@@ -1,7 -1,7 +1,7 @@@  #! /usr/bin/env ruby  def hello-   puts 'hola world' -  puts 'hello mundo'++  puts 'hola mundo'  end</code></pre><p><img src="https://git-scm.com/book/en/v2/images/rerere3.png" alt="rerere3"></p><p>也可以通过 <code>checkout</code> 命令重新恢复到冲突时候的文件状态：</p><pre class=" language-console"><code class="language-console">$ git checkout --conflict=merge hello.rb$ cat hello.rb#! /usr/bin/env rubydef hello<<<<<<< ours  puts 'hola world'=======  puts 'hello mundo'>>>>>>> theirsend</code></pre><p>我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_advanced_merging" target="_blank" rel="noopener">高级合并</a> 中看到这个的一个例子。 然而现在，让我们通过运行 <code>rerere</code> 来重新解决它：</p><pre class=" language-console"><code class="language-console">$ git rerereResolved 'hello.rb' using previous resolution.$ cat hello.rb#! /usr/bin/env rubydef hello  puts 'hola mundo'end</code></pre><p>我们通过 <code>rerere</code> 缓存的解决方案来自动重新解决了文件冲突。 现在可以添加并继续变基来完成它。</p><pre class=" language-console"><code class="language-console">$ git add hello.rb$ git rebase --continueApplying: i18n one word</code></pre><p>所以，如果做了很多次重新合并，或者想要一个特性分支始终与你的 master 分支保持最新但却不想要一大堆合并，或者经常变基，打开 <code>rerere</code> 功能可以帮助你的生活变得更美好。</p><h2 id="使用-Git-调试"><a href="#使用-Git-调试" class="headerlink" title="使用 Git 调试"></a>使用 Git 调试</h2><p>Git 也提供了两个工具来辅助你调试项目中的问题。 由于 Git 被设计成适用于几乎所有类型的项目，这些工具是比较通用的，但它们可以在出现问题的时候帮助你找到 bug 或者错误。</p><h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。 它展示了文件中每一行最后一次修改的提交。 所以，如果你在代码中看到一个有问题的方法，你可以使用 <code>git blame</code> 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。 这个例子使用 <code>-L</code> 选项来限制输出范围在第12至22行：</p><pre class=" language-console"><code class="language-console">$ git blame -L 12,22 simplegit.rb^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #{tree}")^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #{tree}")9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #{path}")42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</code></pre><p>请注意，第一个字段是最后一次修改该行的提交的部分 SHA-1 值。 接下来两个字段的值是从提交中提取出来的——作者的名字以及提交的时间——所以你就可以很轻易地找到是谁在什么时候修改了那一行。 接下来就是行号和文件内容。 注意一下 <code>^4832fe2</code> 这个提交的那些行，这些指的是这个文件第一次提交的那些行。 这个提交是这个文件第一次加入到这个项目时的提交，并且这些行从未被修改过。 这会带来小小的困惑，因为你已经至少看到三种 Git 使用 <code>^</code> 来修饰一个提交的 SHA-1 值的不同含义，但这里确实就是这个意思。</p><p>另一件比较酷的事情是 Git 不会显式地记录文件的重命名。 它会记录快照，然后在事后尝试计算出重命名的动作。 这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。 如果你在 <code>git blame</code> 后面加上一个 <code>-C</code>，Git 会分析你正在标注的文件，并且尝试找出文件中从别的地方复制过来的代码片段的原始出处。 比如，你将 <code>GITServerHandler.m</code> 这个文件拆分为数个文件，其中一个文件是 <code>GITPackUpload.m</code>。 对 <code>GITPackUpload.m</code> 执行带 <code>-C</code> 参数的blame命令，你就可以看到代码块的原始出处：</p><pre class=" language-console"><code class="language-console">$ git blame -C -L 141,153 GITPackUpload.mf344f58d GITServerHandler.m (Scott 2009-01-04 141)f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromCf344f58d GITServerHandler.m (Scott 2009-01-04 143) {70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMIad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [gad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMIad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</code></pre><p>这个功能很有用。 通常来说，你会认为复制代码过来的那个提交是最原始的提交，因为那是你第一次在这个文件中修改了这几行。 但 Git 会告诉你，你第一次写这几行代码的那个提交才是原始提交，即使这是在另外一个文件里写的。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。 如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 <code>git bisect</code> 来帮助查找。 <code>bisect</code> 命令会对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题。</p><p>假设你刚刚在线上环境部署了你的代码，接着收到一些 bug 反馈，但这些 bug 在你之前的开发环境里没有出现过，这让你百思不得其解。 你重新查看了你的代码，发现这个问题是可以被重现的，但是你不知道哪里出了问题。 你可以用二分法来找到这个问题。 首先执行 <code>git bisect start</code> 来启动，接着执行 <code>git bisect bad</code> 来告诉系统当前你所在的提交是有问题的。 然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用 <code>git bisect good [good_commit]</code>：</p><pre class=" language-console"><code class="language-console">$ git bisect start$ git bisect bad$ git bisect good v1.0Bisecting: 6 revisions left to test after this[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</code></pre><p>Git 发现在你标记为正常的提交(v1.0)和当前的错误版本之间有大约12次提交，于是 Git 检出中间的那个提交。 现在你可以执行测试，看看在这个提交下问题是不是还是存在。 如果还存在，说明问题是在这个提交之前引入的；如果问题不存在，说明问题是在这个提交之后引入的。 假设测试结果是没有问题的，你可以通过 <code>git bisect good</code> 来告诉 Git，然后继续寻找。</p><pre class=" language-console"><code class="language-console">$ git bisect goodBisecting: 3 revisions left to test after this[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</code></pre><p>现在你在另一个提交上了，这个提交是刚刚那个测试通过的提交和有问题的提交的中点。 你再一次执行测试，发现这个提交下是有问题的，因此你可以通过 <code>git bisect bad</code> 告诉 Git：</p><pre class=" language-console"><code class="language-console">$ git bisect badBisecting: 1 revisions left to test after this[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</code></pre><p>这个提交是正常的，现在 Git 拥有的信息已经可以确定引入问题的位置在哪里。 它会告诉你第一个错误提交的 SHA-1 值并显示一些提交说明，以及哪些文件在那次提交里修改过，这样你可以找出引入 bug 的根源：</p><pre class=" language-console"><code class="language-console">$ git bisect goodb047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commitcommit b047b02ea83310a70fd603dc8cd7a6cd13d15c04Author: PJ Hyett <pjhyett@example.com>Date:   Tue Jan 27 14:48:32 2009 -0800    secure this thing:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</code></pre><p>当你完成这些操作之后，你应该执行 <code>git bisect reset</code> 重置你的 HEAD 指针到最开始的位置，否则你会停留在一个很奇怪的状态：</p><pre class=" language-console"><code class="language-console">$ git bisect reset</code></pre><p>这是一个可以帮助你在几分钟内从数百个提交中找到 bug 的强大工具。 事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 <code>git bisect</code> 自动化这些操作。 首先，你设定好项目正常以及不正常所在提交的二分查找范围。 你可以通过 <code>bisect start</code> 命令的参数来设定这两个提交，第一个参数是项目不正常的提交，第二个参数是项目正常的提交：</p><pre class=" language-console"><code class="language-console">$ git bisect start HEAD v1.0$ git bisect run test-error.sh</code></pre><p>Git 会自动在每个被检出的提交里执行 <code>test-error.sh</code> 直到找到第一个项目不正常的提交。 你也可以执行 <code>make</code> 或者 <code>make tests</code> 或者其他东西来进行自动化测试。</p><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p><p>我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。</p><p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p><h3 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h3><p>我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。</p><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 <code>git submodule add</code>命令后面加上想要跟踪的项目 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p><pre class=" language-console"><code class="language-console">$ git submodule add https://github.com/chaconinc/DbConnectorCloning into 'DbConnector'...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.</code></pre><p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p><p>如果这时运行 <code>git status</code>，你会注意到几件事。</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   .gitmodules    new file:   DbConnector</code></pre><p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p><pre class=" language-console"><code class="language-console">$ cat .gitmodules[submodule "DbConnector"]    path = DbConnector    url = https://github.com/chaconinc/DbConnector</code></pre><p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p><table><thead><tr><th>Note</th><th>由于 .gitmodules 文件中的 URL 是人们首先尝试克隆/拉取的地方，因此请尽可能确保你使用的URL 大家都能访问。 例如，若你要使用的推送 URL 与他人的拉取 URL 不同，那么请使用他人能访问到的 URL。 你也可以根据自己的需要，通过在本地执行 <code>git config submodule.DbConnector.url &lt;私有URL&gt;</code> 来覆盖这个选项的值。 如果可行的话，一个相对路径会很有帮助。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在 <code>git status</code> 输出中列出的另一个是项目文件夹记录。 如果你运行 <code>git diff</code>，会看到类似下面的信息：</p><pre class=" language-console"><code class="language-console">$ git diff --cached DbConnectordiff --git a/DbConnector b/DbConnectornew file mode 160000index 0000000..c3f01dc--- /dev/null+++ b/DbConnector@@ -0,0 +1 @@+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</code></pre><p>虽然 <code>DbConnector</code> 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作该仓库中的一个特殊提交。</p><p>如果你想看到更漂亮的差异输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 选项。</p><pre class=" language-console"><code class="language-console">$ git diff --cached --submodulediff --git a/.gitmodules b/.gitmodulesnew file mode 100644index 0000000..71fc376--- /dev/null+++ b/.gitmodules@@ -0,0 +1,3 @@+[submodule "DbConnector"]+       path = DbConnector+       url = https://github.com/chaconinc/DbConnectorSubmodule DbConnector 0000000...c3f01dc (new submodule)</code></pre><p>当你提交时，会看到类似下面的信息：</p><pre class=" language-console"><code class="language-console">$ git commit -am 'added DbConnector module'[master fb9093c] added DbConnector module 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 DbConnector</code></pre><p>注意 DbConnector 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p><h3 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h3><p>接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/chaconinc/MainProjectCloning into 'MainProject'...remote: Counting objects: 14, done.remote: Compressing objects: 100% (13/13), done.remote: Total 14 (delta 1), reused 13 (delta 0)Unpacking objects: 100% (14/14), done.Checking connectivity... done.$ cd MainProject$ ls -latotal 16drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodulesdrwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefiledrwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includesdrwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scriptsdrwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src$ cd DbConnector/$ ls$</code></pre><p>其中有 <code>DbConnector</code> 目录，不过是空的。 你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><pre class=" language-console"><code class="language-console">$ git submodule initSubmodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'$ git submodule updateCloning into 'DbConnector'...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre><p>现在 <code>DbConnector</code> 子目录是处在和之前提交时相同的状态了。</p><p>不过还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recursive</code> 选项，它就会自动初始化并更新仓库中的每一个子模块。</p><pre class=" language-console"><code class="language-console">$ git clone --recursive https://github.com/chaconinc/MainProjectCloning into 'MainProject'...remote: Counting objects: 14, done.remote: Compressing objects: 100% (13/13), done.remote: Total 14 (delta 1), reused 13 (delta 0)Unpacking objects: 100% (14/14), done.Checking connectivity... done.Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'Cloning into 'DbConnector'...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre><h3 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h3><p>现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。</p><h4 id="拉取上游修改"><a href="#拉取上游修改" class="headerlink" title="拉取上游修改"></a>拉取上游修改</h4><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。</p><p>如果想要在子模块中查看新工作，可以进入到目录中运行 <code>git fetch</code> 与 <code>git merge</code>，合并上游分支来更新本地代码。</p><pre class=" language-console"><code class="language-console">$ git fetchFrom https://github.com/chaconinc/DbConnector   c3f01dc..d0354fc  master     -> origin/master$ git merge origin/masterUpdating c3f01dc..d0354fcFast-forward scripts/connect.sh | 1 + src/db.c           | 1 + 2 files changed, 2 insertions(+)</code></pre><p>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 <code>git diff</code> 时都输入 <code>--submodle</code>，那么可以将 <code>diff.submodule</code> 设置为 “log” 来将其作为默认行为。</p><pre class=" language-console"><code class="language-console">$ git config --global diff.submodule log$ git diffSubmodule DbConnector c3f01dc..d0354fc:  > more efficient db routine  > better connection routine</code></pre><p>如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。</p><p>如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 <code>git submodule update --remote</code>，Git 将会进入子模块然后抓取并更新。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remote DbConnectorremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector   3f19983..d0354fc  master     -> origin/masterSubmodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'</code></pre><p>此命令默认会假定你想要更新并检出子模块仓库的 <code>master</code> 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 <code>.gitmodules</code> 文件中设置（这样其他人也可以跟踪它），也可以只在本地的 <code>.git/config</code> 文件中设置。 让我们在 <code>.gitmodules</code> 文件中设置它：</p><pre class=" language-console"><code class="language-console">$ git config -f .gitmodules submodule.DbConnector.branch stable$ git submodule update --remoteremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector   27cf5d3..c87d55d  stable -> origin/stableSubmodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</code></pre><p>如果不用 <code>-f .gitmodules</code> 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。</p><p>这时我们运行 <code>git status</code>，Git 会显示子模块中有 “新提交”。</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)  modified:   .gitmodules  modified:   DbConnector (new commits)no changes added to commit (use "git add" and/or "git commit -a")</code></pre><p>如果你设置了配置选项 <code>status.submodulesummary</code>，Git 也会显示你的子模块的更改摘要：</p><pre class=" language-console"><code class="language-console">$ git config status.submodulesummary 1$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   .gitmodules    modified:   DbConnector (new commits)Submodules changed but not updated:* DbConnector c3f01dc...c87d55d (4):  > catch non-null terminated lines</code></pre><p>这时如果运行 <code>git diff</code>，可以看到我们修改了 .gitmodules 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。</p><pre class=" language-console"><code class="language-console">$ git diffdiff --git a/.gitmodules b/.gitmodulesindex 6fc0b3d..fd1cc29 100644--- a/.gitmodules+++ b/.gitmodules@@ -1,3 +1,4 @@ [submodule "DbConnector"]        path = DbConnector        url = https://github.com/chaconinc/DbConnector+       branch = stable Submodule DbConnector c3f01dc..c87d55d:  > catch non-null terminated lines  > more robust error handling  > more efficient db routine  > better connection routine</code></pre><p>这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 <code>git log -p</code> 查看这个信息。</p><pre class=" language-console"><code class="language-console">$ git log -p --submodulecommit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7aeAuthor: Scott Chacon <schacon@gmail.com>Date:   Wed Sep 17 16:37:02 2014 +0200    updating DbConnector for bug fixesdiff --git a/.gitmodules b/.gitmodulesindex 6fc0b3d..fd1cc29 100644--- a/.gitmodules+++ b/.gitmodules@@ -1,3 +1,4 @@ [submodule "DbConnector"]        path = DbConnector        url = https://github.com/chaconinc/DbConnector+       branch = stableSubmodule DbConnector c3f01dc..c87d55d:  > catch non-null terminated lines  > more robust error handling  > more efficient db routine  > better connection routine</code></pre><p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新<strong>所有</strong>子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。</p><h4 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h4><p>你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。</p><p>现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。</p><p>到目前为止，当我们运行 <code>git submodule update</code> 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。 这意味着没有本地工作分支（例如 “master”）跟踪改动。 所以你做的任何改动都不会被跟踪。</p><p>为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 <code>git submodule update --remote</code>来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。</p><p>首先，让我们进入子模块目录然后检出一个分支。</p><pre class=" language-console"><code class="language-console">$ git checkout stableSwitched to branch 'stable'</code></pre><p>然后尝试用 “merge” 选项。 为了手动指定它，我们只需给 <code>update</code> 添加 <code>--merge</code> 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remote --mergeremote: Counting objects: 4, done.remote: Compressing objects: 100% (2/2), done.remote: Total 4 (delta 2), reused 4 (delta 2)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector   c87d55d..92c7337  stable     -> origin/stableUpdating c87d55d..92c7337Fast-forward src/main.c | 1 + 1 file changed, 1 insertion(+)Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'</code></pre><p>如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 <code>stable</code> 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。</p><pre class=" language-console"><code class="language-console">$ cd DbConnector/$ vim src/db.c$ git commit -am 'unicode support'[stable f906e16] unicode support 1 file changed, 1 insertion(+)</code></pre><p>如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remote --rebaseFirst, rewinding head to replay your work on top of it...Applying: unicode supportSubmodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre><p>如果你忘记 <code>--rebase</code> 或 <code>--merge</code>，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remoteSubmodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre><p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 <code>origin/stable</code>（或任何一个你想要的远程分支）就行了。</p><p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remoteremote: Counting objects: 4, done.remote: Compressing objects: 100% (3/3), done.remote: Total 4 (delta 0), reused 4 (delta 0)Unpacking objects: 100% (4/4), done.From https://github.com/chaconinc/DbConnector   5d60ef9..c75e92a  stable     -> origin/stableerror: Your local changes to the following files would be overwritten by checkout:    scripts/setup.shPlease, commit your changes or stash them before you can switch branches.AbortingUnable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre><p>如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。</p><pre class=" language-console"><code class="language-console">$ git submodule update --remote --mergeAuto-merging scripts/setup.shCONFLICT (content): Merge conflict in scripts/setup.shRecorded preimage for 'scripts/setup.sh'Automatic merge failed; fix conflicts and then commit the result.Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre><p>你可以进入子模块目录中然后就像平时那样修复冲突。</p><h4 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h4><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p><pre class=" language-console"><code class="language-console">$ git diffSubmodule DbConnector c87d55d..82d2ad3:  > Merge from origin/stable  > updated setup script  > unicode support  > remove unnecessary method  > add new option for conn pooling</code></pre><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。</p><p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 <code>git push</code> 命令接受可以设置为 “check” 或 “on-demand” 的 <code>--recurse-submodules</code> 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 <code>push</code> 操作失败。</p><pre class=" language-console"><code class="language-console">$ git push --recurse-submodules=checkThe following submodule paths contain changes that cannot be found on any remote:  DbConnectorPlease try    git push --recurse-submodules=on-demandor cd to the path and use    git pushto push them to a remote.</code></pre><p>如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。</p><p>另一个选项是使用 “on-demand” 值，它会尝试为你这样做。</p><pre class=" language-console"><code class="language-console">$ git push --recurse-submodules=on-demandPushing submodule 'DbConnector'Counting objects: 9, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.Total 9 (delta 3), reused 0 (delta 0)To https://github.com/chaconinc/DbConnector   c75e92a..82d2ad3  stable -> stableCounting objects: 2, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.Total 2 (delta 1), reused 0 (delta 0)To https://github.com/chaconinc/MainProject   3d6d338..9a377d1  master -> master</code></pre><p>如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。</p><h4 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h4><p>如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。</p><p>如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。</p><p>不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：</p><pre class=" language-console"><code class="language-console">$ git pullremote: Counting objects: 2, done.remote: Compressing objects: 100% (1/1), done.remote: Total 2 (delta 1), reused 2 (delta 1)Unpacking objects: 100% (2/2), done.From https://github.com/chaconinc/MainProject   9a377d1..eb974f8  master     -> origin/masterFetching submodule DbConnectorwarning: Failed to merge submodule DbConnector (merge following commits not found)Auto-merging DbConnectorCONFLICT (submodule): Merge conflict in DbConnectorAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found”（未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。</p><p>为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 <code>git diff</code>，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。</p><pre class=" language-console"><code class="language-console">$ git diffdiff --cc DbConnectorindex eb41d76,c771610..0000000--- a/DbConnector+++ b/DbConnector</code></pre><p>所以，在本例中，<code>eb41d76</code> 是我们的子模块中<strong>大家共有</strong>的提交，而 <code>c771610</code> 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 <code>eb41d76</code> 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。</p><p>来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。</p><p>所以，我们将会进入子模块目录，基于 <code>git diff</code> 的第二个 SHA 创建一个分支然后手动合并。</p><pre class=" language-console"><code class="language-console">$ cd DbConnector$ git rev-parse HEADeb41d764bccf88be77aced643c13a7fa86714135$ git branch try-merge c771610(DbConnector) $ git merge try-mergeAuto-merging src/main.cCONFLICT (content): Merge conflict in src/main.cRecorded preimage for 'src/main.c'Automatic merge failed; fix conflicts and then commit the result.</code></pre><p>我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。</p><pre class=" language-console"><code class="language-console">$ vim src/main.c (1)$ git add src/main.c$ git commit -am 'merged our changes'Recorded resolution for 'src/main.c'.[master 9fd905e] merged our changes$ cd .. (2)$ git diff (3)diff --cc DbConnectorindex eb41d76,c771610..0000000--- a/DbConnector+++ b/DbConnector@@@ -1,1 -1,1 +1,1 @@@- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a$ git add DbConnector (4)$ git commit -m "Merge Tom's Changes" (5)[master 10d2c60] Merge Tom's Changes</code></pre><ol><li>首先解决冲突</li><li>然后返回到主项目目录中</li><li>再次检查 SHA-1 值</li><li>解决冲突的子模块记录</li><li>提交我们的合并</li></ol><p>这可能会让你有点儿困惑，但它确实不难。</p><p>有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的<strong>两边</strong>的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。</p><p>这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 <strong>这样</strong> 做。 它让人困惑是因为<strong>谁能想到它会尝试这样做？</strong></p><p>如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：</p><pre class=" language-console"><code class="language-console">$ git merge origin/masterwarning: Failed to merge submodule DbConnector (not fast-forward)Found a possible merge resolution for the submodule: 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changesIf this is correct simply add it to the index for exampleby using:  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"which will accept this suggestion.Auto-merging DbConnectorCONFLICT (submodule): Merge conflict in DbConnectorAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>它会建议你更新索引，就像你运行了 <code>git add</code> 那样，这样会清除冲突然后提交。不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。</p><pre class=" language-console"><code class="language-console">$ cd DbConnector/$ git merge 9fd905eUpdating eb41d76..9fd905eFast-forward$ cd ..$ git add DbConnector$ git commit -am 'Fast forwarded to a common submodule child'</code></pre><p>这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。</p><h3 id="子模块技巧"><a href="#子模块技巧" class="headerlink" title="子模块技巧"></a>子模块技巧</h3><p>你可以做几件事情来让用子模块工作轻松一点儿。</p><h4 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h4><p>有一个 <code>foreach</code> 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p><p>例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。</p><pre class=" language-console"><code class="language-console">$ git submodule foreach 'git stash'Entering 'CryptoLibrary'No local changes to saveEntering 'DbConnector'Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stableHEAD is now at 82d2ad3 Merge from origin/stable</code></pre><p>然后我们可以创建一个新分支，并将所有子模块都切换过去。</p><pre class=" language-console"><code class="language-console">$ git submodule foreach 'git checkout -b featureA'Entering 'CryptoLibrary'Switched to a new branch 'featureA'Entering 'DbConnector'Switched to a new branch 'featureA'</code></pre><p>你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。</p><pre class=" language-console"><code class="language-console">$ git diff; git submodule foreach 'git diff'Submodule DbConnector contains modified contentdiff --git a/src/main.c b/src/main.cindex 210f1ae..1f0acdc 100644--- a/src/main.c+++ b/src/main.c@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)      commit_pager_choice();+     url = url_decode(url_orig);+      /* build alias_argv */      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));      alias_argv[0] = alias_string + 1;Entering 'DbConnector'diff --git a/src/db.c b/src/db.cindex 1aaefb6..5297645 100644--- a/src/db.c+++ b/src/db.c@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)        return url_decode_internal(&url, len, NULL, &out, 0); }+char *url_decode(const char *url)+{+       return url_decode_mem(url, strlen(url));+}+ char *url_decode_parameter_name(const char **query) {        struct strbuf out = STRBUF_INIT;</code></pre><p>在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。</p><h4 id="有用的别名"><a href="#有用的别名" class="headerlink" title="有用的别名"></a>有用的别名</h4><p>你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_aliases" target="_blank" rel="noopener">Git 别名</a> 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。</p><pre class=" language-console"><code class="language-console">$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"$ git config alias.spush 'push --recurse-submodules=on-demand'$ git config alias.supdate 'submodule update --remote --merge'</code></pre><p>这样当你想要更新子模块时可以简单地运行 <code>git supdate</code>，或 <code>git spush</code> 检查子模块依赖后推送。</p><h3 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h3><p>然而使用子模块还是有一些小问题。</p><p>例如在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p><pre class=" language-console"><code class="language-console">$ git checkout -b add-cryptoSwitched to a new branch 'add-crypto'$ git submodule add https://github.com/chaconinc/CryptoLibraryCloning into 'CryptoLibrary'......$ git commit -am 'adding crypto library'[add-crypto 4445836] adding crypto library 2 files changed, 4 insertions(+) create mode 160000 CryptoLibrary$ git checkout masterwarning: unable to rmdir CryptoLibrary: Directory not emptySwitched to branch 'master'Your branch is up-to-date with 'origin/master'.$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Untracked files:  (use "git add <file>..." to include in what will be committed)    CryptoLibrary/nothing added to commit but untracked files present (use "git add" to track)</code></pre><p>移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 <code>submodule update --init</code> 来重新建立和填充。</p><pre class=" language-console"><code class="language-console">$ git clean -fdxRemoving CryptoLibrary/$ git checkout add-cryptoSwitched to branch 'add-crypto'$ ls CryptoLibrary/$ git submodule update --initSubmodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'$ ls CryptoLibrary/Makefile    includes    scripts        src</code></pre><p>再说一遍，这真的不难，只是会让人有点儿困惑。</p><p>另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 <code>submodule add</code>，Git 会朝你大喊：</p><pre class=" language-console"><code class="language-console">$ rm -Rf CryptoLibrary/$ git submodule add https://github.com/chaconinc/CryptoLibrary'CryptoLibrary' already exists in the index</code></pre><p>你必须要先取消暂存 <code>CryptoLibrary</code> 目录。 然后才可以添加子模块：</p><pre class=" language-console"><code class="language-console">$ git rm -r CryptoLibrary$ git submodule add https://github.com/chaconinc/CryptoLibraryCloning into 'CryptoLibrary'...remote: Counting objects: 11, done.remote: Compressing objects: 100% (10/10), done.remote: Total 11 (delta 0), reused 11 (delta 0)Unpacking objects: 100% (11/11), done.Checking connectivity... done.</code></pre><p>现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时 - 你会得到这个错误：</p><pre class=" language-console"><code class="language-console">$ git checkout mastererror: The following untracked working tree files would be overwritten by checkout:  CryptoLibrary/Makefile  CryptoLibrary/includes/crypto.h  ...Please move or remove them before you can switch branches.Aborting</code></pre><p>你可以通过 <code>checkout -f</code> 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。</p><pre class=" language-console"><code class="language-console">$ git checkout -f masterwarning: unable to rmdir CryptoLibrary: Directory not emptySwitched to branch 'master'</code></pre><p>当你切换回来之后，因为某些原因你得到了一个空的 <code>CryptoLibrary</code> 目录，并且 <code>git submodule update</code> 也无法修复它。 你需要进入到子模块目录中运行 <code>git checkout .</code> 来找回所有的文件。 你也可以通过 <code>submodule foreach</code> 脚本来为多个子模块运行它。</p><p>要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 <code>.git</code> 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。</p><p>拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。</p><p>Git 可以将它的数据 “打包” 到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人，却不希望通过 <code>format-patch</code> 的方式传输 40 个提交。</p><p>这些情况下 <code>git bundle</code> 就会很有用。 <code>bundle</code> 命令会将 <code>git push</code> 命令所传输的所有内容打包成一个二进制文件，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><p>来看看一个简单的例子。 假设你有一个包含两个提交的仓库：</p><pre class=" language-console"><code class="language-console">$ git logcommit 9a466c572fe88b195efd356c3f2bbeccdb504102Author: Scott Chacon <schacon@gmail.com>Date:   Wed Mar 10 07:34:10 2010 -0800    second commitcommit b1ec3248f39900d2a406049d762aa68e9641be25Author: Scott Chacon <schacon@gmail.com>Date:   Wed Mar 10 07:34:01 2010 -0800    first commit</code></pre><p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 <code>git bundle create</code> 命令来打包。</p><pre class=" language-console"><code class="language-console">$ git bundle create repo.bundle HEAD masterCounting objects: 6, done.Delta compression using up to 2 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (6/6), 441 bytes, done.Total 6 (delta 0), reused 0 (delta 0)</code></pre><p>然后你就会有一个名为 <code>repo.bundle</code> 的文件，该文件包含了所有重建该仓库 <code>master</code> 分支所需的数据。 在使用 <code>bundle</code> 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</p><p>你可以将这个 <code>repo.bundle</code> 文件通过邮件或者U盘传给别人。</p><p>另一方面，假设别人传给你一个 <code>repo.bundle</code> 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。</p><pre class=" language-console"><code class="language-console">$ git clone repo.bundle repoInitialized empty Git repository in /private/tmp/bundle/repo/.git/$ cd repo$ git log --oneline9a466c5 second commitb1ec324 first commit</code></pre><p>如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 <code>-b master</code> 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。</p><p>现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。</p><pre class=" language-console"><code class="language-console">$ git log --oneline71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo9a466c5 second commitb1ec324 first commit</code></pre><p>首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。</p><p>为了实现这个目标，你需要计算出差别。 就像我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_ranges" target="_blank" rel="noopener">提交区间</a> 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 <code>origin/master..master</code> 或者 <code>master ^origin/master</code> 之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 <code>log</code> 命令来测试。</p><pre class=" language-console"><code class="language-console">$ git log --oneline master ^origin/master71b84da last commit - second repoc99cf5b fourth commit - second repo7011d3d third commit - second repo</code></pre><p>这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 <code>git bundle create</code>命令，加上我们想用的文件名，以及要打包的提交区间。</p><pre class=" language-console"><code class="language-console">$ git bundle create commits.bundle master ^9a466c5Counting objects: 11, done.Delta compression using up to 2 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (9/9), 775 bytes, done.Total 9 (delta 0), reused 0 (delta 0)</code></pre><p>现在在我们的目录下会有一个 <code>commits.bundle</code> 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。</p><p>当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 <code>bundle verify</code> 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</p><pre class=" language-console"><code class="language-console">$ git bundle verify ../commits.bundleThe bundle contains 1 ref71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/masterThe bundle requires these 1 ref9a466c572fe88b195efd356c3f2bbeccdb504102 second commit../commits.bundle is okay</code></pre><p>如果打包工具仅仅把最后两个提交打包，而不是三个，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 <code>verify</code> 的输出类似：</p><pre class=" language-console"><code class="language-console">$ git bundle verify ../commits-bad.bundleerror: Repository lacks these prerequisite commits:error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</code></pre><p>而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：</p><pre class=" language-console"><code class="language-console">$ git bundle list-heads ../commits.bundle71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master</code></pre><p><code>verify</code> 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 <code>fetch</code> 或者 <code>pull</code> 命令从包中导入提交。 这里我们要从包中取出 <code>master</code> 分支到我们仓库中的 <em>other-master</em> 分支：</p><pre class=" language-console"><code class="language-console">$ git fetch ../commits.bundle master:other-masterFrom ../commits.bundle * [new branch]      master     -> other-master</code></pre><p>可以看到我们已经将提交导入到 <em>other-master</em> 分支，以及在这期间我们自己在 <em>master</em> 分支上的提交。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --decorate --graph --all* 8255d41 (HEAD, master) third commit - first repo| * 71b84da (other-master) last commit - second repo| * c99cf5b fourth commit - second repo| * 7011d3d third commit - second repo|/* 9a466c5 second commit* b1ec324 first commit</code></pre><p>因此，当你在没有合适的网络或者可共享仓库的情况下，<code>git bundle</code> 很适合用于共享或者网络类型的操作。</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>Git 对象是不可改变的，但它提供一种有趣的方式来用其他对象假装替换数据库中的 Git 对象。</p><p><code>replace</code> 命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。 在你用一个不同的提交替换历史中的一个提交时，这会非常有用。</p><p>例如，你有一个大型的代码历史并想把自己的仓库分成一个短的历史和一个更大更长久的历史，短历史供新的开发者使用，后者给喜欢数据挖掘的人使用。 你可以通过用新仓库中最早的提交 <code>replace</code> 老仓库中最新的提交来连接历史，这种方式可以把一条历史移植到其他历史上。 这意味着你不用在新历史中真正替换每一个提交（因为历史来源会影响 SHA 的值），你可以加入他们。</p><p>让我们来试试吧。 首先获取一个已经存在的仓库，并将其分成两个仓库，一个是最近的仓库，一个是历史版本的仓库，然后我们将看到如何在不更改仓库 SHA 值的情况下通过 <code>replace</code> 命令来合并他们。</p><p>我们将使用一个拥有 5 个提交的简单仓库：</p><pre class=" language-console"><code class="language-console">$ git log --onelineef989d8 fifth commitc6e1e95 fourth commit9c68fdc third commit945704c second commitc1822cf first commit</code></pre><p>我们想将其分成拆分成两条历史。 第一个到第四个提交的作为第一个历史版本。 第四、第五个提交的作为最近的第二个历史版本。</p><p><img src="https://git-scm.com/book/en/v2/images/replace1.png" alt="replace1"></p><p>创建历史版本的历史很容易，我们可以只将一个历史中的分支推送到一个新的远程仓库的 master 分支。</p><pre class=" language-console"><code class="language-console">$ git branch history c6e1e95$ git log --oneline --decorateef989d8 (HEAD, master) fifth commitc6e1e95 (history) fourth commit9c68fdc third commit945704c second commitc1822cf first commit</code></pre><p><img src="https://git-scm.com/book/en/v2/images/replace2.png" alt="replace2"></p><p>现在我们可以把这个新的 <code>history</code> 分支推送到我们新仓库的 <code>master</code> 分支：</p><pre class=" language-console"><code class="language-console">$ git remote add project-history https://github.com/schacon/project-history$ git push project-history history:masterCounting objects: 12, done.Delta compression using up to 2 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (12/12), 907 bytes, done.Total 12 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (12/12), done.To git@github.com:schacon/project-history.git * [new branch]      history -> master</code></pre><p>这样一来，我们的历史版本就发布了。 稍难的部分则是删减我们最近的历史来让它变得更小。 我们需要一个重叠以便于用一个相等的提交来替换另一个提交，这样一来，我们将截断到第四、五个提交。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --decorateef989d8 (HEAD, master) fifth commitc6e1e95 (history) fourth commit9c68fdc third commit945704c second commitc1822cf first commit</code></pre><p>在这种情况下，创建一个能够指导扩展历史的基础提交是很有用的。 这样一来，如果其他的开发者想要修改第一次提交或者其他操作时就知道要做些什么，因此，接下来我们要做的是用命令创建一个最初的提交对象，然后将剩下的提交（第四、第五个提交）变基到它的上面。</p><p>为了这么做，我们需要选择一个点去拆分，对于我们而言是第三个提交（SHA 是 <code>9c68fdc</code>）。因此我们的提交将基于此提交树。我们可以使用 <code>commit-tree</code> 命令来创建基础提交，这样我们就有了一个树，并返回一个全新的、无父节点的 SHA 提交对象。</p><pre class=" language-console"><code class="language-console">$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}622e88e9cbfbacfb75b5279245b9fb38dfea10cf</code></pre><table><thead><tr><th>Note</th><th><code>commit-tree</code> 命令属于底层指令。有许多指令并非直接使用，而是被 <strong>其他的</strong> Git 命令用来做更小一些的工作。有时当我们做一些像这样的奇怪事情时，它们允许我们做一些不适用于日常使用但真正底层的东西。更多关于底层命令的内容请参见 <a href="https://git-scm.com/book/zh/v2/ch00/r_plumbing_porcelain" target="_blank" rel="noopener">底层命令和高层命令</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="https://git-scm.com/book/en/v2/images/replace3.png" alt="replace3"></p><p>现在我们已经有一个基础提交了，我们可以通过 <code>git rebase --onto</code> 命令来将剩余的历史变基到基础提交之上。<code>--onto</code> 参数是刚才 <code>commit-tree</code> 命令返回的 SHA 值，变基点会成为第三个提交（我们想留下的第一个提交的父提交，<code>9c68fdc</code>）：</p><pre class=" language-console"><code class="language-console">$ git rebase --onto 622e88 9c68fdcFirst, rewinding head to replay your work on top of it...Applying: fourth commitApplying: fifth commit</code></pre><p><img src="https://git-scm.com/book/en/v2/images/replace4.png" alt="replace4"></p><p>我们已经用基础提交重写了最近的历史，基础提交包括如何重新组成整个历史的说明。 我们可以将新历史推送到新项目中，当其他人克隆这个仓库时，他们仅能看到最近两次提交以及一个包含上述说明的基础提交。</p><p>现在我们将以想获得整个历史的人的身份来初次克隆这个项目。 在克隆这个截断后的仓库后为了得到历史数据，需要添加第二个远程的历史版本库并对其做获取操作：</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/schacon/project$ cd project$ git log --oneline mastere146b5f fifth commit81a708d fourth commit622e88e get history from blah blah blah$ git remote add project-history https://github.com/schacon/project-history$ git fetch project-historyFrom https://github.com/schacon/project-history * [new branch]      master     -> project-history/master</code></pre><p>现在，协作者在 <code>master</code> 分支中拥有他们最近的提交并且在 <code>project-history/master</code> 分支中拥有过去的提交。</p><pre class=" language-console"><code class="language-console">$ git log --oneline mastere146b5f fifth commit81a708d fourth commit622e88e get history from blah blah blah$ git log --oneline project-history/masterc6e1e95 fourth commit9c68fdc third commit945704c second commitc1822cf first commit</code></pre><p>为了合并它们，你可以使用 <code>git replace</code> 命令加上你想替换的提交信息来进行替换。 这样一来，我们就可以将 master 分支中的第四个提交替换为 <code>project-history/master</code> 分支中的“第四个”提交。</p><pre class=" language-console"><code class="language-console">$ git replace 81a708d c6e1e95</code></pre><p>现在，查看 <code>master</code> 分支中的历史信息，显示如下：</p><pre class=" language-console"><code class="language-console">$ git log --oneline mastere146b5f fifth commit81a708d fourth commit9c68fdc third commit945704c second commitc1822cf first commit</code></pre><p>很酷，是不是？不用改变上游的 SHA-1 我们就能用一个提交来替换历史中的所有不同的提交，并且所有的工具（<code>bisect</code>，<code>blame</code> 等）也都奏效。</p><p><img src="https://git-scm.com/book/en/v2/images/replace5.png" alt="replace5"></p><p>有趣的是，即使是使用了 <code>c6e1e95</code> 提交数据来进行替换，它的 SHA-1 仍显示为 <code>81a708d</code>。 即使你运行了 <code>cat-file</code> 命令，它仍会显示你替换的数据：</p><pre class=" language-console"><code class="language-console">$ git cat-file -p 81a708dtree 7bc544cf438903b65ca9104a1e30345eee6c083dparent 9c68fdceee073230f19ebb8b5e7fc71b479c0252author Scott Chacon <schacon@gmail.com> 1268712581 -0700committer Scott Chacon <schacon@gmail.com> 1268712581 -0700fourth commit</code></pre><p>请记住，<code>81a708d</code> 真正的父提交是 <code>622e882</code> 占位提交，而非呈现的 <code>9c68fdce</code> 提交。</p><p>另一个有趣的事情是数据将会以以下引用显示：</p><pre class=" language-console"><code class="language-console">$ git for-each-refe146b5f14e79d4935160c0e83fb9ebe526b8da0d commit    refs/heads/masterc6e1e95051d41771a649f3145423f8809d1a74d4 commit    refs/remotes/history/mastere146b5f14e79d4935160c0e83fb9ebe526b8da0d commit    refs/remotes/origin/HEADe146b5f14e79d4935160c0e83fb9ebe526b8da0d commit    refs/remotes/origin/masterc6e1e95051d41771a649f3145423f8809d1a74d4 commit    refs/replace/81a708dd0e167a3f691541c7a6463343bc457040</code></pre><p>这意味着我们可以轻而易举的和其他人分享替换，因为我们可以将替换推送到服务器中并且其他人可以轻松地下载。 也许在历史移植情况下不是很有用（既然每个人都乐意下载最新版本和历史版本，为何还要拆分他们呢？），但在其他情况下仍然很有用。</p><h2 id="凭证存储"><a href="#凭证存储" class="headerlink" title="凭证存储"></a>凭证存储</h2><p>如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。 然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。 这在使用双重认证的情况下会更麻烦，因为你需要输入一个随机生成并且毫无规律的 token 作为密码。</p><p>幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：</p><ul><li>默认所有都不缓存。 每一次连接都会询问你的用户名和密码。</li><li>“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。</li><li>“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。</li><li>如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。</li><li>如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在 <a href="https://gitcredentialstore.codeplex.com/" target="_blank" rel="noopener">https://gitcredentialstore.codeplex.com</a> 下载。</li></ul><p>你可以设置 Git 的配置来选择上述的一种方式</p><pre class=" language-console"><code class="language-console">$ git config --global credential.helper cache</code></pre><p>部分辅助工具有一些选项。 “store” 模式可以接受一个 <code>--file &lt;path&gt;</code> 参数，可以自定义存放密码的文件路径（默认是 <code>~/.git-credentials</code> ）。 “cache” 模式有 <code>--timeout &lt;seconds&gt;</code> 参数，可以设置后台进程的存活时间（默认是 “900”，也就是 15 分钟）。 下面是一个配置 “store” 模式自定义路径的例子：</p><pre class=" language-console"><code class="language-console">$ git config --global credential.helper store --file ~/.my-credentials</code></pre><p>Git 甚至允许你配置多个辅助工具。 当查找特定服务器的凭证时，Git 会按顺序查询，并且在找到第一个回答时停止查询。 当保存凭证时，Git 会将用户名和密码发送给 <strong>所有</strong> 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。 如果你在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，<code>.gitconfig</code> 配置文件如下：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[credential]</span><span class="token constant">    helper</span> <span class="token attr-value"><span class="token punctuation">=</span> store --file /mnt/thumbdrive/.git-credentials</span><span class="token constant">    helper</span> <span class="token attr-value"><span class="token punctuation">=</span> cache --timeout 30000</span></code></pre><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>这些是如何实现的呢？ Git 凭证辅助工具系统的命令是 <code>git credential</code>，这个命令接收一个参数，并通过标准输入获取更多的参数。</p><p>举一个例子更容易理解。 我们假设已经配置好一个凭证辅助工具，这个辅助工具保存了 <code>mygithost</code> 的凭证信息。 下面是一个使用 “fill” 命令的会话，当 Git 尝试寻找一个服务器的凭证时就会被调用。</p><pre class=" language-console"><code class="language-console">$ git credential fill (1)protocol=https (2)host=mygithost(3)protocol=https (4)host=mygithostusername=bobpassword=s3cre7$ git credential fill (5)protocol=httpshost=unknownhostUsername for 'https://unknownhost': bobPassword for 'https://bob@unknownhost':protocol=httpshost=unknownhostusername=bobpassword=s3cre7</code></pre><ol><li>这是开始交互的命令。</li><li>Git-credential 接下来会等待标准输入。 我们提供我们所知道的信息：协议和主机名。</li><li>一个空行代表输入已经完成，凭证系统应该输出它所知道的信息。</li><li>接下来由 Git-credential 接管，并且将找到的信息打印到标准输出。</li><li>如果没有找到对应的凭证，Git 会询问用户的用户名和密码，我们将这些信息输入到在标准输出的地方（这个例子中是同一个控制台）。</li></ol><p>凭证系统实际调用的程序和 Git 本身是分开的；具体是哪一个以及如何调用与 <code>credential.helper</code> 配置的值有关。 这个配置有多种格式：</p><table><thead><tr><th align="left">配置值</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left"><code>foo</code></td><td align="left">执行 <code>git-credential-foo</code></td></tr><tr><td align="left"><code>foo -a --opt=bcd</code></td><td align="left">执行 <code>git-credential-foo -a --opt=bcd</code></td></tr><tr><td align="left"><code>/absolute/path/foo -xyz</code></td><td align="left">执行 <code>/absolute/path/foo -xyz</code></td></tr><tr><td align="left"><code>!f() { echo &quot;password=s3cre7&quot;; }; f</code></td><td align="left"><code>!</code> 后面的代码会在shell执行</td></tr></tbody></table><p>上面描述的辅助工具可以被称做 <code>git-credential-cache</code>、<code>git-credential-store</code> 之类，我们可以配置它们来接受命令行参数。 通常的格式是 “git-credential-foo [args] <action>.” 标准输入/输出协议和 git-credential 一样，但它们使用的是一套稍微不太一样的行为：</action></p><ul><li><code>get</code> 是请求输入一对用户名和密码。</li><li><code>store</code> 是请求保存一个凭证到辅助工具的内存。</li><li><code>erase</code> 会将给定的证书从辅助工具内存中清除。</li></ul><p>对于 <code>store</code> 和 <code>erase</code> 两个行为是不需要返回数据的（Git 也会忽略掉）。 然而对于 <code>get</code>，Git 对辅助工具的返回信息十分感兴趣。</p><p>如果辅助工具没有任何有用的信息，它可以直接退出而不需要输出任何东西，但如果它有这些信息，它在提供的信息后面增加它所拥有的信息。 这些输出会被视为一系列的赋值语句；每一个提供的数据都会将 Git 已有的数据替换掉。</p><p>这有一个和上面一样的例子，但是跳过了 git-credential 这一步，直接到 git-credential-store:</p><pre class=" language-console"><code class="language-console">$ git credential-store --file ~/git.store store (1)protocol=httpshost=mygithostusername=bobpassword=s3cre7$ git credential-store --file ~/git.store get (2)protocol=httpshost=mygithostusername=bob (3)password=s3cre7</code></pre><ol><li>我们告诉 <code>git-credential-store</code> 去保存凭证：当访问 <code>https://mygithost</code> 时使用用户名 “bob”，密码是 “s3cre7”。</li><li>现在我们取出这个凭证。 我们提供连接这部分的信息（<code>https://mygithost</code>）以及一个空行。</li><li><code>git-credential-store</code> 输出我们之前保存的用户名和密码。</li></ol><p><code>~/git.store</code> 文件的内容类似：</p><pre><code>https://bob:s3cre7@mygithost</code></pre><p>仅仅是一系列包含凭证信息URL组成的行。 <code>osxkeychain</code> 和 <code>winstore</code> 辅助工具使用它们后端存储的原生格式，而 <code>cache</code> 使用它的内存格式（其他进程无法读取）。</p><h3 id="自定义凭证缓存"><a href="#自定义凭证缓存" class="headerlink" title="自定义凭证缓存"></a>自定义凭证缓存</h3><p>已经知道 <code>git-credential-store</code> 之类的是和 Git 是相互独立的程序，就不难理解 Git 凭证辅助工具可以是 <em>任意</em> 程序。 虽然 Git 提供的辅助工具覆盖了大多数常见的使用场景，但并不能满足所有情况。 比如，假设你的整个团队共享一些凭证，也许是在部署时使用。 这些凭证是保存在一个共享目录里，由于这些凭证经常变更，所以你不想把它们复制到你自己的凭证仓库中。 现有的辅助工具无法满足这种情况；来看看我们如何自己实现一个。 这个程序应该拥有几个核心功能：</p><ol><li>我们唯一需要关注的行为是 <code>get</code>；<code>store</code> 和 <code>erase</code> 是写操作，所以当接受到这两个请求时我们直接退出即可。</li><li>共享的凭证文件格式和 <code>git-credential-store</code> 使用的格式相同。</li><li>凭证文件的路径一般是固定的，但我们应该允许用户传入一个自定义路径以防万一。</li></ol><p>我们再一次使用 Ruby 来编写这个扩展，但只要 Git 能够执行最终的程序，任何语言都是可以的。 这是我们的凭证辅助工具的完整代码：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#!/usr/bin/env ruby</span><span class="token keyword">require</span> <span class="token string">'optparse'</span>path <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span>expand_path <span class="token string">'~/.git-credentials'</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token constant">OptionParser</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">do</span> <span class="token operator">|</span>opts<span class="token operator">|</span>    opts<span class="token punctuation">.</span>banner <span class="token operator">=</span> <span class="token string">'USAGE: git-credential-read-only [options] &lt;action>'</span>    opts<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'-f'</span><span class="token punctuation">,</span> <span class="token string">'--file PATH'</span><span class="token punctuation">,</span> <span class="token string">'Specify path for backing store'</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>argpath<span class="token operator">|</span>        path <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span>expand_path argpath    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token punctuation">.</span>parse<span class="token operator">!</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">unless</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>downcase <span class="token operator">==</span> <span class="token string">'get'</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">unless</span> <span class="token builtin">File</span><span class="token punctuation">.</span>exists<span class="token operator">?</span> pathknown <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">while</span> line <span class="token operator">=</span> <span class="token constant">STDIN</span><span class="token punctuation">.</span>gets    <span class="token keyword">break</span> <span class="token keyword">if</span> line<span class="token punctuation">.</span>strip <span class="token operator">==</span> <span class="token string">''</span>    k<span class="token punctuation">,</span>v <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">.</span>split <span class="token string">'='</span><span class="token punctuation">,</span> <span class="token number">2</span>    known<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token keyword">end</span><span class="token builtin">File</span><span class="token punctuation">.</span><span class="token function">readlines</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>fileline<span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    prot<span class="token punctuation">,</span>user<span class="token punctuation">,</span>pass<span class="token punctuation">,</span>host <span class="token operator">=</span> fileline<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token regex">/^(.*?):\/\/(.*?):(.*?)@(.*)$/</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first    <span class="token keyword">if</span> prot <span class="token operator">==</span> known<span class="token punctuation">[</span><span class="token string">'protocol'</span><span class="token punctuation">]</span> <span class="token keyword">and</span> host <span class="token operator">==</span> known<span class="token punctuation">[</span><span class="token string">'host'</span><span class="token punctuation">]</span> <span class="token keyword">then</span>        puts <span class="token string">"protocol=<span class="token interpolation"><span class="token delimiter tag">#{</span>prot<span class="token delimiter tag">}</span></span>"</span>        puts <span class="token string">"host=<span class="token interpolation"><span class="token delimiter tag">#{</span>host<span class="token delimiter tag">}</span></span>"</span>        puts <span class="token string">"username=<span class="token interpolation"><span class="token delimiter tag">#{</span>user<span class="token delimiter tag">}</span></span>"</span>        puts <span class="token string">"password=<span class="token interpolation"><span class="token delimiter tag">#{</span>pass<span class="token delimiter tag">}</span></span>"</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><ol><li>我们在这里解析命令行参数，允许用户指定输入文件，默认是 <code>~/.git-credentials</code>.</li><li>这个程序只有在接受到 <code>get</code> 行为的请求并且后端存储的文件存在时才会有输出。</li><li>这个循环从标准输入读取数据，直到读取到第一个空行。 输入的数据被保存到 <code>known</code> 哈希表中，之后需要用到。</li><li>这个循环读取存储文件中的内容，寻找匹配的行。 如果 <code>known</code> 中的协议和主机名与该行相匹配，这个程序输出结果并退出。</li></ol><p>我们把这个辅助工具保存为 <code>git-credential-read-only</code>，放到我们的 <code>PATH</code> 路径下并且给予执行权限。 一个交互式会话类似：</p><pre class=" language-console"><code class="language-console">$ git credential-read-only --file=/mnt/shared/creds getprotocol=httpshost=mygithostprotocol=httpshost=mygithostusername=bobpassword=s3cre7</code></pre><p>由于这个的名字是 “git-” 开头，所以我们可以在配置值中使用简便的语法：</p><pre class=" language-console"><code class="language-console">$ git config --global credential.helper read-only --file /mnt/shared/creds</code></pre><p>正如你看到的，扩展这个系统是相当简单的，并且可以为你和你的团队解决一些常见问题。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>你已经接触了很多能够精确地操控提交和暂存区的高级工具。 当你碰到问题时，你应该可以很容易找出是哪个分支在什么时候由谁引入了它们。 如果你想在项目中使用子项目，你也已经知道如何来满足这些需求。 到此，你应该能毫无压力地在命令行中使用 Git 来完成日常中的大部分事情。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub</title>
      <link href="/2019/07/15/GitHub/"/>
      <url>/2019/07/15/GitHub/</url>
      
        <content type="html"><![CDATA[<p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p><p>本章将讨论如何高效地使用 GitHub。 我们将学习如何注册和管理账户、创建和使用 Git 版本库、向已有项目贡献的通用流程以及如何接受别人向你自己项目的贡献、GitHub 的编程接口和很多能够让这些操作更简单的小提示。</p><p>如果你对如何使用 GitHub 托管自己的项目，或者与已经托管在 GitHub 上面的项目进行合作没有兴趣，可以直接跳到 <a href="https://git-scm.com/book/zh/v2/GitHub-账户的创建和配置#ch07-git-tools" target="_blank" rel="noopener">Git 工具</a> 这一章。</p><h2 id="账户的创建和配置"><a href="#账户的创建和配置" class="headerlink" title="账户的创建和配置"></a>账户的创建和配置</h2><p>你所需要做的第一件事是创建一个免费账户。 直接访问 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a>，选择一个未被占用的用户名，提供一个电子邮件地址和密码，点击写着`‘Sign up for GitHub’’的绿色大按钮即可。</p><p><img src="https://git-scm.com/book/en/v2/images/signup.png" alt="GitHub 注册表单。"></p><p>Figure 82. GitHub 注册表单。</p><p>你将看到的下一个页面是升级计划的价格页面，目前我们可以直接忽略这个页面。 GitHub 会给你提供的邮件地址发送一封验证邮件。 尽快到你的邮箱进行验证，这是非常重要的（我们会在后面了解到这点）。</p><table><thead><tr><th>Note</th><th>GitHub 为免费账户提供了完整功能，限制是你的项目都将被完全公开（每个人都具有读权限）。 GitHub 的付费计划可以让你拥有一定数目的私有项目，不过本书将不涉及这部分内容。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>点击屏幕左上角的 Octocat 图标，你将来到控制面板页面。 现在，你已经做好了使用 GitHub 的准备工作。</p><h3 id="SSH-访问"><a href="#SSH-访问" class="headerlink" title="SSH 访问"></a>SSH 访问</h3><p>现在，你完全可以使用 <code>https://</code> 协议，通过你刚刚创建的用户名和密码访问 Git 版本库。 但是，如果仅仅克隆公有项目，你甚至不需要注册——刚刚我们创建的账户是为了以后 fork 其它项目，以及推送我们自己的修改。</p><p>如果你习惯使用 SSH 远程，你需要配置一个公钥。 （如果你没有公钥，参考 <a href="https://git-scm.com/book/zh/v2/ch00/r_generate_ssh_key" target="_blank" rel="noopener">生成 SSH 公钥</a>。） 使用窗口右上角的链接打开你的账户设置：</p><p><img src="https://git-scm.com/book/en/v2/images/account-settings.png" alt="``Account settings&#39;&#39;链接。"></p><p>Figure 83. ‘`Account settings’’链接。</p><p>然后在左侧选择`‘SSH keys’’部分。</p><p><img src="https://git-scm.com/book/en/v2/images/ssh-keys.png" alt="``SSH keys&#39;&#39;链接。"></p><p>Figure 84. ‘`SSH keys’’链接。</p><p>在这个页面点击“<code>Add an SSH key</code>”按钮，给你的公钥起一个名字，将你的 <code>~/.ssh/id_rsa.pub</code>（或者自定义的其它名字）公钥文件的内容粘贴到文本区，然后点击`‘Add key’’。</p><table><thead><tr><th>Note</th><th>确保给你的 SSH 密钥起一个能够记得住的名字。 你可以为每一个密钥起名字（例如，“我的笔记本电脑”或者“工作账户”等），以便以后需要吊销密钥时能够方便地区分。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>下一步，如果愿意的话，你可以将生成的头像换成你喜欢的图片。 首先，来到<code>‘Profile’*标签页（在</code>‘SSH Keys*’标签页上方），点击``Upload new picture’’。</p><p><img src="https://git-scm.com/book/en/v2/images/your-profile.png" alt="``Profile&#39;&#39;链接。"></p><p>Figure 85. ‘`Profile’’链接。</p><p>我们选择了本地磁盘上的一个 Git 图标，上传之后还可以对其进行裁剪。</p><p><img src="https://git-scm.com/book/en/v2/images/avatar-crop.png" alt="裁剪已上传的头像。"></p><p>Figure 86. 裁剪头像</p><p>现在，在网站任意有你参与的位置，人们都可以在你的用户名旁边看到你的头像。</p><p>如果你已经把头像上传到了流行的 Gravatar 托管服务（Wordpress 账户经常使用），默认就会使用这个头像，因此，你就不需要进行这一步骤了。</p><h3 id="邮件地址"><a href="#邮件地址" class="headerlink" title="邮件地址"></a>邮件地址</h3><p>GitHub 使用用户邮件地址区分 Git 提交。 如果你在自己的提交中使用了多个邮件地址，希望 GitHub 可以正确地将它们连接起来，你需要在管理页面的 Emails 部分添加你拥有的所有邮箱地址。</p><p><img src="https://git-scm.com/book/en/v2/images/email-settings.png" alt="添加所有邮件地址。"></p><p>Figure 87. 添加邮件地址</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/r_add_email_addresses" target="_blank" rel="noopener">添加邮件地址</a> 中我们可以看到一些不同的状态。 顶部的地址是通过验证的，并且被设置为主要地址，这意味着该地址会接收到所有的通知和回复。 第二个地址是通过验证的，如果愿意的话，可以将其设置为主要地址。 最后一个地址是未通过验证的，这意味着你不能将其设置为主要地址。 当 GitHub 发现任意版本库中的任意提交信息包含了这些地址，它就会将其链接到你的账户。</p><h3 id="两步验证"><a href="#两步验证" class="headerlink" title="两步验证"></a>两步验证</h3><p>最后，为了额外的安全性，你绝对应当设置两步验证，简写为 “2FA”。 两步验证是一种用于降低因你的密码被盗而带来的账户风险的验证机制，现在已经变得越来越流行。 开启两步验证，GitHub 会要求你用两种不同的验证方法，这样，即使其中一个被攻破，攻击者也不能访问你的账户。</p><p>你可以在 Account settings 页面的 Security 标签页中找到 Two-factor Authentication 设置。</p><p><img src="https://git-scm.com/book/en/v2/images/2fa-1.png" alt="Security 标签页中的 2FA"></p><p>Figure 88. Security 标签页中的 2FA</p><p>点击<code>‘Set up two-factor authentication’*按钮，会跳转到设置页面。该页面允许你选择是要在登录时使用手机 app 生成辅助码（一种</code>‘基于时间的一次性密码*’），还是要 GitHub 通过 SMS 发送辅助码。</p><p>选择合适的方法后，按照提示步骤设置 2FA，你的账户会变得更安全，每次登录 GitHub 时都需要提供除密码以外的辅助码。</p><h2 id="对项目做出贡献"><a href="#对项目做出贡献" class="headerlink" title="对项目做出贡献"></a>对项目做出贡献</h2><p>账户已经建立好了，现在我们来了解一些能帮助你对现有的项目做出贡献的知识。</p><h3 id="派生（Fork）项目"><a href="#派生（Fork）项目" class="headerlink" title="派生（Fork）项目"></a>派生（Fork）项目</h3><p>如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项目进行“派生”。 派生的意思是指，GitHub 将在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。</p><table><thead><tr><th>Note</th><th>在以前，“fork”是一个贬义词，指的是某个人使开源项目向不同的方向发展，或者创建一个竞争项目，使得原项目的贡献者分裂。 在 GitHub，“fork”指的是你自己的空间中创建的项目副本，这个副本允许你以一种更开放的方式对其进行修改。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>通过这种方式，项目的管理者不再需要忙着把用户添加到贡献者列表并给予他们推送权限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通过创建合并请求（Pull Request）来让他们的改动进入源版本库，下文我们会详细说明。 创建了合并请求后，就会开启一个可供审查代码的板块，项目的拥有者和贡献者可以在此讨论相关修改，直到项目拥有者对其感到满意，并且认为这些修改可以被合并到版本库。</p><p>你可以通过点击项目页面右上角的“Fork”按钮，来派生这个项目。</p><p><img src="https://git-scm.com/book/en/v2/images/forkbutton.png" alt="“Fork”按钮."></p><p>Figure 89. “Fork”按钮</p><p>稍等片刻，你将被转到新项目页面，该项目包含可写的代码副本。</p><h3 id="GitHub-流程"><a href="#GitHub-流程" class="headerlink" title="GitHub 流程"></a>GitHub 流程</h3><p>GitHub 设计了一个以合并请求为中心的特殊合作流程。 它基于我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 的 <a href="https://git-scm.com/book/zh/v2/ch00/r_topic_branch" target="_blank" rel="noopener">特性分支</a> 中提到的工作流程。 不管你是在一个紧密的团队中使用单独的版本库，或者使用许多的“Fork”来为一个由陌生人组成的国际企业或网络做出贡献，这种合作流程都能应付。</p><p>流程通常如下：</p><ol><li>从 <code>master</code> 分支中创建一个新分支</li><li>提交一些修改来改进项目</li><li>将这个分支推送到 GitHub 上</li><li>创建一个合并请求</li><li>讨论，根据实际情况继续修改</li><li>项目的拥有者合并或关闭你的合并请求</li></ol><p>这基本和 <a href="https://git-scm.com/book/zh/v2/ch00/r_integration_manager" target="_blank" rel="noopener">集成管理者工作流</a> 中的一体化管理流程差不多，但是团队可以使用 GitHub 提供的网页工具替代电子邮件来交流和审查修改。</p><p>现在我们来看一个使用这个流程的例子。</p><h4 id="创建合并请求"><a href="#创建合并请求" class="headerlink" title="创建合并请求"></a>创建合并请求</h4><p>Tony 在找一些能在他的 Arduino 微控制器上运行的代码，他觉得 <a href="https://github.com/schacon/blink" target="_blank" rel="noopener">https://github.com/schacon/blink</a> 中的代码不错。</p><p><img src="https://git-scm.com/book/en/v2/images/blink-01-start.png" alt="他想要做出贡献的项目"></p><p>Figure 90. 他想要做出贡献的项目</p><p>但是有个问题，这个代码中的的闪烁频率太高，我们觉得 3 秒一次比 1 秒一次更好一些。 所以让我们来改进这个程序，并将修改后的代码提交给这个项目。</p><p>首先，单击“Fork”按钮来获得这个项目的副本。 我们使用的用户名是“tonychacon”，所以这个项目副本的访问地址是： <code>https://github.com/tonychacon/blink</code> 。 我们将它克隆到本地，创建一个分支，修改代码，最后再将改动推送到 GitHub。</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/tonychacon/blink (1)Cloning into 'blink'...$ cd blink$ git checkout -b slow-blink (2)Switched to a new branch 'slow-blink'$ sed -i '' 's/1000/3000/' blink.ino (3)$ git diff --word-diff (4)diff --git a/blink.ino b/blink.inoindex 15b9911..a6cc5a5 100644--- a/blink.ino+++ b/blink.ino@@ -18,7 +18,7 @@ void setup() {// the loop routine runs over and over again forever:void loop() {  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)  [-delay(1000);-]{+delay(3000);+}               // wait for a second  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW  [-delay(1000);-]{+delay(3000);+}               // wait for a second}$ git commit -a -m 'three seconds is better' (5)[slow-blink 5ca509d] three seconds is better 1 file changed, 2 insertions(+), 2 deletions(-)$ git push origin slow-blink (6)Username for 'https://github.com': tonychaconPassword for 'https://tonychacon@github.com':Counting objects: 5, done.Delta compression using up to 8 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.Total 3 (delta 1), reused 0 (delta 0)To https://github.com/tonychacon/blink * [new branch]      slow-blink -> slow-blink</code></pre><ol><li>将派生出的副本克隆到本地</li><li>创建出名称有意义的分支</li><li>修改代码</li><li>检查改动</li><li>将改动提交到分支中</li><li>将新分支推送到 GitHub 的副本中</li></ol><p>现在到 GitHub 上查看之前的项目副本，可以看到 GitHub 提示我们有新的分支，并且显示了一个大大的绿色按钮让我们可以检查我们的改动，并给源项目创建合并请求。</p><p>你也可以到“Branches”（分支）页面查看分支并创建合并请求： <code>https://github.com/&lt;用户名&gt;/&lt;项目名&gt;/branches</code></p><p><img src="https://git-scm.com/book/en/v2/images/blink-02-pr.png" alt="合并请求按钮"></p><p>Figure 91. 合并请求按钮</p><p>如果你点击了那个绿色按钮，就会看到一个新页面，在这里我们可以对改动填写标题和描述，让项目的拥有者考虑一下我们的改动。通常花点时间来编写个清晰有用的描述是个不错的主意，这能让作者明白为什么这个改动可以给他的项目带来好处，并且让他接受合并请求。</p><p>同时我们也能看到比主分支中所“领先”（ahead）的提交（在这个例子中只有一个）以及所有将会被合并的改动与之前代码的对比。</p><p><img src="https://git-scm.com/book/en/v2/images/blink-03-pull-request-open.png" alt="合并请求创建页面"></p><p>Figure 92. 合并请求创建页面</p><p>当你单击了“Create pull request”（创建合并请求）的按钮后，这个项目的拥有者将会收到一条包含关改动和合并请求页面的链接的提醒。</p><table><thead><tr><th>Note</th><th>虽然合并请求通常是在贡献者准备好在公开项目中提交改动的时候提交，但是也常被用在仍处于开发阶段的内部项目中。因为合并请求在提交后 <strong>依然可以加入新的改动</strong> ，它也经常被用来建立团队合作的环境，而不只是在最终阶段使用。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="利用合并请求"><a href="#利用合并请求" class="headerlink" title="利用合并请求"></a>利用合并请求</h4><p>现在，项目的拥有者可以看到你的改动并合并它，拒绝它或是发表评论。在这里我们就当作他喜欢这个点子，但是他想要让灯熄灭的时间比点亮的时间稍长一些。</p><p>接下来可能会通过电子邮件进行互动，就像我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git" target="_blank" rel="noopener">分布式 Git</a> 中提到的工作流程那样，但是在 GitHub，这些都在线上完成。项目的拥有者可以审查修改，只需要单击某一行，就可以对其发表评论。</p><p><img src="https://git-scm.com/book/en/v2/images/blink-04-pr-comment.png" alt="合并请求中对某一行的评论"></p><p>Figure 93. 对合并请求内的特定一行发表评论</p><p>当维护者发表评论后，提交合并请求的人，以及所有正在关注（Watching）这个版本库的用户都会收到通知。我们待会儿将会告诉你如何修改这项设置。现在，如果 Tony 有开启电子邮件提醒，他将会收到这样的一封邮件：</p><p><img src="https://git-scm.com/book/en/v2/images/blink-04-email.png" alt="电子邮件提醒"></p><p>Figure 94. 通过电子邮件发送的评论提醒</p><p>每个人都能在合并请求中发表评论。在 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_discussion" target="_blank" rel="noopener">合并请求讨论页面</a> 里我们可以看到项目拥有者对某行代码发表评论，并在讨论区留下了一个普通评论。你可以看到被评论的代码也会在互动中显示出来。</p><p><img src="https://git-scm.com/book/en/v2/images/blink-05-general-comment.png" alt="合并请求讨论页面"></p><p>Figure 95. 合并请求讨论页面</p><p>现在贡献者可以看到如何做才能让他们的改动被接受。幸运的是，这也是一件轻松的事情。如果你使用的是电子邮件进行交流，你需要再次对代码进行修改并重新提交至邮件列表，在 GitHub 上，你只需要再次提交到你的分支中并推送即可。</p><p>如果贡献者完成了以上的操作，项目的拥有者会再次收到提醒，当他们查看页面时，将会看到最新的改动。事实上，只要提交中有一行代码改动，GitHub 都会注意到并处理掉旧的变更集。</p><p><img src="https://git-scm.com/book/en/v2/images/blink-06-final.png" alt="最终的合并请求"></p><p>Figure 96. 最终的合并请求</p><p>如果你点开合并请求的“Files Changed”（更改的文件）选项卡，你将会看到“整理过的”差异表 —— 也就是这个分支被合并到主分支之后将会产生的所有改动，其实就是 <code>git diff master...&lt;分支名&gt;</code> 命令的执行结果。你可以浏览 <a href="https://git-scm.com/book/zh/v2/ch00/r_what_is_introduced" target="_blank" rel="noopener">确定引入了哪些东西</a> 来了解更多关于差异表的知识。</p><p>你还会注意到，GitHub 会检查你的合并请求是否能直接合并，如果可以，将会提供一个按钮来进行合并操作。这个按钮只在你对版本库有写入权限并且可以进行简洁合并时才会显示。你点击后 GitHub 将做出一个“非快进式”（non-fast-forward）合并，即使这个合并 <strong>能够</strong> 快进式（fast-forward）合并，GitHub 依然会创建一个合并提交。</p><p>如果你需要，你还可以将分支拉取并在本地合并。如果你将这个分支合并到 <code>master</code> 分支中并推送到 GitHub，这个合并请求会被自动关闭。</p><p>这就是大部分 GitHub 项目使用的工作流程。创建分支，基于分支创建合并请求，进行讨论，根据需要继续在分支上进行修改，最终关闭或合并合并请求。</p><table><thead><tr><th>Note</th><th>不必总是 Fork有件很重要的事情：你可以在同一个版本库中不同的分支提交合并请求。如果你正在和某人实现某个功能，而且你对项目有写权限，你可以推送分支到版本库，并在 <code>master</code> 分支提交一个合并请求并在此进行代码审查和讨论的操作。不需要进行“Fork”。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="合并请求的进阶用法"><a href="#合并请求的进阶用法" class="headerlink" title="合并请求的进阶用法"></a>合并请求的进阶用法</h3><p>目前，我们学到了如何在 GitHub 平台对一个项目进行最基础的贡献。现在我们会教给你一些小技巧，让你可以更加有效率地使用合并请求。</p><h4 id="将合并请求制作成补丁"><a href="#将合并请求制作成补丁" class="headerlink" title="将合并请求制作成补丁"></a>将合并请求制作成补丁</h4><p>有一件重要的事情：许多项目并不认为合并请求可以作为补丁，就和通过邮件列表工作的的项目对补丁贡献的看法一样。大多数的 GitHub 项目将合并请求的分支当作对改动的交流方式，并将变更集合起来统一进行合并。</p><p>这是个重要的差异，因为一般来说改动会在代码完成前提出，这和基于邮件列表的补丁贡献有着天差地别。这使得维护者们可以更早的沟通，由社区中的力量能提出更好的方案。当有人从合并请求提交了一些代码，并且维护者和社区提出了一些意见，这个补丁系列并不需要从头来过，只需要将改动重新提交并推送到分支中，这使得讨论的背景和过程可以齐头并进。</p><p>举个例子，你可以回去看看 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_final" target="_blank" rel="noopener">最终的合并请求</a>，你会注意到贡献者没有变基他的提交再提交一个新的合并请求，而是直接增加了新的提交并推送到已有的分支中。如果你之后再回去查看这个合并请求，你可以轻松地找到这个修改的原因。点击网页上的“Merge”（合并）按钮后，会建立一个合并提交并指向这个合并请求，你就可以很轻松的研究原来的讨论内容。</p><h4 id="与上游保持同步"><a href="#与上游保持同步" class="headerlink" title="与上游保持同步"></a>与上游保持同步</h4><p>如果你的合并请求由于过时或其他原因不能干净地合并，你需要进行修复才能让维护者对其进行合并。GitHub 会对每个提交进行测试，让你知道你的合并请求能否简洁的合并。</p><p><img src="https://git-scm.com/book/en/v2/images/pr-01-fail.png" alt="合并请求合并失败"></p><p>Figure 97. 不能进行干净合并</p><p>如果你看到了像 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_fail" target="_blank" rel="noopener">不能进行干净合并</a> 中的画面，你就需要修复你的分支让这个提示变成绿色，这样维护者就不需要再做额外的工作。</p><p>你有两种方法来解决这个问题。你可以把你的分支变基到目标分支中去（通常是你派生出的版本库中的 <code>master</code> 分支），或者你可以合并目标分支到你的分支中去。</p><p>GitHub 上的大多数的开发者会使用后一种方法，基于我们在上一节提到的理由：我们最看重的是历史记录和最后的合并，变基除了给你带来看上去简洁的历史记录，只会让你的工作变得更加困难且更容易犯错。</p><p>如果你想要合并目标分支来让你的合并请求变得可合并，你需要将源版本库添加为一个新的远端，并从远端抓取内容，合并主分支的内容到你的分支中去，修复所有的问题并最终重新推送回你提交合并请求使用的分支。</p><p>在这个例子中，我们再次使用之前的“tonychacon”用户来进行示范，源作者提交了一个改动，使得合并请求和它产生了冲突。现在来看我们解决这个问题的步骤。</p><pre class=" language-console"><code class="language-console">$ git remote add upstream https://github.com/schacon/blink (1)$ git fetch upstream (2)remote: Counting objects: 3, done.remote: Compressing objects: 100% (3/3), done.Unpacking objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0)From https://github.com/schacon/blink * [new branch]      master     -> upstream/master$ git merge upstream/master (3)Auto-merging blink.inoCONFLICT (content): Merge conflict in blink.inoAutomatic merge failed; fix conflicts and then commit the result.$ vim blink.ino (4)$ git add blink.ino$ git commit[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \    into slower-blink$ git push origin slow-blink (5)Counting objects: 6, done.Delta compression using up to 8 threads.Compressing objects: 100% (6/6), done.Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.Total 6 (delta 2), reused 0 (delta 0)To https://github.com/tonychacon/blink   ef4725c..3c8d735  slower-blink -> slow-blink</code></pre><ol><li>将源版本库添加为一个远端，并命名为“upstream”（上游）</li><li>从远端抓取最新的内容</li><li>将主分支的内容合并到你的分支中</li><li>修复产生的冲突</li><li>再推送回同一个分支</li></ol><p>你完成了上面的步骤后，合并请求将会自动更新并重新检查是否能干净的合并。</p><p><img src="https://git-scm.com/book/en/v2/images/pr-02-merge-fix.png" alt="修复了的合并请求"></p><p>Figure 98. 合并请求现在可以干净地合并了</p><p>Git 的伟大之处就是你可以一直重复以上操作。如果你有一个运行了十分久的项目，你可以轻松地合并目标分支且只需要处理最近的一次冲突，这使得管理流程更加容易。</p><p>如果你一定想对分支做变基并进行清理，你可以这么做，但是强烈建议你不要强行的提交到已经提交了合并请求的分支。如果其他人拉取了这个分支并进行一些修改，你将会遇到 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_peril" target="_blank" rel="noopener">变基的风险</a> 中提到的问题。相对的，将变基后的分支推送到 GitHub 上的一个新分支中，并且创建一个全新的合并请求引用旧的合并请求，然后关闭旧的合并请求。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>你的下个问题可能是“我该如何引用旧的合并请求？”。有许多方法可以让你在 GitHub 上的几乎任何地方引用其他东西。</p><p>先从如何对合并请求或议题（Issue）进行相互引用开始。所有的合并请求和议题在项目中都会有一个独一无二的编号。举个例子，你无法同时拥有 3 号合并请求和 3 号议题。如果你想要引用任何一个合并请求或议题，你只需要在提交或描述中输入 <code>#&lt;编号&gt;</code> 即可。你也可以指定引用其他版本库的议题或合并请求，如果你想要引用其他人对该版本库的“Fork”中的议题或合并请求，输入 <code>用户名#&lt;编号&gt;</code> ，如果在不同的版本库中，输入 <code>用户名/版本库名#&lt;编号&gt;</code> 。</p><p>我们来看一个例子。假设我们对上个例子中的分支进行了变基，并为此创建一个新的合并请求，现在我们希望能在新的合并请求中引用旧的合并请求。我们同时希望引用一个派生出的项目中的议题和一个完全不同的项目中的议题，就可以像 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_references" target="_blank" rel="noopener">在合并请求中的交叉引用</a> 这样填写描述。</p><p><img src="https://git-scm.com/book/en/v2/images/mentions-01-syntax.png" alt="合并请求中的引用"></p><p>Figure 99. 在合并请求中的交叉引用</p><p>当我们提交了这个合并请求，我们将会看到以上内容被渲染成这样：<a href="https://git-scm.com/book/zh/v2/ch00/r_pr_references_render" target="_blank" rel="noopener">在合并请求中渲染后的交叉引用</a></p><p><img src="https://git-scm.com/book/en/v2/images/mentions-02-render.png" alt="渲染后的合并请求中的引用"></p><p>Figure 100. 在合并请求中渲染后的交叉引用</p><p>你会注意到完整的 GitHub 地址被简化了，只留下了必要的信息。</p><p>如果 Tony 回去关闭了源合并请求，我们可以看到一个被引用的提示，GitHub 会自动的反向追踪事件并显示在合并请求的时间轴上。这意味着任何查看这个合并请求的人可以轻松地访问新的合并请求。这个链接就像 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_closed" target="_blank" rel="noopener">在合并请求中渲染后的交叉引用</a> 中展示的那样。</p><p><img src="https://git-scm.com/book/en/v2/images/mentions-03-closed.png" alt="合并请求关闭"></p><p>Figure 101. 在合并请求中渲染后的交叉引用</p><p>除了议题编号外，你还可以通过使用提交的 SHA-1 来引用提交。你必须完整的写出 40 位长的 SHA，GitHub 会在评论中自动地产生指向这个提交的链接。同样的，你可以像引用议题一样对“Fork”出的项目中的提交或者其他项目中的提交进行引用。</p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>对于在 GitHub 中绝大多数文本框中能够做到的事，引用其他议题只是个开始。在议题和合并请求的描述，评论和代码评论还有其他地方，都可以使用“GitHub 风格的 Markdown”。Markdown 可以让你输入纯文本，但是渲染出丰富的内容。</p><p>查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_example_markdown" target="_blank" rel="noopener">一个 Markdown 的例子和渲染效果</a> 里的例子来了解如何书写评论或文本，并通过 Markdown 进行渲染。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-01-example.png" alt="Markdown 例子"></p><p>Figure 102. 一个 Markdown 的例子和渲染效果</p><h4 id="GitHub-风格的-Markdown"><a href="#GitHub-风格的-Markdown" class="headerlink" title="GitHub 风格的 Markdown"></a>GitHub 风格的 Markdown</h4><p>GitHub 风格的 Markdown 增加了一些基础的 Markdown 中做不到的东西。它在创建合并请求和议题中的评论和描述时十分有用。</p><h6 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h6><p>第一个 GitHub 专属的 Markdown 功能，特别是用在合并请求中，就是任务列表。一个任务列表可以展示出一系列你想要完成的事情，并带有复选框。把它们放在议题或合并请求中时，通常可以展示你想要完成的事情。</p><p>你可以这样创建一个任务列表：</p><pre><code>- [X] 编写代码- [ ] 编写所有测试程序- [ ] 为代码编写文档</code></pre><p>如果我们将这个列表加入合并请求或议题的描述中，它将会被渲染 <a href="https://git-scm.com/book/zh/v2/ch00/r_task_lists" target="_blank" rel="noopener">Markdown 评论中渲染后的任务列表</a> 这样。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-02-tasks.png" alt="任务列表示例"></p><p>Figure 103. Markdown 评论中渲染后的任务列表</p><p>在合并请求中，任务列表经常被用来在合并之前展示这个分支将要完成的事情。最酷的地方就是，你只需要点击复选框，就能更新评论 —— 你不需要直接修改 Markdown。</p><p>不仅如此，GitHub 还会将你在议题和合并请求中的任务列表整理起来集中展示。举个例子，如果你在一个合并请求中有任务清单，你将会在所有合并请求的总览页面上看到它的进度。这使得人们可以把一个合并请求分解成不同的小任务，同时便于其他人了解分支的进度。你可以在 <a href="https://git-scm.com/book/zh/v2/ch00/r_task_list_progress" target="_blank" rel="noopener">在合并请求列表中的任务列表总结</a>看到一个例子。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-03-task-summary.png" alt="任务列表示例"></p><p>Figure 104. 在合并请求列表中的任务列表总结</p><p>当你在实现一个任务的早期就提交合并请求，并使用任务清单追踪你的进度，这个功能会十分的有用。</p><h6 id="摘录代码"><a href="#摘录代码" class="headerlink" title="摘录代码"></a>摘录代码</h6><p>你也可以在评论中摘录代码。这在你想要展示尚未提交到分支中的代码时会十分有用。它也经常被用在展示无法正常工作的代码或这个合并请求需要的代码。</p><p>你需要用“反引号”将需要添加的摘录代码包起来。</p><pre><code>​```javafor(int i=0 ; i &lt; 5 ; i++){   System.out.println(&quot;i is : &quot; + i);}​```</code></pre><p>如果加入语言的名称，就像我们这里加入的“java”一样，GitHub 会自动尝试对摘录的片段进行语法高亮。在下面的例子中，它最终会渲染成这个样子： <a href="https://git-scm.com/book/zh/v2/ch00/r_md_code" target="_blank" rel="noopener">渲染后的摘录代码示例</a> 。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-04-fenced-code.png" alt="渲染后的摘录代码"></p><p>Figure 105. 渲染后的摘录代码示例</p><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><p>如果你在回复一个很长的评论之中的一小段，你只需要复制你需要的片段，并在每行前添加 <code>&gt;</code> 符号即可。事实上，因为这个功能会被经常用到，它也有一个快捷键。只要你把你要回应的文字选中，并按下 <code>r</code> 键，选中的问题会自动引用并填入评论框。</p><p>引用的部分就像这样:</p><pre><code>&gt; Whether &#39;tis Nobler in the mind to suffer&gt; The Slings and Arrows of outrageous Fortune,How big are these slings and in particular, these arrows?</code></pre><p>经过渲染后，就会变成这样： <a href="https://git-scm.com/book/zh/v2/ch00/r_md_quote" target="_blank" rel="noopener">渲染后的引用示例</a></p><p><img src="https://git-scm.com/book/en/v2/images/markdown-05-quote.png" alt="渲染后的引用"></p><p>Figure 106. 渲染后的引用示例</p><h6 id="表情符号（EMOJI）"><a href="#表情符号（EMOJI）" class="headerlink" title="表情符号（EMOJI）"></a>表情符号（EMOJI）</h6><p>最后，我们可以在评论中使用表情符号。这经常出现在 GitHub 的议题和合并请求的评论中。GitHub 上甚至有表情助手。如果你在输入评论时以 <code>:</code> 开头，自动完成器会帮助你找到你需要的表情。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-06-emoji-complete.png" alt="表情符号自动完成器"></p><p>Figure 107. 表情符号自动完成器</p><p>你也可以在评论的任何地方使用 <code>:&lt;表情名称&gt;:</code> 来添加表情符号。举个例子，你可以输入以下文字：</p><pre><code>I :eyes: that :bug: and I :cold_sweat:.:trophy: for :microscope: it.:+1: and :sparkles: on this :ship:, it&#39;s :fire::poop:!:clap::tada::panda_face:</code></pre><p>渲染之后，就会变成这样： <a href="https://git-scm.com/book/zh/v2/ch00/r_md_emoji" target="_blank" rel="noopener">使用了大量表情符号的评论</a></p><p><img src="https://git-scm.com/book/en/v2/images/markdown-07-emoji.png" alt="Emoji"></p><p>Figure 108. 使用了大量表情符号的评论</p><p>虽然这个功能并不是非常实用，但是它在这种不方便表达感情的媒体里，加入了趣味的元素。</p><table><thead><tr><th>Note</th><th>事实上现在已经有大量的在线服务可以使用表情符号，这里有个列表可以让你快速的找到能表达你的情绪的表情符号：<a href="http://www.emoji-cheat-sheet.com/" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><p>从技术层面来说，这并不是 GitHub 风格 Markdown 的功能，但是也很有用。如果不想使用 Markdown 语法来插入图片，GitHub 允许你通过拖拽图片到文本区来插入图片。</p><p><img src="https://git-scm.com/book/en/v2/images/markdown-08-drag-drop.png" alt="拖拽插入图片"></p><p>Figure 109. 通过拖拽的方式自动插入图片</p><p>如果你回去查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_pr_references" target="_blank" rel="noopener">在合并请求中的交叉引用</a> ，你会发现文本区上有个“Parsed as Markdown”的提示。点击它你可以了解所有能在 GitHub 上使用的 Markdown 功能。</p><h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><p>现在我们可以很方便地向一个项目贡献内容，来看一下另一个方面的内容：创建、维护和管理你自己的项目。</p><h3 id="创建新的版本库"><a href="#创建新的版本库" class="headerlink" title="创建新的版本库"></a>创建新的版本库</h3><p>让我们创建一个版本库来分享我们的项目。 通过点击面板右侧的“New repository”按钮，或者顶部工具条你用户名旁边的 <code>+</code> 按钮来开始我们的旅程。 参见 <a href="https://git-scm.com/book/zh/v2/ch00/r_new_repo_dropdown" target="_blank" rel="noopener">这是 “New repository” 下拉列表.</a>。</p><p><img src="https://git-scm.com/book/en/v2/images/newrepo.png" alt="``Your repositories&#39;&#39; 区域."></p><p>Figure 110. 这是 ‘`Your repositories’’区域.</p><p><img src="https://git-scm.com/book/en/v2/images/new-repo.png" alt="``new repository&#39;&#39; 下拉列表."></p><p>Figure 111. 这是 “New repository” 下拉列表.</p><p>这会带你到 “new repository” 表单:</p><p><img src="https://git-scm.com/book/en/v2/images/newrepoform.png" alt="``new repository&#39;&#39; 表单。"></p><p>Figure 112. 这是 “new repository” 表单.</p><p>这里除了一个你必须要填的项目名，其他字段都是可选的。 现在只需要点击 “Create Repository” 按钮，Duang!!! – 你就在 GitHub 上拥有了一个以 <code>&lt;user&gt;/&lt;project_name&gt;</code> 命名的新仓库了。</p><p>因为目前暂无代码，GitHub 会显示有关创建新版本库或者关联到一个已有的 Git 版本库的一些说明。 我们不会在这里详细说明此项，如果你需要复习，去看 <a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics" target="_blank" rel="noopener">Git 基础</a>。</p><p>现在你的项目就托管在 GitHub 上了，你可以把 URL 给任何你想分享的人。 GitHub 上的项目可通过 HTTP 或 SSH 访问，格式是：HTTP ： <code>https://github.com/&lt;user&gt;/&lt;project_name&gt;</code> ， SSH ： <code>git@github.com:&lt;user&gt;/&lt;project_name&gt;</code> 。 Git 可以通过以上两种 URL 进行抓取和推送，但是用户的访问权限又因连接时使用的证书不同而异。</p><table><thead><tr><th>Note</th><th>通常对于公开项目可以优先分享基于 HTTP 的 URL，因为用户克隆项目不需要有一个 GitHub 帐号。 如果你分享 SSH URL，用户必须有一个帐号并且上传 SSH 密钥才能访问你的项目。 HTTP URL 与你贴到浏览器里查看项目用的地址是一样的。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="添加合作者"><a href="#添加合作者" class="headerlink" title="添加合作者"></a>添加合作者</h3><p>如果你想与他人合作，并想给他们提交的权限，你需要把他们添加为 “Collaborators”。 如果 Ben，Jeff，Louise 都在 GitHub 上注册了，你想给他们推送的权限，你可以将他们添加到你的项目。 这样做会给他们 “推送” 权限，就是说他们对项目和 Git 版本库都有读写的权限。</p><p>点击边栏底部的 “Settings” 链接。</p><p><img src="https://git-scm.com/book/en/v2/images/reposettingslink.png" alt="版本库设置链接."></p><p>Figure 113. 版本库设置链接.</p><p>然后从左侧菜单中选择 “Collaborators” 。 然后，在输入框中填写用户名，点击 “Add collaborator.” 如果你想授权给多个人，你可以多次重复这个步骤。 如果你想收回权限，点击他们同一行右侧的 “X”</p><p><img src="https://git-scm.com/book/en/v2/images/collaborators.png" alt="版本库合作者."></p><p>Figure 114. 版本库合作者.</p><h3 id="管理合并请求"><a href="#管理合并请求" class="headerlink" title="管理合并请求"></a>管理合并请求</h3><p>现在你有一个包含一些代码的项目，可能还有几个有推送权限的合作者，下面来看当你收到合并请求时该做什么。</p><p>合并请求可以来自仓库副本的一个分支，或者同一仓库的另一个分支。 唯一的区别是 fork 过来的通常是和你不能互相推送的人，而内部的推送通常都可以互相访问。</p><p>作为例子，假设你是 “tonychacon” ，你创建了一个名为 “fade” 的 Arduino 项目.</p><h4 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h4><p>有人来修改了你的代码，给你发了一个合并请求。 你会收一封关于合并请求的提醒邮件，它看起来像 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_pr" target="_blank" rel="noopener">新的合并请求的邮件通知.</a>。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-01-email.png" alt="合并请求的邮件通知"></p><p>Figure 115. 新的合并请求的邮件通知.</p><p>关于这个邮件有几个要注意的地方。 它会给你一个小的变动统计结果 — 一个包含合并请求中改变的文件和改变了多少的列表。 它还给你一个 GitHub 上进行合并请求操作的链接。 还有几个可以在命令行使用的 URL。</p><p>如果你注意到 <code>git pull &lt;url&gt; patch-1</code> 这一行，这是一种合并远程分支的简单方式，无需必须添加一个远程分支。 我们很快会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_checking_out_remotes" target="_blank" rel="noopener">检出远程分支</a> 讲到它。 如果你愿意，你可以创建并切换到一个主题分支，然后运行这个命令把合并请求合并进来。</p><p>还有一些有趣的 URL，像 <code>.diff</code> 和 <code>.patch</code> ，就像你猜的那样，它们提供 diff 和 patch 的标准版本。 你可以技术性地用下面的方法合并“合并请求”：</p><pre class=" language-console"><code class="language-console">$ curl http://github.com/tonychacon/fade/pull/1.patch | git am</code></pre><h4 id="在合并请求上进行合作"><a href="#在合并请求上进行合作" class="headerlink" title="在合并请求上进行合作"></a>在合并请求上进行合作</h4><p>就像我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_github_flow" target="_blank" rel="noopener">GitHub 流程</a>， 说过的，现在你可以跟开启合并请求的人进行会话。 你既可以对某些代码添加注释，也可以对整个提交添加注释或对整个合并请求添加注释，在任何地方都可以用 GitHub Flavored Markdown。</p><p>每次有人在合并请求上进行注释你都会收到通知邮件，通知你哪里发生改变。 他们都会包含一个到改变位置的链接，你可以直接在邮件中对合并请求进行注释。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-03-email-resp.png" alt="邮件回复"></p><p>Figure 116. Responses to emails are included in the thread.</p><p>一旦代码符合了你的要求，你想把它合并进来，你可以把代码拉取下来在本地进行合并，也可以用我们之前提到过的 <code>git pull &lt;url&gt; &lt;branch&gt;</code> 语法，或者把 fork 添加为一个 remote，然后进行抓取和合并。</p><p>对于很琐碎的合并，你也可以用 GitHub 网站上的 “Merge” 按钮。 它会做一个 “non-fast-forward” 合并，即使可以快进（fast-forward）合并也会产生一个合并提交记录。 就是说无论如何，只要你点击 merge 按钮，就会产生一个合并提交记录。 你可以在 <a href="https://git-scm.com/book/zh/v2/ch00/r_merge_button" target="_blank" rel="noopener">合并按钮和手工合并一个合并请求的指令.</a> 看到，如果你点击提示链接，GitHub 会给你所有的这些信息。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-02-merge.png" alt="合并按钮"></p><p>Figure 117. 合并按钮和手工合并一个合并请求的指令.</p><p>如果你决定不合并它，你可以把合并请求关掉，开启合并请求的人会收到通知。</p><h4 id="合并请求引用"><a href="#合并请求引用" class="headerlink" title="合并请求引用"></a>合并请求引用</h4><p>如果你正在处理 <strong>许多</strong> 合并请求，不想添加一堆 remote 或者每次都要做一次拉取，这里有一个可以在 GitHub 上用的小技巧。 这是有点高级的技巧，但它相当有用，我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_refspec" target="_blank" rel="noopener">引用规格</a> 有更多的细节说明。</p><p>实际上 GitHub 在服务器上把合并请求分支视为一种 “假分支”。 默认情况下你克隆时不会得到它们，但它们还是隐式地存在，你可以很容易地访问到它们。</p><p>为了展示这个，我们要用到一个叫做 <code>ls-remote</code> 的低级命令（通常被叫做“plumbing”，我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_plumbing_porcelain" target="_blank" rel="noopener">底层命令和高层命令</a> 读到更多相关内容）。 这个命令在日常 Git 操作中基本不会用到，但在显示服务器上有哪些引用（reference）时很管用。</p><p>如果在我们之前用过的 “blink” 版本库上使用这个命令，我们会得到一个版本库里所有的分支，标签和其它引用（reference）的列表。</p><pre class=" language-console"><code class="language-console">$ git ls-remote https://github.com/schacon/blink10d539600d86723087810ec636870a504f4fee4d    HEAD10d539600d86723087810ec636870a504f4fee4d    refs/heads/master6a83107c62950be9453aac297bb0193fd743cd6e    refs/pull/1/headafe83c2d1a70674c9505cc1d8b7d380d5e076ed3    refs/pull/1/merge3c8d735ee16296c242be7a9742ebfbc2665adec1    refs/pull/2/head15c9f4f80973a2758462ab2066b6ad9fe8dcf03d    refs/pull/2/mergea5a7751a33b7e86c5e9bb07b26001bb17d775d1a    refs/pull/4/head31a45fc257e8433c8d8804e3e848cf61c9d3166c    refs/pull/4/merge</code></pre><p>当然，如果你在你自己的版本库或其它你想检查的远程版本库中使用 <code>git ls-remote origin</code> ，它会显示相似的内容。</p><p>如果版本库在 GitHub 上并且有打开的合并请求，你会得到一些以 <code>refs/pull/</code> 开头的引用。 它们实际上是分支，但因为它们不在 <code>refs/heads/</code> 中，所以正常情况下你克隆时不会从服务器上得到它们 — 抓取过程正常情况下会忽略它们。</p><p>每个合并请求有两个引用 - 其中以 <code>/head</code> 结尾的引用指向的提交记录与合并请求分支中的最后一个提交记录是同一个。 所以如果有人在我们的版本库中开启了一个合并请求，他们的分支叫做 <code>bug-fix</code>，指向 <code>a5a775</code> 这个提交记录，那么在 <strong>我们的</strong> 版本库中我们没有 <code>bug-fix</code> 分支（因为那是在他们的 fork 中），但我们 <strong>可以</strong> 有一个 <code>pull/&lt;pr#&gt;/head</code> 指向 <code>a5a775</code>。 这意味着我们可以很容易地拉取每一个合并请求分支而不用添加一堆 remote。</p><p>现在，你可以像直接抓取引用一样抓取那些分支或提交。</p><pre class=" language-console"><code class="language-console">$ git fetch origin refs/pull/958/headFrom https://github.com/libgit2/libgit2 * branch            refs/pull/958/head -> FETCH_HEAD</code></pre><p>这告诉 Git： “连接到 <code>origin</code> 这个 remote，下载名字为 <code>refs/pull/958/head</code> 的引用。” Git 高高兴兴去执行，下载构建那个引用需要的所有内容，然后把指针指向 <code>.git/FETCH_HEAD</code> 下面你想要的提交记录。 然后你可以用 <code>git merge FETCH_HEAD</code> 把它合并到你想进行测试的分支，但那个合并的提交信息看起来有点怪。 然而，如果你需要审查 <strong>一大批</strong> 合并请求，这样操作会很麻烦。</p><p>还有一种方法可以抓取 <em>所有的</em> 合并请求，并且在你连接到远程（remote）的时候保持更新。 用你最喜欢的编辑器打开 <code>.git/config</code> ，查找 <code>origin</code> 远程（remote）。 看起来差不多像下面这样：</p><pre><code>[remote &quot;origin&quot;]    url = https://github.com/libgit2/libgit2    fetch = +refs/heads/*:refs/remotes/origin/*</code></pre><p>以 <code>fetch =</code> 开头的行是一个 “refspec.” 它是一种把 remote 的名称映射到你本地 <code>.git</code> 目录的方法。 这一条（就是上面的这一条）告诉 Git，“remote 上 <code>refs/heads</code> 下面的内容在我本地版本库中都放在 <code>refs/remotes/origin</code> 。” 你可以把这一段修改一下，添加另一个 refspec：</p><pre><code>[remote &quot;origin&quot;]    url = https://github.com/libgit2/libgit2.git    fetch = +refs/heads/*:refs/remotes/origin/*    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</code></pre><p>最后一行告诉 Git： “所有看起来像 <code>refs/pull/123/head</code> 的引用应该在本地版本库像 <code>refs/remotes/origin/pr/123</code> 一样存储” 现在，如果你保存那个文件，执行 <code>git fetch</code>：</p><pre class=" language-console"><code class="language-console">$ git fetch# … * [new ref]         refs/pull/1/head -> origin/pr/1 * [new ref]         refs/pull/2/head -> origin/pr/2 * [new ref]         refs/pull/4/head -> origin/pr/4# …</code></pre><p>现在所有的合并请求在本地像分支一样展现，它们是只读的，当你执行抓取时它们也会更新。 这让在本地测试合并请求中的代码变得超级简单：</p><pre class=" language-console"><code class="language-console">$ git checkout pr/2Checking out files: 100% (3769/3769)， done.Branch pr/2 set up to track remote branch pr/2 from origin.Switched to a new branch 'pr/2'</code></pre><p>你的鹰眼系统会发现在 refspec 的 remote 部分的结尾有个 <code>head</code> 。 在 GitHub 那边也有一个 <code>refs/pull/#/merge</code> 引用，它代表的是如果你在网站上按了 “merge” 按钮对应的提交记录。 这甚至让你可以在按按钮之前就测试这个合并。</p><h4 id="合并请求之上的合并请求"><a href="#合并请求之上的合并请求" class="headerlink" title="合并请求之上的合并请求"></a>合并请求之上的合并请求</h4><p>你不仅可以在主分支或者说 <code>master</code> 分支上开启合并请求，实际上你可以在网络上的任何一个分支上开启合并请求。 其实，你甚至可以在另一个合并请求上开启一个合并请求。</p><p>如果你看到一个合并请求在向正确的方向发展，然后你想在这个合并请求上做一些修改或者你不太确定这是个好主意，或者你没有目标分支的推送权限，你可以直接在合并请求上开启一个合并请求。</p><p>当你开启一个合并请求时，在页面的顶端有一个框框显示你要合并到哪个分支和你从哪个分支合并过来的。 如果你点击那个框框右边的 “Edit” 按钮，你不仅可以改变分支，还可以选择哪个 fork。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-04-target.png" alt="合并目标"></p><p>Figure 118. 手工修改合并请求的目标.</p><p>这里你可以很简单地指明合并你的分支到哪一个合并请求或 fork。</p><h3 id="提醒和通知"><a href="#提醒和通知" class="headerlink" title="提醒和通知"></a>提醒和通知</h3><p>GitHub 内置了一个很好的通知系统，当你需要与别人或别的团队交流时用起来很方便。</p><p>在任何评论中你可以先输入一个 <code>@</code> ，系统会自动补全项目中合作者或贡献者的名字和用户名。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-05-mentions.png" alt="提醒"></p><p>Figure 119. 输入 @ 来提醒某人.</p><p>你也可以提醒不在列表中的用户，但是通常自动补全用起更快。</p><p>当你发布了一个带用户提醒的评论，那个用户会收到通知。 这意味着把人们拉进会话中要比让他们投票有效率得多。 对于 GitHub 上的合并请求，人们经常把他们团队或公司中的其它人拉来审查问题或合并请求。</p><p>如果有人收到了合并请求或问题的提醒，他们会＂订阅＂它，后面有新的活动发生他们都会持续收到提醒。 如果你是合并请求或者问题的发起方你也会被订阅上，比如你在关注一个版本库或者你评论了什么东西。 如果你不想再收到提醒，在页面上有个 “Unsubscribe” 按钮，点一下就不会再收到更新了。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-06-unsubscribe.png" alt="取消订阅"></p><p>Figure 120. 取消订阅一个问题或合并请求.</p><h3 id="通知页面"><a href="#通知页面" class="headerlink" title="通知页面"></a>通知页面</h3><p>当我们在这提到特指 GitHub 的 “notifications” ，指的是当 GitHub 上有事件发生时，它通知你的方式，这里有几种不同的方式来配置它们。 如果你打开配置页面的 “Notification center” 标签，你可以看到一些选项。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-07-notifications.png" alt="通知中心"></p><p>Figure 121. 通知中心选项.</p><p>有两个选项，通过＂邮件(Email)＂和通过＂网页(Web)＂，你可以选用一个或者都不选或者都选。</p><h3 id="网页通知"><a href="#网页通知" class="headerlink" title="网页通知"></a>网页通知</h3><p>网页通知只在 GitHub 上存在，你也只能在 GitHub 上查看。 如果你打开了这个选项并且有一个你的通知，你会在你屏幕上方的通知图标上看到一个小蓝点。参见 <a href="https://git-scm.com/book/zh/v2/ch00/r_not_center" target="_blank" rel="noopener">通知中心.</a>。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-08-notifications-page.png" alt="通知中心"></p><p>Figure 122. 通知中心.</p><p>如果你点击那个玩意儿，你会看到你被通知到的所有条目，按照项目分好了组。 你可以点击左边栏的项目名字来过滤项目相关的通知。 你可以点击通知旁边的对号图标把通知标为已读，或者点击组上面的图标把项目中 <strong>所有的</strong> 通知标为已读。 在每个对号图标旁边都有一个静音按钮，你可以点一下，以后就不会收到它相关的通知。</p><p>所有这些工具对于处理大量通知非常有用。 很多 GitHub 资深用户都关闭邮件通知，在这个页面上处理他们所有的通知。</p><h3 id="邮件通知-1"><a href="#邮件通知-1" class="headerlink" title="邮件通知"></a>邮件通知</h3><p>邮件通知是你处理 GitHub 通知的另一种方式。 如果你打开这个选项，每当有通知时，你会收到一封邮件。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_notification" target="_blank" rel="noopener">通过电子邮件发送的评论提醒</a> 和 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_pr" target="_blank" rel="noopener">新的合并请求的邮件通知.</a> 看到了一些例子。 邮件也会被合适地按话题组织在一起，如果你使用一个具有会话功能的邮件客户端那会很方便。</p><p>GitHub 在发送给你的邮件头中附带了很多元数据，这对于设置过滤器和邮件规则非常有帮助。</p><p>举个例子，我们来看一看在 <a href="https://git-scm.com/book/zh/v2/ch00/r_email_pr" target="_blank" rel="noopener">新的合并请求的邮件通知.</a> 中发给 Tony 的一封真实邮件的头部，我们会看到下面这些：</p><pre class=" language-mbox"><code class="language-mbox">To: tonychacon/fade <fade@noreply.github.com>Message-ID: <tonychacon/fade/pull/1@github.com>Subject: [fade] Wait longer to see the dimming effect better (#1)X-GitHub-Recipient: tonychaconList-ID: tonychacon/fade <fade.tonychacon.github.com>List-Archive: https://github.com/tonychacon/fadeList-Post: <mailto:reply+i-4XXX@reply.github.com>List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>，...X-GitHub-Recipient-Address: tchacon@example.com</code></pre><p>这里有一些有趣的东西。 如果你想高亮或者转发这个项目甚至这个合并请求相关的邮件，<code>Message-ID</code> 中的信息会以 <code>&lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt;</code> 的格式展现所有的数据。 例如，如果这是一个问题(issue)，那么 <code>&lt;type&gt;</code> 字段就会是 “issues” 而不是 “pull” 。</p><p><code>List-Post</code> 和 <code>List-Unsubscribe</code> 字段表示如果你的邮件客户端能够处理这些，那么你可以很容易地在列表中发贴或取消对这个相关帖子的订阅。 那会很有效率，就像在页面中点击静音按钮或在问题／合并请求页面点击 “Unsubscribe” 一样。</p><p>值得注意的是，如果你同时打开了邮件和网页通知，那么当你在邮件客户端允许加载图片的情况下阅读邮件通知时，对应的网页通知也将会同时被标记为已读。</p><h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>如果你的版本库中有一些特殊文件，GitHub 会提醒你。</p><h3 id="README"><a href="#README" class="headerlink" title="README"></a>README</h3><p>第一个就是 <code>README</code> 文件，可以是几乎任何 GitHub 可以识别的格式。 例如，它可以是 <code>README</code> ，<code>README.md</code> ， <code>README.asciidoc</code> 。 如果 GitHub 在你的版本库中找到 README 文件，会把它在项目的首页渲染出来。</p><p>很多团队在这个文件里放版本库或项目新人需要了解的所有相关的信息。 它一般包含这些内容：</p><ul><li>该项目的作用</li><li>如何配置与安装</li><li>有关如何使用和运行的例子</li><li>项目的许可证</li><li>如何向项目贡献力量</li></ul><p>因为 GitHub 会渲染这个文件，你可以在文件里植入图片或链接让它更容易理解。</p><h3 id="贡献-CONTRIBUTING"><a href="#贡献-CONTRIBUTING" class="headerlink" title="贡献 CONTRIBUTING"></a>贡献 CONTRIBUTING</h3><p>另一个 GitHub 可以识别的特殊文件是 <code>CONTRIBUTING</code> 。 如果你有一个任意扩展名的 <code>CONTRIBUTING</code> 文件，当有人开启一个合并请求时 GitHub 会显示 <a href="https://git-scm.com/book/zh/v2/ch00/r_contrib_file" target="_blank" rel="noopener">开启合并请求时有 CONTRIBUTING 文件存在.</a>。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-09-contrib.png" alt="贡献注意事项"></p><p>Figure 123. 开启合并请求时有 CONTRIBUTING 文件存在.</p><p>这个的作用就是你可以在这里指出对于你的项目开启的合并请求你想要的／不想要的各种事情。 这样别人在开启合并请求之前可以读到这些指导方针。</p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>对于一个单个项目其实没有很多管理事务要做，但也有几点有趣的。</p><h4 id="改变默认分支"><a href="#改变默认分支" class="headerlink" title="改变默认分支"></a>改变默认分支</h4><p>如果你想用 “master” 之外的分支作为你的默认分支，其他人将默认会在这个分支上开启合并请求或进行浏览，你可以在你版本库的设置页面的 “options” 标签下修改。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-10-default-branch.png" alt="默认分支"></p><p>Figure 124. 改变项目的默认分支.</p><p>简单地改变默认分支下拉列表中的选项，它就会作为所有主要操作的默认分支，他人进行克隆时该分支也将被默认检出。</p><h4 id="移交项目"><a href="#移交项目" class="headerlink" title="移交项目"></a>移交项目</h4><p>如果你想把一个项目移交给 GitHub 中的另一个人或另一个组织，还是设置页面的这个 ＂options＂标签下有一个 “Transfer ownership” 选项可以用来干这个。</p><p><img src="https://git-scm.com/book/en/v2/images/maint-11-transfer.png" alt="移交"></p><p>Figure 125. 把项目移交给另一个 GitHub 用户或组织。</p><p>当你正准备放弃一个项目且正好有别人想要接手时，或者你的项目壮大了想把它移到一个组织里时，这就管用了。</p><p>这么做不仅会把版本库连带它所有的观察和星标数都移到另一个地方，它还会将你的 URL 重定向到新的位置。 它也重定向了来自 Git 的克隆和抓取，而不仅仅是网页端请求。</p><h2 id="管理组织"><a href="#管理组织" class="headerlink" title="管理组织"></a>管理组织</h2><p>除了个人帐户之外，GitHub 还提供被称为组织（Organizations）的帐户。 组织账户和个人账户一样都有一个用于存放所拥有项目的命名空间，但是许多其他的东西都是不同的。 组织帐户代表了一组共同拥有多个项目的人，同时也提供一些工具用于对成员进行分组管理。 通常，这种账户被用于开源群组（例如：“perl”或者“rails”），或者公司（例如：“google”或者“twitter”）。</p><h3 id="组织的基本知识"><a href="#组织的基本知识" class="headerlink" title="组织的基本知识"></a>组织的基本知识</h3><p>我们可以很简单地创建一个组织，只需要点击任意 GitHub 页面右上角的“+”图标，在菜单中选择“New organization”即可。</p><p><img src="https://git-scm.com/book/en/v2/images/neworg.png" alt="``New organization&#39;&#39;菜单项"></p><p>Figure 126. ‘`New organization’’菜单项</p><p>首先你必须提供组织的名称和组织的主要联系邮箱。 然后，如果你希望的话，也可以邀请其他用户作为共同拥有人。</p><p>完成以上步骤后，你就会拥有一个全新的组织。 类似于个人帐户，如果组织的所有内容都是开源的，那么你就可以免费使用这个组织。</p><p>作为一个组织的拥有者，当你在派生一个版本库的时候，你可以选择把它派生到你的组织的命名空间内。 当你新建版本库时，你可以把它存放到你的个人帐户或你拥有的组织内。 同时，你也会自动地“关注”所有这些组织内的新版本库。</p><p>就像<a href="https://git-scm.com/book/zh/v2/ch00/r_personal_avatar" target="_blank" rel="noopener">头像</a>，你可以为你的组织上传头像，使它更个性化。 同时，也和个人帐户类似，组织会有一个着陆页（landing page），用于列出该组织所有的版本库，并且该页面可供所有人浏览。</p><p>下面我们来说一些组织和个人帐户不同的地方。</p><h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>组织使用团队（Teams）来管理成员，团队就是组织中的一组个人账户和版本库，以及团队成员对这些版本库的访问权限。</p><p>例如，假设你的公司有三个版本库：<code>frontend</code>、<code>backend</code> 和 <code>deployscripts</code>。 你会希望你的 HTML/CSS/Javascript 开发者有 <code>frontend</code> 或者 <code>backend</code> 的访问权限，操作人员有 <code>backend</code> 和 <code>deployscripts</code> 的访问权限。 团队让这个任务变得更简单，而不用为每个版本库管理它的协作者。</p><p>组织页面主要由一个面板（dashboard）构成，这个仪表盘包含了这个组织内的所有版本库，用户和团队。</p><p><img src="https://git-scm.com/book/en/v2/images/orgs-01-page.png" alt="组织页面"></p><p>Figure 127. 组织页面</p><p>你可以点击 <a href="https://git-scm.com/book/zh/v2/ch00/r_org_page" target="_blank" rel="noopener">组织页面</a> 右边的团队侧边栏（Teams）来管理你的团队。 点击之后，你会进入一个新页面，在这里你可以添加新成员和版本库到团队中，或者管理团队的访问权限和其它设置。 每个团队对于版本库可以有只读、读写和管理三种权限。 你可以通过点击在 <a href="https://git-scm.com/book/zh/v2/ch00/r_team_page" target="_blank" rel="noopener">团队页面</a> 内的 “Settings” 按钮更改相应权限等级。</p><p><img src="https://git-scm.com/book/en/v2/images/orgs-02-teams.png" alt="团队页面"></p><p>Figure 128. 团队页面</p><p>当你邀请一个用户加入团队，该用户会收到一封通知他被邀请的邮件。</p><p>除此之外，团队也类似于个人帐户，有 <code>@mentions</code>（例如：<code>@acmecorp/frontend</code>）的功能，不同之处就在于被提及的团队内 <strong>所有</strong> 成员都会成为这个话题的订阅者。 当你希望得到团队中某个人的关注，又不知道具体应该问谁的时候，这个功能就显得很有帮助。</p><p>一个用户可以加入任意数量的团队，所以别把自己局限于拥有访问控制的团队。 对于某一类课题，像 <code>ux</code>, <code>css</code> 或者 <code>refactoring</code> 这样有着特殊关注点的团队就显得很有帮助，而像 <code>legal</code> 和 <code>colorblind</code> 这样的就完全是针对它们各自领域的。</p><h3 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h3><p>组织的拥有者还可以访问组织中发生的事情的所有信息。 在 <em>Audit Log</em> 标签页有整个组织的日志，你可以看到谁在世界上哪个地方做了什么事。</p><p><img src="https://git-scm.com/book/en/v2/images/orgs-03-audit.png" alt="orgs 03 audit"></p><p>Figure 129. 审计日志</p><p>你也可以通过选定某一类型的事件、某个地方、某个人对日志进行过滤。</p><h2 id="脚本-GitHub"><a href="#脚本-GitHub" class="headerlink" title="脚本 GitHub"></a>脚本 GitHub</h2><p>所以现在我们已经介绍了 GitHub 的大部分功能与工作流程，但是任意一个小组或项目都会去自定义，因为他们想要创造或扩展想要整合的服务。</p><p>对我们来说很幸运的是，GitHub 在许多方面都真的很方便 Hack。 在本节中我们将会介绍如何使用 GitHub 钩子系统与 API 接口，使 GitHub 按照我们的设想来工作。</p><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>GitHub 仓库管理中的钩子与服务区块是 GitHub 与外部系统交互最简单的方式。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>首先我们来看一下服务。 钩子与服务整合都可以在仓库的设置区块中找到，就在我们之前添加协作者与改变项目的默认分支的地方。 在 “Webhooks and Services” 标签下你会看到与 <a href="https://git-scm.com/book/zh/v2/ch00/r_services_hooks" target="_blank" rel="noopener">服务与钩子配置区域</a> 类似的内容。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-01-services.png" alt="服务与钩子"></p><p>Figure 130. 服务与钩子配置区域</p><p>有许多可以选择的服务，大多数是整合到其他的商业与开源系统中。 它们中的大多数是为了整合持续集成服务、BUG 与问题追踪系统、聊天室系统与文档系统。 我们将会通过设置一个非常简单的例子来介绍。 如果从 “Add Service” 选择 “email”，会得到一个类似 <a href="https://git-scm.com/book/zh/v2/ch00/r_service_config" target="_blank" rel="noopener">电子邮件服务配置</a> 的配置屏幕。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-02-email-service.png" alt="电子邮件服务"></p><p>Figure 131. 电子邮件服务配置</p><p>在本例中，如果我们点击 “Add service” 按钮，每次有人推送内容到仓库时，指定的电子邮件地址都会收到一封邮件。 服务可以监听许多不同类型的事件，但是大多数只监听推送事件然后使用那些数据做一些事情。</p><p>如果有一个正在使用的系统想要整合到 GitHub，应当先检查这里看有没有已有的可用的服务整合。 例如，如果正使用 Jenkins 来测试你的代码库，当每次有人推送到你的仓库时你可以启用 Jenkins 内置的整合启动测试运行。</p><h4 id="钩子-1"><a href="#钩子-1" class="headerlink" title="钩子"></a>钩子</h4><p>如果需要做一些更具体的事，或者想要整合一个不在这个列表中的服务或站点，可以转而使用更通用的钩子系统。 GitHub 仓库钩子是非常简单的。 指定一个 URL 然后 GitHub 在任一期望的事件发生时就会发送一个 HTTP 请求到那个 URL 。</p><p>通常做这件事的方式是可以设置一个小的 web 服务来监听 GitHub 钩子请求然后使用收到的数据做一些事情。</p><p>为了启用一个钩子，点击 <a href="https://git-scm.com/book/zh/v2/ch00/r_services_hooks" target="_blank" rel="noopener">服务与钩子配置区域</a> 中的 “Add webhook” 按钮。 这会将你引导至一个类似 <a href="https://git-scm.com/book/zh/v2/ch00/r_web_hook" target="_blank" rel="noopener">Web 钩子配置</a> 的页面。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-03-webhook.png" alt="Web 钩子配置"></p><p>Figure 132. Web 钩子配置</p><p>Web 钩子的设置非常简单。 大多数情况下只需要输入一个 URL 与一个密钥然后点击 “Add webhook”。 有几个选项可以指定在哪个事件时想要 GitHub 发送请求 — 默认的行为是只有当某人推送新代码到仓库的任一分支时的 <code>push</code> 事件获得一个请求。</p><p>让我们看一个设置处理 web 钩子的 web 服务的小例子。 我们将会使用 Ruby web 框架 Sinatra，因为它相当简洁，应该能够轻松地看到我们正在做什么。</p><p>假设我们想要在某个特定的人推送到我们的项目的特定分支并修改一个特定文件时得到一封邮件。 我们可以相当容易地使用类似下面的代码做到：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'sinatra'</span><span class="token keyword">require</span> <span class="token string">'json'</span><span class="token keyword">require</span> <span class="token string">'mail'</span>post <span class="token string">'/payload'</span> <span class="token keyword">do</span>  push <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">.</span>read<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># parse the JSON</span>  <span class="token comment" spellcheck="true"># gather the data we're looking for</span>  pusher <span class="token operator">=</span> push<span class="token punctuation">[</span><span class="token string">"pusher"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span>  branch <span class="token operator">=</span> push<span class="token punctuation">[</span><span class="token string">"ref"</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># get a list of all the files touched</span>  files <span class="token operator">=</span> push<span class="token punctuation">[</span><span class="token string">"commits"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>map <span class="token keyword">do</span> <span class="token operator">|</span>commit<span class="token operator">|</span>    commit<span class="token punctuation">[</span><span class="token string">'added'</span><span class="token punctuation">]</span> <span class="token operator">+</span> commit<span class="token punctuation">[</span><span class="token string">'modified'</span><span class="token punctuation">]</span> <span class="token operator">+</span> commit<span class="token punctuation">[</span><span class="token string">'removed'</span><span class="token punctuation">]</span>  <span class="token keyword">end</span>  files <span class="token operator">=</span> files<span class="token punctuation">.</span>flatten<span class="token punctuation">.</span>uniq  <span class="token comment" spellcheck="true"># check for our criteria</span>  <span class="token keyword">if</span> pusher <span class="token operator">==</span> <span class="token string">'schacon'</span> <span class="token operator">&amp;&amp;</span>     branch <span class="token operator">==</span> <span class="token string">'ref/heads/special-branch'</span> <span class="token operator">&amp;&amp;</span>     files<span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span><span class="token string">'special-file.txt'</span><span class="token punctuation">)</span>    <span class="token constant">Mail</span><span class="token punctuation">.</span>deliver <span class="token keyword">do</span>      from     <span class="token string">'tchacon@example.com'</span>      to       <span class="token string">'tchacon@example.com'</span>      subject  <span class="token string">'Scott Changed the File'</span>      body     <span class="token string">"ALARM"</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>这里我们拿到一个 GitHub 传送给我们的 JSON 请求然后查找推送者，他们推送到了什么分支以及推送的所有提交都改动了哪些文件。 然后我们检查它是否与我们的条件区配，如果匹配则发送一封邮件。</p><p>为了开发与测试类似这样的东西，在设置钩子的地方有一个漂亮的开发者控制台。 可以看到 GitHub 为那个 webhook 的最后几次请求。 对每一个钩子，当它发送后都可以深入挖掘，检测它是否是成功的与请求及回应的消息头与消息体。 这使得测试与调试钩子非常容易。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-04-webhook-debug.png" alt="Web 钩子调试信息"></p><p>Figure 133. Web 钩子调试信息</p><p>开发者控制台的另一个很棒的功能是可以轻松地重新发送任何请求来测试你的服务。</p><p>关于如何编写 web 钩子与所有可监听的不同事件类型的更多信息，请访问在 <a href="https://developer.github.com/webhooks/" target="_blank" rel="noopener">https://developer.github.com/webhooks/</a> 的 GitHub 开发者文档。</p><h3 id="GitHub-API"><a href="#GitHub-API" class="headerlink" title="GitHub API"></a>GitHub API</h3><p>服务与钩子给你提供了一种方式来接收关于在仓库中发生的事件的推送通知，但是如何获取相关事件的详情呢？如何自动化一些诸如添加协作者或给问题加标签的事情呢？</p><p>这是 GitHub API 派上用场的地方。 在自动化流行的趋势下，GitHub 提供了大量的 API 接口，可以进行几乎任何能在网站上进行的操作。 在本节中我们将会学习如何授权与连接到 API，如何通过 API 在一个问题上评论与如何修改一个 Pull Request 的状态。</p><h3 id="基本用途"><a href="#基本用途" class="headerlink" title="基本用途"></a>基本用途</h3><p>可以做的最基本的事情是向一个不需要授权的接口上发送一个简单的 GET 请求。 该接口可能是一个用户或开源项目的只读信息。 例如，如果我们想要知道更多关于名为 “schacon” 的用户信息，我们可以运行类似下面的东西：</p><pre class=" language-javascript"><code class="language-javascript">$ curl https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>users<span class="token operator">/</span>schacon<span class="token punctuation">{</span>  <span class="token string">"login"</span><span class="token punctuation">:</span> <span class="token string">"schacon"</span><span class="token punctuation">,</span>  <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">70</span><span class="token punctuation">,</span>  <span class="token string">"avatar_url"</span><span class="token punctuation">:</span> <span class="token string">"https://avatars.githubusercontent.com/u/70"</span><span class="token punctuation">,</span># …  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Scott Chacon"</span><span class="token punctuation">,</span>  <span class="token string">"company"</span><span class="token punctuation">:</span> <span class="token string">"GitHub"</span><span class="token punctuation">,</span>  <span class="token string">"following"</span><span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span>  <span class="token string">"created_at"</span><span class="token punctuation">:</span> <span class="token string">"2008-01-27T17:19:28Z"</span><span class="token punctuation">,</span>  <span class="token string">"updated_at"</span><span class="token punctuation">:</span> <span class="token string">"2014-06-10T02:37:23Z"</span><span class="token punctuation">}</span></code></pre><p>有大量类似这样的接口来获得关于组织、项目、问题、提交的信息 — 差不多就是你能在 GitHub 上看到的所有东西。 甚至可以使用 API 来渲染任意 Markdown 或寻找一个 <code>.gitignore</code> 模板。</p><pre class=" language-javascript"><code class="language-javascript">$ curl https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>gitignore<span class="token operator">/</span>templates<span class="token operator">/</span>Java<span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Java"</span><span class="token punctuation">,</span>  <span class="token string">"source"</span><span class="token punctuation">:</span> "<span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">class</span># Mobile Tools <span class="token keyword">for</span> Java <span class="token punctuation">(</span>J2ME<span class="token punctuation">)</span><span class="token punctuation">.</span>mtj<span class="token punctuation">.</span>tmp<span class="token operator">/</span># Package Files #<span class="token operator">*</span><span class="token punctuation">.</span>jar<span class="token operator">*</span><span class="token punctuation">.</span>war<span class="token operator">*</span><span class="token punctuation">.</span>ear# virtual machine crash logs<span class="token punctuation">,</span> see http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>java<span class="token punctuation">.</span>com<span class="token operator">/</span>en<span class="token operator">/</span>download<span class="token operator">/</span>help<span class="token operator">/</span>error_hotspot<span class="token punctuation">.</span>xmlhs_err_pid<span class="token operator">*</span>"<span class="token punctuation">}</span></code></pre><h3 id="在一个问题上评论"><a href="#在一个问题上评论" class="headerlink" title="在一个问题上评论"></a>在一个问题上评论</h3><p>然而，如果想要在网站上进行一个操作，如在 Issue 或 Pull Request 上评论，或者想要查看私有内容或与其交互，你需要授权。</p><p>这里提供了几种授权方式。 你可以使用仅需用户名与密码的基本授权，但是通常更好的主意是使用一个个人访问令牌。 可以从设置页的 “Applications” 标签生成访问令牌。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-05-access-token.png" alt="访问令牌"></p><p>Figure 134. 从设置页的 “Applications” 标签生成访问令牌。</p><p>它会询问这个令牌的作用域与一个描述。 确保使用一个好的描述信息，这样当脚本或应用不再使用时你会很放心地移除。</p><p>GitHub 只会显示令牌一次，所以记得一定要拷贝它。 现在可以在脚本中使用它代替使用用户名写密码来授权。 这很漂亮，因为可以限制想要做的范围并且令牌是可废除的。</p><p>这也会有一个提高频率上限的附加优点。 如果没有授权的话，你会被限制在一小时最多发起 60 次请求。 如果授权则可以一小时最多发起 5000 次请求。</p><p>所以让我们利用它来对我们的其中一个问题进行评论。 想要对一个特定问题 Issue #6 留下一条评论。 必须使用刚刚生成的令牌作为 Authorization 头信息，发送一个到 <code>repos/&lt;user&gt;/&lt;repo&gt;/issues/&lt;num&gt;/comments</code> 的 HTTP POST 请求。</p><pre class=" language-javascript"><code class="language-javascript">$ curl <span class="token operator">-</span>H <span class="token string">"Content-Type: application/json"</span> \       <span class="token operator">-</span>H <span class="token string">"Authorization: token TOKEN"</span> \       <span class="token operator">--</span>data <span class="token string">'{"body":"A new comment, :+1:"}'</span> \       https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>repos<span class="token operator">/</span>schacon<span class="token operator">/</span>blink<span class="token operator">/</span>issues<span class="token operator">/</span><span class="token number">6</span><span class="token operator">/</span>comments<span class="token punctuation">{</span>  <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">58322100</span><span class="token punctuation">,</span>  <span class="token string">"html_url"</span><span class="token punctuation">:</span> <span class="token string">"https://github.com/schacon/blink/issues/6#issuecomment-58322100"</span><span class="token punctuation">,</span>  <span class="token operator">...</span>  <span class="token string">"user"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"login"</span><span class="token punctuation">:</span> <span class="token string">"tonychacon"</span><span class="token punctuation">,</span>    <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">7874698</span><span class="token punctuation">,</span>    <span class="token string">"avatar_url"</span><span class="token punctuation">:</span> <span class="token string">"https://avatars.githubusercontent.com/u/7874698?v=2"</span><span class="token punctuation">,</span>    <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"User"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"created_at"</span><span class="token punctuation">:</span> <span class="token string">"2014-10-08T07:48:19Z"</span><span class="token punctuation">,</span>  <span class="token string">"updated_at"</span><span class="token punctuation">:</span> <span class="token string">"2014-10-08T07:48:19Z"</span><span class="token punctuation">,</span>  <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">"A new comment, :+1:"</span><span class="token punctuation">}</span></code></pre><p>现在如果进入到那个问题，可以看到我们刚刚发布的评论，像 <a href="https://git-scm.com/book/zh/v2/ch00/r_api_comment" target="_blank" rel="noopener">从 GitHub API 发布的一条评论</a> 一样。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-06-comment.png" alt="API 评论"></p><p>Figure 135. 从 GitHub API 发布的一条评论</p><p>可以使用 API 去做任何可以在网站上做的事情 — 创建与设置里程碑、指派人员到 Issues 与 Pull Requests，创建与修改标签、访问提交数据、创建新的提交与分支、打开关闭或合并 Pull Requests、创建与编辑团队、在 Pull Request 中评论某行代码、搜索网站等等。</p><h3 id="修改-Pull-Request-的状态"><a href="#修改-Pull-Request-的状态" class="headerlink" title="修改 Pull Request 的状态"></a>修改 Pull Request 的状态</h3><p>如果使用 Pull Requests 的话我们将要看到的最后一个例子会很有用。 每一个提交可以有一个或多个与它关联的状态，有 API 来添加与查询状态。</p><p>大多数持续集成与测试服务通过测试推送的代码后使用这个 API 来回应，然后报告提交是否通过了全部测试。 你也可以使用该接口来检查提交信息是否经过合适的格式化、提交者是否遵循了所有你的贡献准则、提交是否经过有效的签名 — 种种这类事情。</p><p>假设在仓库中设置了一个 web 钩子访问一个用来检查提交信息中的 <code>Signed-off-by</code> 字符串的小的 web 服务。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">require</span> <span class="token string">'httparty'</span><span class="token keyword">require</span> <span class="token string">'sinatra'</span><span class="token keyword">require</span> <span class="token string">'json'</span>post <span class="token string">'/payload'</span> <span class="token keyword">do</span>  push <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">.</span>read<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># parse the JSON</span>  repo_name <span class="token operator">=</span> push<span class="token punctuation">[</span><span class="token string">'repository'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'full_name'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># look through each commit message</span>  push<span class="token punctuation">[</span><span class="token string">"commits"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>commit<span class="token operator">|</span>    <span class="token comment" spellcheck="true"># look for a Signed-off-by string</span>    <span class="token keyword">if</span> <span class="token regex">/Signed-off-by/</span><span class="token punctuation">.</span>match commit<span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span>      state <span class="token operator">=</span> <span class="token string">'success'</span>      description <span class="token operator">=</span> <span class="token string">'Successfully signed off!'</span>    <span class="token keyword">else</span>      state <span class="token operator">=</span> <span class="token string">'failure'</span>      description <span class="token operator">=</span> <span class="token string">'No signoff found.'</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true"># post status to GitHub</span>    sha <span class="token operator">=</span> commit<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span>    status_url <span class="token operator">=</span> <span class="token string">"https://api.github.com/repos/<span class="token interpolation"><span class="token delimiter tag">#{</span>repo_name<span class="token delimiter tag">}</span></span>/statuses/<span class="token interpolation"><span class="token delimiter tag">#{</span>sha<span class="token delimiter tag">}</span></span>"</span>    status <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token string">"state"</span>       <span class="token operator">=</span><span class="token operator">></span> state<span class="token punctuation">,</span>      <span class="token string">"description"</span> <span class="token operator">=</span><span class="token operator">></span> description<span class="token punctuation">,</span>      <span class="token string">"target_url"</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"http://example.com/how-to-signoff"</span><span class="token punctuation">,</span>      <span class="token string">"context"</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"validate/signoff"</span>    <span class="token punctuation">}</span>    <span class="token constant">HTTParty</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>status_url<span class="token punctuation">,</span>      <span class="token symbol">:body</span> <span class="token operator">=</span><span class="token operator">></span> status<span class="token punctuation">.</span>to_json<span class="token punctuation">,</span>      <span class="token symbol">:headers</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token string">'Content-Type'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'application/json'</span><span class="token punctuation">,</span>        <span class="token string">'User-Agent'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'tonychacon/signoff'</span><span class="token punctuation">,</span>        <span class="token string">'Authorization'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"token <span class="token interpolation"><span class="token delimiter tag">#{</span>ENV<span class="token punctuation">[</span><span class="token string">'TOKEN'</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>"</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>希望这相当容易做。 在这个 web 钩子处理器中我们浏览刚刚推送上来的每一个提交，在提交信息中查找字符串 <em>Signed-off-by</em> 并且最终使用 HTTP 向 <code>/repos/&lt;user&gt;/&lt;repo&gt;/statuses/&lt;commit_sha&gt;</code> API 接口发送一个带有状态的 POST 请求。</p><p>在本例中可以发送一个状态（<em>success</em>, <em>failure</em>, <em>error</em>）、一个发生了什么的描述信息、一个用户可以了解更多信息的目标 URL 与一个 “context” 以防一个单独的提交有多个状态。 例如，一个测试服务可以提供一个状态与一个类似这样的验证服务也可能提供一个状态 — “context” 字段是用来区别它们的。</p><p>如果某人在 GitHub 中打开了一个新的 Pull Request 并且这个钩子已经设置，会看到类似 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_status" target="_blank" rel="noopener">通过 API 的提交状态</a> 的信息。</p><p><img src="https://git-scm.com/book/en/v2/images/scripting-07-status.png" alt="提交状态"></p><p>Figure 136. 通过 API 的提交状态</p><p>现在可以看到一个小的绿色对勾标记在提交信息中有 “Signed-off-by” 的提交旁边，红色的对勾标记在作者忘记签名的提交旁边。 也可以看到 Pull Request 显示在那个分支上的最后提交的状态，如果失败的话会警告你。 如果对测试结果使用这个 API 那么就不会不小心合并某些未通过测试的最新提交。</p><h3 id="Octokit"><a href="#Octokit" class="headerlink" title="Octokit"></a>Octokit</h3><p>尽管我们在这些例子中都是通过 <code>curl</code> 与基本的 HTTP 请求来做几乎所有的事情，还有一些以更自然的方式利用 API 的开源库存在着。 在写这篇文章的时候，被支持的语言包括 Go、Objective-C、Ruby 与 .NET。 访问 <a href="http://github.com/octokit" target="_blank" rel="noopener">http://github.com/octokit</a> 了解更多相关信息，它们帮你处理了更多 HTTP 相关的内容。</p><p>希望这些工具能帮助你自定义与修改 GitHub 来更好地为特定的工作流程工作。 关于全部 API 的完整文档与常见任务的指南，请查阅 <a href="https://developer.github.com/" target="_blank" rel="noopener">https://developer.github.com</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在你已经是一名 GitHub 用户了。 你知道了如何创建账户、管理组织、创建和推送版本库、向别人的项目提供贡献以及接受别人的贡献。 在下一章中，你将学习更多强有力的工具，以及处理复杂情况的知识，这些将使你成为真正的 Git 大师。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式Git</title>
      <link href="/2019/07/15/%E5%88%86%E5%B8%83%E5%BC%8FGit/"/>
      <url>/2019/07/15/%E5%88%86%E5%B8%83%E5%BC%8FGit/</url>
      
        <content type="html"><![CDATA[<p>你现在拥有了一个远程 Git 版本库，能为所有开发者共享代码提供服务，在一个本地工作流程下，你也已经熟悉了基本 Git 命令。你现在可以学习如何利用 Git 提供的一些分布式工作流程了。</p><p>这一章中，你将会学习如何作为贡献者或整合者，在一个分布式协作的环境中使用 Git。 你会学习为一个项目成功地贡献代码，并接触一些最佳实践方式，让你和项目的维护者能轻松地完成这个过程。另外，你也会学到如何管理有很多开发者提交贡献的项目。</p><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>同传统的集中式版本控制系统（CVCS）不同，Git 的分布式特性使得开发者间的协作变得更加灵活多样。 在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。 而在 Git 中，每个开发者同时扮演着节点和集线器的角色——也就是说，每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码。 由此，Git 的分布式协作可以为你的项目和团队衍生出种种不同的工作流程，接下来的章节会介绍几种利用了 Git 的这种灵活性的常见应用方式。 我们将讨论每种方式的优点以及可能的缺点；你可以选择使用其中的某一种，或者将它们的特性混合搭配使用。</p><h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>集中式系统中通常使用的是单点协作模型——集中式工作流。 一个中心集线器，或者说仓库，可以接受代码，所有人将自己的工作与之同步。 若干个开发者则作为节点——也就是中心仓库的消费者——并且与其进行同步。</p><p><img src="https://git-scm.com/book/en/v2/images/centralized_workflow.png" alt="集中式工作流。"></p><p>Figure 54. 集中式工作流。</p><p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。</p><p>如果在公司或者团队中，你已经习惯了使用这种集中式工作流程，完全可以继续采用这种简单的模式。 只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。Git 不会让用户覆盖彼此的修改。 例如 John 和 Jessica 同时开始工作。 John 完成了他的修改并推送到服务器。 接着 Jessica 尝试提交她自己的修改，却遭到服务器拒绝。 她被告知她的修改正通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。 这种模式的工作流程的使用非常广泛，因为大多数人对其很熟悉也很习惯。</p><p>当然这并不局限于小团队。 利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好地在单个项目上协作。</p><h3 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表`‘官方’’项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示（见 <a href="https://git-scm.com/book/zh/v2/ch00/rwfdiag_b" target="_blank" rel="noopener">集成管理者工作流。</a>）：</p><ol><li>项目维护者推送到主仓库。</li><li>贡献者克隆此仓库，做出修改。</li><li>贡献者将数据推送到自己的公开仓库。</li><li>贡献者给维护者发送邮件，请求拉取自己的更新。</li><li>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</li><li>维护者将合并后的修改推送到主仓库。</li></ol><p><img src="https://git-scm.com/book/en/v2/images/integration-manager.png" alt="集成管理者工作流。"></p><p>Figure 55. 集成管理者工作流。</p><p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目派生成为自己的公开仓库，向这个仓库推送自己的修改，并为每个人所见。 这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。 贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己的节奏工作。</p><h3 id="司令官与副官工作流"><a href="#司令官与副官工作流" class="headerlink" title="司令官与副官工作流"></a>司令官与副官工作流</h3><p>这其实是多仓库工作流程的变种。 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。 所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。 司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的(见 <a href="https://git-scm.com/book/zh/v2/ch00/rwfdiag_c" target="_blank" rel="noopener">司令官与副官工作流。</a>):</p><ol><li>普通开发者在自己的特性分支上工作，并根据 <code>master</code> 分支进行变基。 这里是司令官的 <code>master</code> 分支。</li><li>副官将普通开发者的特性分支合并到自己的 <code>master</code> 分支中。</li><li>司令官将所有副官的 <code>master</code> 分支并入自己的 <code>master</code> 分支中。</li><li>司令官将集成后的 <code>master</code> 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。</li></ol><p><img src="https://git-scm.com/book/en/v2/images/benevolent-dictator.png" alt="司令官与副官工作流。"></p><p>Figure 56. 司令官与副官工作流。</p><p>这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。 利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来，用于之后的整合。</p><h3 id="工作流程总结"><a href="#工作流程总结" class="headerlink" title="工作流程总结"></a>工作流程总结</h3><p>上面介绍了在 Git 等分布式系统中经常使用的工作流程，但是在实际的开发中，你会遇到许多可能适合你的特定工作流程的变种。 现在你应该已经清楚哪种工作流程组合可能比较适合你了，我们会给出一些如何扮演不同工作流程中主要角色的更具体的例子。 下一节我们将会学习为项目做贡献的一些常用模式。</p><h2 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h2><p>描述如何向一个项目贡献的主要困难在于完成贡献有很多不同的方式。 因为 Git 非常灵活，人们可以通过不同的方式来一起工作，所以描述应该如何贡献并不是非常准确 - 每一个项目都有一点儿不同。 影响因素包括活跃贡献者的数量、选择的工作流程、提交权限与可能包含的外部贡献方法。</p><p>第一个影响因素是活跃贡献者的数量 - 积极地向这个项目贡献代码的用户数量以及他们的贡献频率。 在许多情况下，你可能会有两三个开发者一天提交几次，对于不活跃的项目可能更少。 对于大一些的公司或项目，开发者的数量可能会是上千，每天都有成百上千次提交。 这很重要，因为随着开发者越来越多，在确保你的代码能干净地应用或轻松地合并时会遇到更多问题。 提交的改动可能表现为过时的，也可能在你正在做改动或者等待改动被批准应用时被合并入的工作严重损坏。 如何保证代码始终是最新的，并且提交始终是有效的？</p><p>下一个影响因素是项目使用的工作流程。 它是中心化的吗，即每一个开发者都对主线代码有相同的写入权限？ 项目是否有一个检查所有补丁的维护者或整合者？ 是否所有的补丁是同行评审后批准的？ 你是否参与了那个过程？ 是否存在副官系统，你必须先将你的工作提交到上面？</p><p>下一个问题是提交权限。 是否有项目的写权限会使向项目贡献所需的流程有极大的不同。 如果没有写权限，项目会选择何种方式接受贡献的工作？ 是否甚至有一个如何贡献的规范？ 你一次贡献多少工作？ 你多久贡献一次？</p><p>所有这些问题都会影响实际如何向一个项目贡献，以及对你来说哪些工作流程更适合或者可用。 我们将会由浅入深，通过一系列用例来讲述其中的每一个方面；从这些例子应该能够建立实际中你需要的特定工作流程。</p><h3 id="提交准则"><a href="#提交准则" class="headerlink" title="提交准则"></a>提交准则</h3><p>在我们开始查看特定的用例前，这里有一个关于提交信息的快速说明。 有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易。 Git 项目提供了一个文档，其中列举了关于创建提交到提交补丁的若干好的提示 - 可以在 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件中阅读它。</p><p>首先，你不会想要把空白错误（根据 git help diff 的描述，结合下面给出的图片，空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为）提交上去。 Git 提供了一个简单的方式来检查这点 - 在提交前，运行 <code>git diff --check</code>，它将会找到可能的空白错误并将它们为你列出来。</p><p><img src="https://git-scm.com/book/en/v2/images/git-diff-check.png" alt="`git diff --check` 的输出。"></p><p>Figure 57. <code>git diff --check</code> 的输出</p><p>如果在提交前运行那个命令，可以知道提交中是否包含可能会使其他开发者恼怒的空白问题。</p><p>接下来，尝试让每一个提交成为一个逻辑上的独立变更集。 如果可以，尝试让改动可以理解 - 不要在整个周末编码解决五个问题，然后在周一时将它们提交为一个巨大的提交。 即使在周末期间你无法提交，在周一时使用暂存区域将你的工作最少拆分为每个问题一个提交，并且为每一个提交附带一个有用的信息。 如果其中一些改动修改了同一个文件，尝试使用 <code>git add --patch</code> 来部分暂存文件（在 <a href="https://git-scm.com/book/zh/v2/ch00/r_interactive_staging" target="_blank" rel="noopener">交互式暂存</a> 中有详细介绍）。 不管你做一个或五个提交，只要所有的改动是在同一时刻添加的，项目分支末端的快照就是独立的，使同事开发者必须审查你的改动时尽量让事情容易些。 当你之后需要时这个方法也会使拉出或还原一个变更集更容易些。 <a href="https://git-scm.com/book/zh/v2/ch00/r_rewriting_history" target="_blank" rel="noopener">重写历史</a> 描述了重写历史与交互式暂存文件的若干有用的 Git 技巧 - 在将工作发送给其他人前使用这些工具来帮助生成一个干净又易懂的历史。</p><p>最后一件要牢记的事是提交信息。 有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。 一般情况下，信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。 Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比 - 这是一个值得遵循的好规则。 在这些信息中使用现在时态祈使语气也是一个好想法。 换句话说，使用命令。 使用 “Add tests for.” 而不是 “I added tests for” 或 “Adding tests for,”。 这里是一份最初由 Tim Pope 写的模板：</p><pre class=" language-text"><code class="language-text">修改的摘要（50 个字符或更少）如果必要的话，加入更详细的解释文字。在大概 72 个字符的时候换行。在某些情形下，第一行被当作一封电子邮件的标题，剩下的文本作为正文。分隔摘要与正文的空行是必须的（除非你完全省略正文）；如果你将两者混在一起，那么类似变基等工具无法正常工作。空行接着更进一步的段落。  - 句号也是可以的。  - 项目符号可以使用典型的连字符或星号    前面一个空格，之间用空行隔开，    但是可以依据不同的惯例有所不同。</code></pre><p>如果你所有的提交信息看起来都像这样，对你与跟你工作在一起的其他开发者来说事情会变得非常容易。 Git 项目有一个良好格式化的提交信息 - 尝试在那儿运行 <code>git log --no-merges</code> 来看看漂亮的格式化的项目提交历史像什么样。</p><p>在接下来的例子中，以及贯穿本书大部分，出于简洁性的原因本书不会有像这样漂亮格式的信息；相反，我们使用 <code>-m</code> 选项的 <code>git commit</code>。 照我们说的做，而不是照我们做的做。</p><h3 id="私有小型团队"><a href="#私有小型团队" class="headerlink" title="私有小型团队"></a>私有小型团队</h3><p>你可能会遇到的最简单的配置是有一两个其他开发者的私有项目。 “私有” 在这个上下文中，意味着闭源 - 不可以从外面的世界中访问到。 你和其他的开发者都有仓库的推送权限。</p><p>在这个环境下，可以采用一个类似使用 Subversion 或其他集中式的系统时会使用的工作流程。 依然可以得到像离线提交、非常容易地新建分支与合并分支等高级功能，但是工作流程可以是很简单的；主要的区别是合并发生在客户端这边而不是在提交时发生在服务器那边。 让我们看看当两个开发者在一个共享仓库中一起工作时会是什么样子。 第一个开发者，John，克隆了仓库，做了改动，然后本地提交。 （为了缩短这些例子长度，协议信息已被替换为 <code>...</code>。）</p><pre class=" language-console"><code class="language-console"># John's Machine$ git clone john@githost:simplegit.gitInitialized empty Git repository in /home/john/simplegit/.git/...$ cd simplegit/$ vim lib/simplegit.rb$ git commit -am 'removed invalid default value'[master 738ee87] removed invalid default value 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre><p>第二个开发者，Jessica，做了同样的事情 - 克隆仓库并提交了一个改动：</p><pre class=" language-console"><code class="language-console"># Jessica's Machine$ git clone jessica@githost:simplegit.gitInitialized empty Git repository in /home/jessica/simplegit/.git/...$ cd simplegit/$ vim TODO$ git commit -am 'add reset task'[master fbff5bc] add reset task 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre><p>现在，Jessica 把她的工作推送到服务器上：</p><pre class=" language-console"><code class="language-console"># Jessica's Machine$ git push origin master...To jessica@githost:simplegit.git   1edee6b..fbff5bc  master -> master</code></pre><p>John 也尝试推送他的改动：</p><pre class=" language-console"><code class="language-console"># John's Machine$ git push origin masterTo john@githost:simplegit.git ! [rejected]        master -> master (non-fast forward)error: failed to push some refs to 'john@githost:simplegit.git'</code></pre><p>不允许 John 推送是因为在同一时间 Jessica 已经推送了。 如果之前习惯于用 Subversion 那么理解这点特别重要，因为你会注意到两个开发者并没有编辑同一个文件。 尽管 Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你在本地合并提交。 John 必须抓取 Jessica 的改动并合并它们，才能被允许推送。</p><pre class=" language-console"><code class="language-console">$ git fetch origin...From john@githost:simplegit + 049d078...fbff5bc master     -> origin/master</code></pre><p>在这个时候，John 的本地仓库看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-1.png" alt="John 的分叉历史。"></p><p>Figure 58. John 的分叉历史</p><p>John 有一个引用指向 Jessica 推送上去的改动，但是他必须将它们合并入自己的工作中之后才能被允许推送。</p><pre class=" language-console"><code class="language-console">$ git merge origin/masterMerge made by recursive. TODO |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre><p>合并进行地很顺利 - John 的提交历史现在看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-2.png" alt="合并了 `origin/master` 之后 John 的仓库。"></p><p>Figure 59. 合并了 <code>origin/master</code> 之后 John 的仓库</p><p>现在，John 可以测试代码，确保它依然正常工作，然后他可以把合并的新工作推送到服务器上：</p><pre class=" language-console"><code class="language-console">$ git push origin master...To john@githost:simplegit.git   fbff5bc..72bbc59  master -> master</code></pre><p>最终，John 的提交历史看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-3.png" alt="推送到 `origin` 服务器后 John 的历史。"></p><p>Figure 60. 推送到 <code>origin</code> 服务器后 John 的历史</p><p>在此期间，Jessica 在一个特性分支上工作。 她创建了一个称作 <code>issue54</code> 的特性分支并且在那个分支上做了三次提交。 她还没有抓取 John 的改动，所以她的提交历史看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-4.png" alt="Jessica 的特性分支。"></p><p>Figure 61. Jessica 的特性分支</p><p>Jessica 想要与 John 同步，所以她进行了抓取操作：</p><pre class=" language-console"><code class="language-console"># Jessica's Machine$ git fetch origin...From jessica@githost:simplegit   fbff5bc..72bbc59  master     -> origin/master</code></pre><p>那会同时拉取 John 推送的工作。 Jessica 的历史现在看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-5.png" alt="抓取 John 的改动后 Jessica 的历史。"></p><p>Figure 62. 抓取 John 的改动后 Jessica 的历史</p><p>Jessica 认为她的特性分支已经准备好了，但是她想要知道必须合并什么进入她的工作才能推送。 她运行 <code>git log</code> 来找出：</p><pre class=" language-console"><code class="language-console">$ git log --no-merges issue54..origin/mastercommit 738ee872852dfaa9d6634e0dea7a324040193016Author: John Smith <jsmith@example.com>Date:   Fri May 29 16:01:27 2009 -0700   removed invalid default value</code></pre><p><code>issue54..origin/master</code> 语法是一个日志过滤器，要求 Git 只显示所有在后面分支（在本例中是 <code>origin/master</code>）但不在前面分支（在本例中是 <code>issue54</code>）的提交的列表。 我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_commit_ranges" target="_blank" rel="noopener">提交区间</a> 中详细介绍这个语法。</p><p>目前，我们可以从输出中看到有一个 John 生成的但是 Jessica 还没有合并入的提交。 如果她合并 <code>origin/master</code>，也就是说将会修改她的本地工作的那个单个提交。</p><p>现在，Jessica 可以合并她的特性工作到她的 master 分支，合并 John 的工作（<code>origin/master</code>）进入她的 <code>master</code> 分支，然后再次推送回服务器。 首先，为了整合所有这些工作她切换回她的 master 分支。</p><pre class=" language-console"><code class="language-console">$ git checkout masterSwitched to branch 'master'Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</code></pre><p>她既可以先合并 <code>origin/master</code> 也可以先合并 <code>issue54</code> - 它们都是上游，所以顺序并没有关系。 不论她选择的顺序是什么最终的结果快照是完全一样的；只是历史会有一点轻微的区别。 她选择先合并入 <code>issue54</code>：</p><pre class=" language-console"><code class="language-console">$ git merge issue54Updating fbff5bc..4af4298Fast forward README           |    1 + lib/simplegit.rb |    6 +++++- 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre><p>没有发生问题；如你所见它是一次简单的快进。 现在 Jessica 合并入 John 的工作（<code>origin/master</code>）：</p><pre class=" language-console"><code class="language-console">$ git merge origin/masterAuto-merging lib/simplegit.rbMerge made by recursive. lib/simplegit.rb |    2 +- 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre><p>每一个文件都干净地合并了，Jessica 的历史看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-6.png" alt="合并了 John 的改动后 Jessica 的历史。"></p><p>Figure 63. 合并了 John 的改动后 Jessica 的历史</p><p>现在 <code>origin/master</code> 是可以从 Jessica 的 <code>master</code> 分支到达的，所以她应该可以成功地推送（假设同一时间 John 并没有再次推送）：</p><pre class=" language-console"><code class="language-console">$ git push origin master...To jessica@githost:simplegit.git   72bbc59..8059c15  master -> master</code></pre><p>每一个开发者都提交了几次并成功地合并了其他人的工作。</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-7.png" alt="推送所有的改动回服务器后 Jessica 的历史。"></p><p>Figure 64. 推送所有的改动回服务器后 Jessica 的历史</p><p>这是一个最简单的工作流程。 你通常在一个特性分支工作一会儿，当它准备好整合时合并回你的 master 分支。 当想要共享工作时，将其合并回你自己的 master 分支，如果有改动的话然后抓取并合并 <code>origin/master</code>，最终推送到服务器上的 <code>master</code> 分支。 通常顺序像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/small-team-flow.png" alt="一个简单的多人 Git 工作流程的通常事件顺序。"></p><p>Figure 65. 一个简单的多人 Git 工作流程的通常事件顺序</p><h3 id="私有管理团队"><a href="#私有管理团队" class="headerlink" title="私有管理团队"></a>私有管理团队</h3><p>在接下来的情形中，你会看到大型私有团队中贡献者的角色。 在你将学习到的这种工作环境中，小组基于特性进行协作，这些团队的贡献将会由其他人整合。</p><p>让我们假设 John 与 Jessica 在一个特性上工作，同时 Jessica 与 Josie 在第二个特性上工作。 在本例中，公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，主仓库的 <code>master</code> 分支只能被那些工程师更新。 在这种情况下，所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起。</p><p>因为 Jessica 在两个特性上工作，并且平行地与两个不同的开发者协作，让我们跟随她的工作流程。 假设她已经克隆了仓库，首先决定在 <code>featureA</code> 上工作。 她为那个特性创建了一个新分支然后在那做了一些工作：</p><pre class=" language-console"><code class="language-console"># Jessica's Machine$ git checkout -b featureASwitched to a new branch 'featureA'$ vim lib/simplegit.rb$ git commit -am 'add limit to log function'[featureA 3300904] add limit to log function 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre><p>在这个时候，她需要将工作共享给 John，所以她推送了 <code>featureA</code> 分支的提交到服务器上。 Jessica 没有 <code>master</code> 分支的推送权限 - 只有整合者有 - 所以为了与 John 协作必须推送另一个分支。</p><pre class=" language-console"><code class="language-console">$ git push -u origin featureA...To jessica@githost:simplegit.git * [new branch]      featureA -> featureA</code></pre><p>Jessica 向 John 发邮件告诉他已经推送了一些工作到 <code>featureA</code> 分支现在可以看一看。 当她等待 John 的反馈时，Jessica 决定与 Josie 开始在 <code>featureB</code> 上工作。 为了开始工作，她基于服务器的 <code>master</code> 分支开始了一个新分支。</p><pre class=" language-console"><code class="language-console"># Jessica's Machine$ git fetch origin$ git checkout -b featureB origin/masterSwitched to a new branch 'featureB'</code></pre><p>现在，Jessica 在 <code>featureB</code> 分支上创建了几次提交：</p><pre class=" language-console"><code class="language-console">$ vim lib/simplegit.rb$ git commit -am 'made the ls-tree function recursive'[featureB e5b0fdc] made the ls-tree function recursive 1 files changed, 1 insertions(+), 1 deletions(-)$ vim lib/simplegit.rb$ git commit -am 'add ls-files'[featureB 8512791] add ls-files 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre><p>Jessica 的仓库看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/managed-team-1.png" alt="Jessica 的初始提交历史。"></p><p>Figure 66. Jessica 的初始提交历史</p><p>她准备好推送工作了，但是一封来自 Josie 的邮件告知一些初始工作已经被推送到服务器上的 <code>featureBee</code> 上了。 Jessica 在能推送到服务器前首先需要将那些改动与她自己的合并。 然后她可以通过 <code>git fetch</code> 抓取 Josie 的改动：</p><pre class=" language-console"><code class="language-console">$ git fetch origin...From jessica@githost:simplegit * [new branch]      featureBee -> origin/featureBee</code></pre><p>Jessica 现在可以通过 <code>git merge</code> 将其合并到她做的工作中：</p><pre class=" language-console"><code class="language-console">$ git merge origin/featureBeeAuto-merging lib/simplegit.rbMerge made by recursive. lib/simplegit.rb |    4 ++++ 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre><p>有点儿问题 - 她需要将在 <code>featureB</code> 分支上合并的工作推送到服务器上的 <code>featureBee</code> 分支。 她可以通过指定本地分支加上冒号（:）加上远程分支给 <code>git push</code> 命令来这样做：</p><pre class=" language-console"><code class="language-console">$ git push -u origin featureB:featureBee...To jessica@githost:simplegit.git   fba9af8..cd685d1  featureB -> featureBee</code></pre><p>这称作一个 <em>引用规格</em>。 查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_refspec" target="_blank" rel="noopener">引用规格</a> 了解关于 Git 引用规格与通过它们可以做的不同的事情的详细讨论。 也要注意 <code>-u</code> 标记；这是 <code>--set-upstream</code> 的简写，该标记会为之后轻松地推送与拉取配置分支。</p><p>紧接着，John 发邮件给 Jessica 说他已经推送了一些改动到 <code>featureA</code> 分支并要求她去验证它们。 她运行一个 <code>git fetch</code> 来拉取下那些改动：</p><pre class=" language-console"><code class="language-console">$ git fetch origin...From jessica@githost:simplegit   3300904..aad881d  featureA   -> origin/featureA</code></pre><p>然后，通过 <code>git log</code> 她可以看到哪些发生了改变：</p><pre class=" language-console"><code class="language-console">$ git log featureA..origin/featureAcommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6Author: John Smith <jsmith@example.com>Date:   Fri May 29 19:57:33 2009 -0700    changed log output to 30 from 25</code></pre><p>最终，她合并 John 的工作到她自己的 <code>featureA</code> 分支：</p><pre class=" language-console"><code class="language-console">$ git checkout featureASwitched to branch 'featureA'$ git merge origin/featureAUpdating 3300904..aad881dFast forward lib/simplegit.rb |   10 +++++++++-1 files changed, 9 insertions(+), 1 deletions(-)</code></pre><p>Jessica 想要轻微调整一些东西，所以她再次提交然后将其推送回服务器：</p><pre class=" language-console"><code class="language-console">$ git commit -am 'small tweak'[featureA 774b3ed] small tweak 1 files changed, 1 insertions(+), 1 deletions(-)$ git push...To jessica@githost:simplegit.git   3300904..774b3ed  featureA -> featureA</code></pre><p>Jessica 的提交历史现在看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/managed-team-2.png" alt="在一个特性分支提交后 Jessica 的历史。"></p><p>Figure 67. 在一个特性分支提交后 Jessica 的历史</p><p>Jessica、Josie 与 John 通知整合者在服务器上的 <code>featureA</code> 与 <code>featureBee</code> 分支准备好整合到主线中了。 在整合者合并这些分支到主线后，一次抓取会拿下来一个新的合并提交，使历史看起来像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/managed-team-3.png" alt="合并了 Jessica 的两个特性分支后她的历史。"></p><p>Figure 68. 合并了 Jessica 的两个特性分支后她的历史</p><p>许多团队切换到 Git 是因为这一允许多个团队并行工作、并在之后合并不同工作的能力。 团队中更小一些的子小组可以通过远程分支协作而不必影响或妨碍整个团队的能力是 Git 的一个巨大优势。 在这儿看到的工作流程顺序类似这样：</p><p><img src="https://git-scm.com/book/en/v2/images/managed-team-flow.png" alt="这种管理团队工作流程的基本顺序。"></p><p>Figure 69. 这种管理团队工作流程的基本顺序</p><h3 id="派生的公开项目"><a href="#派生的公开项目" class="headerlink" title="派生的公开项目"></a>派生的公开项目</h3><p>向公开项目做贡献有一点儿不同。 因为没有权限直接更新项目的分支，你必须用其他办法将工作给维护者。 第一个例子描述在支持简单派生的 Git 托管上使用派生来做贡献。 许多托管站点支持这个功能（包括 GitHub、BitBucket、Google Code、repo.or.cz 等等），许多项目维护者期望这种风格的贡献。 下一节会讨论偏好通过邮件接受贡献补丁的项目。</p><p>首先，你可能想要克隆主仓库，为计划贡献的补丁或补丁序列创建一个特性分支，然后在那儿做工作。 顺序看起来基本像这样：</p><pre class=" language-console"><code class="language-console">$ git clone (url)$ cd project$ git checkout -b featureA# (work)$ git commit# (work)$ git commit</code></pre><table><thead><tr><th>Note</th><th>你可能会想要使用 <code>rebase -i</code> 来将工作压缩成一个单独的提交，或者重排提交中的工作使补丁更容易被维护者审核 - 查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_rewriting_history" target="_blank" rel="noopener">重写历史</a> 了解关于交互式变基的更多信息。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>当你的分支工作完成后准备将其贡献回维护者，去原始项目中然后点击 “Fork” 按钮，创建一份自己的可写的项目派生仓库。 然后需要添加这个新仓库 URL 为第二个远程仓库，在本例中称作 <code>myfork</code>：</p><pre class=" language-console"><code class="language-console">$ git remote add myfork (url)</code></pre><p>然后需要推送工作到上面。 相对于合并到主分支再推送上去，推送你正在工作的特性分支到仓库上更简单。 原因是工作如果不被接受或者是被拣选的，就不必回退你的 master 分支。 如果维护者合并、变基或拣选你的工作，不管怎样你最终会通过拉取他们的仓库找回来你的工作。</p><pre class=" language-console"><code class="language-console">$ git push -u myfork featureA</code></pre><p>当工作已经被推送到你的派生后，你需要通知维护者。 这通常被称作一个拉取请求（pull request），你既可以通过网站生成它 - GitHub 有它自己的 Pull Request 机制，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch06-github" target="_blank" rel="noopener">GitHub</a> 介绍 - 也可以运行 <code>git request-pull</code> 命令然后手动地将输出发送电子邮件给项目的维护者。</p><p><code>request-pull</code> 命令接受特性分支拉入的基础分支，以及它们拉入的 Git 仓库 URL，输出请求拉入的所有修改的总结。 例如，Jessica 想要发送给 John 一个拉取请求，她已经在刚刚推送的分支上做了两次提交。她可以运行这个：</p><pre class=" language-console"><code class="language-console">$ git request-pull origin/master myforkThe following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:  John Smith (1):        added a new functionare available in the git repository at:  git://githost/simplegit.git featureAJessica Smith (2):      add limit to log function      change log output to 30 from 25 lib/simplegit.rb |   10 +++++++++- 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre><p>这个输出可以被发送给维护者 - 它告诉他们工作是从哪个分支开始、归纳的提交与从哪里拉入这些工作。</p><p>在一个你不是维护者的项目上，通常有一个总是跟踪 <code>origin/master</code> 的 <code>master</code> 分支会很方便，在特性分支上做工作是因为如果它们被拒绝时你可以轻松地丢弃。 如果同一时间主仓库移动了然后你的提交不再能干净地应用，那么使工作主题独立于特性分支也会使你变基（rebase）工作时更容易。 例如，你想要提供第二个特性工作到项目，不要继续在刚刚推送的特性分支上工作 - 从主仓库的 <code>master</code> 分支重新开始：</p><pre class=" language-console"><code class="language-console">$ git checkout -b featureB origin/master# (work)$ git commit$ git push myfork featureB# (email maintainer)$ git fetch origin</code></pre><p>现在，每一个特性都保存在一个贮藏库中 - 类似于补丁队列 - 可以重写、变基与修改而不会让特性互相干涉或互相依赖，像这样：</p><p><img src="https://git-scm.com/book/en/v2/images/public-small-1.png" alt="`featureB` 的初始提交历史。"></p><p>Figure 70. <code>featureB</code> 的初始提交历史</p><p>假设项目维护者已经拉取了一串其他补丁，然后尝试拉取你的第一个分支，但是没有干净地合并。 在这种情况下，可以尝试变基那个分支到 <code>origin/master</code> 的顶部，为维护者解决冲突，然后重新提交你的改动：</p><pre class=" language-console"><code class="language-console">$ git checkout featureA$ git rebase origin/master$ git push -f myfork featureA</code></pre><p>这样会重写你的历史，现在看起来像是 <a href="https://git-scm.com/book/zh/v2/ch00/rpsp_b" target="_blank" rel="noopener"><code>featureA</code> 工作之后的提交历史</a></p><p><img src="https://git-scm.com/book/en/v2/images/public-small-2.png" alt="`featureA` 工作之后的提交历史。"></p><p>Figure 71. <code>featureA</code> 工作之后的提交历史</p><p>因为你将分支变基了，所以必须为推送命令指定 <code>-f</code> 选项，这样才能将服务器上有一个不是它的后代的提交的 <code>featureA</code> 分支替换掉。 一个替代的选项是推送这个新工作到服务器上的一个不同分支（可能称作 <code>featureAv2</code>）。</p><p>让我们看一个更有可能的情况：维护者看到了你的第二个分支上的工作并且很喜欢其中的概念，但是想要你修改一下实现的细节。 你也可以利用这次机会将工作基于项目现在的 <code>master</code> 分支。 你从现在的 <code>origin/master</code> 分支开始一个新分支，在那儿压缩 <code>featureB</code> 的改动，解决任何冲突，改变实现，然后推送它为一个新分支。</p><pre class=" language-console"><code class="language-console">$ git checkout -b featureBv2 origin/master$ git merge --squash featureB# (change implementation)$ git commit$ git push myfork featureBv2</code></pre><p><code>--squash</code> 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集，使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交。 这意味着你的未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动，然后在记录一个新提交前做更多的改动。 同样 <code>--no-commit</code> 选项在默认合并过程中可以用来延迟生成合并提交。</p><p>现在你可以给维护者发送一条消息，表示你已经做了要求的修改然后他们可以在你的 <code>featureBv2</code> 分支上找到那些改动。</p><p><img src="https://git-scm.com/book/en/v2/images/public-small-3.png" alt="`featureBv2` 工作之后的提交历史。"></p><p>Figure 72. <code>featureBv2</code> 工作之后的提交历史</p><h3 id="通过邮件的公开项目"><a href="#通过邮件的公开项目" class="headerlink" title="通过邮件的公开项目"></a>通过邮件的公开项目</h3><p>许多项目建立了接受补丁的流程 - 需要检查每一个项目的特定规则，因为它们之间有区别。 因为有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁，现在我们将会通过一个例子来演示。</p><p>工作流程与之前的用例是类似的 - 你为工作的每一个补丁序列创建特性分支。 区别是如何提交它们到项目中。 生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。</p><pre class=" language-console"><code class="language-console">$ git checkout -b topicA# (work)$ git commit# (work)$ git commit</code></pre><p>现在有两个提交要发送到邮件列表。 使用 <code>git format-patch</code> 来生成可以邮寄到列表的 mbox 格式的文件 - 它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。 它有一个好处是使用 <code>format-patch</code> 生成的一封电子邮件应用的提交正确地保留了所有的提交信息。</p><pre class=" language-console"><code class="language-console">$ git format-patch -M origin/master0001-add-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patch</code></pre><p><code>format-patch</code> 命令打印出它创建的补丁文件名字。 <code>-M</code> 开关告诉 Git 查找重命名。 文件最后看起来像这样：</p><pre class=" language-console"><code class="language-console">$ cat 0001-add-limit-to-log-function.patchFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001From: Jessica Smith <jessica@example.com>Date: Sun, 6 Apr 2008 10:17:23 -0700Subject: [PATCH 1/2] add limit to log functionLimit log functionality to the first 20--- lib/simplegit.rb |    2 +- 1 files changed, 1 insertions(+), 1 deletions(-)diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex 76f47bc..f9815f1 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -14,7 +14,7 @@ class SimpleGit   end   def log(treeish = 'master')-    command("git log #{treeish}")+    command("git log -n 20 #{treeish}")   end   def ls_tree(treeish = 'master')--2.1.0</code></pre><p>也可以编辑这些补丁文件为邮件列表添加更多不想要在提交信息中显示出来的信息。 如果在 <code>---</code> 行与补丁开头（<code>diff --git</code> 行）之间添加文本，那么开发者就可以阅读它；但是应用补丁时会排除它。</p><p>为了将其邮寄到邮件列表，你既可以将文件粘贴进电子邮件客户端，也可以通过命令行程序发送它。 粘贴文本经常会发生格式化问题，特别是那些不会合适地保留换行符与其他空白的 “更聪明的” 客户端。 幸运的是，Git 提供了一个工具帮助你通过 IMAP 发送正确格式化的补丁，这可能对你更容易些。 我们将会演示如何通过 Gmail 发送一个补丁，它正好是我们所知最好的邮件代理；可以在之前提到的 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件的最下面了解一系列邮件程序的详细指令。</p><p>首先，需要在 <code>~/.gitconfig</code> 文件中设置 imap 区块。 可以通过一系列的 <code>git config</code> 命令来分别设置每一个值，或者手动添加它们，不管怎样最后配置文件应该看起来像这样：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[imap]</span><span class="token constant">  folder</span> <span class="token attr-value"><span class="token punctuation">=</span> "[Gmail]/Drafts"</span><span class="token constant">  host</span> <span class="token attr-value"><span class="token punctuation">=</span> imaps://imap.gmail.com</span><span class="token constant">  user</span> <span class="token attr-value"><span class="token punctuation">=</span> user@gmail.com</span><span class="token constant">  pass</span> <span class="token attr-value"><span class="token punctuation">=</span> p4ssw0rd</span><span class="token constant">  port</span> <span class="token attr-value"><span class="token punctuation">=</span> 993</span><span class="token constant">  sslverify</span> <span class="token attr-value"><span class="token punctuation">=</span> false</span></code></pre><p>如果 IMAP 服务器不使用 SSL，最后两行可能没有必要，host 的值会是 <code>imap://</code> 而不是 <code>imaps://</code>。 当那些设置完成后，可以使用 <code>git imap-send</code> 将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹中：</p><pre class=" language-console"><code class="language-console">$ cat *.patch |git imap-sendResolving imap.gmail.com... okConnecting to [74.125.142.109]:993... okLogging in...sending 2 messages100% (2/2) done</code></pre><p>在这个时候，你应该能够到 Drafts 文件夹中，修改收件人字段为想要发送补丁的邮件列表，可能需要抄送给维护者或负责那个部分的人，然后发送。</p><p>你也可以通过一个 SMTP 服务器发送补丁。 同之前一样，你可以通过一系列的 <code>git config</code> 命令来分别设置选项，或者你可以手动地将它们添加到你的 <code>~/.gitconfig</code> 文件的 sendmail 区块：</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[sendemail]</span><span class="token constant">  smtpencryption</span> <span class="token attr-value"><span class="token punctuation">=</span> tls</span><span class="token constant">  smtpserver</span> <span class="token attr-value"><span class="token punctuation">=</span> smtp.gmail.com</span><span class="token constant">  smtpuser</span> <span class="token attr-value"><span class="token punctuation">=</span> user@gmail.com</span><span class="token constant">  smtpserverport</span> <span class="token attr-value"><span class="token punctuation">=</span> 587</span></code></pre><p>当这完成后，你可以使用 <code>git send-email</code> 发送你的补丁：</p><pre class=" language-console"><code class="language-console">$ git send-email *.patch0001-added-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patchWho should the emails appear to be from? [Jessica Smith <jessica@example.com>]Emails will be sent from: Jessica Smith <jessica@example.com>Who should the emails be sent to? jessica@example.comMessage-ID to be used as In-Reply-To for the first email? y</code></pre><p>然后，对于正在发送的每一个补丁，Git 会吐出这样的一串日志信息：</p><pre class=" language-text"><code class="language-text">(mbox) Adding cc: Jessica Smith <jessica@example.com> from  \line 'From: Jessica Smith <jessica@example.com>'OK. Log says:Sendmail: /usr/sbin/sendmail -i jessica@example.comFrom: Jessica Smith <jessica@example.com>To: jessica@example.comSubject: [PATCH 1/2] added limit to log functionDate: Sat, 30 May 2009 13:29:15 -0700Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirtyIn-Reply-To: <y>References: <y>Result: OK</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个部分介绍了处理可能会遇到的几个迥然不同类型的 Git 项目的一些常见的工作流程，介绍了帮助管理这个过程的一些新工具。 接下来，你会了解到如何在贡献的另一面工作：维护一个 Git 项目。 你将会学习如何成为一个仁慈的独裁者或整合管理者。</p><h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><p>除了如何有效地参与一个项目的贡献之外，你可能也需要了解如何维护项目。 这包含接受并应用别人使用 <code>format-patch</code> 生成并通过电子邮件发送过来的补丁，或对项目添加的远程版本库分支中的更改进行整合。 但无论是管理版本库，还是帮忙验证、审核收到的补丁，都需要同其他贡献者约定某种长期可持续的工作方式。</p><h3 id="在特性分支中工作"><a href="#在特性分支中工作" class="headerlink" title="在特性分支中工作"></a>在特性分支中工作</h3><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中。 这样便于单独调整补丁，如果遇到无法正常工作的情况，可以先不用管，等到有时间的时候再来处理。 如果你基于你所尝试进行工作的特性为分支创建一个简单的名字，比如 <code>ruby_client</code> 或者具有类似描述性的其他名字，这样即使你必须暂时抛弃它，以后回来时也不会忘记。 项目的维护者一般还会为这些分支附带命名空间，比如 <code>sc/ruby_client</code>（其中 <code>sc</code> 是贡献该项工作的人名称的简写）。 你应该记得，可以使用如下方式基于 master 分支建立特性分支：</p><pre class=" language-console"><code class="language-console">$ git branch sc/ruby_client master</code></pre><p>或者如果你同时想立刻切换到新分支上的话，可以使用 <code>checkout -b</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git checkout -b sc/ruby_client master</code></pre><p>现在你已经准备好将别人贡献的工作加入到这个特性分支，并考虑是否将其合并到长期分支中去了。</p><h3 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h3><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到特性分支中进行评估。 有两种应用该种补丁的方法：使用 <code>git apply</code>，或者使用 <code>git am</code>。</p><h4 id="使用-apply-命令应用补丁"><a href="#使用-apply-命令应用补丁" class="headerlink" title="使用 apply 命令应用补丁"></a>使用 <code>apply</code> 命令应用补丁</h4><p>如果你收到了一个使用 <code>git diff</code> 或 Unix <code>diff</code> 命令（不推荐使用这种方式，具体见下一节）创建的补丁，可以使用 <code>git apply</code> 命令来应用。 假设你将补丁保存在了 <code>/tmp/patch-ruby-client.patch</code>中，可以这样应用补丁：</p><pre class=" language-console"><code class="language-console">$ git apply /tmp/patch-ruby-client.patch</code></pre><p>这会修改工作目录中的文件。 它与运行 <code>patch -p1</code> 命令来应用补丁几乎是等效的，但是这种方式更加严格，相对于 patch 来说，它能够接受的模糊匹配更少。 它也能够处理 <code>git diff</code> 格式文件所描述的文件添加、删除和重命名操作，而 <code>patch</code> 则不会。 最后，<code>git apply</code> 命令采用了一种“全部应用，否则就全部撤销（apply all or abort all）”的模型，即补丁只有全部内容都被应用和完全不被应用两个状态，而 <code>patch</code> 可能会导致补丁文件被部分应用，最后使你的工作目录保持在一个比较奇怪的状态。 总体来看，<code>git apply</code> 命令要比 <code>patch</code> 谨慎得多。 并且，它不会为你创建提交——在运行之后，你需要手动暂存并提交补丁所引入的更改。</p><p>在实际应用补丁前，你还可以使用 git apply 来检查补丁是否可以顺利应用——即对补丁运行 <code>git apply --check</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git apply --check 0001-seeing-if-this-helps-the-gem.patcherror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not apply</code></pre><p>如果没有产生输出，则该补丁可以顺利应用。 如果检查失败了，该命令还会以一个非零的状态退出，所以需要时你也可以在脚本中使用它。</p><h4 id="使用-am-命令应用补丁"><a href="#使用-am-命令应用补丁" class="headerlink" title="使用 am 命令应用补丁"></a>使用 <code>am</code> 命令应用补丁</h4><p>如果补丁的贡献者也是一个 Git 用户，并且其能熟练使用 <code>format-patch</code> 命令来生成补丁，这样的话你的工作会变得更加轻松，因为这种补丁中包含了作者信息和提交信息供你参考。 如果可能的话，请鼓励贡献者使用 <code>format-patch</code> 而不是 <code>diff</code> 来为你生成补丁。 而只有对老式的补丁，你才必须使用 <code>git apply</code>命令。</p><p>要应用一个由 <code>format-patch</code> 命令生成的补丁，你应该使用 <code>git am</code> 命令。 从技术的角度看，<code>git am</code>是为了读取 mbox 文件而构建的，mbox 是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式。 其大致格式如下所示：</p><pre class=" language-console"><code class="language-console">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001From: Jessica Smith <jessica@example.com>Date: Sun, 6 Apr 2008 10:17:23 -0700Subject: [PATCH 1/2] add limit to log functionLimit log functionality to the first 20</code></pre><p>这其实就是你前面看到的 format-patch 命令输出的开始几行。 而同时它也是有效的 mbox 电子邮件格式。 如果有人使用 git send-email 命令将补丁以电子邮件的形式发送给你，你便可以将它下载为 mbox 格式的文件，之后将 git am 命令指向该文件，它会应用其中包含的所有补丁。 如果你所使用的邮件客户端能够同时将多封邮件保存为 mbox 格式的文件，你甚至能够将一系列补丁打包为单个 mbox 文件，并利用 <code>git am</code> 命令将它们一次性全部应用。</p><p>然而，如果贡献者将 <code>format-patch</code> 生成的补丁文件上传到类似 Request Ticket 的任务处理系统，你可以先将其保存到本地，之后通过 <code>git am</code> 来应用补丁：</p><pre class=" language-console"><code class="language-console">$ git am 0001-limit-log-function.patchApplying: add limit to log function</code></pre><p>你会看到补丁被顺利地应用，并且为你自动创建了一个新的提交。 其中的作者信息来自于电子邮件头部的 <code>From</code> 和 <code>Date</code> 字段，提交消息则取自 <code>Subject</code> 和邮件正文中补丁之前的内容。 比如，应用上面那个 mbox 示例后生成的提交是这样的：</p><pre><code>$ git log --pretty=fuller -1commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0Author:     Jessica Smith &lt;jessica@example.com&gt;AuthorDate: Sun Apr 6 10:17:23 2008 -0700Commit:     Scott Chacon &lt;schacon@gmail.com&gt;CommitDate: Thu Apr 9 09:19:06 2009 -0700   add limit to log function   Limit log functionality to the first 20</code></pre><p>其中 <code>Commit</code> 信息表示的是应用补丁的人和应用补丁的时间。 <code>Author</code> 信息则表示补丁的原作者和原本的创建时间。</p><p>但是，有时候无法顺利地应用补丁。 这也许是因为你的主分支和创建补丁的分支相差较多，也有可能是因为这个补丁依赖于其他你尚未应用的补丁。 这种情况下，<code>git am</code> 进程将会报错并且询问你要做什么：</p><pre class=" language-console"><code class="language-console">$ git am 0001-seeing-if-this-helps-the-gem.patchApplying: seeing if this helps the gemerror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not applyPatch failed at 0001.When you have resolved this problem run "git am --resolved".If you would prefer to skip this patch, instead run "git am --skip".To restore the original branch and stop patching run "git am --abort".</code></pre><p>该命令将会在所有出现问题的文件内加入冲突标记，就和发生冲突的合并或变基操作一样。 而你解决问题的手段很大程度上也是一样的——即手动编辑那些文件来解决冲突，暂存新的文件，之后运行 <code>git am --resolved</code> 继续应用下一个补丁：</p><pre class=" language-console"><code class="language-console">$ (fix the file)$ git add ticgit.gemspec$ git am --resolvedApplying: seeing if this helps the gem</code></pre><p>如果你希望 Git 能够尝试以更加智能的方式解决冲突，你可以对其传递 <code>-3</code> 选项来使 Git 尝试进行三方合并。 该选项默认并没有打开，因为如果用于创建补丁的提交并不在你的版本库内的话，这样做是没有用处的。 而如果你确实有那个提交的话——比如补丁是基于某个公共提交的——那么通常 <code>-3</code> 选项对于应用有冲突的补丁是更加明智的选择。</p><pre class=" language-console"><code class="language-console">$ git am -3 0001-seeing-if-this-helps-the-gem.patchApplying: seeing if this helps the gemerror: patch failed: ticgit.gemspec:1error: ticgit.gemspec: patch does not applyUsing index info to reconstruct a base tree...Falling back to patching base and 3-way merge...No changes -- Patch already applied.</code></pre><p>比如上面这种情况，我在之前已经应用过同样的补丁。 如果没有 <code>-3</code> 选项的话，这看起来就像是存在一个冲突。</p><p>如果你正在利用一个 mbox 文件应用多个补丁，也可以在交互模式下运行 <code>am</code> 命令，这样在每个补丁之前，它会停住询问你是否要应用该补丁：</p><pre class=" language-console"><code class="language-console">$ git am -3 -i mboxCommit Body is:--------------------------seeing if this helps the gem--------------------------Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre><p>这在你保存的补丁较多时很好用，因为你可以在应用之前查看忘掉内容的补丁，并且跳过已经应用过的补丁。</p><p>当与你的特性相关的所有补丁都被应用并提交到分支中之后，你就可以选择是否以及如何将其整合到更长期的分支中去了。</p><h3 id="检出远程分支"><a href="#检出远程分支" class="headerlink" title="检出远程分支"></a>检出远程分支</h3><p>如果你的贡献者建立了自己的版本库，并且向其中推送了若干修改，之后将版本库的 URL 和包含更改的远程分支发送给你，那么你可以将其添加为一个远程分支，并且在本地进行合并。</p><p>比如 Jessica 向你发送了一封电子邮件，内容是在她的版本库中的 <code>ruby-client</code> 分支中有一个很不错的新功能，为了测试该功能，你可以将其添加为一个远程分支，并在本地检出：</p><pre class=" language-console"><code class="language-console">$ git remote add jessica git://github.com/jessica/myproject.git$ git fetch jessica$ git checkout -b rubyclient jessica/ruby-client</code></pre><p>如果她再次发邮件说另一个分支中包含另一个优秀功能，因为之前已经设置好远程分支了，你就可以直接进行抓取及检出操作。</p><p>这对于与他人长期合作工作来说很有用。 而对于提交补丁频率较小的贡献者，相对于每个人维护自己的服务器，不断增删远程分支的做法，使用电子邮件来接收可能会比较省时。 况且你也不会想要加入数百个只提供一两个补丁的远程分支。 然而，脚本和托管服务在一定程度上可以简化这些工作——这很大程度上依赖于你和你的贡献者开发的方式。</p><p>这种方式的另一种优点是你可以同时得到提交历史。 虽然代码合并中可能会出现问题，但是你能获知他人的工作是基于你的历史中的具体哪一个位置；所以Git 会默认进行三方合并，不需要提供 <code>-3</code> 选项，你也不需要担心补丁是基于某个你无法访问的提交生成的。</p><p>对于非持续性的合作，如果你依然想要以这种方式拉取数据的话，你可以对远程版本库的 URL 调用 <code>git pull</code> 命令。 这会执行一个一次性的抓取，而不会将该 URL 存为远程引用：</p><pre class=" language-console"><code class="language-console">$ git pull https://github.com/onetimeguy/projectFrom https://github.com/onetimeguy/project * branch            HEAD       -> FETCH_HEADMerge made by recursive.</code></pre><h3 id="确定引入了哪些东西"><a href="#确定引入了哪些东西" class="headerlink" title="确定引入了哪些东西"></a>确定引入了哪些东西</h3><p>你已经有了一个包含其他人贡献的特性分支。 现在你可以决定如何处理它们了。 本节回顾了若干命令，以便于你检查若将其合并入主分支所引入的更改。</p><p>一般来说，你应该对该分支中所有 master 分支尚未包含的提交进行检查。 通过在分支名称前加入 <code>--not</code>选项，你可以排除 master 分支中的提交。 这和我们之前使用的 <code>master..contrib</code> 格式是一样的。 假设贡献者向你发送了两个补丁，为此你创建了一个名叫 <code>contrib</code> 的分支并在其上应用补丁，你可以运行：</p><pre class=" language-console"><code class="language-console">$ git log contrib --not mastercommit 5b6235bd297351589efc4d73316f0a68d484f118Author: Scott Chacon <schacon@gmail.com>Date:   Fri Oct 24 09:53:59 2008 -0700    seeing if this helps the gemcommit 7482e0d16d04bea79d0dba8988cc78df655f16a0Author: Scott Chacon <schacon@gmail.com>Date:   Mon Oct 22 19:38:36 2008 -0700    updated the gemspec to hopefully work better</code></pre><p>如果要查看每次提交所引入的具体修改，你应该记得可以给 <code>git log</code> 命令传递 <code>-p</code> 选项，这样它会在每次提交后面附加对应的差异（diff）。</p><p>而要查看将该特性分支与另一个分支合并的完整 diff，你可能需要使用一个有些奇怪的技巧来得到正确的结果。 你可能会想到这种方式：</p><pre class=" language-console"><code class="language-console">$ git diff master</code></pre><p>这个命令会输出一个 diff，但它可能并不是我们想要的。 如果在你创建特性分支之后，<code>master</code> 分支向前移动了，你获得的结果就会显得有些不对。 这是因为 Git 会直接将该特性分支与 <code>master</code> 分支的最新提交快照进行比较。 比如说你在 <code>master</code> 分支中向某个文件添加了一行内容，那么直接比对最新快照的结果看上去就像是你在特性分支中将这一行删除了。</p><p>如果 <code>master</code> 分支是你的特性分支的直接祖先，其实是没有任何问题的；但是一旦两个分支的历史产生了分叉，上述比对产生的 diff 看上去就像是将特性分支中所有的新东西加入，并且将 <code>master</code> 分支所独有的东西删除。</p><p>而你真正想要检查的东西，实际上仅仅是特性分支所添加的更改——也就是该分支与 master 分支合并所要引入的工作。 要达到此目的，你需要让 Git 对特性分支上最新的提交与该分支与 master 分支的首个公共祖先进行比较。</p><p>从技术的角度讲，你可以以手工的方式找出公共祖先，并对其显式运行 diff 命令：</p><pre class=" language-console"><code class="language-console">$ git merge-base contrib master36c7dba2c95e6bbb78dfa822519ecfec6e1ca649$ git diff 36c7db</code></pre><p>然而，这种做法比较麻烦，所以 Git 提供了一种比较便捷的方式：三点语法。 对于 <code>diff</code> 命令来说，你可以通过把 <code>...</code> 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较：</p><pre class=" language-console"><code class="language-console">$ git diff master...contrib</code></pre><p>该命令仅会显示自当前特性分支与 master 分支的共同祖先起，该分支中的工作。 这个语法很有用，应该牢记。</p><h3 id="将贡献的工作整合进来"><a href="#将贡献的工作整合进来" class="headerlink" title="将贡献的工作整合进来"></a>将贡献的工作整合进来</h3><p>当特性分支中所有的工作都已经准备好整合进入更靠近主线的分支时，接下来的问题就是如何进行整合了。 此外，还有一个问题是，你想使用怎样的总体工作流来维护你的项目？ 你的选择有很多，我们会介绍其中的一部分。</p><h4 id="合并工作流"><a href="#合并工作流" class="headerlink" title="合并工作流"></a>合并工作流</h4><p>一种非常简单的工作流会直接将工作合并进入 <code>master</code> 分支。 在这种情况下，<code>master</code> 分支包含的代码是基本稳定的。 当你完成某个特性分支的工作，或审核通过了其他人所贡献的工作时，你会将其合并进入 master 分支，之后将特性分支删除，如此反复。 如果我们的版本库包含类似 <a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_a" target="_blank" rel="noopener">包含若干特性分支的提交历史。</a> 的两个名称分别为 <code>ruby_client</code> 和 <code>php_client</code> 的分支，并且我们先合并 <code>ruby_client</code> 分支，之后合并 <code>php_client</code> 分支，那么提交历史最后会变成 <a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_b" target="_blank" rel="noopener">合并特性分支之后。</a> 的样子。</p><p><img src="https://git-scm.com/book/en/v2/images/merging-workflows-1.png" alt="包含若干特性分支的提交历史。"></p><p>Figure 73. 包含若干特性分支的提交历史。</p><p><img src="https://git-scm.com/book/en/v2/images/merging-workflows-2.png" alt="合并特性分支之后。"></p><p>Figure 74. 合并特性分支之后。</p><p>这也许是最简单的工作流了，但是当项目更大，或更稳定，你对自己所引入的工作更加在意时，它可能会带来问题。</p><p>如果你的项目非常重要，你可能会使用两阶段合并循环。 在这种情况下，你会维护两个长期分支，分别是 <code>master</code> 和 <code>develop</code>，<code>master</code> 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 <code>develop</code> 分支。 你定期将这两个分支推送到公共版本库中。 每次需要合并新的特性分支时（<a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_c" target="_blank" rel="noopener">合并特性分支前。</a>），你都应该合并进入 <code>develop</code> 分支（<a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_d" target="_blank" rel="noopener">合并特性分支后。</a>）；当打标签发布的时候，你会将 <code>master</code> 分支快进到已经稳定的 <code>develop</code> 分支（<a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_e" target="_blank" rel="noopener">一次发布之后。</a>）。</p><p><img src="https://git-scm.com/book/en/v2/images/merging-workflows-3.png" alt="合并特性分支前。"></p><p>Figure 75. 合并特性分支前。</p><p><img src="https://git-scm.com/book/en/v2/images/merging-workflows-4.png" alt="合并特性分支后。"></p><p>Figure 76. 合并特性分支后。</p><p><img src="https://git-scm.com/book/en/v2/images/merging-workflows-5.png" alt="一次发布之后。"></p><p>Figure 77. 一次发布之后。</p><p>这样当人们克隆你项目的版本库后，既可以检出 master 分支以构建最新的稳定版本并保持更新，也可以检出包含更多新东西的 develop 分支。 你也可以扩展这个概念，维护一个将所有工作合并到一起的整合分支。 当该分支的代码稳定并通过测试之后，将其合并进入 develop 分支；经过一段时间，确认其稳定之后，将其以快进的形式并入 master 分支。</p><h4 id="大项目合并工作流"><a href="#大项目合并工作流" class="headerlink" title="大项目合并工作流"></a>大项目合并工作流</h4><p>Git 项目包含四个长期分支：<code>master</code>、<code>next</code>，用于新工作的 <code>pu</code>（proposed updates）和用于维护性向后移植工作（maintenance backports）的 <code>maint</code> 分支。 贡献者的新工作会以类似之前所介绍的方式收入特性分支中（见 <a href="https://git-scm.com/book/zh/v2/ch00/rmerwf_f" target="_blank" rel="noopener">管理复杂的一系列接收贡献的平行特性分支。</a>）。 之后对特性分支进行测试评估，检查其是否已经能够合并，或者仍需要更多工作。 安全的特性分支会被合并入 <code>next</code> 分支，之后该分支会被推送使得所有人都可以尝试整合到一起的特性。</p><p><img src="https://git-scm.com/book/en/v2/images/large-merges-1.png" alt="管理复杂的一系列接收贡献的平行特性分支。"></p><p>Figure 78. 管理复杂的一系列接收贡献的平行特性分支。</p><p>如果特性分支需要更多工作，它则会被并入 <code>pu</code> 分支。 当它们完全稳定之后，会被再次并入 <code>master</code> 分支。 这意味着 <code>master</code> 分支始终在进行快进，<code>next</code> 分支偶尔会被变基，而 <code>pu</code> 分支的变基比较频繁：</p><p><img src="https://git-scm.com/book/en/v2/images/large-merges-2.png" alt="将贡献的特性分支并入长期整合分支。"></p><p>Figure 79. 将贡献的特性分支并入长期整合分支。</p><p>当特性分支最终被并入 <code>master</code> 分支后，便会被从版本库中删除掉。 Git 项目还有一个从上一次发布中派生出来的 <code>maint</code> 分支来提供向后移植过来的补丁以供发布维护更新。 因此，当你克隆 Git 的版本库之后，就会有四个可分别评估该项目开发的不同阶段的可检出的分支，检出哪个分支，取决于你需要多新的版本，或者你想要如何进行贡献；对于维护者来说，这套结构化的工作流能帮助它们审查新的贡献。</p><h4 id="变基与拣选工作流"><a href="#变基与拣选工作流" class="headerlink" title="变基与拣选工作流"></a>变基与拣选工作流</h4><p>为了保持线性的提交历史，有些维护者更喜欢在 master 分支上对贡献过来的工作进行变基和拣选，而不是直接将其合并。 当你完成了某个特性分支中的工作，并且决定要将其整合的时候，你可以在该分支中运行变基命令，在当前 master 分支（或者是 <code>develop</code> 等分支）的基础上重新构造修改。 如果结果理想的话，你可以快进 <code>master</code> 分支，最后得到一个线性的项目提交历史。</p><p>另一种将引入的工作转移到其他分支的方法是拣选。 Git 中的拣选类似于对特定的某次提交的变基。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入特性分支中的某个提交，或者特性分支中只有一个提交，而你不想运行变基时很有用。 举个例子，假设你的项目提交历史类似：</p><p><img src="https://git-scm.com/book/en/v2/images/rebasing-1.png" alt="拣选之前的示例历史。"></p><p>Figure 80. 拣选之前的示例历史。</p><p>如果你希望将提交 <code>e43a6</code> 拉取到 master 分支，你可以运行：</p><pre class=" language-console"><code class="language-console">$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdfFinished one cherry-pick.[master]: created a0a41a9: "More friendly message when locking the index fails." 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre><p>这样会拉取和 <code>e43a6</code> 相同的更改，但是因为应用的日期不同，你会得到一个新的提交 SHA-1 值。 现在你的历史会变成这样：</p><p><img src="https://git-scm.com/book/en/v2/images/rebasing-2.png" alt="拣选特性分支中的一个提交后的历史。"></p><p>Figure 81. 拣选特性分支中的一个提交后的历史。</p><p>现在你可以删除这个特性分支，并丢弃不想拉入的提交。</p><h4 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h4><p>如果你在进行大量的合并或变基，或维护一个长期的特性分支，Git 提供的一个叫做“rerere”的功能会有一些帮助。</p><p>Rerere 是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法。 当启用 rerere 时，Git 将会维护一些成功合并之前和之后的镜像，当 Git 发现之前已经修复过类似的冲突时，便会使用之前的修复方案，而不需要你的干预。</p><p>这个功能包含两个部分：一个配置选项和一个命令。 其中的配置选项是 <code>rerere.enabled</code>，把它放在全局配置中就可以了：</p><pre class=" language-console"><code class="language-console">$ git config --global rerere.enabled true</code></pre><p>现在每当你进行一次需要解决冲突的合并时，解决方案都会被记录在缓存中，以备之后使用。</p><p>如果你需要和 rerere 的缓存交互，你可以使用 <code>git rerere</code> 命令。 当单独调用它时，Git 会检查解决方案数据库，尝试寻找一个和当前任一冲突相关的匹配项并解决冲突（尽管当 <code>rerere.enabled</code> 被设置为 <code>true</code> 时会自动进行）。 它也有若干子命令，可用来查看记录项，删除特定解决方案和清除缓存全部内容等。 我们将在 <a href="https://git-scm.com/book/zh/v2/ch00/r_rerere" target="_blank" rel="noopener">Rerere</a> 中详细探讨。</p><h3 id="为发布打标签"><a href="#为发布打标签" class="headerlink" title="为发布打标签"></a>为发布打标签</h3><p>当你决定进行一次发布时，你可能想要留下一个标签，这样在之后的任何一个提交点都可以重新创建该发布。 你在 <a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics" target="_blank" rel="noopener">Git 基础</a> 中已经了解了创建新标签的过程。 作为一个维护者，如果你决定要为标签签名的话，打标签的过程应该是这样子的：</p><pre class=" language-console"><code class="language-console">$ git tag -s v1.5 -m 'my signed 1.5 tag'You need a passphrase to unlock the secret key foruser: "Scott Chacon <schacon@gmail.com>"1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre><p>如果你为标签签名了，你可能会遇到分发用来签名的 PGP 公钥的问题。 Git 项目的维护者已经解决了这一问题，其方法是在版本库中以 blob 对象的形式包含他们的公钥，并添加一个直接指向该内容的标签。 要完成这一任务，首先你可以通过运行 <code>gpg --list-keys</code> 找出你所想要的 key：</p><pre class=" language-console"><code class="language-console">$ gpg --list-keys/Users/schacon/.gnupg/pubring.gpg---------------------------------pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]uid                  Scott Chacon <schacon@gmail.com>sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre><p>之后你可以通过导出 key 并通过管道传递给 <code>git hash-object</code> 来直接将 key 导入到 Git 的数据库中，<code>git hash-object</code> 命令会向 Git 中写入一个包含其内容的新 blob 对象，并向你返回该 blob 对象的 SHA-1 值：</p><pre class=" language-console"><code class="language-console">$ gpg -a --export F721C45A | git hash-object -w --stdin659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre><p>既然 Git 中已经包含你的 key 的内容了，你就可以通过指定由 <code>hash-object</code> 命令给出的新 SHA-1 值来创建一个直接指向它的标签：</p><pre class=" language-console"><code class="language-console">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre><p>如果你运行 <code>git push --tags</code> 命令，那么 <code>maintainer-pgp-pub</code> 标签将会被共享给所有人。 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入 PGP key：</p><pre class=" language-console"><code class="language-console">$ git show maintainer-pgp-pub | gpg --import</code></pre><p>人们可以使用这个 key 来校验所有由你签名的标签。 另外，如果你在标签信息中包含了一些操作说明，用户可以通过运行 <code>git show &lt;tag&gt;</code> 来获取更多关于标签校验的说明。</p><h3 id="生成一个构建号"><a href="#生成一个构建号" class="headerlink" title="生成一个构建号"></a>生成一个构建号</h3><p>Git 中不存在随每次提交递增的“v123”之类的数字序列，如果你想要为提交附上一个可读的名称，可以对其运行 <code>git describe</code> 命令。 Git 将会给出一个字符串，它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值构成：</p><pre class=" language-console"><code class="language-console">$ git describe masterv1.6.2-rc1-20-g8c5b85c</code></pre><p>这样你在导出一个快照或构建时，可以给出一个便于人们理解的命名。 实际上，如果你的 Git 是从 Git 自己的版本库克隆下来并构建的，那么 <code>git --version</code> 命令给出的结果是与此类似的。 如果你所描述的提交自身就有一个标签，那么它将只会输出标签名，没有后面两项信息。</p><p>注意 <code>git describe</code> 命令只适用于有注解的标签（即使用 <code>-a</code> 或 <code>-s</code> 选项创建的标签），所以如果你在使用 <code>git describe</code> 命令的话，为了确保能为标签生成合适的名称，打发布标签时都应该采用加注解的方式。 你也可以使用这个字符串来调用 checkout 或 show 命令，但是这依赖于其末尾的简短 SHA-1 值，因此不一定一直有效。 比如，最近 Linux 内核为了保证 SHA-1 值对象的唯一性，将其位数由 8 位扩展到了 10 位，导致以前的 <code>git describe</code> 输出全部失效。</p><h3 id="准备一次发布"><a href="#准备一次发布" class="headerlink" title="准备一次发布"></a>准备一次发布</h3><p>现在你可以发布一个构建了。 其中一件事情就是为那些不使用 Git 的可怜包们创建一个最新的快照归档。 使用 <code>git archive</code> 命令完成此工作：</p><pre class=" language-console"><code class="language-console">$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz$ ls *.tar.gzv1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre><p>如果有人将这个压缩包解压，他就可以得到你的项目文件夹的最新快照。 你也可以以类似的方式创建一个 zip 压缩包，但此时你应该向 <code>git archive</code> 命令传递 <code>--format=zip</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git archive master --prefix='project/' --format=zip > `git describe master`.zip</code></pre><p>现在你有了本次发布的一个 tar 包和一个 zip 包，可以将其上传到网站或以电子邮件的形式发送给人们。</p><h3 id="制作提交简报"><a href="#制作提交简报" class="headerlink" title="制作提交简报"></a>制作提交简报</h3><p>现在是时候通知邮件列表里那些好奇你的项目发生了什么的人了。 使用 <code>git shortlog</code> 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志（changelog）类文档。 它会对你给定范围内的所有提交进行总结；比如，你的上一次发布名称是 v1.0.1，那么下面的命令可以给出上次发布以来所有提交的总结：</p><pre class=" language-console"><code class="language-console">$ git shortlog --no-merges master --not v1.0.1Chris Wanstrath (8):      Add support for annotated tags to Grit::Tag      Add packed-refs annotated tag support.      Add Grit::Commit#to_patch      Update version and History.txt      Remove stray `puts`      Make ls_tree ignore nilsTom Preston-Werner (4):      fix dates in history      dynamic version method      Version bump to 1.0.2      Regenerated gemspec for version 1.0.2</code></pre><p>这份整洁的总结包括了自 v1.0.1 以来的所有提交，并且已经按照作者分好组，你可以通过电子邮件将其直接发送到列表中。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>你现在能自如地使用 Git 为项目做出贡献、维护自己的项目或采纳其他用户的贡献了。 恭喜你成为了一个高效的 Git 开发者！ 下一章中，你将会学到如何使用规模最大最流行的 Git 托管服务，GitHub。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器上的Git</title>
      <link href="/2019/07/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Git/"/>
      <url>/2019/07/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Git/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，你应该已经有办法使用 Git 来完成日常工作。 然而，为了使用 Git 协作功能，你还需要有远程的 Git 仓库。 尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。 此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。 因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。</p><p>架设一台 Git 服务器并不难。 首先，选择你希望服务器使用的通讯协议。 在本章第一节将介绍可用的协议以及各自优缺点。 下面一节将解释使用那些协议的典型设置及如何在你的服务器上运行。 最后，如果你不介意托管你的代码在其他人的服务器，且不想经历设置与维护自己服务器的麻烦，可以试试我们介绍的几个仓库托管服务。</p><p>如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的帐户然后继续下一章，我们会在那里讨论分散式源码控制环境的林林总总。</p><p>一个远程仓库通常只是一个裸仓库（<em>bare repository</em>）— 即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 在此，我们将会讨论那些协议及哪些情形应该使用（或避免使用）他们。</p><h3 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h3><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><pre class=" language-console"><code class="language-console">$ git clone /opt/git/project.git</code></pre><p>或你可以执行这个命令：</p><pre class=" language-console"><code class="language-console">$ git clone file:///opt/git/project.git</code></pre><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><p>要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：</p><pre class=" language-console"><code class="language-console">$ git remote add local_proj /opt/git/project.git</code></pre><p>然后，就可以像在网络上一样从远端版本库推送和拉取更新了。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了， 我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server" target="_blank" rel="noopener">在服务器上搭建 Git</a> 讨论如何导出一个裸版本库。</p><p>这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 <code>git pull /home/john/project</code> 的命令比推送到服务器再取回简单多了。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p><p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p><p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h4 id="智能（Smart）-HTTP-协议"><a href="#智能（Smart）-HTTP-协议" class="headerlink" title="智能（Smart） HTTP 协议"></a>智能（Smart） HTTP 协议</h4><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>)，和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h4 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h4><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_hooks" target="_blank" rel="noopener">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。 下面是设置从 HTTP 访问版本库的方法：</p><pre class=" language-console"><code class="language-console">$ cd /var/www/htdocs/$ git clone --bare /path/to/git_project gitproject.git$ cd gitproject.git$ mv hooks/post-update.sample hooks/post-update$ chmod a+x hooks/post-update</code></pre><p>这样就可以了。 Git 自带的 <code>post-update</code> 挂钩会默认执行合适的命令（<code>git update-server-info</code>），来确保通过 HTTP 的获取和克隆操作正常工作。 这条命令会在你通过 SSH 向版本库推送之后被执行；然后别人就可以通过类似下面的命令来克隆：</p><pre class=" language-console"><code class="language-console">$ git clone https://example.com/gitproject.git</code></pre><p>这里我们用了 Apache 里设置了常用的路径 <code>/var/www/htdocs</code>，不过你可以使用任何静态 web 服务器 —— 只需要把裸版本库放到正确的目录下就可以。 Git 的数据是以基本的静态文件形式提供的（详情见 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a>）。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching" target="_blank" rel="noopener">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><pre class=" language-console"><code class="language-console">$ git clone ssh://user@server/project.git</code></pre><p>或者使用一个简短的 scp 式的写法：</p><pre class=" language-console"><code class="language-console">$ git clone user@server:project.git</code></pre><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h3 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h3><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h2 id="在服务器上搭建-Git"><a href="#在服务器上搭建-Git" class="headerlink" title="在服务器上搭建 Git"></a>在服务器上搭建 Git</h2><p>现在我们将讨论如何在你自己的服务器上搭建 Git 服务来运行这些协议。</p><table><thead><tr><th>Note</th><th>这里我们将要演示在 Linux 服务器上进行一次基本且简化的安装所需的命令与步骤，当然在 Mac 或 Windows 服务器上同样可以运行这些服务。 事实上，在你的计算机基础架构中建立一个生产环境服务器，将不可避免的使用到不同的安全措施与操作系统工具。但是，希望你能从本节中获得一些必要的知识。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库。 这通常是很简单的。 为了通过克隆你的仓库来创建一个新的裸仓库，你需要在克隆命令后加上 <code>--bare</code> 选项。 按照惯例，裸仓库目录名以 .git 结尾，就像这样：</p><pre class=" language-console"><code class="language-console">$ git clone --bare my_project my_project.gitCloning into bare repository 'my_project.git'...done.</code></pre><p>现在，你的 <code>my_project.git</code> 目录中应该有 Git 目录的副本了。</p><p>整体上效果大致相当于</p><pre class=" language-console"><code class="language-console">$ cp -Rf my_project/.git my_project.git</code></pre><p>虽然在配置文件中有若干不同，但是对于你的目的来说，这两种方式都是一样的。 它只取出 Git 仓库自身，不要工作目录，然后特别为它单独创建一个目录。</p><h3 id="把裸仓库放到服务器上"><a href="#把裸仓库放到服务器上" class="headerlink" title="把裸仓库放到服务器上"></a>把裸仓库放到服务器上</h3><p>既然你有了裸仓库的副本，剩下要做的就是把裸仓库放到服务器上并设置你的协议。 假设一个域名为 <code>git.example.com</code> 的服务器已经架设好，并可以通过 SSH 连接，你想把所有的 Git 仓库放在 <code>/opt/git</code>目录下。 假设服务器上存在 <code>/opt/git/</code> 目录，你可以通过以下命令复制你的裸仓库来创建一个新仓库：</p><pre class=" language-console"><code class="language-console">$ scp -r my_project.git user@git.example.com:/opt/git</code></pre><p>此时，其他通过 SSH 连接这台服务器并对 <code>/opt/git</code> 目录拥有可读权限的使用者，通过运行以下命令就可以克隆你的仓库。</p><pre class=" language-console"><code class="language-console">$ git clone user@git.example.com:/opt/git/my_project.git</code></pre><p>如果一个用户，通过使用 SSH 连接到一个服务器，并且其对 <code>/opt/git/my_project.git</code> 目录拥有可写权限，那么他将自动拥有推送权限。</p><p>如果到该项目目录中运行 <code>git init</code> 命令，并加上 <code>--shared</code> 选项，那么 Git 会自动修改该仓库目录的组权限为可写。</p><pre class=" language-console"><code class="language-console">$ ssh user@git.example.com$ cd /opt/git/my_project.git$ git init --bare --shared</code></pre><p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和协作者都有 SSH 访问权的服务器是多么容易。 现在你们已经准备好在同一项目上展开合作了。</p><p>值得注意的是，这的确是架设一个几个人拥有连接权的 Git 服务的全部——只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。 你已经准备好了一切，无需更多。</p><p>下面的几节中，你会了解如何扩展到更复杂的设定。 这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面等等。 然而，请记住这一点，如果只是和几个人在一个私有项目上合作的话，<em>仅仅</em> 是一个 SSH 服务器和裸仓库就足够了。</p><h3 id="小型安装"><a href="#小型安装" class="headerlink" title="小型安装"></a>小型安装</h3><p>如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。 架设 Git 服务最复杂的地方在于用户管理。 如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可安排就会比较困难。</p><h4 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h4><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了，因为你几乎什么都不用做（正如我们上一节所说的）。 如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p><p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。 我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。</p><p>有几个方法可以使你给团队每个成员提供访问权。 第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。 或许你不会想要为每个人运行一次 <code>adduser</code> 并且设置临时密码。</p><p>第二个办法是在主机上建立一个 <em>git</em> 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的 <code>~/.ssh/authorized_keys</code> 文件。 这样一来，所有人都将通过 <em>git</em> 账户访问主机。 这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</p><p>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。 只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</p><h2 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h2><p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p><pre class=" language-console"><code class="language-console">$ cd ~/.ssh$ lsauthorized_keys2  id_dsa       known_hostsconfig            id_dsa.pub</code></pre><p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。在 Linux/Mac 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p><pre class=" language-console"><code class="language-console">$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/schacon/.ssh/id_rsa):Created directory '/home/schacon/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/schacon/.ssh/id_rsa.Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.The key fingerprint is:d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</code></pre><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。</p><p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p><pre class=" language-console"><code class="language-console">$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local</code></pre><p>关于在多种操作系统中生成 SSH 密钥的更深入教程，请参阅 GitHub 的 SSH 密钥指南 <a href="https://help.github.com/articles/generating-ssh-keys。" target="_blank" rel="noopener">https://help.github.com/articles/generating-ssh-keys。</a></p><h2 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h2><p>我们来看看如何配置服务器端的 SSH 访问。 本例中，我们将使用 <code>authorized_keys</code> 方法来对用户进行认证。 同时我们假设你使用的操作系统是标准的 Linux 发行版，比如 Ubuntu。 首先，创建一个操作系统用户 <code>git</code>，并为其建立一个 <code>.ssh</code> 目录。</p><pre class=" language-console"><code class="language-console">$ sudo adduser git$ su git$ cd$ mkdir .ssh && chmod 700 .ssh$ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys</code></pre><p>接着，我们需要为系统用户 <code>git</code> 的 <code>authorized_keys</code> 文件添加一些开发者 SSH 公钥。 假设我们已经获得了若干受信任的公钥，并将它们保存在临时文件中。 与前文类似，这些公钥看起来是这样的：</p><pre class=" language-console"><code class="language-console">$ cat /tmp/id_rsa.john.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair</code></pre><p>将这些公钥加入系统用户 <code>git</code> 的 <code>.ssh</code> 目录下 <code>authorized_keys</code> 文件的末尾：</p><pre class=" language-console"><code class="language-console">$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys</code></pre><p>现在我们来为开发者新建一个空仓库。可以借助带 <code>--bare</code> 选项的 <code>git init</code> 命令来做到这一点，该命令在初始化仓库时不会创建工作目录：</p><pre class=" language-console"><code class="language-console">$ cd /opt/git$ mkdir project.git$ cd project.git$ git init --bareInitialized empty Git repository in /opt/git/project.git/</code></pre><p>接着，John、Josie 或者 Jessica 中的任意一人可以将他们项目的最初版本推送到这个仓库中，他只需将此仓库设置为项目的远程仓库并向其推送分支。 请注意，每添加一个新项目，都需要有人登录服务器取得 shell，并创建一个裸仓库。 我们假定这个设置了 <code>git</code> 用户和 Git 仓库的服务器使用 <code>gitserver</code> 作为主机名。 同时，假设该服务器运行在内网，并且你已在 DNS 配置中将 <code>gitserver</code> 指向此服务器。那么我们可以运行如下命令（假定 <code>myproject</code> 是已有项目且其中已包含文件）：</p><pre class=" language-console"><code class="language-console"># on John's computer$ cd myproject$ git init$ git add .$ git commit -m 'initial commit'$ git remote add origin git@gitserver:/opt/git/project.git$ git push origin master</code></pre><p>此时，其他开发者可以克隆此仓库，并推回各自的改动，步骤很简单：</p><pre class=" language-console"><code class="language-console">$ git clone git@gitserver:/opt/git/project.git$ cd project$ vim README$ git commit -am 'fix for the README file'$ git push origin master</code></pre><p>通过这种方法，你可以快速搭建一个具有读写权限、面向多个开发者的 Git 服务器。</p><p>需要注意的是，目前所有（获得授权的）开发者用户都能以系统用户 <code>git</code> 的身份登录服务器从而获得一个普通 shell。 如果你想对此加以限制，则需要修改 <code>passwd</code> 文件中（<code>git</code> 用户所对应）的 shell 值。</p><p>借助一个名为 <code>git-shell</code> 的受限 shell 工具，你可以方便地将用户 <code>git</code> 的活动限制在与 Git 相关的范围内。该工具随 Git 软件包一同提供。 如果将 <code>git-shell</code> 设置为用户 <code>git</code> 的登录 shell（login shell），那么用户 <code>git</code> 便不能获得此服务器的普通 shell 访问权限。 若要使用 <code>git-shell</code>，需要用它替换掉 bash 或 csh，使其成为系统用户的登录 shell。 为进行上述操作，首先你必须确保 <code>git-shell</code> 已存在于 <code>/etc/shells</code> 文件中：</p><pre class=" language-console"><code class="language-console">$ cat /etc/shells   # see if `git-shell` is already in there.  If not...$ which git-shell   # make sure git-shell is installed on your system.$ sudo vim /etc/shells  # and add the path to git-shell from last command</code></pre><p>现在你可以使用 <code>chsh &lt;username&gt;</code> 命令修改任一系统用户的 shell：</p><pre class=" language-console"><code class="language-console">$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell</code></pre><p>这样，用户 <code>git</code> 就只能利用 SSH 连接对 Git 仓库进行推送和拉取操作，而不能登录机器并取得普通 shell。 如果试图登录，你会发现尝试被拒绝，像这样：</p><pre class=" language-console"><code class="language-console">$ ssh git@gitserverfatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access.Connection to gitserver closed.</code></pre><p>现在，网络相关的 Git 命令依然能够正常工作，但是开发者用户已经无法得到一个普通 shell 了。 正如输出信息所提示的，你也可以在 <code>git</code> 用户的家目录下建立一个目录，来对 <code>git-shell</code> 命令进行一定程度的自定义。 比如，你可以限制掉某些本应被服务器接受的 Git 命令，或者对刚才的 SSH 拒绝登录信息进行自定义，这样，当有开发者用户以类似方式尝试登录时，便会看到你的信息。 要了解更多有关自定义 shell 的信息，请运行 <code>git help shell</code>。</p><h2 id="Git-守护进程"><a href="#Git-守护进程" class="headerlink" title="Git 守护进程"></a>Git 守护进程</h2><p>接下来我们将通过 “Git” 协议建立一个基于守护进程的仓库。 对于快速且无需授权的 Git 数据访问，这是一个理想之选。 请注意，因为其不包含授权服务，任何通过该协议管理的内容将在其网络上公开。</p><p>如果运行在防火墙之外的服务器上，它应该只对那些公开的只读项目服务。 如果运行在防火墙之内的服务器上，它可用于支撑大量参与人员或自动系统（用于持续集成或编译的主机）只读访问的项目，这样可以省去逐一配置 SSH 公钥的麻烦。</p><p>无论何时，该 Git 协议都是相对容易设定的。 通常，你只需要以守护进程的形式运行该命令：</p><pre class=" language-console"><code class="language-console">git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</code></pre><p><code>--reuseaddr</code> 允许服务器在无需等待旧连接超时的情况下重启，<code>--base-path</code> 选项允许用户在未完全指定路径的条件下克隆项目，结尾的路径将告诉 Git 守护进程从何处寻找仓库来导出。 如果有防火墙正在运行，你需要开放端口 9418 的通信权限。</p><p>你可以通过许多方式将该进程以守护进程的方式运行，这主要取决于你所使用的操作系统。 在一台 Ubuntu 机器上，你可以使用一份 Upstart 脚本。 因此，找到如下文件：</p><pre class=" language-console"><code class="language-console">/etc/event.d/local-git-daemon</code></pre><p>并添加下列脚本内容：</p><pre class=" language-console"><code class="language-console">start on startupstop on shutdownexec /usr/bin/git daemon \    --user=git --group=git \    --reuseaddr \    --base-path=/opt/git/ \    /opt/git/respawn</code></pre><p>出于安全考虑，强烈建议使用一个对仓库拥有只读权限的用户身份来运行该守护进程 - 你可以创建一个新用户 <em>git-ro</em> 并且以该用户身份来运行守护进程。 为简便起见，我们将像 <code>git-shell</code> 一样，同样使用 <em>git</em> 用户来运行它。</p><p>当你重启机器时，你的 Git 守护进程将会自动启动，并且如果进程被意外结束它会自动重新运行。 为了在不重启的情况下直接运行，你可以运行以下命令：</p><pre class=" language-console"><code class="language-console">initctl start local-git-daemon</code></pre><p>在其他系统中，你可以使用 <code>sysvinit</code> 系统中的 <code>xinetd</code> 脚本，或者另外的方式来实现 - 只要你能够将其命令守护进程化并实现监控。</p><p>接下来，你需要告诉 Git 哪些仓库允许基于服务器的无授权访问。 你可以在每个仓库下创建一个名为 <code>git-daemon-export-ok</code> 的文件来实现。</p><pre class=" language-console"><code class="language-console">$ cd /path/to/project.git$ touch git-daemon-export-ok</code></pre><p>该文件将允许 Git 提供无需授权的项目访问服务。</p><h2 id="Smart-HTTP"><a href="#Smart-HTTP" class="headerlink" title="Smart HTTP"></a>Smart HTTP</h2><p>我们一般通过 SSH 进行授权访问，通过 git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>在完成以上简单的安装步骤后， 我们将用 Apache 来作为 CGI 服务器。 如果你没有安装 Apache，你可以在 Linux 环境下执行如下或类似的命令来安装：</p><pre class=" language-console"><code class="language-console">$ sudo apt-get install apache2 apache2-utils$ a2enmod cgi alias env</code></pre><p>该操作将会启用 <code>mod_cgi</code>， <code>mod_alias</code>， 和 <code>mod_env</code> 等 Apache 模块， 这些模块都是使该功能正常工作所必须的。</p><p>接下来我们要向 Apache 配置文件添加一些内容，来让 <code>git-http-backend</code> 作为 Web 服务器对 <code>/git</code> 路径请求的处理器。</p><pre class=" language-console"><code class="language-console">SetEnv GIT_PROJECT_ROOT /opt/gitSetEnv GIT_HTTP_EXPORT_ALLScriptAlias /git/ /usr/lib/git-core/git-http-backend/</code></pre><p>如果留空 <code>GIT_HTTP_EXPORT_ALL</code> 这个环境变量，Git 将只对无授权客户端提供带 <code>git-daemon-export-ok</code> 文件的版本库，就像 Git 守护进程一样。</p><p>接着你需要让 Apache 接受通过该路径的请求，添加如下的内容至 Apache 配置文件：</p><pre class=" language-console"><code class="language-console"><Directory "/usr/lib/git-core*">   Options ExecCGI Indexes   Order allow,deny   Allow from all   Require all granted</Directory></code></pre><p>最后，如果想实现写操作授权验证，使用如下的未授权屏蔽配置即可：</p><pre class=" language-console"><code class="language-console"><LocationMatch "^/git/.*/git-receive-pack$">    AuthType Basic    AuthName "Git Access"    AuthUserFile /opt/git/.htpasswd    Require valid-user</LocationMatch></code></pre><p>这需要你创建一个包含所有合法用户密码的 <code>.htaccess</code> 文件。 以下是一个添加 “schacon” 用户到此文件的例子：</p><pre class=" language-console"><code class="language-console">$ htdigest -c /opt/git/.htpasswd "Git Access" schacon</code></pre><p>你可以通过许多方式添加 Apache 授权用户，选择使用其中一种方式即可。 以上仅仅只是我们可以找到的最简单的一个例子。 如果愿意的话，你也可以通过 SSL 运行它，以保证所有数据是在加密状态下进行传输的。</p><p>我们不想深入去讲解 Apache 配置文件，因为你可能会使用不同的 Web 服务器，或者可能有不同的授权需求。 它的主要原理是使用一个 Git 附带的，名为 <code>git-http-backend</code> 的 CGI。它被引用来处理协商通过 HTTP 发送和接收的数据。 它本身并不包含任何授权功能，但是授权功能可以在 Web 服务器层引用它时被轻松实现。 你可以在任何所有可以处理 CGI 的 Web 服务器上办到这点，所以随便挑一个你最熟悉的 Web 服务器试手吧。</p><table><thead><tr><th>Note</th><th>欲了解更多的有关配置 Apache 授权访问的信息，请通过以下链接浏览 Apache 文档： <a href="http://httpd.apache.org/docs/current/howto/auth.html" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/howto/auth.html</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="GitWeb"><a href="#GitWeb" class="headerlink" title="GitWeb"></a>GitWeb</h2><p>如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。 Git 提供了一个叫做 GitWeb 的 CGI 脚本来做这项工作。</p><p><img src="https://git-scm.com/book/en/v2/images/git-instaweb.png" alt="GitWeb 的网页用户界面"></p><p>Figure 49. GitWeb 的网页用户界面</p><p>如果你想要查看 GitWeb 如何展示你的项目，并且在服务器上安装了轻量级网络服务器比如 <code>lighttpd</code> 或 <code>webrick</code>， Git 提供了一个命令来让你启动一个临时的服务器。 在 Linux 系统的电脑上，<code>lighttpd</code> 通常已经安装了，所以你只需要在项目目录里执行 <code>git instaweb</code> 命令即可。 如果你使用 Mac 系统， Mac OS X Leopard 系统已经预安装了 Ruby，所以 <code>webrick</code> 或许是你最好的选择。 如果不想使用 lighttpd 启动 <code>instaweb</code> 命令，你需要在执行时加入 <code>--httpd</code> 参数。</p><pre class=" language-console"><code class="language-console">$ git instaweb --httpd=webrick[2009-02-21 10:02:21] INFO  WEBrick 1.3.1[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</code></pre><p>这个命令启动了一个监听 1234 端口的 HTTP 服务器，并且自动打开了浏览器。 这对你来说十分方便。 当你已经完成了工作并想关闭这个服务器，你可以执行同一个命令，并加上 <code>--stop</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git instaweb --httpd=webrick --stop</code></pre><p>如果你现在想为你的团队或你托管的开源项目持续的运行这个页面，你需要通过普通的 Web 服务器来设置 CGI 脚本。 一些 Linux 发行版的软件库有 <code>gitweb</code> 包，可以通过 <code>apt</code> 或 <code>yum</code> 来安装，你可以先试试。 接下来我们来快速的了解一下如何手动安装 GitWeb。 首先，你需要获得 Git 的源代码，它包含了 GitWeb ，并可以生成自定义的 CGI 脚本：</p><pre class=" language-console"><code class="language-console">$ git clone git://git.kernel.org/pub/scm/git/git.git$ cd git/$ make GITWEB_PROJECTROOT="/opt/git" prefix=/usr gitweb    SUBDIR gitweb    SUBDIR ../make[2]: `GIT-VERSION-FILE' is up to date.    GEN gitweb.cgi    GEN static/gitweb.js$ sudo cp -Rf gitweb /var/www/</code></pre><p>需要注意的是，你需要在命令中指定 <code>GITWEB_PROJECTROOT</code> 变量来让程序知道你的 Git 版本库的位置。 现在，你需要在 Apache 中使用这个 CGI 脚本，你需要为此添加一个虚拟主机：</p><pre class=" language-console"><code class="language-console"><VirtualHost *:80>    ServerName gitserver    DocumentRoot /var/www/gitweb    <Directory /var/www/gitweb>        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch        AllowOverride All        order allow,deny        Allow from all        AddHandler cgi-script cgi        DirectoryIndex gitweb.cgi    </Directory></VirtualHost></code></pre><p>再次提醒，GitWeb 可以通过任何一个支持 CGI 或 Perl 的网络服务器架设；如果你需要的话，架设起来应该不会很困难。 现在，你可以访问 <code>http://gitserver/</code> 在线查看你的版本库。</p><h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p>虽然 GitWeb 相当简单。 但如果你正在寻找一个更现代，功能更全的 Git 服务器，这里有几个开源的解决方案可供你选择安装。 因为 GitLab 是其中最出名的一个，我们将它作为示例并讨论它的安装和使用。 这比 GitWeb 要复杂的多并且需要更多的维护，但它的确是一个功能更全的选择。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>GitLab 是一个数据库支持的 web 应用，所以相比于其他 git 服务器，它的安装过程涉及到更多的东西。 幸运的是，这个过程有非常详细的文档说明和支持。</p><p>这里有一些可参考的方法帮你安装 GitLab 。 为了更快速的启动和运行，你可以下载虚拟机镜像或者在 <a href="https://bitnami.com/stack/gitlab" target="_blank" rel="noopener">https://bitnami.com/stack/gitlab</a> 上获取一键安装包，同时调整配置使之符合你特定的环境。 Bitnami 的一个优点在于它的登录界面（通过 alt-&amp;rarr 键进入；）；它会告诉你安装好的 GitLab 的 IP 地址以及默认的用户名和密码。</p><p><img src="https://git-scm.com/book/en/v2/images/bitnami.png" alt="Bitnami GitLab 虚拟机登录界面。"></p><p>Figure 50. Bitnami GitLab 虚拟机登录界面。</p><p>无论如何，跟着 GitLab 社区版的 readme 文件一步步来，你可以在这里找到它 <a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/tree/master</a> 。 在这里你将会在主菜单中找到安装 GitLab 的帮助，一个可以在 Digital Ocean 上运行的虚拟机，以及 RPM 和 DEB 包（都是测试版）。 这里还有 “非官方” 的引导让 GitLab 运行在非标准的操作系统和数据库上，一个全手动的安装脚本，以及许多其他的话题。</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>GitLab 的管理界面是通过网络进入的。 将你的浏览器转到已经安装 GitLab 的 主机名或 IP 地址，然后以管理员身份登录即可。 默认的用户名是 <code>admin@local.host</code>，默认的密码是 <code>5iveL!fe</code>（你会得到类似 请登录后尽快更换密码 的提示）。 登录后，点击主栏上方靠右位置的 “Admin area” 图标进行管理。</p><p><img src="https://git-scm.com/book/en/v2/images/gitlab-menu.png" alt="GitLab 主栏的 ``Admin area&#39;&#39; 图标。"></p><p>Figure 51. GitLab 主栏的 “Admin area” 图标。</p><h4 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h4><p>GitLab 上的用户指的是对应协作者的帐号。 用户帐号没有很多复杂的地方，主要是包含登录数据的用户信息集合。 每一个用户账号都有一个 <strong>命名空间</strong> ，即该用户项目的逻辑集合。 如果一个叫 <code>jane</code> 的用户拥有一个名称是 <code>project</code> 的项目，那么这个项目的 url 会是 <a href="http://server/jane/project" target="_blank" rel="noopener">http://server/jane/project</a> 。</p><p><img src="https://git-scm.com/book/en/v2/images/gitlab-users.png" alt=".GitLab 用户管理界面。"></p><p>Figure 52. GitLab 用户管理界面。</p><p>移除一个用户有两种方法。 “屏蔽（Blocking）” 一个用户阻止他登录 GitLab 实例，但是该用户命名空间下的所有数据仍然会被保存，并且仍可以通过该用户提交对应的登录邮箱链接回他的个人信息页。</p><p>而另一方面，“销毁（Destroying）” 一个用户，会彻底的将他从数据库和文件系统中移除。 他命名空间下的所有项目和数据都会被删除，拥有的任何组也会被移除。 这显然是一个更永久且更具破坏力的行为，所以很少用到这种方法。</p><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><p>一个 GitLab 的组是一些项目的集合，连同关于多少用户可以访问这些项目的数据。 每一个组都有一个项目命名空间（与用户一样），所以如果一个叫 <code>training</code> 的组拥有一个名称是 <code>materials</code> 的项目，那么这个项目的 url 会是 <a href="http://server/training/materials" target="_blank" rel="noopener">http://server/training/materials</a> 。</p><p><img src="https://git-scm.com/book/en/v2/images/gitlab-groups.png" alt="GitLab组 管理界面。"></p><p>Figure 53. GitLab组 管理界面。</p><p>每一个组都有许多用户与之关联，每一个用户对组中的项目以及组本身的权限都有级别区分。 权限的范围从 “访客”（仅能提问题和讨论） 到 “拥有者”（完全控制组、成员和项目）。 权限的种类太多以至于难以在这里一一列举，不过在 GitLab 的管理界面上有帮助链接。</p><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><p>一个 GitLab 的项目相当于 git 的版本库。 每一个项目都属于一个用户或者一个组的单个命名空间。 如果这个项目属于一个用户，那么这个拥有者对所有可以获取这个项目的人拥有直接管理权；如果这个项目属于一个组，那么该组中用户级别的权限也会起作用。</p><p>每一个项目都有一个可视级别，控制着谁可以看到这个项目页面和仓库。 如果一个项目是 <em>私有</em> 的，这个项目的拥有者必须明确授权从而使特定的用户可以访问。 一个 <em>内部</em> 的项目可以被所有登录的人看到，而一个 <em>公开</em> 的项目则是对所有人可见的。 注意，这种控制既包括 git “fetch” 的使用也包括对项目 web 用户界面的访问。</p><h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>GitLab 在项目和系统级别上都支持钩子程序。 对任意级别，当有相关事件发生时，GitLab 的服务器会执行一个包含描述性 JSON 数据的 HTTP 请求。 这是自动化连接你的 git 版本库和 GitLab 实例到其他的开发工具，比如 CI 服务器，聊天室，或者部署工具的一个极好方法。</p><h3 id="基本用途"><a href="#基本用途" class="headerlink" title="基本用途"></a>基本用途</h3><p>你想要在 GitLab 做的第一件事就是建立一个新项目。 这通过点击工具栏上的 “+” 图标完成。 你会被要求填写项目名称，也就是这个项目所属的命名空间，以及它的可视层级。 绝大多数的设定并不是永久的，可以通过设置界面重新调整。 点击 “Create Project”，你就完成了。</p><p>项目存在后，你可能会想将它与本地的 Git 版本库连接。 每一个项目都可以通过 HTTPS 或者 SSH 连接，任意两者都可以被用来配置远程 Git。 在项目主页的顶栏可以看到这个项目的 URLs。 对于一个存在的本地版本库，这个命令将会向主机位置添加一个叫 <code>gitlab</code> 的远程仓库：</p><pre class=" language-console"><code class="language-console">$ git remote add gitlab https://server/namespace/project.git</code></pre><p>如果你的本地没有版本库的副本，你可以这样做：</p><pre class=" language-console"><code class="language-console">$ git clone https://server/namespace/project.git</code></pre><p>web 用户界面提供了几个有用的获取版本库信息的网页。 每一个项目的主页都显示了最近的活动，并且通过顶部的链接可以使你浏览项目文件以及提交日志。</p><h3 id="一起工作"><a href="#一起工作" class="headerlink" title="一起工作"></a>一起工作</h3><p>在一个 GitLab 项目上一起工作的最简单方法就是赋予协作者对 git 版本库的直接 push 权限。 你可以通过项目设定的 “Members（成员）” 部分向一个项目添加写作者，并且将这个新的协作者与一个访问级别关联（不同的访问级别在 <a href="https://git-scm.com/book/zh/v2/ch00/r_gitlab_groups_section" target="_blank" rel="noopener">组</a> 中已简单讨论）。 通过赋予一个协作者 “Developer（开发者）” 或者更高的访问级别，这个用户就可以毫无约束地直接向版本库或者向分支进行提交。</p><p>另外一个让合作更解耦的方法就是使用合并请求。 它的优点在于让任何能够看到这个项目的协作者在被管控的情况下对这个项目作出贡献。 可以直接访问的协作者能够简单的创建一个分支，向这个分支进行提交，也可以开启一个向 <code>master</code> 或者其他任何一个分支的合并请求。 对版本库没有推送权限的协作者则可以 “fork” 这个版本库（即创建属于自己的这个库的副本），向 <em>那个</em> 副本进行提交，然后从那个副本开启一个到主项目的合并请求。 这个模型使得项目拥有者完全控制着向版本库的提交，以及什么时候允许加入陌生协作者的贡献。</p><p>在 GitLab 中合并请求和问题是一个长久讨论的主要部分。 每一个合并请求都允许在提出改变的行进行讨论（它支持一个轻量级的代码审查），也允许对一个总体性话题进行讨论。 两者都可以被分配给用户，或者组织到 milestones（里程碑） 界面。</p><p>这个部分主要聚焦于在 GitLab 中与 Git 相关的特性，但是 GitLab 作为一个成熟的系统，它提供了许多其他产品来帮助你协同工作，例如项目 wiki 与系统维护工具。 GitLab 的一个优点在于，服务器设置和运行以后，你将很少需要调整配置文件或通过 SSH 连接服务器；绝大多数的管理和日常使用都可以在浏览器界面中完成。</p><h2 id="第三方托管的选择"><a href="#第三方托管的选择" class="headerlink" title="第三方托管的选择"></a>第三方托管的选择</h2><p>如果不想设立自己的 Git 服务器，你可以选择将你的 Git 项目托管到一个外部专业的托管网站。 这带来了一些好处：一个托管网站可以用来快速建立并开始项目，且无需进行服务器维护和监控工作。 即使你在内部设立并且运行了自己的服务器，你仍然可以把你的开源代码托管在公共托管网站 - 这通常更有助于开源社区来发现和帮助你。</p><p>现在，有非常多的托管供你选择，每个选择都有不同的优缺点。 欲查看最新列表，请浏览 Git 维基的 GitHosting 页面 <a href="https://git.wiki.kernel.org/index.php/GitHosting" target="_blank" rel="noopener">https://git.wiki.kernel.org/index.php/GitHosting</a></p><p>我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch06-github" target="_blank" rel="noopener">GitHub</a> 详细讲解 GitHub，作为目前最大的 Git 托管平台，你很可能需要与托管在 GitHub 上的项目进行交互，而且你也很可能并不想去设立你自己的 Git 服务器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你有多种远程存取 Git 仓库的选择便于与其他人合作或是分享你的工作。</p><p>运行你自己的服务器将有许多权限且允许你运行该服务于你自己的防火墙内，但如此通常需要耗费你大量的时间去设置与维护服务器。 如果你放置你的资料于托管服务器内，可轻易的设置与维护；无论如何，你必须能够保存你的代码在其他服务器，且某些组织不允许此作法。 这将直截了当的决定哪个作法或组合的方式较适合你或你的组织。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支</title>
      <link href="/2019/07/15/Git%E5%88%86%E6%94%AF/"/>
      <url>/2019/07/15/Git%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>有人把 Git 的分支模型称为它的`‘必杀技特性’’，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p><p>或许你还记得 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction" target="_blank" rel="noopener">起步</a> 的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction" target="_blank" rel="noopener">起步</a> 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><pre class=" language-console"><code class="language-console">$ git add README test.rb LICENSE$ git commit -m 'The initial commit of my project'</code></pre><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt="首次提交对象及其树结构。"></p><p>Figure 9. 首次提交对象及其树结构</p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="提交对象及其父对象。"></p><p>Figure 10. 提交对象及其父对象</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><table><thead><tr><th>Note</th><th>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="https://git-scm.com/book/en/v2/images/branch-and-history.png" alt="分支及其提交历史。"></p><p>Figure 11. 分支及其提交历史</p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git branch testing</code></pre><p>这会在当前所在的提交对象上创建一个指针。</p><p><img src="https://git-scm.com/book/en/v2/images/two-branches.png" alt="两个指向相同提交历史的分支。"></p><p>Figure 12. 两个指向相同提交历史的分支</p><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p><p>Figure 13. HEAD 指向当前所在的分支</p><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --decoratef30ab (HEAD, master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project</code></pre><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><pre class=" language-console"><code class="language-console">$ git checkout testing</code></pre><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p><p>Figure 14. HEAD 指向当前所在的分支</p><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><pre class=" language-console"><code class="language-console">$ vim test.rb$ git commit -a -m 'made a change'</code></pre><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></p><p>Figure 15. HEAD 分支随着提交操作自动向前移动</p><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code>时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><pre class=" language-console"><code class="language-console">$ git checkout master</code></pre><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="检出时 HEAD 随之移动。"></p><p>Figure 16. 检出时 HEAD 随之移动</p><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p><table><thead><tr><th>Note</th><th>分支切换会改变你工作目录中的文件在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>我们不妨再稍微做些修改并提交：</p><pre class=" language-console"><code class="language-console">$ vim test.rb$ git commit -a -m 'made other changes'</code></pre><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="项目分叉历史。"></p><p>Figure 17. 项目分叉历史</p><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><pre class=" language-console"><code class="language-console">$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project</code></pre><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p><p>接下来，让我们看看你为什么应该这样做。</p><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="一个简单的提交历史。"></p><p>Figure 18. 一个简单提交历史</p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git checkout -b iss53Switched to a new branch "iss53"</code></pre><p>它是下面两条命令的简写：</p><pre class=" language-console"><code class="language-console">$ git branch iss53$ git checkout iss53</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。"></p><p>Figure 19. 创建一个新分支指针</p><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><pre class=" language-console"><code class="language-console">$ vim index.html$ git commit -a -m 'added a new footer [issue 53]'</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt="iss53 分支随着工作的进展向前推进。"></p><p>Figure 20. iss53 分支随着工作的进展向前推进</p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing" target="_blank" rel="noopener">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><pre class=" language-console"><code class="language-console">$ git checkout masterSwitched to branch 'master'</code></pre><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><pre class=" language-console"><code class="language-console">$ git checkout -b hotfixSwitched to a new branch 'hotfix'$ vim index.html$ git commit -a -m 'fixed the broken email address'[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+)</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于 `master` 分支的紧急问题分支（hotfix branch）。"></p><p>Figure 21. 基于 <code>master</code> 分支的紧急问题分支 <code>hotfix branch</code></p><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><pre class=" language-console"><code class="language-console">$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)</code></pre><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="`master` 被快进到 `hotfix`。"></p><p>Figure 22. <code>master</code> 被快进到 <code>hotfix</code></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><pre class=" language-console"><code class="language-console">$ git branch -d hotfixDeleted branch hotfix (3a0874c).</code></pre><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><pre class=" language-console"><code class="language-console">$ git checkout iss53Switched to branch "iss53"$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+)</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="继续在 `iss53` 分支上的工作。"></p><p>Figure 23. 继续在 <code>iss53</code> 分支上的工作</p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git checkout masterSwitched to branch 'master'$ git merge iss53Merge made by the 'recursive' strategy.index.html |    1 +1 file changed, 1 insertion(+)</code></pre><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p><p>Figure 24. 一次典型合并中所用到的三个快照</p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。"></p><p>Figure 25. 一个合并提交</p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><pre class=" language-console"><code class="language-console">$ git branch -d iss53</code></pre><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><pre class=" language-console"><code class="language-console">$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterYou have unmerged paths.  (fix conflicts and run "git commit")Unmerged paths:  (use "git add <file>..." to mark resolution)    both modified:      index.htmlno changes added to commit (use "git add" and/or "git commit -a")</code></pre><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><pre class=" language-html"><code class="language-html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>contact : email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>=======<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> please contact us at support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>>>>>>>> iss53:index.html</code></pre><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>please contact us at email.support@github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><pre class=" language-console"><code class="language-console">$ git mergetoolThis message is displayed because 'merge.tool' is not configured.See 'git mergetool --tool-help' or 'git help config' for more details.'git mergetool' will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict for 'index.html':  {local}: modified file  {remote}: modified fileHit return to start merge resolution tool (opendiff):</code></pre><p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code> 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p><table><thead><tr><th>Note</th><th>如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_advanced_merging" target="_blank" rel="noopener">高级合并</a> 介绍更多关于分支合并的内容。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterAll conflicts fixed but you are still merging.  (use "git commit" to conclude merge)Changes to be committed:    modified:   index.html</code></pre><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><pre class=" language-console"><code class="language-console">Merge branch 'iss53'Conflicts:    index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file#    .git/MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:#    modified:   index.html#</code></pre><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><pre class=" language-console"><code class="language-console">$ git branch  iss53* master  testing</code></pre><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><pre class=" language-console"><code class="language-console">$ git branch -v  iss53   93b412c fix javascript issue* master  7a98805 Merge branch 'iss53'  testing 782fd34 add scott to the author list in the readmes</code></pre><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><pre class=" language-console"><code class="language-console">$ git branch --merged  iss53* master</code></pre><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><pre class=" language-console"><code class="language-console">$ git branch --no-merged  testing</code></pre><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><pre class=" language-console"><code class="language-console">$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'.</code></pre><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-1.png" alt="渐进稳定分支的线性图。"></p><p>Figure 26. 渐进稳定分支的线性图</p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="渐进稳定分支的工作流（“silo”）视图。"></p><p>Figure 27. 渐进稳定分支的流水线（“silo”）视图</p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code>分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png" alt="拥有多个特性分支的提交历史。"></p><p>Figure 28. 拥有多个特性分支的提交历史</p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png" alt="合并了 `dumbidea` 和 `iss91v2` 分支之后的提交历史。"></p><p>Figure 29. 合并了 <code>dumbidea</code> 和 <code>iss91v2</code> 分支之后的提交历史</p><p>我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git" target="_blank" rel="noopener">分布式 Git</a> 中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。</p><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote (remote)</code>来显式地获得远程引用的完整列表，或者通过 <code>git remote show (remote)</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p><p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><table><thead><tr><th>Note</th><th>“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></p><p>Figure 30. 克隆之后的服务器与本地仓库</p><p>如果你在本地的 <code>master</code> 分支做了一些工作，与此同时，其他人推送提交到 <code>git.ourcompany.com</code> 并更新了它的 <code>master</code> 分支，那么你的提交历史将向不同的方向前进。 另外，只要你不与 origin 服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></p><p>Figure 31. 本地与远程的工作可以分叉</p><p>如果要同步你的工作，运行 <code>git fetch origin</code> 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针指向新的、更新后的位置。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png" alt="`git fetch` 更新你的远程仓库引用。"></p><p>Figure 32. <code>git fetch</code> 更新你的远程仓库引用</p><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics" target="_blank" rel="noopener">Git 基础</a> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为整个 URL 的缩写。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-4.png" alt="添加另一个远程仓库。"></p><p>Figure 33. 添加另一个远程仓库</p><p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-5.png" alt="远程跟踪分支 `teamone/master`。"></p><p>Figure 34. 远程跟踪分支 <code>teamone/master</code></p><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push (remote) (branch)</code>:</p><pre class=" language-console"><code class="language-console">$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch]      serverfix -> serverfix</code></pre><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 的 <code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行 <code>git push origin serverfix:serverfix</code>，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><table><thead><tr><th>Note</th><th>如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。想要了解更多关于不同验证缓存的可用选项，查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching" target="_blank" rel="noopener">凭证存储</a>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><pre class=" language-console"><code class="language-console">$ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/schacon/simplegit * [new branch]      serverfix    -> origin/serverfix</code></pre><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支 - 只有一个不可以修改的 <code>origin/serverfix</code>指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><pre class=" language-console"><code class="language-console">$ git checkout -b serverfix origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix'</code></pre><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的 “跟踪分支”（它跟踪的分支叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><pre class=" language-console"><code class="language-console">$ git checkout --track origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix'</code></pre><p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><pre class=" language-console"><code class="language-console">$ git checkout -b sf origin/serverfixBranch sf set up to track remote branch serverfix from origin.Switched to a new branch 'sf'</code></pre><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><pre class=" language-console"><code class="language-console">$ git branch -u origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.</code></pre><table><thead><tr><th>Note</th><th>上游快捷方式当设置好跟踪分支后，可以通过 <code>@{upstream}</code> 或 <code>@{u}</code> 快捷方式来引用它。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用 <code>git merge @{u}</code> 来取代 <code>git merge origin/master</code>。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><pre class=" language-console"><code class="language-console">$ git branch -vv  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets  master    1ae2a45 [origin/master] deploying index fix* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it  testing   5ea463a trying something new</code></pre><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<code>$ git fetch --all; git branch -vv</code></p><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code>命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><pre class=" language-console"><code class="language-console">$ git push origin --delete serverfixTo https://github.com/schacon/simplegit - [deleted]         serverfix</code></pre><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>请回顾之前在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_merging" target="_blank" rel="noopener">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p><p>Figure 35. 分叉的提交历史</p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p><p>Figure 36. 通过合并操作来整合分叉了的历史</p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><pre class=" language-console"><code class="language-console">$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command</code></pre><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="将 `C4` 中的修改变基到 `C3` 上。"></p><p>Figure 37. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><pre class=" language-console"><code class="language-console">$ git checkout master$ git merge experiment</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-4.png" alt="master 分支的快进合并。"></p><p>Figure 38. master 分支的快进合并</p><p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_e" target="_blank" rel="noopener">从一个特性分支里再分出一个特性分支的提交历史</a> 中的例子那样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-1.png" alt="从一个特性分支里再分出一个特性分支的提交历史。"></p><p>Figure 39. 从一个特性分支里再分出一个特性分支的提交历史</p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><pre class=" language-console"><code class="language-console">$ git rebase --onto master server client</code></pre><p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-2.png" alt="截取特性分支上的另一个特性分支，然后变基到其他分支。"></p><p>Figure 40. 截取特性分支上的另一个特性分支，然后变基到其他分支</p><p>现在可以快进合并 <code>master</code> 分支了。（如图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_g" target="_blank" rel="noopener">快进合并 master 分支，使之包含来自 client 分支的修改</a>）：</p><pre class=" language-console"><code class="language-console">$ git checkout master$ git merge client</code></pre><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-3.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改。"></p><p>Figure 41. 快进合并 master 分支，使之包含来自 client 分支的修改</p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><pre class=" language-console"><code class="language-console">$ git rebase master server</code></pre><p>如图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_h" target="_blank" rel="noopener">将 server 中的修改变基到 master 上</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-4.png" alt="将 server 中的修改变基到 master 上。"></p><p>Figure 42. 将 server 中的修改变基到 master 上</p><p>然后就可以快进合并主分支 master 了：</p><pre class=" language-console"><code class="language-console">$ git checkout master$ git merge server</code></pre><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_i" target="_blank" rel="noopener">最终的提交历史</a> 中的样子：</p><pre class=" language-console"><code class="language-console">$ git branch -d client$ git branch -d server</code></pre><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p><p>Figure 43. 最终的提交历史</p><h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p><p>Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发</p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p><p>Figure 45. 抓取别人的提交，合并到自己的开发分支</p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p><p>Figure 46. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p><p>Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交</p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h3 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 <a href="https://git-scm.com/book/zh/v2/ch00/r_pre_merge_rebase_work" target="_blank" rel="noopener">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>从而我们将得到与 <a href="https://git-scm.com/book/zh/v2/ch00/r_merge_rebase_work" target="_blank" rel="noopener">你将相同的内容又合并了一次，生成了一个新的提交</a> 中不同的结果，如图 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_rebase_work" target="_blank" rel="noopener">在一个被变基然后强制推送的分支上再次执行变基</a> 所示。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>Figure 48. 在一个被变基然后强制推送的分支上再次执行变基</p><p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经讲完了 Git 分支与合并的基础知识。 你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。 你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。 下一章，我们将要讲到，如果你想要运行自己的 Git 仓库托管服务器，你需要知道些什么。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2019/07/15/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/07/15/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>假如你只能阅读一章来学习 Git，本章就是你的不二选择。 本章内容涵盖你在使用 Git 完成各种工作中将要使用的各种基本命令。 在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。 本章也将向你演示如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。</p><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。</p><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><pre class=" language-console"><code class="language-console">$ git init</code></pre><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 (参见 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals" target="_blank" rel="noopener">Git 内部原理</a> 来了解更多关于到底 <code>.git</code> 文件夹中包含了哪些文件的信息。)</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code> 命令来实现对指定文件的跟踪，然后执行 <code>git commit</code> 提交：</p><pre class=" language-console"><code class="language-console">$ git add *.c$ git add LICENSE$ git commit -m 'initial project version'</code></pre><p>稍后我们再逐一解释每一条指令的意思。 现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的 Git 仓库。</p><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 VCS 系统（比如说Subversion）很熟悉，请留心一下你所使用的命令是”clone”而不是”checkout”。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在，详见 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server" target="_blank" rel="noopener">在服务器上搭建 Git</a> ）。</p><p>克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/libgit2/libgit2</code></pre><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/libgit2/libgit2 mylibgit</code></pre><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 <code>mylibgit</code>。</p><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server" target="_blank" rel="noopener">在服务器上搭建 Git</a> 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。</p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。 接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p><p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="Git 下文件生命周期图。"></p><p>Figure 8. 文件的状态变化周期</p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masternothing to commit, working directory clean</code></pre><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 会详细讨论分支和引用。</p><p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><pre class=" language-console"><code class="language-console">$ echo 'My Project' > README$ git statusOn branch masterUntracked files:  (use "git add <file>..." to include in what will be committed)    READMEnothing added to commit but untracked files present (use "git add" to track)</code></pre><p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><pre class=" language-console"><code class="language-console">$ git add README</code></pre><p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   README</code></pre><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add (files)</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   READMEChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><pre class=" language-console"><code class="language-console">$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   README    modified:   CONTRIBUTING.md</code></pre><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><pre class=" language-console"><code class="language-console">$ vim CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   README    modified:   CONTRIBUTING.mdChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本， 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><pre class=" language-console"><code class="language-console">$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    new file:   README    modified:   CONTRIBUTING.md</code></pre><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。 运行 <code>git status -s</code> ，状态报告输出如下：</p><pre class=" language-console"><code class="language-console">$ git status -s M READMEMM RakefileA  lib/git.rbM  lib/simplegit.rb?? LICENSE.txt</code></pre><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p><pre class=" language-console"><code class="language-console">$ cat .gitignore*.[oa]*~</code></pre><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>) 表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> , <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>我们再看一个 .gitignore 文件的例子：</p><pre><code># no .a files*.a# but do track lib.a, even though you&#39;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf</code></pre><table><thead><tr><th>Tip</th><th>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它.</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code>命令。 稍后我们会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code> 将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    modified:   READMEChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><pre class=" language-console"><code class="language-console">$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you're contributing in the first place, you're less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it's</code></pre><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）</p><pre class=" language-console"><code class="language-console">$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..03902a1--- /dev/null+++ b/README@@ -0,0 +1 @@+My Project</code></pre><p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本。 如果我们的环境（终端输出）看起来如下：</p><pre class=" language-console"><code class="language-console">$ git add CONTRIBUTING.md$ echo '# test line' >> CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    modified:   CONTRIBUTING.mdChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>现在运行 <code>git diff</code> 看暂存前后的变化：</p><pre class=" language-console"><code class="language-console">$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 643e24f..87f08c8 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -119,3 +119,4 @@ at the ## Starter Projects See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).+# test line</code></pre><p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）</p><pre class=" language-console"><code class="language-console">$ git diff --cacheddiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you're contributing in the first place, you're less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it's</code></pre><table><thead><tr><th>Note</th><th>Git Diff 的插件版本在本书中，我们使用 <code>git diff</code> 来分析文件差异。 但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 <code>git difftool</code> 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 <code>git difftool --tool-help</code> 命令来看你的系统支持哪些 Git Diff 插件。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><pre class=" language-console"><code class="language-console">$ git commit</code></pre><p>这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction" target="_blank" rel="noopener">起步</a> 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><pre><code># Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:#    new file:   README#    modified:   CONTRIBUTING.md#~~~&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</code></pre><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 (如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><pre class=" language-console"><code class="language-console">$ git commit -m "Story 182: Fix benchmarks for speed"[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README</code></pre><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><pre class=" language-console"><code class="language-console">$ git statusOn branch masterChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.mdno changes added to commit (use "git add" and/or "git commit -a")$ git commit -a -m 'added new benchmarks'[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre><p>看到了吗？提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><pre class=" language-console"><code class="language-console">$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit:  (use "git add/rm <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)        deleted:    PROJECTS.mdno changes added to commit (use "git add" and/or "git commit -a")</code></pre><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><pre class=" language-console"><code class="language-console">$ git rm PROJECTS.mdrm 'PROJECTS.md'$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    deleted:    PROJECTS.md</code></pre><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git rm --cached README</code></pre><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p><pre class=" language-console"><code class="language-console">$ git rm log/\*.log</code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><pre class=" language-console"><code class="language-console">$ git rm \*~</code></pre><p>该命令为删除以 <code>~</code> 结尾的所有文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p><p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p><pre class=" language-console"><code class="language-console">$ git mv file_from file_to</code></pre><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><pre class=" language-console"><code class="language-console">$ git mv README.md README$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    renamed:    README.md -> README</code></pre><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><pre class=" language-console"><code class="language-console">$ mv README.md README$ git rm README.md$ git add README</code></pre><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>接下来的例子会用我专门用于演示的 simplegit 项目， 运行下面的命令获取该项目源代码：</p><pre class=" language-console"><code class="language-console">git clone https://github.com/schacon/simplegit-progit</code></pre><p>然后在此项目中运行 git log，应该会看到下面的输出：</p><pre class=" language-console"><code class="language-console">$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <schacon@gee-mail.com>Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <schacon@gee-mail.com>Date:   Sat Mar 15 10:31:28 2008 -0700    first commit</code></pre><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。</p><p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交：</p><pre class=" language-console"><code class="language-console">$ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version numberdiff --git a/Rakefile b/Rakefileindex a874b73..8f94139 100644--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require 'rake/gempackagetask' spec = Gem::Specification.new do |s|     s.platform  =   Gem::Platform::RUBY     s.name      =   "simplegit"-    s.version   =   "0.1.0"+    s.version   =   "0.1.1"     s.author    =   "Scott Chacon"     s.email     =   "schacon@gee-mail.com"     s.summary   =   "A simple gem for using Git in Ruby code."commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <schacon@gee-mail.com>Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary testdiff --git a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae..47c6340 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit     end end--if $0 == __FILE__-  git = SimpleGit.new-  puts git.show-end\ No newline at end of file</code></pre><p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 <code>--stat</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git log --statcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon <schacon@gee-mail.com>Date:   Sat Mar 15 16:40:33 2008 -0700    removed unnecessary test lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon <schacon@gee-mail.com>Date:   Sat Mar 15 10:31:28 2008 -0700    first commit README           |  6 ++++++ Rakefile         | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+)</code></pre><p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p><pre class=" language-console"><code class="language-console">$ git log --pretty=onelineca82a6dff817ec66f44342007202690a93763949 changed the version number085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary testa11bef06a3f659402fe7563abf99ad00de2209e6 first commit</code></pre><p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=format:"%h - %an, %ar : %s"ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit</code></pre><p><a href="https://git-scm.com/book/zh/v2/ch00/rpretty_format" target="_blank" rel="noopener"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>%H</code></td><td align="left">提交对象（commit）的完整哈希字串</td></tr><tr><td align="left"><code>%h</code></td><td align="left">提交对象的简短哈希字串</td></tr><tr><td align="left"><code>%T</code></td><td align="left">树对象（tree）的完整哈希字串</td></tr><tr><td align="left"><code>%t</code></td><td align="left">树对象的简短哈希字串</td></tr><tr><td align="left"><code>%P</code></td><td align="left">父对象（parent）的完整哈希字串</td></tr><tr><td align="left"><code>%p</code></td><td align="left">父对象的简短哈希字串</td></tr><tr><td align="left"><code>%an</code></td><td align="left">作者（author）的名字</td></tr><tr><td align="left"><code>%ae</code></td><td align="left">作者的电子邮件地址</td></tr><tr><td align="left"><code>%ad</code></td><td align="left">作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td align="left"><code>%ar</code></td><td align="left">作者修订日期，按多久以前的方式显示</td></tr><tr><td align="left"><code>%cn</code></td><td align="left">提交者（committer）的名字</td></tr><tr><td align="left"><code>%ce</code></td><td align="left">提交者的电子邮件地址</td></tr><tr><td align="left"><code>%cd</code></td><td align="left">提交日期</td></tr><tr><td align="left"><code>%cr</code></td><td align="left">提交日期，按多久以前的方式显示</td></tr><tr><td align="left"><code>%s</code></td><td align="left">提交说明</td></tr></tbody></table><p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git" target="_blank" rel="noopener">分布式 Git</a> 再详细介绍两者之间的细微差别。</p><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=format:"%h %s" --graph* 2d3acf9 ignore errors from SIGCHLD on trap*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit|\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema*  11d191e Merge branch 'defunkt' into local</code></pre><p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p><p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a href="https://git-scm.com/book/zh/v2/ch00/rlog_options" target="_blank" rel="noopener"><code>git log</code> 的常用选项</a> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-p</code></td><td align="left">按补丁格式显示每个更新之间的差异。</td></tr><tr><td align="left"><code>--stat</code></td><td align="left">显示每次更新的文件修改统计信息。</td></tr><tr><td align="left"><code>--shortstat</code></td><td align="left">只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td align="left"><code>--name-only</code></td><td align="left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td align="left"><code>--name-status</code></td><td align="left">显示新增、修改、删除的文件清单。</td></tr><tr><td align="left"><code>--abbrev-commit</code></td><td align="left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td align="left"><code>--relative-date</code></td><td align="left">使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td align="left"><code>--graph</code></td><td align="left">显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td align="left"><code>--pretty</code></td><td align="left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交， 实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p><p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code> 也很有用。 例如，下面的命令列出所有最近两周内的提交：</p><pre class=" language-console"><code class="language-console">$ git log --since=2.weeks</code></pre><p>这个命令可以在多种格式下工作，比如说具体的某一天 <code>&quot;2008-01-15&quot;</code>，或者是相对地多久以前 <code>&quot;2 years 1 day 3 minutes ago&quot;</code>。</p><p>还可以给出若干搜索条件，列出符合的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。 （请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code>--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来）</p><p>另一个非常有用的筛选选项是 <code>-S</code>，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p><pre class=" language-console"><code class="language-console">$ git log -Sfunction_name</code></pre><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/rlimit_options" target="_blank" rel="noopener">限制 <code>git log</code> 输出的选项</a> 中列出了常用的选项</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-(n)</code></td><td align="left">仅显示最近的 n 条提交</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示指定作者相关的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示指定提交者相关的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示含指定关键字的提交</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p><pre class=" language-console"><code class="language-console">$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \   --before="2008-11-01" --no-merges -- t/5610e3b - Fix testcase failure when extended attributes are in useacd3b9e - Enhance hold_lock_file_for_{update,append}() APIf563754 - demonstrate breakage of detached checkout with symbolic link HEADd1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths51a94af - Fix "checkout --track -b newbranch" on detached HEADb0ad11e - pull: allow "git pull origin $something:$current_branch" into an unborn branch</code></pre><p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p><h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><pre class=" language-console"><code class="language-console">$ git commit --amend</code></pre><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><pre class=" language-console"><code class="language-console">$ git commit -m 'initial commit'$ git add forgotten_file$ git commit --amend</code></pre><p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p><pre class=" language-console"><code class="language-console">$ git add *$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    renamed:    README.md -> README    modified:   CONTRIBUTING.md</code></pre><p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p><pre class=" language-console"><code class="language-console">$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:M    CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    renamed:    README.md -> READMEChanges not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p><table><thead><tr><th>Note</th><th>虽然在调用时加上 <code>--hard</code> 选项<strong>可以</strong>令 <code>git reset</code> 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用 <code>git reset</code> 并不危险 — 它只会修改暂存区域。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code> 命令了解的全部。我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset" target="_blank" rel="noopener">重置揭密</a> 中了解 <code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p><pre class=" language-console"><code class="language-console">Changes not staged for commit:  (use "git add <file>..." to update what will be committed)  (use "git checkout -- <file>..." to discard changes in working directory)    modified:   CONTRIBUTING.md</code></pre><p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p><pre class=" language-console"><code class="language-console">$ git checkout -- CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:  (use "git reset HEAD <file>..." to unstage)    renamed:    README.md -> README</code></pre><p>可以看到那些修改已经被撤消了。</p><table><thead><tr><th>Important</th><th>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 介绍保存进度与分支；这些通常是更好的做法。</p><p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复（阅读 <a href="https://git-scm.com/book/zh/v2/ch00/r_data_recovery" target="_blank" rel="noopener">数据恢复</a> 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：</p><pre class=" language-console"><code class="language-console">$ git clone https://github.com/schacon/ticgitCloning into 'ticgit'...remote: Reusing existing pack: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0)Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.Resolving deltas: 100% (772/772), done.Checking connectivity... done.$ cd ticgit$ git remoteorigin</code></pre><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><pre class=" language-console"><code class="language-console">$ git remote -vorigin    https://github.com/schacon/ticgit (fetch)origin    https://github.com/schacon/ticgit (push)</code></pre><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><pre class=" language-console"><code class="language-console">$ cd grit$ git remote -vbakkdoor  https://github.com/bakkdoor/grit (fetch)bakkdoor  https://github.com/bakkdoor/grit (push)cho45     https://github.com/cho45/grit (fetch)cho45     https://github.com/cho45/grit (push)defunkt   https://github.com/defunkt/grit (fetch)defunkt   https://github.com/defunkt/grit (push)koke      git://github.com/koke/grit.git (fetch)koke      git://github.com/koke/grit.git (push)origin    git@github.com:mojombo/grit.git (fetch)origin    git@github.com:mojombo/grit.git (push)</code></pre><p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p><p>注意这些远程仓库使用了不同的协议；我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server" target="_blank" rel="noopener">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p><pre class=" language-console"><code class="language-console">$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin    https://github.com/schacon/ticgit (fetch)origin    https://github.com/schacon/ticgit (push)pb    https://github.com/paulboone/ticgit (fetch)pb    https://github.com/paulboone/ticgit (push)</code></pre><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><pre class=" language-console"><code class="language-console">$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch]      master     -> pb/master * [new branch]      ticgit     -> pb/ticgit</code></pre><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><pre class=" language-console"><code class="language-console">$ git fetch [remote-name]</code></pre><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code>命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><pre class=" language-console"><code class="language-console">$ git push origin master</code></pre><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p><h3 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><pre class=" language-console"><code class="language-console">$ git remote show origin* remote origin  Fetch URL: https://github.com/schacon/ticgit  Push  URL: https://github.com/schacon/ticgit  HEAD branch: master  Remote branches:    master                               tracked    dev-branch                           tracked  Local branch configured for 'git pull':    master merges with remote master  Local ref configured for 'git push':    master pushes to master (up to date)</code></pre><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><pre class=" language-console"><code class="language-console">$ git remote show origin* remote origin  URL: https://github.com/my-org/complex-project  Fetch URL: https://github.com/my-org/complex-project  Push  URL: https://github.com/my-org/complex-project  HEAD branch: master  Remote branches:    master                           tracked    dev-branch                       tracked    markdown-strip                   tracked    issue-43                         new (next fetch will store in remotes/origin)    issue-45                         new (next fetch will store in remotes/origin)    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)  Local branches configured for 'git pull':    dev-branch merges with remote dev-branch    master     merges with remote master  Local refs configured for 'git push':    dev-branch                     pushes to dev-branch                     (up to date)    markdown-strip                 pushes to markdown-strip                 (up to date)    master                         pushes to master                         (up to date)</code></pre><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><pre class=" language-console"><code class="language-console">$ git remote rename pb paul$ git remoteoriginpaul</code></pre><p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p><pre class=" language-console"><code class="language-console">$ git remote rm paul$ git remoteorigin</code></pre><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><pre class=" language-console"><code class="language-console">$ git tagv0.1v1.3</code></pre><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><pre class=" language-console"><code class="language-console">$ git tag -l 'v1.8.5*'v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5</code></pre><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><pre class=" language-console"><code class="language-console">$ git tag -a v1.4 -m 'my version 1.4'$ git tagv0.1v1.3v1.4</code></pre><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><pre class=" language-console"><code class="language-console">$ git show v1.4tag v1.4Tagger: Ben Straub <ben@straub.cc>Date:   Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version number</code></pre><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h3><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><pre class=" language-console"><code class="language-console">$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5</code></pre><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><pre class=" language-console"><code class="language-console">$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon <schacon@gee-mail.com>Date:   Mon Mar 17 21:52:11 2008 -0700    changed the version number</code></pre><h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><pre class=" language-console"><code class="language-console">$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</code></pre><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p><pre class=" language-console"><code class="language-console">$ git tag -a v1.2 9fceb02</code></pre><p>可以看到你已经在那次提交上打上标签了：</p><pre class=" language-console"><code class="language-console">$ git tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ git show v1.2tag v1.2Tagger: Scott Chacon <schacon@gee-mail.com>Date:   Mon Feb 9 15:32:16 2009 -0800version 1.2commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon <mchacon@gee-mail.com>Date:   Sun Apr 27 20:43:35 2008 -0700    updated rakefile...</code></pre><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</p><pre class=" language-console"><code class="language-console">$ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag]         v1.5 -> v1.5</code></pre><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><pre class=" language-console"><code class="language-console">$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag]         v1.4 -> v1.4 * [new tag]         v1.4-lw -> v1.4-lw</code></pre><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><pre class=" language-console"><code class="language-console">$ git tag -d v1.4-lwDeleted tag 'v1.4-lw' (was e7d5add)</code></pre><p>应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p><pre class=" language-console"><code class="language-console">$ git push origin :refs/tags/v1.4-lwTo /git@github.com:schacon/simplegit.git - [deleted]         v1.4-lw</code></pre><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用：</p><pre class=" language-console"><code class="language-console">$ git checkout 2.0.0Note: checking out '2.0.0'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example:  git checkout -b <new-branch>HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final$ git checkout 2.0-beta-0.1Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-finalHEAD is now at df3f601... add atlas.json and cover image</code></pre><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p><pre class=" language-console"><code class="language-console">$ git checkout -b version2 v2.0.0Switched to a new branch 'version2'</code></pre><p>当然，如果在这之后又进行了一次提交，<code>version2</code> 分支会因为这个改动向前移动，<code>version2</code> 分支就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p><h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><pre class=" language-console"><code class="language-console">$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status</code></pre><p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p><p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p><pre class=" language-console"><code class="language-console">$ git config --global alias.unstage 'reset HEAD --'</code></pre><p>这会使下面的两个命令等价：</p><pre class=" language-console"><code class="language-console">$ git unstage fileA$ git reset HEAD -- fileA</code></pre><p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p><pre class=" language-console"><code class="language-console">$ git config --global alias.last 'log -1 HEAD'</code></pre><p>这样，可以轻松地看到最后一次提交：</p><pre class=" language-console"><code class="language-console">$ git lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel <dreamer3@example.com>Date:   Tue Aug 26 19:48:51 2008 +0800    test for current head    Signed-off-by: Scott Chacon <schacon@example.com></code></pre><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><pre class=" language-console"><code class="language-console">$ git config --global alias.visual '!gitk'</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，你可以完成所有基本的 Git 本地操作－创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。 下一步，本书将介绍 Git 的杀手级特性：分支模型。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章 进程</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Modern operating systems are usually multitasking, meaning that they create the illusion of doing more than one thing at once by rapidly switching from one executing program to another. The Linux kernel manages this through the use of processes. Processes are how Linux organizes the different programs waiting for their turn at the CPU.</p><p>通常，现在的操作系统都支持多任务，意味着操作系统通过在一个执行中的程序和另一个 程序之间快速地切换造成了一种它同时能够做多件事情的假象。Linux 内核通过使用进程来 管理多任务。进程，就是Linux 组织安排正在等待使用 CPU的各种程序的方式。</p><p>Sometimes a computer will become sluggish or an application will stop responding. In this chapter, we will look at some of the tools available at the command line that let us examine what programs are doing, and how to terminate processes that are misbehaving.</p><p>有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看一些 可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进程。</p><p>This chapter will introduce the following commands:</p><p>这一章将介绍以下命令：</p><ul><li>ps– Report a snapshot of current processes</li><li>top – Display tasks</li><li>jobs – List active jobs</li><li>bg – Place a job in the background</li><li>fg – Place a job in the foreground</li><li>kill – Send a signal to a process</li><li>killall – Kill processes by name</li><li>shutdown – Shutdown or reboot the system</li><li>ps – 报告当前进程快照</li><li>top – 显示任务</li><li>jobs – 列出活跃的任务</li><li>bg – 把一个任务放到后台执行</li><li>fg – 把一个任务放到前台执行</li><li>kill – 给一个进程发送信号</li><li>killall – 杀死指定名字的进程</li><li>shutdown – 关机或重启系统</li></ul><h3 id="进程是怎样工作的"><a href="#进程是怎样工作的" class="headerlink" title="进程是怎样工作的"></a>进程是怎样工作的</h3><p>When a system starts up, the kernel initiates a few of its own activities as processes and launches a program called init. init, in turn, runs a series of shell scripts (located in /etc) called init scripts, which start all the system services. Many of these services are implemented as daemon programs, programs that just sit in the background and do their thing without having any user interface. So even if we are not logged in, the system is at least a little busy performing routine stuff.</p><p>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口(User Interface)。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</p><p>The fact that a program can launch other programs is expressed in the process scheme as a parent process producing a child process.</p><p>在进程方案中，一个程序可以发动另一个程序被表述为一个父进程可以产生一个子进程。</p><p>The kernel maintains information about each process to help keep things organized. For example, each process is assigned a number called a process ID or PID. PIDs are assigned in ascending order, with init always getting PID 1. The kernel also keeps track of the memory assigned to each process, as well as the processes’ readiness to resume execution. Like files, processes also have owners and user IDs, effective user IDs, etc.</p><p>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>The most commonly used command to view processes (there are several) is ps. The ps program has a lot of options, but in it simplest form it is used like this:</p><p>查看进程，最常使用地命令（有几个命令）是 ps(process status)。ps 程序有许多选项，它最简单地使用形式是这样的：</p><pre><code>[me@linuxbox ~]$ psPID TTY           TIME CMD5198 pts/1    00:00:00 bash10129 pts/1   00:00:00 ps</code></pre><p>The result in this example lists two processes, process 5198 and process 10129, which are bash and ps respectively. As we can see, by default, ps doesn’t show us very much, just the processes associated with the current terminal session. To see more, we need to add some options, but before we do that, let’s look at the other fields produced by ps. TTY is short for “Teletype,” and refers to the controlling terminal for the process. Unix is showing its age here. The TIME field is the amount of CPU time consumed by the process. As we can see, neither process makes the computer work very hard.</p><p>上例中，列出了两个进程，进程 5198 和进程 10129，各自代表命令 bash 和 ps。正如我们所看到的， 默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。为了得到更多信息， 我们需要加上一些选项，但是在这样做之前，我们先看一下 ps 命令运行结果的其它字段。 TTY 是 “Teletype”(直译电传打字机) 的简写，是指进程的控制终端。TTY足足显示了 Unix 的年代久远。TIME 字段表示 进程所消耗的 CPU 时间数量。正如我们所看到的，这两个进程使计算机工作起来很轻松。</p><p>If we add an option, we can get a bigger picture of what the system is doing:</p><p>如果给 ps 命令加上选项，我们可以得到更多关于系统运行状态的信息：</p><pre><code>[me@linuxbox ~]$ ps xPID TTY   STAT   TIME COMMAND2799 ?    Ssl    0:00 /usr/libexec/bonobo-activation-server –ac2820 ?    Sl     0:01 /usr/libexec/evolution-data-server-1.10 --and many more...</code></pre><p>Adding the “x” option (note that there is no leading dash) tells ps to show all of our processes regardless of what terminal (if any) they are controlled by. The presence of a “?” in the TTY column indicates no controlling terminal. Using this option, we see a list of every process that we own.</p><p>加上 “x” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以 看到我们所拥有的每个进程的信息。</p><p>Since the system is running a lot of processes, ps produces a long list. It is often helpful to pipe the output from ps into less for easier viewing. Some option combinations also produce long lines of output, so maximizing the terminal emulator window may be a good idea, too.</p><p>因为系统中正运行着许多进程，所以 ps 命令的输出结果很长。为了方便查看，将ps的输出管道 到less中通常很有帮助。一些选项组合也会产生很长的输出结果，所以最大化 终端仿真器窗口可能也是一个好主意。</p><p>A new column titled STAT has been added to the output. STAT is short for “state” and reveals the current status of the process:</p><p>输出结果中，新添加了一栏，标题为 STAT 。STAT 是 “state” 的简写，它揭示了进程当前状态：</p><table><thead><tr><th align="left">State</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">R</td><td align="left">Running. This means that the process is running or ready to run.</td></tr><tr><td align="left">S</td><td align="left">Sleeping. A process is not running; rather, it is waiting for an event, such as a keystroke or network packet.</td></tr><tr><td align="left">D</td><td align="left">Uninterruptible Sleep. Process is waiting for I/O such as a disk drive.</td></tr><tr><td align="left">T</td><td align="left">Stopped. Process has been instructed to stop. More on this later.</td></tr><tr><td align="left">Z</td><td align="left">A defunct or “zombie” process. This is a child process that has terminated, but has not been cleaned up by its parent.</td></tr><tr><td align="left">&lt;</td><td align="left">A high priority process. It’s possible to grant more importance to a process, giving it more time on the CPU. This property of a process is called niceness. A process with high priority is said to be less nice because it’s taking more of the CPU’s time, which leaves less for everybody else.</td></tr><tr><td align="left">N</td><td align="left">A low priority process. A process with low priority (a “nice” process) will only get processor time after other processes with higher priority have been serviced.</td></tr></tbody></table><table><thead><tr><th align="left">状态</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">R</td><td align="left">运行中。这意味着，进程正在运行或准备运行。</td></tr><tr><td align="left">S</td><td align="left">正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。</td></tr><tr><td align="left">D</td><td align="left">不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td></tr><tr><td align="left">T</td><td align="left">已停止. 已经指示进程停止运行。稍后介绍更多。</td></tr><tr><td align="left">Z</td><td align="left">一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）</td></tr><tr><td align="left">&lt;</td><td align="left">一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。</td></tr><tr><td align="left">N</td><td align="left">低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。</td></tr></tbody></table><p>The process state may be followed by other characters. These indicate various exotic process characteristics. See the ps man page for more detail.</p><p>进程状态信息之后，可能还跟随其他的字符。这表示各种外来进程的特性。详细信息请看 ps 手册页。</p><p>Another popular set of options is “aux” (without a leading dash). This gives us even more information:</p><p>另一个流行的选项组合是 “aux”（不带开头的”-“字符）。这会给我们更多信息：</p><pre><code>[me@linuxbox ~]$ ps auxUSER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMANDroot     1   0.0   0.0    2136    644  ?     Ss     Mar05   0:31  initroot     2   0.0   0.0       0      0  ?     S&amp;lt;     Mar05   0:00  [kt]and many more...</code></pre><p>This set of options displays the processes belonging to every user. Using the options without the leading dash invokes the command with “BSD style” behavior. The Linux version of ps can emulate the behavior of the ps program found in several different Unix implementations. With these options, we get these additional columns:</p><p>这个选项组合，能够显示属于每个用户的进程信息。使用这个选项，可以唤醒 “BSD 风格” 的输出结果。 Linux 版本的 ps 命令，可以模拟几个不同 Unix 版本中的 ps 程序的行为。通过这些选项，我们得到 这些额外的列。</p><table><thead><tr><th align="left">Header</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">USER</td><td align="left">User ID. This is the owner of the process.</td></tr><tr><td align="left">%CPU</td><td align="left">CPU usage in percent</td></tr><tr><td align="left">%MEM</td><td align="left">Memory usage in percent</td></tr><tr><td align="left">VSZ</td><td align="left">Virtual memory size</td></tr><tr><td align="left">RSS</td><td align="left">Resident Set Size. The amount of physical memory (RAM) the process is using in kilobytes.</td></tr><tr><td align="left">START</td><td align="left">Time when the process started. For values over twenty four hours, a date is used.</td></tr></tbody></table><table><thead><tr><th align="left">标题</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">USER</td><td align="left">用户 ID. 进程的所有者。</td></tr><tr><td align="left">%CPU</td><td align="left">以百分比表示的 CPU 使用率</td></tr><tr><td align="left">%MEM</td><td align="left">以百分比表示的内存使用率</td></tr><tr><td align="left">VSZ</td><td align="left">虚拟内存大小</td></tr><tr><td align="left">RSS</td><td align="left">进程占用的物理内存的大小，以千字节为单位。</td></tr><tr><td align="left">START</td><td align="left">进程启动的时间。若它的值超过24小时，则用天表示。</td></tr></tbody></table><h3 id="用-top-命令动态查看进程"><a href="#用-top-命令动态查看进程" class="headerlink" title="用 top 命令动态查看进程"></a>用 top 命令动态查看进程</h3><p>While the ps command can reveal a lot about what the machine is doing, it provides only a snapshot of the machine’s state at the moment the ps command is executed. To see a more dynamic view of the machine’s activity, we use the top command:</p><p>虽然 ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照。 为了看到更多动态的信息，我们使用 top 命令：</p><pre><code>[me@linuxbox ~]$ top</code></pre><p>The top program displays a continuously updating (by default, every 3 seconds) display of the system processes listed in order of process activity. The name “top” comes from the fact that the top program is used to see the “top” processes on the system. The top display consists of two parts: a system summary at the top of the display, followed by a table of processes sorted by CPU activity:</p><p>top 程序以进程活动顺序显示连续更新的系统进程列表。（默认情况下，每三秒钟更新一次），”top”这个名字 来源于 top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p><pre><code>top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombieCpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%siMem:   319496k total,   314860k used,   4636k free,   19392k buffSwap:  875500k total,   149128k used,   726372k free,  114676k cach PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd....</code></pre><p>The system summary contains a lot of good stuff. Here’s a rundown:</p><p>其中系统概要包含许多有用信息。下表是对系统概要的说明：</p><table><thead><tr><th align="left">Row</th><th align="left">Field</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">top</td><td align="left">Name of the program</td></tr><tr><td align="left"></td><td align="left">14:59:20</td><td align="left">Current time of day.</td></tr><tr><td align="left"></td><td align="left">up 6:30</td><td align="left">This is called uptime. It is the amount of time since the machine was last booted. In this example, the system has been up for six and a half hours.</td></tr><tr><td align="left"></td><td align="left">2 users</td><td align="left">There are two users logged in.</td></tr><tr><td align="left"></td><td align="left">load average:</td><td align="left">Load average refers to the number of processes that are waiting to run, that is, the number of processes that are in a runnable state and are sharing the CPU. Three values are shown, each for a different period of time. The first is the average for the last 60 seconds, the next the previous 5 minutes, and finally the previous 15 minutes. Values under 1.0 indicate that the machine is not busy.</td></tr><tr><td align="left">2</td><td align="left">Tasks:</td><td align="left">This summarizes the number of processes and their various process states.</td></tr><tr><td align="left">3</td><td align="left">Cpu(s):</td><td align="left">This row describes the character of the activities that the CPU is performing.</td></tr><tr><td align="left"></td><td align="left">0.7%us</td><td align="left">0.7% of the CPU is being used for user processes. This means processes outside of the kernel itself.</td></tr><tr><td align="left"></td><td align="left">1.0%sy</td><td align="left">1.0% of the CPU is being used for system (kernel) processes.</td></tr><tr><td align="left"></td><td align="left">0.0%ni</td><td align="left">0.0% of the CPU is being used by “nice” (low priority) processes.</td></tr><tr><td align="left"></td><td align="left">98.3%id</td><td align="left">98.3% of the CPU is idle.</td></tr><tr><td align="left"></td><td align="left">0.0%wa</td><td align="left">0.0% of the CPU is waiting for I/O.</td></tr><tr><td align="left">4</td><td align="left">Mem:</td><td align="left">Shows how physical RAM is being used.</td></tr><tr><td align="left">5</td><td align="left">Swap:</td><td align="left">Shows how swap space (virtual memory) is being used.</td></tr></tbody></table><table><thead><tr><th align="left">行号</th><th align="left">字段</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">top</td><td align="left">程序名。</td></tr><tr><td align="left"></td><td align="left">14:59:20</td><td align="left">当前时间。</td></tr><tr><td align="left"></td><td align="left">up 6:30</td><td align="left">这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。</td></tr><tr><td align="left"></td><td align="left">2 users</td><td align="left">有两个用户登录系统。</td></tr><tr><td align="left"></td><td align="left">load average:</td><td align="left">加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。</td></tr><tr><td align="left">2</td><td align="left">Tasks:</td><td align="left">总结了进程数目和这些进程的各种状态。</td></tr><tr><td align="left">3</td><td align="left">Cpu(s):</td><td align="left">这一行描述了 CPU 正在进行的活动的特性。</td></tr><tr><td align="left"></td><td align="left">0.7%us</td><td align="left">0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。</td></tr><tr><td align="left"></td><td align="left">1.0%sy</td><td align="left">1.0%的 CPU 时间被用于系统（内核）进程。</td></tr><tr><td align="left"></td><td align="left">0.0%ni</td><td align="left">0.0%的 CPU 时间被用于”nice”（低优先级）进程。</td></tr><tr><td align="left"></td><td align="left">98.3%id</td><td align="left">98.3%的 CPU 时间是空闲的。</td></tr><tr><td align="left"></td><td align="left">0.0%wa</td><td align="left">0.0%的 CPU 时间来等待 I/O。</td></tr><tr><td align="left">4</td><td align="left">Mem:</td><td align="left">展示物理内存的使用情况。</td></tr><tr><td align="left">5</td><td align="left">Swap:</td><td align="left">展示交换分区（虚拟内存）的使用情况。</td></tr></tbody></table><p>The top program accepts a number of keyboard commands. The two most interesting are h, which displays the program’s help screen, and q, which quits top.</p><p>top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。</p><p>Both major desktop environments provide graphical applications that display information similar to top (in much the same way that Task Manager in Windows works), but I find that top is better than the graphical versions because it is faster and it consumes far fewer system resources. After all, our system monitor program shouldn’t be the source of the system slowdown that we are trying to track.</p><p>两个主要的桌面环境都提供了图形化应用程序，来显示与 top 程序相似的信息 （和 Windows 中的任务管理器差别不多），但是我觉得 top 程序要好于图形化的版本， 因为它运行速度快，并且消费很少的系统资源。毕竟，我们的系统监测程序不能成为 我们试图追踪的系统怠工的原因。</p><h3 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h3><p>Now that we can see and monitor processes, let’s gain some control over them. For our experiments, we’re going to use a little program called xlogo as our guinea pig. The xlogo program is a sample program supplied with the X Window System (the underlying engine that makes the graphics on our display go) which simply displays a re- sizable window containing the X logo. First, we’ll get to know our test subject:</p><p>现在我们可以看到和监测进程，让我们得到一些对它们的控制权。为了我们的实验，我们将使用 一个叫做 xlogo 的小程序，作为我们的实验品。这个 xlogo 程序是 X 窗口系统 （使图形界面显示在屏幕上的底层引擎）提供的示例程序，这个程序仅显示一个大小可调的 包含 X 标志的窗口。首先，我们需要知道测试的实验对象：</p><pre><code>[me@linuxbox ~]$ xlogo</code></pre><p>After entering the command, a small window containing the logo should appear somewhere on the screen. On some systems, xlogo may print a warning message, but it may be safely ignored.</p><p>命令执行之后，一个包含 X 标志的小窗口应该出现在屏幕的某个位置上。在一些系统中，xlogo 命令 会打印一条警告信息，但是不用理会它。</p><p>Tip: If your system does not include the xlogo program, try using gedit or kwrite instead.</p><p>小贴士：如果你的系统不包含 xlogo 程序，试着用 gedit 或者 kwrite 来代替。</p><p>We can verify that xlogo is running by resizing its window. If the logo is redrawn in the new size, the program is running.</p><p>通过调整它的窗口大小，我们能够证明 xlogo 程序正在运行。如果这个标志以新的尺寸被重画， 则这个程序正在运行。</p><p>Notice how our shell prompt has not returned? This is because the shell is waiting for the program to finish, just like all the other programs we have used so far. If we close the xlogo window, the prompt returns.</p><p>注意，为什么我们的 shell 提示符还没有返回？这是因为 shell 正在等待这个程序结束， 就像到目前为止我们用过的其它所有程序一样。如果我们关闭 xlogo 窗口，shell 提示符就返回了。</p><h3 id="中断一个进程"><a href="#中断一个进程" class="headerlink" title="中断一个进程"></a>中断一个进程</h3><p>Let’s observe what happens when we run xlogo again. First, enter the xlogo command and verify that the program is running. Next, return to the terminal window and type Ctrl-c.</p><p>我们再运行 xlogo 程序一次，观察一下发生了什么事。首先，执行 xlogo 命令，并且 证实这个程序正在运行。下一步，回到终端窗口，按下 Ctrl-c。</p><pre><code>[me@linuxbox ~]$ xlogo[me@linuxbox ~]$</code></pre><p>In a terminal, typing Ctrl-c, interrupts a program. This means that we politely asked the program to terminate. After typing Ctrl-c, the xlogo window closed and the shell prompt returned.</p><p>在一个终端中，输入 Ctrl-c，中断一个程序。这意味着，我们礼貌地要求终止这个程序。 输入 Ctrl-c 之后，xlogo 窗口关闭，shell 提示符返回。</p><p>Many (but not all) command line programs can be interrupted by using this technique.</p><p>通过这个技巧，许多（但不是全部）命令行程序可以被中断。</p><h3 id="把一个进程放置到后台-执行"><a href="#把一个进程放置到后台-执行" class="headerlink" title="把一个进程放置到后台(执行)"></a>把一个进程放置到后台(执行)</h3><p>Let’s say we wanted to get the shell prompt back without terminating the xlogo program. We’ll do this by placing the program in the background. Think of the terminal as having a foreground (with stuff visible on the surface like the shell prompt) and a background (with hidden stuff behind the surface.) To launch a program so that it is immediately placed in the background, we follow the command with an- “&amp;” character:</p><p>假如说我们想让 shell 提示符返回，却不终止 xlogo 程序。我们可以把 这个程序放到后台(background)执行。把终端想象是一个有前台（包含在表层可见的事物，像 shell 提示符） 和后台（包含表层之下的隐藏的事物）（的设备）。为了启动一个程序并让它立即在后台 运行，我们在程序命令之后，加上”&amp;”字符：</p><pre><code>[me@linuxbox ~]$ xlogo &amp;[1] 28236[me@linuxbox ~]$</code></pre><p>After entering the command, the xlogo window appeared and the shell prompt returned, but some funny numbers were printed too. This message is part of a shell feature called job control. With this message, the shell is telling us that we have started job number 1 (“[1]”) and that it has PID 28236. If we run ps, we can see our process:</p><p>执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。 这条信息是 shell 特性的一部分，叫做任务控制 (job control)。通过这条信息，shell 告诉我们，已经启动了 任务号(job number)为1（“［1］”），PID 为28236的程序。如果我们运行 ps 命令，可以看到我们的进程：</p><pre><code>[me@linuxbox ~]$ ps  PID TTY         TIME   CMD10603 pts/1   00:00:00   bash28236 pts/1   00:00:00   xlogo28239 pts/1   00:00:00   ps</code></pre><p>The shell’s job control facility also gives us a way to list the jobs that are have been launched from our terminal. Using the jobs command, we can see this list:</p><p>shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 jobs 命令，我们可以看到这个输出列表：</p><pre><code>[me@linuxbox ~]$ jobs[1]+ Running            xlogo &amp;</code></pre><p>The results show that we have one job, numbered “1”, that it is running, and that the command was xlogo &amp;.</p><p>结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo ＆。</p><h3 id="进程返回到前台"><a href="#进程返回到前台" class="headerlink" title="进程返回到前台"></a>进程返回到前台</h3><p>A process in the background is immune from keyboard input, including any attempt interrupt it with a Ctrl-c. To return a process to the foreground, use the fg command, this way:</p><p>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。 为了让一个进程返回前台 (foreground)，这样使用 fg 命令：</p><pre><code>[me@linuxbox ~]$ jobs[1]+ Running        xlogo &amp;[me@linuxbox ~]$ fg %1xlogo</code></pre><p>The command fg followed by a percent sign and the job number (called a jobspec) does the trick. If we only have one background job, the jobspec is optional. To terminate xlogo, type Ctrl-c.</p><p>fg 命令之后，跟随着一个百分号和任务序号（叫做 jobspec,如此处的%1）就可以了。如果我们只有一个后台任务，那么 jobspec(job specification) 是可有可无的。输入 Ctrl-c 来终止 xlogo 程序。</p><h3 id="停止一个进程"><a href="#停止一个进程" class="headerlink" title="停止一个进程"></a>停止一个进程</h3><p>Sometimes we’ll want to stop a process without terminating it. This is often done to allow a foreground process to be moved to the background. To stop a foreground process, type Ctrl-z. Let’s try it. At the command prompt, type xlogo, the Enter key, then Ctrl-z:</p><p>有时候，我们想要停止一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动到后台。 输入 Ctrl-z，可以停止一个前台进程。让我们试一下。在命令提示符下，执行 xlogo 命令， 然后输入 Ctrl-z:</p><pre><code>[me@linuxbox ~]$ xlogo[1]+ Stopped                 xlogo[me@linuxbox ~]$</code></pre><p>After stopping xlogo, we can verify that the program has stopped by attempting to resize the xlogo window. We will see that it appears quite dead. We can either restore the program to the foreground, using the fg command, or move the program to the background with the bg command:</p><p>停止 xlogo 程序之后，通过调整 xlogo 的窗口大小，我们可以证实这个程序已经停止了。 它看起来像死掉了一样。使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。</p><pre><code>[me@linuxbox ~]$ bg %1[1]+ xlogo &amp;[me@linuxbox ~]$</code></pre><p>As with the fg command, the jobspec is optional if there is only one job.</p><p>和 fg 命令一样，如果只有一个任务的话，jobspec 参数是可选的。</p><p>Moving a process from the foreground to the background is handy if we launch a graphical program from the command, but forget to place it in the background by appending the trailing “&amp;”.</p><p>如果我们从命令行启动一个图形程序，但是忘了在命令后加字符 “&amp;”， 将一个进程从前台移动到后台也是很方便的。</p><p>Why would you want to launch a graphical program from the command line? There are two reasons. First, the program you wish to run might not be listed on the window manager’s menus (such as xlogo). Secondly, by launching a program from the command line, you might be able to see error messages that would otherwise be invisible if the program were launched graphically. Sometimes, a program will fail to start up when launched from the graphical menu. By launching it from the command line instead, we may see an error message that will reveal the problem. Also, some graphical programs have many interesting and useful command line options.</p><p>为什么要从命令行启动一个图形界面程序呢？有两个原因。第一个，你想要启动的程序，可能 没有在窗口管理器的菜单中列出来（比方说 xlogo）。第二个，从命令行启动一个程序， 你能够看到一些错误信息，如果从图形界面中运行程序的话，这些信息是不可见的。有时候， 一个程序不能从图形界面菜单中启动。通过从命令行中启动它，我们可能会看到 能揭示问题的错误信息。一些图形界面程序还有许多有意思并且有用的命令行选项。</p><h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><p>The kill command is used to “kill” programs. This allows us to terminate programs that need killing. Here’s an example:</p><p>kill 命令被用来“杀死”程序。这样我们就可以终止需要杀死的程序。这里有一个例子：</p><pre><code>[me@linuxbox ~]$ xlogo &amp;[1] 28401[me@linuxbox ~]$ kill 28401[1]+ Terminated               xlogo</code></pre><p>We first launch xlogo in the background. The shell prints the jobspec and the PID of the background process. Next, we use the kill command and specify the PID of the process we want to terminate. We could have also specified the process using a jobspec (for example, “%1”) instead of a PID.</p><p>首先，我们在后台启动 xlogo 程序。shell 打印出这个后台进程的 jobspec 和 PID。下一步，我们使用 kill 命令，并且指定我们想要终止的进程 PID。也可以用 jobspec（例如，“％1”）来代替 PID。</p><p>While this is all very straightforward, there is more to it than that. The kill command doesn’t exactly “kill” programs, rather it sends them signals. Signals are one of several ways that the operating system communicates with programs. We have already seen signals in action with the use of Ctrl-c and Ctrl-z. When the terminal receives one of these keystrokes, it sends a signal to the program in the foreground. In the case of Ctrl-c, a signal called INT (Interrupt) is sent; with Ctrl-z, a signal called TSTP (Terminal Stop.) Programs, in turn, “listen” for signals and may act upon them as they are received. The fact that a program can listen and act upon signals allows a program to do things like save work in progress when it is sent a termination signal.</p><p>虽然这个命令看上去很直白， 但是它的含义不止于此。这个 kill 命令不是真的“杀死”程序，而是给程序 发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种。 在使用 Ctrl-c 和 Ctrl-z 的过程中我们已经看到信号的实际用法。当终端接受了其中一个按键组合后，它会给在前端运行 的程序发送一个信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（Interrupt,中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（Terminal Stop,终端停止）的信号。程序，相应地，监听信号的到来，当程序 接到信号之后，则做出响应。一个程序能够监听和响应信号这件事允许一个程序做些事情， 比如，当程序接到一个终止信号时，它可以保存所做的工作。</p><h3 id="通过-kill-命令给进程发送信号"><a href="#通过-kill-命令给进程发送信号" class="headerlink" title="通过 kill 命令给进程发送信号"></a>通过 kill 命令给进程发送信号</h3><p>The kill command is used to send signals to programs. Its most common syntax looks like this:</p><p>kill 命令被用来给程序发送信号。它最常见的语法形式看起来像这样：</p><pre><code>kill [-signal] PID...</code></pre><p>If no signal is specified on the command line, then the TERM (Terminate) signal is sent by default. The kill command is most often used to send the following signals:</p><p>如果在命令行中没有指定信号，那么默认情况下，发送 TERM（Terminate，终止）信号。kill 命令被经常 用来发送以下命令：</p><table><thead><tr><th align="left">Number</th><th align="left">Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">HUP</td><td align="left">Hangup. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.This signal is also used by many daemon programs to cause a reinitialization. This means that when a daemon is sent this signal, it will restart and re-read its configuration file. The Apache web server is an example of a daemon that uses the HUP signal in this way.</td></tr><tr><td align="left">2</td><td align="left">INT</td><td align="left">Interrupt. Performs the same function as the Ctrl-c key sent from the terminal. It will usually terminate a program.</td></tr><tr><td align="left">9</td><td align="left">KILL</td><td align="left">Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal should only be used as a last resort when other termination signals fail.</td></tr><tr><td align="left">15</td><td align="left">TERM</td><td align="left">Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.</td></tr><tr><td align="left">18</td><td align="left">CONT</td><td align="left">Continue. This will restore a process after a STOP signal.</td></tr><tr><td align="left">19</td><td align="left">STOP</td><td align="left">Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.</td></tr></tbody></table><table><thead><tr><th align="left">编号</th><th align="left">名字</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">HUP</td><td align="left">挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</td></tr><tr><td align="left">2</td><td align="left">INT</td><td align="left">中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。</td></tr><tr><td align="left">9</td><td align="left">KILL</td><td align="left">杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。</td></tr><tr><td align="left">15</td><td align="left">TERM</td><td align="left">终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。</td></tr><tr><td align="left">18</td><td align="left">CONT</td><td align="left">继续。在一个停止信号后，这个信号会恢复进程的运行。</td></tr><tr><td align="left">19</td><td align="left">STOP</td><td align="left">停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</td></tr></tbody></table><p>Let’s try out the kill command:</p><p>让我们试一下 kill 命令：</p><pre><code>[me@linuxbox ~]$ xlogo &amp;[1] 13546[me@linuxbox ~]$ kill -1 13546[1]+ Hangup         xlogo</code></pre><p>In this example, we start the xlogo program in the background and then send it a HUP signal with kill. The xlogo program terminates and the shell indicates that the background process has received a hangup signal. You may need to press the enter key a couple of times before you see the message. Note that signals may be specified either by number or by name, including the name prefixed with the letters “SIG”:</p><p>在这个例子里，我们在后台启动 xlogo 程序，然后通过 kill 命令，发送给它一个 HUP 信号。 这个 xlogo 程序终止运行，并且 shell 指示这个后台进程已经接受了一个挂起信号。在看到这条 信息之前，你可能需要多按几次 enter 键。注意，信号既可以用号码，也可以用名字来指定， 包括在前面加上字母 “SIG” 的名字。</p><pre><code>[me@linuxbox ~]$ xlogo 1] 13601[me@linuxbox ~]$ kill -INT 13601[1]+ Interrupt                    xlogo[me@linuxbox ~]$ xlogo &amp;[1] 13608[me@linuxbox ~]$ kill -SIGINT 13608[1]+ Interrupt                    xlogo</code></pre><p>Repeat the example above and try out the other signals. Remember, you can also use jobspecs in place of PIDs.</p><p>重复上面的例子，试着使用其它的信号。记住，你也可以用 jobspecs 来代替 PID。</p><p>Processes, like files, have owners, and you must be the owner of a process (or the superuser) in order to send it signals with kill.</p><p>进程，和文件一样，拥有所有者，所以为了能够通过 kill 命令来给进程发送信号， 你必须是进程的所有者（或者是超级用户）。</p><p>In addition to the list of signals above, which are most often used with kill, there are other signals frequently used by the system. Here is a list of other common signals:</p><p>除了上表列出的 kill 命令最常使用的信号之外，还有一些系统频繁使用的信号。以下是其它一些常用 信号列表：</p><table><thead><tr><th align="left">Number</th><th align="left">Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">QUIT</td><td align="left">Quit</td></tr><tr><td align="left">11</td><td align="left">SEGV</td><td align="left">Segmentation Violation. This signal is sent if a program makes illegal use of memory, that is, it tried to write somewhere it was not allowed to.</td></tr><tr><td align="left">20</td><td align="left">TSTP</td><td align="left">Terminal Stop. This is the signal sent by the terminal when the Ctrl-z key is pressed. Unlike the STOP signal, the TSTP signal is received by the process and may be ignored.</td></tr><tr><td align="left">28</td><td align="left">WINCH</td><td align="left">Window Change. This is a signal sent by the system when a window changes size. Some programs , like top and less will respond to this signal by redrawing themselves to fit the new window dimensions.</td></tr></tbody></table><table><thead><tr><th align="left">编号</th><th align="left">名字</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">3</td><td align="left">QUIT</td><td align="left">退出</td></tr><tr><td align="left">11</td><td align="left">SEGV</td><td align="left">段错误(Segmentation Violation)。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。</td></tr><tr><td align="left">20</td><td align="left">TSTP</td><td align="left">终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</td></tr><tr><td align="left">28</td><td align="left">WINCH</td><td align="left">改变窗口大小(Window Change)。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</td></tr></tbody></table><p>For the curious, a complete list of signals can be seen with the following command:</p><p>为了满足读者的好奇心，通过下面的命令可以得到一个完整的信号列表：</p><pre><code>[me@linuxbox ~]$ kill -l</code></pre><h3 id="通过-killall-命令给多个进程发送信号"><a href="#通过-killall-命令给多个进程发送信号" class="headerlink" title="通过 killall 命令给多个进程发送信号"></a>通过 killall 命令给多个进程发送信号</h3><p>It’s also possible to send signals to multiple processes matching a specified program or user name by using the killall command. Here is the syntax:</p><p>也有可能通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号。下面是 killall 命令的语法形式：</p><pre><code>killall [-u user] [-signal] name...</code></pre><p>To demonstrate, we will start a couple of instances of the xlogo program and then terminate them:</p><p>为了说明情况，我们将启动一对 xlogo 程序的实例，然后再终止它们：</p><pre><code>[me@linuxbox ~]$ xlogo &amp;[1] 18801[me@linuxbox ~]$ xlogo &amp;[2] 18802[me@linuxbox ~]$ killall xlogo[1]- Terminated                xlogo[2]+ Terminated                xlogo</code></pre><p>Remember, as with kill, you must have superuser privileges to send signals to processes that do not belong to you.</p><p>记住，和 kill 命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号。</p><h3 id="更多和进程相关的命令"><a href="#更多和进程相关的命令" class="headerlink" title="更多和进程相关的命令"></a>更多和进程相关的命令</h3><p>Since monitoring processes is an important system administration task, there are a lot of commands for it. Here are some to play with:</p><p>因为监测进程是一个很重要的系统管理任务，所以有许多命令与它相关。玩玩下面几个命令：</p><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">pstree</td><td align="left">Outputs a process list arranged in a tree-like pattern showing the parent/child relationships between processes.</td></tr><tr><td align="left">vmstat</td><td align="left">Outputs a snapshot of system resource usage including, memory, swap and disk I/O. To see a continuous display, follow the command with a time delay (in seconds) for updates. For example: vmstat 5. Terminate the output with Ctrl-c.</td></tr><tr><td align="left">xload</td><td align="left">A graphical program that draws a graph showing system load over time</td></tr><tr><td align="left">tload</td><td align="left">Similar to the xload program, but draws the graph in the terminal. Terminate the output with Ctrl-c.</td></tr></tbody></table><table><thead><tr><th align="left">命令名</th><th align="left">命令描述</th></tr></thead><tbody><tr><td align="left">pstree</td><td align="left">输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。</td></tr><tr><td align="left">vmstat</td><td align="left">输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。</td></tr><tr><td align="left">xload</td><td align="left">一个图形界面程序，可以画出系统负载随时间变化的图形。</td></tr><tr><td align="left">tload</td><td align="left">terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十章 权限</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%9D%83%E9%99%90/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>Operating systems in the Unix tradition differ from those in the MS-DOS tradition in that they are not only multitasking systems, but also multi-user systems, as well. What exactly does this mean? It means that more than one person can be using the computer at the same time. While a typical computer will likely have only one keyboard and monitor, it can still be used by more than one user. For example, if a computer is attached to a network or the Internet, remote users can log in via ssh (secure shell) and operate the computer. In fact, remote users can execute graphical applications and have the graphical output appear on a remote display. The X Window System supports this as part of its basic design.</p><p>Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统，区别在于它们不仅是多任务系统，而且也是 多用户系统。这到底意味着什么？它意味着多个用户可以在同一时间使用同一台计算机。然而一个 典型的计算机可能只有一个键盘和一个监视器，但是它仍然可以被多个用户使用。例如，如果一台 计算机连接到一个网络或者因特网，那么远程用户通过 ssh（安全 shell）可以登录并操纵这台电脑。 事实上，远程用户也能运行图形界面应用程序，并且图形化的输出结果会出现在远端的显示器上。 X 窗口系统把这个作为基本设计理念的一部分，并支持这种功能。</p><p>The multi-user capability of Linux is not a recent “innovation,” but rather a feature that is deeply embedded into the design of the operating system. Considering the environment in which Unix was created, this makes perfect sense. Years ago, before computers were “personal,” they were large, expensive, and centralized. A typical university computer system, for example, consisted of a large central computer located in one building and terminals which were located throughout the campus, each connected to the large central computer. The computer would support many users at the same time.</p><p>Linux 系统的多用户性能，不是最近的“创新”，而是一种深深地嵌入到了 Linux 操作系统的 设计中的特性。想想 Unix 系统的诞生环境，这一点就很好理解了。多年前，在个人电脑出现之前，计算机 都是大型、昂贵的、集中化的。例如一个典型的大学计算机系统，是由坐落在一座建筑中的一台 大型中央计算机和许多散布在校园各处的终端机组成，每个终端都连接到这台大型中央计算机。 这台计算机可以同时支持很多用户。</p><p>In order to make this practical, a method had to be devised to protect the users from each other. After all, the actions of one user could not be allowed to crash the computer, nor could one user interfere with the files belonging to another user.</p><p>为了使多用户特性付诸实践，那么必须发明一种方法来阻止用户彼此之间受到影响。毕竟，一个 用户的行为不能导致计算机崩溃，也不能乱动属于另一个用户的文件。</p><p>In this chapter we are going to look at this essential part of system security and introduce the following commands:</p><p>在这一章中，我们将看看这一系统安全的本质部分，会介绍以下命令：</p><ul><li>id – Display user identity</li><li>id – 显示用户身份号</li><li>chmod – Change a file’s mode</li><li>chmod – 更改文件模式</li><li>umask – Set the default file permissions</li><li>umask – 设置默认的文件权限</li><li>su – Run a shell as another user</li><li>su – 以另一个用户的身份来运行 shell</li><li>sudo – Execute a command as another user</li><li>sudo – 以另一个用户的身份来执行命令</li><li>chown – Change a file’s owner</li><li>chown – 更改文件所有者</li><li>chgrp – Change a file’s group ownership</li><li>chgrp – 更改文件组所有权</li><li>passwd – Change a user’s password</li><li>passwd – 更改用户密码</li></ul><h3 id="拥有者、组成员和其他人"><a href="#拥有者、组成员和其他人" class="headerlink" title="拥有者、组成员和其他人"></a>拥有者、组成员和其他人</h3><p>When we were exploring the system back in Chapter 4, we may have encountered a problem when trying to examine a file such as /etc/shadow:</p><p>在第四章探究文件系统时，当我们试图查看一个像/etc/shadow 那样的文件的时候，我们会遇到一个问题。</p><pre><code>[me@linuxbox ~]$ file /etc/shadow/etc/shadow:  regular file, no read permission[me@linuxbox ~]$ less /etc/shadow/etc/shadow:  Permission denied</code></pre><p>The reason for this error message is that, as regular users, we do not have permission to read this file.</p><p>产生这种错误信息的原因是，作为一个普通用户，我们没有权限来读取这个文件。</p><p>In the Unix security model, a user may own files and directories. When a user owns a file or directory, the user has control over its access. Users can, in turn, belong to a group consisting of one or more users who are given access to files and directories by their owners. In addition to granting access to a group, an owner may also grant some set of access rights to everybody, which in Unix terms is referred to as the world. To find out information about your identity, use the id command:</p><p>在 Unix 安全模型中，一个用户可能拥有文件和目录。当一个用户拥有一个文件或目录时， 用户对这个文件或目录的访问权限拥有控制权。用户反过来又属于一个由一个或多个 用户组成的用户组，用户组成员由文件和目录的所有者授予对文件和目录的访问权限。除了 对一个用户组授予权限之外，文件所有者可能会给每个人一些权限，在 Unix 术语中，每个人 是指整个世界。可以用 id 命令，来找到关于你自己身份的信息：</p><pre><code>[me@linuxbox ~]$ iduid=500(me) gid=500(me) groups=500(me)</code></pre><p>Let’s look at the output. When user accounts are created, users are assigned a number called a user ID or uid which is then, for the sake of the humans, mapped to a user name. The user is assigned a primary group ID or gid and may belong to additional groups. The above example is from a Fedora system. On other systems, such as Ubuntu, the output may look a little different:</p><p>让我们看一下输出结果。当用户创建帐户之后，系统会给用户分配一个号码，叫做用户 ID 或者 uid，然后，为了符合人类的习惯，这个 ID 映射到一个用户名。系统又会给这个用户 分配一个原始的组 ID 或者是 gid，这个 gid 可能属于另外的组。上面的例子来自于 Fedora 系统， 比方说 Ubuntu 的输出结果可能看起来有点儿不同：</p><pre><code>[me@linuxbox ~]$ iduid=1000(me) gid=1000(me)groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(lpadmin),114(admin),1000(me)</code></pre><p>As we can see, the uid and gid numbers are different. This is simply because Fedora starts its numbering of regular user accounts at 500, while Ubuntu starts at 1000. We can also see that the Ubuntu user belongs to a lot more groups. This has to do with the way Ubuntu manages privileges for system devices and services.</p><p>正如我们能看到的，两个系统中用户的 uid 和 gid 号码是不同的。原因很简单，因为 Fedora 系统 从500开始进行普通用户帐户的编号，而 Ubuntu 从1000开始。我们也能看到 Ubuntu 的用户属于 更多的用户组。这和 Ubuntu 管理系统设备和服务权限的方式有关系。</p><p>So where does this information come from? Like so many things in Linux, from a couple of text files. User accounts are defined in the /etc/passwd file and groups are defined in the /etc/group file. When user accounts and groups are created, these files are modified along with /etc/shadow which holds information about the user’s password. For each user account, the /etc/passwd file defines the user (login) name, uid, gid, the account’s real name, home directory, and login shell. If you examine the contents of /etc/passwd and /etc/group, you will notice that besides the regular user accounts, there are accounts for the superuser (uid 0) and various other system users.</p><p>那么这些信息来源于哪里呢？像 Linux 系统中的许多东西一样，来自一系列的文本文件。用户帐户 定义在/etc/passwd 文件里面，用户组定义在/etc/group 文件里面。当用户帐户和用户组创建以后， 这些文件随着文件/etc/shadow 的变动而修改，文件/etc/shadow 包含了关于用户密码的信息。 对于每个用户帐号，文件/etc/passwd 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录 和登录 shell。如果你查看一下文件/etc/passwd 和文件/etc/group 的内容，你会注意到除了普通 用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。</p><p>In the next chapter, when we cover processes, you will see that some of these other “users” are, in fact, quite busy.</p><p>在下一章中，当我们讨论进程时，你会知道这些其他的“用户”是谁，实际上，他们相当忙碌。</p><p>While many Unix-like systems assign regular users to a common group such as “users”, modern Linux practice is to create a unique, single-member group with the same name as the user. This makes certain types of permission assignment easier.</p><p>然而许多像 Unix 的系统会把普通用户分配到一个公共的用户组中，例如“users”，现在的 Linux 会创建一个独一无二的，只有一个成员的用户组，这个用户组与用户同名。这样使某种类型的 权限分配更容易些。</p><h3 id="读取、写入和执行"><a href="#读取、写入和执行" class="headerlink" title="读取、写入和执行"></a>读取、写入和执行</h3><p>Access rights to files and directories are defined in terms of read access, write access, and execution access. If we look at the output of the ls command, we can get some clue as to how this is implemented:</p><p>对于文件和目录的访问权力是根据读访问、写访问和执行访问来定义的。如果我们看一下 ls 命令的输出结果，我们能得到一些线索，这是怎样实现的：</p><pre><code>[me@linuxbox ~]$ &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt</code></pre><p>The first ten characters of the listing are the file attributes. The first of these characters is the file type. Here are the file types you are most likely to see (there are other, less common types too):</p><p>列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到 的文件类型（还有其它的，不常见类型）：</p><table><thead><tr><th align="left">Attribute</th><th align="left">File Type</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">a regular file</td></tr><tr><td align="left">d</td><td align="left">A directory</td></tr><tr><td align="left">l</td><td align="left">A symbolic link. Notice that with symbolic links, the remainning file attributes are always “rwxrwxrwx” and are dummy values. The real file attributes are those of the file the symbolic link points to.</td></tr><tr><td align="left">c</td><td align="left">A character special file. This file type refers to a device that handles data as a stream of bytes, such as a terminal or modem.</td></tr><tr><td align="left">b</td><td align="left">A block special file. This file type refers to a device that handles data in blocks, such as a hard drive or CD-ROM drive.</td></tr></tbody></table><table><thead><tr><th align="left">属性</th><th align="left">文件类型</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">一个普通文件</td></tr><tr><td align="left">d</td><td align="left">一个目录</td></tr><tr><td align="left">l</td><td align="left">一个符号链接。注意对于符号链接文件，剩余的文件属性总是”rwxrwxrwx”，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。</td></tr><tr><td align="left">c</td><td align="left">一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器</td></tr><tr><td align="left">b</td><td align="left">一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。</td></tr></tbody></table><p>The remaining nine characters of the file attributes, called the file mode, represent the read, write, and execute permissions for the file’s owner, the file’s group owner, and everybody else:</p><p>剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。</p><p><img src="https://billie66.github.io/TLCL/book/images/101.png" alt="img"><br>图 1: 权限属性</p><p>When set, the r, w, and x mode attributes have the following effect on files and directories:</p><p>当设置文件模式后，r、w和x 模式属性对文件和目录会产生以下影响：</p><table><thead><tr><th align="left">Attribute</th><th align="left">Files</th><th align="left">Directories</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">Allows a file to be opened and read.</td><td align="left">Allows a directory’s contents to be listed if the execute attribute is also set.</td></tr><tr><td align="left">w</td><td align="left">Allows a file to be written to or truncated, however this attribute does not allow files to be renamed or deleted. The ability to delete or rename files is determined by directory attributes.</td><td align="left">Allows files within a directory to be created, deleted, and renamed if the execute attribute is also set.</td></tr><tr><td align="left">x</td><td align="left">Allows a file to be treated as a program and executed. Program files written in scripting languages must also be set as readable to be executed.</td><td align="left">Allows a directory to be entered, e.g., cd directory.</td></tr></tbody></table><table><thead><tr><th align="left">属性</th><th align="left">文件</th><th align="left">目录</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">允许打开并读取文件内容。</td><td align="left">允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。</td></tr><tr><td align="left">w</td><td align="left">允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。</td><td align="left">允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。</td></tr><tr><td align="left">x</td><td align="left">允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。</td><td align="left">允许进入目录，例如：cd directory 。</td></tr></tbody></table><p>Here are some examples of file attribute settings:</p><p>下面是权限属性的一些例子：</p><table><thead><tr><th align="left">File Attributes</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-rwx——</td><td align="left">A regular file that is readable, writable, and executable by the file’s owner. No one else has any access.</td></tr><tr><td align="left">-rw——-</td><td align="left">A regular file that is readable and writable by the file’s owner. No one else has any access.</td></tr><tr><td align="left">-rw-r–r–</td><td align="left">A regular file that is readable and writable by the file’s owner. Members of the file’s owner group may read the file. The file is world-readable.</td></tr><tr><td align="left">-rwxr-xr-x</td><td align="left">A regular file that is readable, writable, and executable by the file’s owner. The file may be read and executed by everybody else.</td></tr><tr><td align="left">-rw-rw—-</td><td align="left">A regular file that is readable and writable by the file’s owner and members of the file’s group owner only.</td></tr><tr><td align="left">lrwxrwxrwx</td><td align="left">A symbolic link. All symbolic links have “dummy” permissions. The real permissions are kept with the actual file pointed to by the symbolic link.</td></tr><tr><td align="left">drwxrwx—</td><td align="left">A directory. The owner and the members of the owner group may enter the directory and, create, rename and remove files within the directory.</td></tr><tr><td align="left">drwxr-x—</td><td align="left">A directory. The owner may enter the directory and create, rename and delete files within the directory. Members of the owner group may enter the directory but cannot create, delete or rename files.</td></tr></tbody></table><table><thead><tr><th align="left">文件属性</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-rwx——</td><td align="left">一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。</td></tr><tr><td align="left">-rw——-</td><td align="left">一个普通文件，对文件所有者来说可读可写。其他人无法访问。</td></tr><tr><td align="left">-rw-r–r–</td><td align="left">一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。</td></tr><tr><td align="left">-rwxr-xr-x</td><td align="left">一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。</td></tr><tr><td align="left">-rw-rw—-</td><td align="left">一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。</td></tr><tr><td align="left">lrwxrwxrwx</td><td align="left">一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。</td></tr><tr><td align="left">drwxrwx—</td><td align="left">一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。</td></tr><tr><td align="left">drwxr-x—</td><td align="left">一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。</td></tr></tbody></table><h3 id="chmod-－-更改文件模式"><a href="#chmod-－-更改文件模式" class="headerlink" title="chmod － 更改文件模式"></a>chmod － 更改文件模式</h3><p>To change the mode (permissions) of a file or directory, the chmod command is used. Be aware that only the file’s owner or the superuser can change the mode of a file or directory. chmod supports two distinct ways of specifying mode changes: octal number representation, or symbolic representation. We will cover octal number representation first.</p><p>更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才 能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或 符号表示法。首先我们讨论一下八进制数字表示法。</p><blockquote><p>What The Heck Is Octal?</p><p>究竟什么是八进制？</p><p>Octal (base 8), and its cousin, hexadecimal (base 16) are number systems often used to express numbers on computers. We humans, owing to the fact that we (or at least most of us) were born with ten fingers, count using a base 10 number system. Computers, on the other hand, were born with only one finger and thus do all their counting in binary (base 2). Their number system only has two numerals, zero and one. So in binary, counting looks like this:</p><p>八进制（以8为基数）及其亲戚十六进制（以16为基数）都是数字系统，通常 被用来表示计算机中的数字。我们人类，因为（或者至少大多数人）天生有 十个手指的事实，利用以10为基数的数字系统来计数。计算机，从另一方面讲，生来只有一个 手指，因此它以二进制（以2为基数）来计数。它们的数字系统只有两个数值，0和1。 因此在二进制中，计数看起来像这样：</p><p>0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011…</p><p>In octal, counting is done with the numerals zero through seven, like so:</p><p>在八进制中，逢八进一，用数字0到7来计数，像这样：</p><p>0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21…</p><p>Hexadecimal counting uses the numerals zero through nine plus the letters “A” through “F”:</p><p>十六进制中，使用数字0到9，加上大写字母”A”到”F”来计数，逢16进一：</p><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, 13…</p><p>While we can see the sense in binary (since computers only have one finger), what are octal and hexadecimal good for? The answer has to do with human convenience. Many times, small portions of data are represented on computers as bit patterns. Take for example an RGB color. On most computer displays, each pixel is composed of three color components: eight bits of red, eight bits of green, and eight bits of blue. A lovely medium blue would be a twenty-four digit number:</p><p>虽然我们能知道二进制的意义（因为计算机只有一个手指），但是八进制和十六进制对什么 有好处呢？ 答案是为了人类的便利。许多时候，在计算机中，一小部分数据以二进制的形式表示。 以 RGB 颜色为例来说明。大多数的计算机显示器，每个像素由三种颜色组成：8位红色，8位绿色， 8位蓝色。这样，一种可爱的中蓝色就由24位数字来表示：</p><p>010000110110111111001101</p><p>How would you like to read and write those kinds of numbers all day? I didn’t think so. Here’s where another number system would help. Each digit in a hexadecimal number represents four digits in binary. In octal, each digit represents three binary digits. So our twenty-four digit medium blue could be condensed down to a six digit hexadecimal number:</p><p>我不认为你每天都喜欢读写这类数字。另一种数字系统对我们更有帮助。每个十六进制 数字代表四个二进制。在八进制中，每个数字代表三个二进制数字。那么代表中蓝色的24位 二进制能够压缩成6位十六进制数：</p><p>436FCD</p><p>Since the digits in the hexadecimal number “line up” with the bits in the binary number we can see that the red component of our color is “43”, the green “6F”, and the blue “CD”.</p><p>因为十六进制中的两个数字对应二进制的8位数字，我们可以看到”43“代表红色，“6F” 代表绿色，“CD”代表蓝色。</p><p>These days, hexadecimal notation (often spoken as “hex”) is more common than octal, but as we shall soon see, octal’s ability to express three bits of binary will be very useful…</p><p>现在，十六进制表示法（经常叫做“hex”）比八进制更普遍，但是我们很快会看到，用八进制 来表示3个二进制数非常有用处…</p></blockquote><p>With octal notation we use octal numbers to set the pattern of desired permissions. Since each digit in an octal number represents three binary digits, this maps nicely to the scheme used to store the file mode. This table shows what we mean:</p><p>通过八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表展示了 我们所要表达的意思：</p><table><thead><tr><th>Octal</th><th>Binary</th><th>File Mode</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>—</td></tr><tr><td>1</td><td>001</td><td>–x</td></tr><tr><td>2</td><td>010</td><td>-w-</td></tr><tr><td>3</td><td>011</td><td>-wx</td></tr><tr><td>4</td><td>100</td><td>r–</td></tr><tr><td>5</td><td>101</td><td>r-x</td></tr><tr><td>6</td><td>110</td><td>rw-</td></tr><tr><td>7</td><td>111</td><td>rwx</td></tr></tbody></table><p>By using three octal digits, we can set the file mode for the owner, group owner, and world:</p><p>通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：</p><pre><code>[me@linuxbox ~]$ &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-rw-r-- 1 me    me    0  2008-03-06 14:52 foo.txt[me@linuxbox ~]$ chmod 600 foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw------- 1 me    me    0  2008-03-06 14:52 foo.txt</code></pre><p>By passing the argument “600”, we were able to set the permissions of the owner to read and write while removing all permissions from the group owner and world. Though remembering the octal to binary mapping may seem inconvenient, you will usually only have to use a few common ones: 7 (rwx), 6 (rw-), 5 (r-x), 4 (r–), and 0 (—).</p><p>通过传递参数 “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有 权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—)。</p><p>chmod also supports a symbolic notation for specifying file modes. Symbolic notation is divided into three parts: who the change will affect, which operation will be performed, and what permission will be set. To specify who is affected, a combination of the characters “u”, “g”, “o”, and “a” is used as follows:</p><p>chmod 命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定 要影响的对象，如下所示：</p><table><thead><tr><th>u</th><th>Short for “user”, but means the file or directory owner.</th></tr></thead><tbody><tr><td>g</td><td>Group owner.</td></tr><tr><td>o</td><td>Short for “others”, but means world.</td></tr><tr><td>a</td><td>Short for “all”, the combination of “u”, “g”, and “o”.</td></tr></tbody></table><table><thead><tr><th>u</th><th>“user”的简写，意思是文件或目录的所有者。</th></tr></thead><tbody><tr><td>g</td><td>用户组。</td></tr><tr><td>o</td><td>“others”的简写，意思是其他所有的人。</td></tr><tr><td>a</td><td>“all”的简写，是”u”, “g”和“o”三者的联合。</td></tr></tbody></table><p>If no character is specified, “all” will be assumed. The operation may be a “+” indicating that a permission is to be added, a “-” indicating that a permission is to be taken away, or a “=” indicating that only the specified permissions are to be applied and that all others are to be removed.</p><p>如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。</p><p>Permissions are specified with the “r”, “w”, and “x” characters. Here are some examples of symbolic notation:</p><p>权限由 “r”、“w”和 “x” 来指定。这里是一些符号表示法的实例：</p><table><thead><tr><th>u+x</th><th>Add execute permission for the owner.</th></tr></thead><tbody><tr><td>u-x</td><td>Remove execute permission from the owner.</td></tr><tr><td>+x</td><td>Add execute permission for the owner, group, and world. Equivalent to a+x.</td></tr><tr><td>o-rw</td><td>Remove the read and write permission from anyone besides the owner and group owner.</td></tr><tr><td>go=rw</td><td>Set the group owner and anyone besides the owner to have read and write permission. If either the group owner or world previously had execute permissions, they are removed.</td></tr><tr><td>u+x,go=rw</td><td>Add execute permission for the owner and set the permissions for the group and others to read and execute. Multiple specifications may be separated by commas.</td></tr></tbody></table><table><thead><tr><th>u+x</th><th>为文件所有者添加可执行权限。</th></tr></thead><tbody><tr><td>u-x</td><td>删除文件所有者的可执行权限。</td></tr><tr><td>+x</td><td>为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。</td></tr><tr><td>o-rw</td><td>除了文件所有者和用户组，删除其他人的读权限和写权限。</td></tr><tr><td>go=rw</td><td>给文件所属的组和文件所属者/组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。</td></tr><tr><td>u+x,go=rw</td><td>给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。</td></tr></tbody></table><p>Some people prefer to use octal notation, some folks really like the symbolic. Symbolic notation does offer the advantage of allowing you to set a single attribute without disturbing any of the others.</p><p>一些人喜欢使用八进制表示法，而另一些人则非常喜欢符号表示法。符号表示法的优点是， 允许你设置文件模式的某个属性，而不影响其他的属性。</p><p>Take a look at the chmod man page for more details and a list of options. A word of caution regarding the “–recursive” option: it acts on both files and directories, so it’s not as useful as one would hope since, we rarely want files and directories to have the same permissions.</p><p>看一下 chmod 命令的手册页，可以得到更详尽的信息和 chmod 命令的各个选项。要注意”–recursive”选项： 它可以同时作用于文件和目录，所以它并不是如我们期望的那么有用处，因为我们很少希望文件和 目录拥有同样的权限。</p><h3 id="借助-GUI-来设置文件模式"><a href="#借助-GUI-来设置文件模式" class="headerlink" title="借助 GUI 来设置文件模式"></a>借助 GUI 来设置文件模式</h3><p>Now that we have seen how the permissions on files and directories are set, we can better understand the permission dialogs in the GUI. In both Nautilus (GNOME) and Konqueror (KDE), right-clicking a file or directory icon will expose a properties dialog. Here is an example from KDE 3.5:</p><p>现在我们已经知道了怎样设置文件和目录的权限，这样我们就可以更好的理解 GUI 中的设置 权限对话框。在 Nautilus (GNOME)和 Konqueror (KDE)中，右击一个文件或目录图标将会弹出一个属性对话框。下面这个例子来自 KDE 3.5：</p><p><img src="https://billie66.github.io/TLCL/book/images/102.png" alt="img"><br>图 2: KDE 3.5 文件属性对话框</p><p>Here we can see the settings for the owner, group, and world. In KDE, clicking on the “Advanced Permissions” button brings up another dialog that allows you to set each of the mode attributes individually. Another victory for understanding brought to us by the command line!</p><p>从这个对话框中，我们看到可以设置文件所有者、用户组和其他人的访问权限。 在 KDE 中，右击”Advanced Permissions”按钮，会打开另一个对话框，这个对话框允许 你单独设置各个模式属性。这也可以通过命令行来理解！</p><h3 id="umask-－-设置默认权限"><a href="#umask-－-设置默认权限" class="headerlink" title="umask － 设置默认权限"></a>umask － 设置默认权限</h3><p>The umask command controls the default permissions given to a file when it is created. It uses octal notation to express a mask of bits to be removed from a file’s mode attributes. Let’s take a look:</p><p>当创建一个文件时，umask 命令控制着文件的默认权限。umask 命令使用八进制表示法来表达 从文件模式属性中删除一个位掩码。大家看下面的例子：</p><pre><code>[me@linuxbox ~]$ rm -f foo.txt[me@linuxbox ~]$ umask0002[me@linuxbox ~]$ &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-rw-r-- 1 me   me   0 2008-03-06 14:53 foo.txt</code></pre><p>We first removed any old copy of foo.txt to make sure we were starting fresh. Next, we ran the umask command without an argument to see the current value. It responded with the value 0002 (the value 0022 is another common default value), which is the octal representation of our mask. We next create a new instance of the file foo.txt and observe its permissions.</p><p>首先，删除文件 foo.txt，以此确定我们从新开始。下一步，运行不带参数的 umask 命令， 看一下当前的掩码值。响应的数值是0002（0022是另一个常用值），这个数值是掩码的八进制 表示形式。下一步，我们创建文件 foo.txt，并且保留它的权限。</p><p>We can see that both the owner and group both get read and write permission, while everyone else only gets read permission. The reason that world does not have write permission is because of the value of the mask. Let’s repeat our example, this time setting the mask ourselves:</p><p>我们可以看到文件所有者和用户组都得到读权限和写权限，而其他人只是得到读权限。 其他人没有得到写权限的原因是由掩码值决定的。重复我们的实验，这次自己设置掩码值：</p><pre><code>[me@linuxbox ~]$ rm foo.txt[me@linuxbox ~]$ umask 0000[me@linuxbox ~]$ &gt; foo.txt[me@linuxbox ~]$ ls -l foo.txt-rw-rw-rw- 1 me   me    0 2008-03-06 14:58 foo.txt</code></pre><p>When we set the mask to 0000 (effectively turning it off), we see that the file is now world writable. To understand how this works, we have to look at octal numbers again. If we take the mask and expand it into binary, then compare it to the attributes we can see what happens:</p><p>当掩码设置为0000（实质上是关掉它）之后，我们看到其他人能够读写文件。为了弄明白这是 怎么回事，我们需要看一下掩码的八进制形式。把掩码展开成二进制形式，然后与文件属性 相比较，看看有什么区别：</p><table><thead><tr><th>Original file mode</th><th>— rw- rw- rw-</th></tr></thead><tbody><tr><td>Mask</td><td>000 000 000 010</td></tr><tr><td>Result</td><td>— rw- rw- r–</td></tr></tbody></table><p>Ignore for the moment the leading zeros (we’ll get to those in a minute) and observe that where the 1 appears in our mask, an attribute was removed—in this case, the world write permission. That’s what the mask does. Everywhere a 1 appears in the binary value of the mask, an attribute is unset. If we look at a mask value of 0022, we can see what it does:</p><p>此刻先忽略掉开头的三个零（我们一会儿再讨论），注意掩码中若出现一个数字1，则 删除文件模式中和这个1在相同位置的属性，在这是指其他人的写权限。这就是掩码要完成的 任务。掩码的二进制形式中，出现数字1的位置，相应地关掉一个文件模式属性。看一下 掩码0022的作用：</p><table><thead><tr><th>Original file mode</th><th>— rw- rw- rw-</th></tr></thead><tbody><tr><td>Mask</td><td>000 000 010 010</td></tr><tr><td>Result</td><td>— rw- r– r–</td></tr></tbody></table><p>Again, where a 1 appears in the binary value, the corresponding attribute is unset. Play with some values (try some sevens) to get used to how this works. When you’re done, remember to clean up:</p><p>又一次，二进制中数字1出现的位置，相对应的属性被删除。再试一下其它的掩码值（一些带数字7的） ，习惯于掩码的工作原理。当你实验完成之后，要记得清理现场：</p><pre><code>[me@linuxbox ~]$ rm foo.txt; umask 0002</code></pre><p>Most of the time you won’t have to change the mask; the default provided by your distribution will be fine. In some high-security situations, however, you will want to control it.</p><p>大多数情况下，你不必修改掩码值，系统提供的默认掩码值就很好了。然而，在一些高 安全级别下，你要能控制掩码值。</p><blockquote><p>Some Special Permissions</p><p>一些特殊权限</p><p>Though we usually see an octal permission mask expressed as a three digit number, it is more technically correct to express it in four digits. Why? Because, in addition to read, write, and execute permission, there are some other, less used, permission settings.</p><p>虽然我们通常看到一个八进制的权限掩码用三位数字来表示，但是从技术层面上来讲， 用四位数字来表示它更确切些。为什么呢？因为除了读取、写入和执行权限之外，还有 其它较少用到的权限设置。</p><p>The first of these is the setuid bit (octal 4000). When applied to an executable file, it sets the effective user ID from that of real user (the user actually running the program) to that of the program’s owner. Most often this is given to a few programs owned by the superuser. When an ordinary user runs a program that is “setuid root” , the program runs with the effective privileges of the superuser. This allows the program to access files and directories that an ordinary user would normally be prohibited from accessing. Clearly, because this raises security concerns, number of setuid programs must be held to an absolute minimum.</p><p>其中之一是 setuid 位（八进制4000）。当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。很明显，因为这会引起安全方面的问题，所有可以 设置 setuid 位的程序个数，必须控制在绝对小的范围内。</p><p>The second is the setgid bit (octal 2000) which, like the setuid bit, changes the effective group ID from the real group ID of the user to that of the file owner. If the setgid bit is set on a directory, newly created files in the directory will be given the group ownership of the directory rather the group ownership of the file’s creator. This is useful in a shared directory when members of a common group need access to all the files in the directory, regardless of the file owner’s primary group.</p><p>第二个是 setgid 位（八进制2000），这个相似于 setuid 位，把有效用户组 ID 从真正的 用户组 ID 更改为文件所有者的组 ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。</p><p>The third is called the sticky bit (octal 1000). This is a holdover from ancient Unix, where it was possible to mark an executable file as “not swappable.” On files, Linux ignores the sticky bit, but if applied to a directory, it prevents users from deleting or renaming files unless the user is either the owner of the directory, the owner of the file, or the superuser. This is often used to control access to a shared directory, such as /tmp.</p><p>第三个是 sticky 位（八进制1000）。这个继承于 Unix，在 Unix 中，它可能把一个可执行文件 标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。这个经常用来控制访问共享目录，比方说/tmp。</p><p>Here are some examples of using chmod with symbolic notation to set these special permissions. First assigning setuid to a program:</p><p>这里有一些例子，使用 chmod 命令和符号表示法，来设置这些特殊的权限。首先， 授予一个程序 setuid 权限。</p><p><em>chmod u+s program</em></p><p>Next, assigning setgid to a directory:</p><p>下一步，授予一个目录 setgid 权限：</p><p><em>chmod g+s dir</em></p><p>Finally, assigning the sticky bit to a directory:</p><p>最后，授予一个目录 sticky 权限：</p><p><em>chmod +t dir</em></p><p>When viewing the output from ls, you can determine the special permissions. Here are some examples. First, a program that is setuid:</p><p>当浏览 ls 命令的输出结果时，你可以确认这些特殊权限。这里有一些例子。首先，一个程序被设置为setuid属性：</p><p><em>-rwsr-xr-x</em></p><p>A directory that has the setgid attribute:</p><p>具有 setgid 属性的目录：</p><p><em>drwxrwsr-x</em></p><p>A directory with the sticky bit set:</p><p>设置了 sticky 位的目录：</p><p><em>drwxrwxrwt</em></p></blockquote><h3 id="更改身份"><a href="#更改身份" class="headerlink" title="更改身份"></a>更改身份</h3><p>At various times, we may find it necessary to take on the identity of another user. Often we want to gain superuser privileges to carry out some administrative task, but it is also possible to “become” another regular user for such things as testing an account. There are three ways to take on an alternate identity:</p><p>在不同的时候，我们会发现很有必要具有另一个用户的身份。经常地，我们想要得到超级 用户特权，来执行一些管理任务，但是也有可能”变为”另一个普通用户，比如说测试一个帐号。 有三种方式，可以拥有多重身份：</p><ol><li>Log out and log back in as the alternate user.</li><li>Use the su command.</li><li>Use the sudo command.</li><li>注销系统并以其他用户身份重新登录系统。</li><li>使用 su 命令。</li><li>使用 sudo 命令。</li></ol><p>We will skip the first technique since we know how to do it and it lacks the convenience of the other two. From within our own shell session, the su command allows you to assume the identity of another user, and either start a new shell session with that user’s IDs, or to issue a single command as that user. The sudo command allows an administrator to set up a configuration file called /etc/sudoers, and define specific commands that particular users are permitted to execute under an assumed identity. The choice of which command to use is largely determined by which Linux distribution you use. Your distribution probably includes both commands, but its configuration will favor either one or the other. We’ll start with su.</p><p>我们将跳过第一种方法，因为我们知道怎样使用它，并且它缺乏其它两种方法的方便性。 在我们自己的 shell 会话中，su 命令允许你假定为另一个用户的身份，以这个用户的 ID 启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。sudo 命令允许一个管理员 设置一个叫做/etc/sudoers 的配置文件，并且定义了一些具体命令，在假定的身份下，特殊用户 可以执行这些命令。选择使用哪个命令，很大程度上是由你使用的 Linux 发行版来决定的。 你的发行版可能这两个命令都包含，但系统配置可能会偏袒其中之一。我们先介绍 su 命令。</p><h3 id="su-－-以其他用户身份和组-ID-运行一个-shell"><a href="#su-－-以其他用户身份和组-ID-运行一个-shell" class="headerlink" title="su － 以其他用户身份和组 ID 运行一个 shell"></a>su － 以其他用户身份和组 ID 运行一个 shell</h3><p>The su command is used to start a shell as another user. The command syntax looks like this:</p><p>su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：</p><pre><code>su [-[l]] [user]</code></pre><p>If the “-l” option is included, the resulting shell session is a login shell for the specified user. This means that the user’s environment is loaded and the working directory is changed to the user’s home directory. This is usually what we want. If the user is not specified, the superuser is assumed. Notice that (strangely) the “-l” may be abbreviated “-”, which is how it is most often used. To start a shell for the superuser, we would do this:</p><p>如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：</p><pre><code>[me@linuxbox ~]$ su -Password:[root@linuxbox ~]#</code></pre><p>After entering the command, we are prompted for the superuser’s password. If it is successfully entered, a new shell prompt appears indicating that this shell has superuser privileges (the trailing “#” rather than a “$”) and the current working directory is now the home directory for the superuser (normally /root.) Once in the new shell, we can carry out commands as the superuser. When finished, type “exit” to return to the previous shell:</p><p>按下回车符之后，shell 提示我们输入超级用户的密码。如果密码输入正确，出现一个新的 shell 提示符， 这表明这个 shell 具有超级用户特权（提示符的末尾字符是”#”而不是”$”），并且当前工作目录是超级用户的家目录 （通常是/root）。一旦进入一个新的 shell，我们能执行超级用户所使用的命令。当工作完成后， 输入”exit”，则返回到原来的 shell:</p><pre><code>[root@linuxbox ~]# exit[me@linuxbox ~]$</code></pre><p>It is also possible to execute a single command rather than starting a new interactive command by using su this way:</p><p>以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：</p><pre><code>su -c &#39;command&#39;</code></pre><p>Using this form, a single command line is passed to the new shell for execution. It is important to enclose the command in quotes, as we do not want expansion to occur in our shell, but rather in the new shell:</p><p>使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想 命令在我们的 shell 中展开，但需要在新 shell 中展开。</p><pre><code>[me@linuxbox ~]$ su -c &#39;ls -l /root/*&#39;Password:-rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg/root/Mail:total 0[me@linuxbox ~]$</code></pre><h3 id="sudo-－-以另一个用户身份执行命令"><a href="#sudo-－-以另一个用户身份执行命令" class="headerlink" title="sudo － 以另一个用户身份执行命令"></a>sudo － 以另一个用户身份执行命令</h3><p>The sudo command is like su in many ways, but has some important additional capabilities. The administrator can configure sudo to allow an ordinary user to execute commands as a different user (usually the superuser) in a very controlled way. In particular, a user may be restricted to one or more specific commands and no others. Another important difference is that the use of sudo does not require access to the superuser’s password. To authenticate using sudo, the user uses his/her own password. Let’s say, for example, that sudo has been configured to allow us to run a fictitious backup program called “backup_script”, which requires superuser privileges. With sudo it would be done like this:</p><p>sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。 另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他/她自己的密码 来认证。比如说，例如，sudo 命令经过配置，允许我们运行一个虚构的备份程序，叫做”backup_script”， 这个程序要求超级用户权限。通过 sudo 命令，这个程序会像这样运行：</p><pre><code>[me@linuxbox ~]$ sudo backup_scriptPassword:System Backup Starting...</code></pre><p>After entering the command, we are prompted for our password (not the superuser’s) and once the authentication is complete, the specified command is carried out. One important difference between su and sudo is that sudo does not start a new shell, nor does it load another user’s environment. This means that commands do not need to be quoted any differently than they would be without using sudo. Note that this behavior can be overridden by specifying various options. See the sudo man page for details.</p><p>按下回车键之后，shell 提示我们输入我们的密码（不是超级用户的）。一旦认证完成，则执行 具体的命令。su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个 用户的 shell 运行环境。这意味者命令不必用单引号引起来。注意通过指定各种各样的选项，这 种行为可以被推翻。详细信息，阅读 sudo 手册页。</p><p>To see what privileges are granted by sudo, use the “-l” option to list them:</p><p>想知道 sudo 命令可以授予哪些权限，使用”-l”选项，列出所有权限：</p><pre><code>[me@linuxbox ~]$ sudo -lUser me may run the following commands on this host:(ALL) ALL</code></pre><blockquote><p>Ubuntu And sudo</p><p>Ubuntu 与 sudo</p><p>One of the recurrent problems for regular users is how to perform certain tasks that require superuser privileges. These tasks include installing and updating software, editing system configuration files, and accessing devices. In the Windows world, this is often done by giving users administrative privileges. This allows users to perform these tasks. However, it also enables programs executed by the user to have the same abilities. This is desirable in most cases, but it also permits malware (malicious software) such as viruses to have free reign of the computer.</p><p>普通用户经常会遇到这样的问题，怎样完成某些需要超级用户权限的任务。这些任务 包括安装和更新软件，编辑系统配置文件，和访问设备。在 Windows 世界里，这些任务是 通过授予用户管理员权限来完成的。这允许用户执行这些任务。然而，这也会导致用户所 执行的程序拥有同样的能力。在大多数情况下，这是我们所期望的，但是它也允许 malware （恶意软件），比方说电脑病毒，自由地支配计算机。</p><p>In the Unix world, there has always been a larger division between regular users and administrators, owing to the multi-user heritage of Unix. The approach taken in Unix is to grant superuser privileges only when needed. To do this, the su and sudo commands are commonly used.</p><p>在 Unix 世界中，由于 Unix 是多用户系统，所以在普通用户和管理员之间总是存在很大的 差别。Unix 采取的方法是只有在需要的时候，才授予普通用户超级用户权限。这样，普遍会 用到 su 和 sudo 命令。</p><p>Up until a couple of years ago, most Linux distributions relied on su for this purpose. su didn’t require the configuration that sudo required, and having a root account is traditional in Unix. This introduced a problem. Users were tempted to operate as root unnecessarily. In fact, some users operated their systems as the root user exclusively, since it does away with all those annoying “permission denied” messages. This is how you reduce the security of a Linux system to that of a Windows system. Not a good idea.</p><p>几年前，大多数的 Linux 发行版都依赖于 su 命令，来达到目的。su 命令不需要 sudo 命令 所要求的配置，su 命令拥有一个 root 帐号，是 Unix 中的传统。但这会引起问题。所有用户 会企图以 root 用户帐号来操纵系统。事实上，一些用户专门以 root 用户帐号来操作系统， 因为这样做，的确消除了所有那些讨厌的“权限被拒绝”的消息。你这样做就会使得 Linux 系统的 安全性能被降低到和 Windows 系统相同的级别。不是一个好主意。</p><p>When Ubuntu was introduced, its creators took a different tack. By default, Ubuntu disables logins to the root account (by failing to set a password for the account), and instead uses sudo to grant superuser privileges. The initial user account is granted full access to superuser privileges via sudo and may grant similar powers to subsequent user accounts.</p><p>当引进 Ubuntu 的时候，它的创作者们采取了不同的策略。默认情况下，Ubuntu 不允许用户登录 到 root 帐号（因为不能为 root 帐号设置密码），而是使用 sudo 命令授予普通用户超级用户权限。 通过 sudo 命令，最初的用户可以拥有超级用户权限，也可以授予随后的用户帐号相似的权力。</p></blockquote><h3 id="chown-－-更改文件所有者和用户组"><a href="#chown-－-更改文件所有者和用户组" class="headerlink" title="chown － 更改文件所有者和用户组"></a>chown － 更改文件所有者和用户组</h3><p>The chown command is used to change the owner and group owner of a file or directory. Superuser privileges are required to use this command. The syntax of chown looks like this:</p><p>chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。chown 命令 的语法看起来像这样：</p><pre><code>chown [owner][:[group]] file...</code></pre><p>chown can change the file owner and/or the file group owner depending on the first argument of the command. Here are some examples:</p><p>chown 可以根据这个命令的第一个参数更改文件所有者和/或文件用户组。这里有 一些例子：</p><table><thead><tr><th align="left">Argument</th><th align="left">Results</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">Changes the ownership of the file from its current owner to user bob.</td></tr><tr><td align="left">bob:users</td><td align="left">Changes the ownership of the file from its current owner to user bob and changes the file group owner to group users.</td></tr><tr><td align="left">:admins</td><td align="left">Changes the group owner to the group admins. The file owner is unchanged.</td></tr><tr><td align="left">bob:</td><td align="left">Change the file owner from the current owner to user bob and changes the group owner to the login group of user bob.</td></tr></tbody></table><table><thead><tr><th align="left">参数</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">bob</td><td align="left">把文件所有者从当前属主更改为用户 bob。</td></tr><tr><td align="left">bob:users</td><td align="left">把文件所有者改为用户 bob，文件用户组改为用户组 users。</td></tr><tr><td align="left">:admins</td><td align="left">把文件用户组改为组 admins，文件所有者不变。</td></tr><tr><td align="left">bob:</td><td align="left">文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。</td></tr></tbody></table><p>Let’s say that we have two users; janet, who has access to superuser privileges and tony, who does not. User janet wants to copy a file from her home directory to the home directory of user tony. Since user janet wants tony to be able to edit the file, janet changes the ownership of the copied file from janet to tony:</p><p>比方说，我们有两个用户，janet拥有超级用户访问权限，而 tony 没有。用户 janet 想要从 她的家目录复制一个文件到用户 tony 的家目录。因为用户 janet 想要 tony 能够编辑这个文件， janet 把这个文件的所有者更改为 tony:</p><pre><code>[janet@linuxbox ~]$ sudo cp myfile.txt ~tonyPassword:[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 root  root 8031 2008-03-20 14:30 /home/tony/myfile.txt[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt-rw-r--r-- 1 tony  tony 8031 2008-03-20 14:30 /home/tony/myfile.txt</code></pre><p>Here we see user janet copy the file from her directory to the home directory of user tony. Next, janet changes the ownership of the file from root (a result of using sudo) to tony. Using the trailing colon in the first argument, janet also changed the group ownership of the file to the login group of tony, which happens to be group tony.</p><p>这里，我们看到用户 janet 把文件从她的目录复制到 tony 的家目录。下一步，janet 把文件所有者 从 root（使用 sudo 命令的原因）改到 tony。通过在第一个参数中使用末尾的”:”字符，janet 同时把 文件用户组改为 tony 登录系统时，所属的用户组，碰巧是用户组 tony。</p><p>Notice that after the first use of sudo, janet was not prompted for her password? This is because sudo, in most configurations, “trusts” you for several minutes until its timer runs out.</p><p>注意，第一次使用 sudo 命令之后，为什么（shell）没有提示 janet 输入她的密码？这是因为，在 大多数的配置中，sudo 命令会相信你几分钟，直到计时结束。</p><h3 id="chgrp-－-更改用户组所有权"><a href="#chgrp-－-更改用户组所有权" class="headerlink" title="chgrp － 更改用户组所有权"></a>chgrp － 更改用户组所有权</h3><p>In older versions of Unix, the chown command only changed file ownership, not group ownership. For that purpose, a separate command, chgrp was used. It works much the same way as chown, except for being more limited.</p><p>在旧版 Unix 系统中，chown 命令只能更改文件所有权，而不是用户组所有权。为了达到目的， 使用一个独立的命令，chgrp 来完成。除了限制多一点之外，chgrp 命令与 chown 命令使用起来很相似。</p><h3 id="练习使用权限"><a href="#练习使用权限" class="headerlink" title="练习使用权限"></a>练习使用权限</h3><p>Now that we have learned how this permissions thing works, it’s time to show it off. We are going to demonstrate the solution to a common problem — setting up a shared directory. Let’s imagine that we have two users named “bill” and “karen.” They both have music CD collections and wish to set up a shared directory, where they will each store their music files as Ogg Vorbis or MP3. User bill has access to superuser privileges via sudo.</p><p>到目前为止，我们已经知道了权限这类东西是怎样工作的，现在是时候炫耀一下了。我们 将展示一个常见问题的解决方案，这个问题是如何设置一个共享目录。假想我们有两个用户， 他们分别是 “bill” 和 “karen”。他们都有音乐 CD 收藏品，也愿意设置一个共享目录，在这个 共享目录中，他们分别以 Ogg Vorbis 或 MP3 的格式来存储他们的音乐文件。通过 sudo 命令， 用户 bill 具有超级用户访问权限。</p><p>The first thing that needs to happen is creating a group that will have both bill and karen as members. Using the graphical user management tool, bill creates a group called music and adds users bill and karen to it:</p><p>我们需要做的第一件事，是创建一个以 bill 和 karen 为成员的用户组。使用图形化的用户管理工具， bill 创建了一个叫做 music 的用户组，并且把用户 bill 和 karen 添加到用户组 music 中：</p><p><img src="https://billie66.github.io/TLCL/book/images/103.png" alt="img"><br>图 3: 用 GNOME 创建一个新的用户组</p><p>Next, bill creates the directory for the music files:</p><p>下一步，bill 创建了存储音乐文件的目录：</p><pre><code>[bill@linuxbox ~]$ sudo mkdir /usr/local/share/Musicpassword:</code></pre><p>Since bill is manipulating files outside his home directory, superuser privileges are required. After the directory is created, it has the following ownerships and permissions:</p><p>因为 bill 正在他的家目录之外操作文件，所以需要超级用户权限。这个目录创建之后，它具有 以下所有权和权限：</p><pre><code>[bill@linuxbox ~]$ ls -ld /usr/local/share/Musicdrwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music</code></pre><p>As we can see, the directory is owned by root and has 755 permissions. To make this directory sharable, bill needs to change the group ownership and the group permissions to allow writing:</p><p>正如我们所见到的，这个目录由 root 用户拥有，并且具有权限755。为了使这个目录共享，允许（用户 karen）写入，bill 需要更改目录用户组所有权和权限：</p><pre><code>[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music[bill@linuxbox ~]$ ls -ld /usr/local/share/Musicdrwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music</code></pre><p>So what does this all mean? It means that we now have a directory, /usr/local/share/Music that is owned by root and allows read and write access to group music. Group music has members bill and karen, thus bill and karen can create files in directory /usr/local/share/Music. Other users can list the contents of the directory but cannot create files there.</p><p>那么这是什么意思呢？ 它的意思是，现在我们拥有一个目录，/usr/local/share/Music，这个目录由 root 用户拥有，并且 允许用户组 music 读取和写入。用户组 music 有两个成员 bill 和 karen，这样 bill 和 karen 能够在目录 /usr/local/share/Music 中创建文件。其他用户能够列出目录中的内容，但是不能在其中创建文件。</p><p>But we still have a problem. With the current permissions, files and directories created within the Music directory will have the normal permissions of the users bill and karen:</p><p>但是我们仍然会遇到问题。通过我们目前所拥有的权限，在 Music 目录中创建的文件，只具有用户 bill 和 karen 的普通权限：</p><pre><code>[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file[bill@linuxbox ~]$ ls -l /usr/local/share/Music-rw-r--r-- 1 bill    bill    0 2008-03-24 20:03 test_file</code></pre><p>Actually there are two problems. First, the default umask on this system is 0022 which prevents group members from writing files belonging to other members of the group. This would not be a problem if the shared directory only contained files, but since this directory will store music, and music is usually organized in a hierarchy of artists and albums, members of the group will need the ability to create files and directories inside directories created by other members. We need to change the umask used by bill and karen to 0002 instead.</p><p>实际上，存在两个问题。第一个，系统中默认的掩码值是0022，这会禁止用户组成员编辑属于同 组成员的文件。如果共享目录中只包含文件，这就不是个问题，但是因为这个目录将会存储音乐， 通常音乐会按照艺术家和唱片的层次结构来组织分类。所以用户组成员需要在同组其他成员创建的 目录中创建文件和目录。我们将把用户 bill 和 karen 使用的掩码值改为0002。</p><p>Second, each file and directory created by one member will be set to the primary group of the user rather than the group music. This can be fixed by setting the setgid bit on the directory:</p><p>第二个问题是，用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是用户组 music。 通过设置此目录的 setgid 位来解决这个问题：</p><pre><code>[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music[bill@linuxbox ~]$ ls -ld /usr/local/share/Musicdrwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music</code></pre><p>Now we test to see if the new permissions fix the problem. bill sets his umask to 0002, removes the previous test file, creates a new test file and directory:</p><p>现在测试一下，看看是否新的权限解决了这个问题。bill 把他的掩码值设为0002，删除 先前的测试文件，并创建了一个新的测试文件和目录：</p><pre><code>[bill@linuxbox ~]$ umask 0002[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file[bill@linuxbox ~]$ &gt; /usr/local/share/Music/test_file[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir[bill@linuxbox ~]$ ls -l /usr/local/share/Musicdrwxrwsr-x 2 bill   music 4096 2008-03-24 20:24 test_dir-rw-rw-r-- 1 bill   music 0 2008-03-24 20:22 test_file[bill@linuxbox ~]$</code></pre><p>Both files and directories are now created with the correct permissions to allow all members of the group music to create files and directories inside the Music directory.</p><p>现在，创建的文件和目录都具有正确的权限，允许用户组 music 的所有成员在目录 Music 中创建 文件和目录。</p><p>The one remaining issue is umask. The necessary setting only lasts until the end of session and must be reset. In the next part of the book, we’ll look at making the change to umask permanent.</p><p>剩下一个问题是关于 umask 命令的。umask 命令设置的掩码值只能在当前 shell 会话中生效，若当前 shell 会话结束后，则必须重新设置。在这本书的第三部分，我们将看一下，怎样使掩码值永久生效。</p><h3 id="更改用户密码"><a href="#更改用户密码" class="headerlink" title="更改用户密码"></a>更改用户密码</h3><p>The last topic we’ll cover in this chapter is setting passwords for yourself (and for other users if you have access to superuser privileges.) To set or change a password, the passwd command is used. The command syntax looks like this:</p><p>这一章最后一个话题，我们将讨论自己帐号的密码（和其他人的密码，如果你具有超级用户权限）。 使用 passwd 命令，来设置或更改用户密码。命令语法如下所示：</p><pre><code>passwd [user]</code></pre><p>To change your password, just enter the passwd command. You will be prompted for your old password and your new password:</p><p>只要输入 passwd 命令，就能更改你的密码。shell 会提示你输入你的旧密码和你的新密码：</p><pre><code>[me@linuxbox ~]$ passwd(current) UNIX password:New UNIX password:</code></pre><p>The passwd command will try to enforce use of “strong” passwords. This means the it will refuse to accept passwords that are too short, too similar to previous passwords, are dictionary words, or too easily guessed:</p><p>passwd 命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前相似的密码、 字典中的单词作为密码或者是太容易猜到的密码：</p><pre><code>[me@linuxbox ~]$ passwd(current) UNIX password:New UNIX password:BAD PASSWORD: is too similar to the old oneNew UNIX password:BAD PASSWORD: it is WAY too shortNew UNIX password:BAD PASSWORD: it is based on a dictionary word</code></pre><p>If you have superuser privileges, you can specify a user name as an argument to the passwd command to set the password for another user. There are other options available to the superuser to allow account locking, password expiration, etc. See the passwd man page for details.</p><p>如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置另一个 用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效，等等。 详细内容，参考 passwd 命令的手册页。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>Wikipedia has a good article on malware:</p></li><li><p>Wikipedia 上面有一篇关于 malware（恶意软件）好文章：</p><p><a href="http://en.wikipedia.org/wiki/Malware" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Malware</a></p></li></ul><p>There are number of command line programs used to create and maintain users and groups. For more information, see the man pages for the following commands:</p><p>还有一系列的命令行程序，可以用来创建和维护用户和用户组。更多信息，查看以下命令的手册页：</p><ul><li><em>adduser</em></li><li><em>useradd</em></li><li><em>groupadd</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九章 键盘高级操作技巧</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%94%AE%E7%9B%98%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%94%AE%E7%9B%98%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>I often kiddingly describe Unix as “the operating system for people who like to type.” Of course, the fact that it even has a command line is a testament to that. But command line users don’t like to type that much. Why else would so many commands have such short names like cp, ls, mv, and rm? In fact, one of the most cherished goals of the command line is laziness; doing the most work with the fewest number of keystrokes. Another goal is never having to lift your fingers from the keyboard, never reaching for the mouse. In this chapter, we will look at bash features that make keyboard use faster and more efficient.</p><p>开玩笑地说，我经常把 Unix 描述为“这个操作系统是为喜欢敲键盘的人们服务的。” 当然，Unix 甚至还有一个命令行这件事证明了我所说的话。但是命令行用户不喜欢敲入 那么多字。要不为什么会有如此多的命令有这样简短的命令名，像cp、ls、mv和 rm？事实上 ，命令行最为珍视的目标之一就是懒惰；用最少的击键次数来完成最多的工作。另一个 目标是你的手指永远不必离开键盘，永不触摸鼠标。在这一章节，我们将看一下 bash 特性 ，这些特性使键盘使用起来更加迅速，更加高效。</p><p>The following commands will make an appearance:</p><p>以下命令将会露面：</p><ul><li>clear - Clear the screen</li><li>history - Display the contents of the history list</li><li>clear － 清空屏幕</li><li>history － 显示历史列表内容</li></ul><h3 id="命令行编辑"><a href="#命令行编辑" class="headerlink" title="命令行编辑"></a>命令行编辑</h3><p>bash uses a library (a shared collection of routines that different programs can use) called Readline to implement command line editing. We have already seen some of this. We know, for example, that the arrow keys move the cursor but there are many more features. Think of these as additional tools that we can employ in our work. It’s not important to learn all of them, but many of them are very useful. Pick and choose as desired.</p><p>Bash 使用了一个名为 Readline 的库（共享的例程集合，可以被不同的程序使用）， 来实现命令行编辑。我们已经看到一些例子。我们知道，例如，箭头按键可以移动光标， 此外还有许多特性。想想这些额外的工具，我们可以在工作中使用。学会所有的特性 并不重要，但许多特性非常有帮助。选择自己需要的特性。</p><p>Note: Some of the key sequences below (particularly those which use the Alt key) may be intercepted by the GUI for other functions. All of the key sequences should work properly when using a virtual console.</p><p>注意：下面一些按键组合（尤其使用 Alt 键的组合），可能会被 GUI 拦截来触发其它的功能。 当使用虚拟控制台时，所有的按键组合都应该正确地工作。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>The following table lists the keys used to move the cursor:</p><p>下表列出了移动光标所使用的按键：</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Ctrl-a</td><td align="left">Move cursor to the beginning of the line.</td></tr><tr><td align="left">Ctrl-e</td><td align="left">Move cursor to the end of the line.</td></tr><tr><td align="left">Ctrl-f</td><td align="left">Move cursor forward one character;same as the right arrow key.</td></tr><tr><td align="left">Ctrl-b</td><td align="left">Move cursor backward one character;same as the left arrow key.</td></tr><tr><td align="left">Alt-f</td><td align="left">Move cursor forward one word.</td></tr><tr><td align="left">Alt-b</td><td align="left">Move cursor backward one word.</td></tr><tr><td align="left">Ctrl-l</td><td align="left">Clear the screen and move the cursor to the top left corner. The clear command does the same thing.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">Ctrl-a</td><td align="left">移动光标到行首。</td></tr><tr><td align="left">Ctrl-e</td><td align="left">移动光标到行尾。</td></tr><tr><td align="left">Ctrl-f</td><td align="left">光标前移一个字符；和右箭头作用一样。</td></tr><tr><td align="left">Ctrl-b</td><td align="left">光标后移一个字符；和左箭头作用一样。</td></tr><tr><td align="left">Alt-f</td><td align="left">光标前移一个字。</td></tr><tr><td align="left">Alt-b</td><td align="left">光标后移一个字。</td></tr><tr><td align="left">Ctrl-l</td><td align="left">清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td></tr></tbody></table><h3 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h3><p>Table 9-2 lists keyboard commands that are used to edit characters on the command line.</p><p>表9－2列出了键盘命令，这些命令用来在命令行中编辑字符。</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Ctrl-d</td><td align="left">Delete the character at the cursor location</td></tr><tr><td align="left">Ctrl-t</td><td align="left">Transpose(exchange)the character at the cursor location with the one preceding it.</td></tr><tr><td align="left">Alt-t</td><td align="left">Transpose the word at the cursor location with the one preceding it.</td></tr><tr><td align="left">Alt-l</td><td align="left">Convert the characters from the cursor location to the end of the word to lowercase.</td></tr><tr><td align="left">Alt-u</td><td align="left">Convert the characters from the cursor location to the end of the word to uppercase.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">Ctrl-d</td><td align="left">删除光标位置的字符。</td></tr><tr><td align="left">Ctrl-t</td><td align="left">光标位置的字符和光标前面的字符互换位置。</td></tr><tr><td align="left">Alt-t</td><td align="left">光标位置的字和其前面的字互换位置。</td></tr><tr><td align="left">Alt-l</td><td align="left">把从光标位置到字尾的字符转换成小写字母。</td></tr><tr><td align="left">Alt-u</td><td align="left">把从光标位置到字尾的字符转换成大写字母。</td></tr></tbody></table><h3 id="剪切和粘贴文本"><a href="#剪切和粘贴文本" class="headerlink" title="剪切和粘贴文本"></a>剪切和粘贴文本</h3><p>The Readline documentation uses the terms killing and yanking to refer to what we would commonly call cutting and pasting. Items that are cut are stored in a buffer called the kill-ring.</p><p>Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。 剪切下来的本文被存储在一个叫做剪切环(kill-ring)的缓冲区中。</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Ctrl-k</td><td align="left">Kill text from the cursor location to the end of line.</td></tr><tr><td align="left">Ctrl-u</td><td align="left">Kill text from the cursor location to the beginning of the line.</td></tr><tr><td align="left">Alt-d</td><td align="left">Kill text from the cursor location to the end of the current word.</td></tr><tr><td align="left">Alt-Backspace</td><td align="left">Kill text from the cursor location to the beginning of the word. If the cursor is at the beginning of a word, kill the previous word.</td></tr><tr><td align="left">Ctrl-y</td><td align="left">Yank text from the kill-ring and insert it at the cursor location.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">Ctrl-k</td><td align="left">剪切从光标位置到行尾的文本。</td></tr><tr><td align="left">Ctrl-u</td><td align="left">剪切从光标位置到行首的文本。</td></tr><tr><td align="left">Alt-d</td><td align="left">剪切从光标位置到词尾的文本。</td></tr><tr><td align="left">Alt-Backspace</td><td align="left">剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。</td></tr><tr><td align="left">Ctrl-y</td><td align="left">把剪切环中的文本粘贴到光标位置。</td></tr></tbody></table><blockquote><p>The Meta Key</p><p>元键</p><p>If you venture into the Readline documentation, which can be found in the READLINE section of the bash man page, you will encounter the term “meta key.” On modern keyboards this maps to the Alt key but it wasn’t always so.</p><p>如果你冒险进入到 Readline 的文档中，你会在 bash 手册页的 READLINE 段落， 遇到一个术语”元键”（meta key）。在当今的键盘上，这个元键是指 Alt 键，但 并不总是这样。</p><p>Back in the dim times (before PCs but after Unix) not everybody had their own computer. What they might have had was a device called a terminal. A terminal was a communication device that featured a text display screen and a keyboard and just enough electronics inside to display text characters and move the cursor around. It was attached (usually by serial cable) to a larger computer or the communication network of a larger computer. There were many different brands of terminals and they all had different keyboards and display feature sets. Since they all tended to at least understand ASCII, software developers wanting portable applications wrote to the lowest common denominator. Unix systems have a very elaborate way of dealing with terminals and their different display features. Since the developers of Readline could not be sure of the presence of a dedicated extra control key, they invented one and called it “meta.” While the Alt key serves as the meta key on modern keyboards, you can also press and release the Esc key to get the same effect as holding down the Alt key if you’re still using a terminal (which you can still do in Linux!).</p><p>回到昏暗的年代（在 PC 之前 Unix 之后），并不是每个人都有他们自己的计算机。 他们可能有一个叫做终端的设备。一个终端是一种通信设备，它以一个文本显示 屏幕和一个键盘作为其特色，它里面有足够的电子器件来显示文本字符和移动光标。 它连接到（通常通过串行电缆）一个更大的计算机或者是一个大型计算机的通信 网络。有许多不同的终端产品商标，它们有着不同的键盘和特征显示集。因为它们 都倾向于至少能理解 ASCII，所以软件开发者想要符合最低标准的可移植的应用程序。 Unix 系统有一个非常精巧的方法来处理各种终端产品和它们不同的显示特征。因为 Readline 程序的开发者们，不能确定一个专用多余的控制键的存在，他们发明了一个 控制键，并把它叫做”元”（”meta”）。然而在现代的键盘上，Alt 键作为元键来服务。 如果你仍然在使用终端（在 Linux 中，你仍然可以得到一个终端），你也可以按下和 释放 Esc 键来得到如控制 Alt 键一样的效果。</p></blockquote><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>Another way that the shell can help you is through a mechanism called completion. Completion occurs when you press the tab key while typing a command. Let’s see how this works. Given a home directory that looks like this:</p><p>shell 能帮助你的另一种方式是通过一种叫做自动补全的机制。当你敲入一个命令时， 按下 tab 键，自动补全就会发生。让我们看一下这是怎样工作的。给出一个看起来 像这样的家目录：</p><pre><code>[me@linuxbox ~]$ lsDesktop   ls-output.txt   Pictures   Templates   Videos....</code></pre><p>Try typing the following but don’t press the Enter key:</p><p>试着输入下面的命令，但不要按下 Enter 键：</p><pre><code>[me@linuxbox ~]$ ls l</code></pre><p>Now press the tab key:</p><p>现在按下 tab 键：</p><pre><code>[me@linuxbox ~]$ ls ls-output.txt</code></pre><p>See how the shell completed the line for you? Let’s try another one. Again, don’t press Enter:</p><p>看一下 shell 是怎样补全这一行的？让我们再试试另一个例子。这回，也 不要按下 Enter:</p><pre><code>[me@linuxbox ~]$ ls D</code></pre><p>Press tab:</p><p>按下 tab:</p><pre><code>[me@linuxbox ~]$ ls D</code></pre><p>No completion, just a beep. This happened because “D” matches more than one entry in the directory. For completion to be successful, the “clue” you give it has to be unambiguous. If we go further:</p><p>没有补全，只是嘟嘟响。因为”D”不止匹配目录中的一个条目。为了自动补全执行成功， 你给它的”线索”不能模棱两可。如果我们继续输入：</p><pre><code>[me@linuxbox ~]$ ls Do</code></pre><p>Then press tab:</p><p>然后按下 tab：</p><pre><code>[me@linuxbox ~]$ ls Documents</code></pre><p>The completion is successful.</p><p>自动补全成功了。</p><p>While this example shows completion of pathnames, which is its most common use, completion will also work on variables (if the beginning of the word is a “$”), user names (if the word begins with “~”), commands (if the word is the first word on the line.) and host names (if the beginning of the word is “@”). Host name completion only works for host names listed in /etc/hosts.</p><p>这个实例展示了路径名自动补全，这是最常用的形式。自动补全也能对变量（如果 字的开头是一个”$”）、用户名字（单词以”~”开始）、命令（如果单词是一行的第一个单词） 和主机名（如果单词的开头是”@”）起作用。主机名自动补全只对包含在文件/etc/hosts 中的主机名有效。</p><p>There are a number of control and meta key sequences that are associated with completion:</p><p>有一系列的控制和元键序列与自动补全相关联：</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Alt-?</td><td align="left">Display list of possible completions. On most systems you can also do this by pressing the tab key a second time, which is much easier.</td></tr><tr><td align="left">Alt-*</td><td align="left">Insert all possible completions. This is useful when you want to use more than one possible match.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行动</th></tr></thead><tbody><tr><td align="left">Alt-?</td><td align="left">显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。</td></tr><tr><td align="left">Alt-*</td><td align="left">插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。</td></tr></tbody></table><blockquote><p>Programmable Completion</p><p>可编程自动补全</p><p>Recent versions of bash have a facility called programmable completion. Programmable completion allows you (or more likely, your distribution provider) to add additional completion rules. Usually this is done to add support for specific applications. For example it is possible to add completions for the option list of a command or match particular file types that an application supports. Ubuntu has a fairly large set defined by default. Programmable completion is implemented by shell functions, a kind of mini shell script that we will cover in later chapters. If you are curious, try:</p><p>目前的 bash 版本有一个叫做可编程自动补全工具。可编程自动补全允许你（更可能是，你的 发行版提供商）来加入额外的自动补全规则。通常需要加入对特定应用程序的支持，来完成这个 任务。例如，有可能为一个命令的选项列表，或者一个应用程序支持的特殊文件类型加入自动补全。 默认情况下，Ubuntu 已经定义了一个相当大的规则集合。可编程自动补全是由 shell 函数实现的，shell 函数是一种小巧的 shell 脚本，我们会在后面的章节中讨论到。如果你感到好奇，试一下：</p><p><em>set | less</em></p><p>and see if you can find them. Not all distributions include them by default.</p><p>查看一下如果你能找到它们的话。默认情况下，并不是所有的发行版都包括它们。</p></blockquote><h3 id="利用历史命令"><a href="#利用历史命令" class="headerlink" title="利用历史命令"></a>利用历史命令</h3><p>As we discovered in Chapter 2, bash maintains a history of commands that have been entered. This list of commands is kept in your home directory in a file called .bash_history. The history facility is a useful resource for reducing the amount of typing you have to do, especially when combined with command line editing.</p><p>正如我们在第二章中讨论到的，bash 维护着一个已经执行过的命令的历史列表。这个命令列表 被保存在你家目录下，一个叫做 .bash_history 的文件里。这个 history 工具是个有用资源， 因为它可以减少你敲键盘的次数，尤其当和命令行编辑联系起来时。</p><h3 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h3><p>At any time, we can view the contents of the history list by:</p><p>在任何时候，我们都可以浏览历史列表的内容，通过：</p><pre><code>[me@linuxbox ~]$ history | less</code></pre><p>By default, bash stores the last five hundred commands you have entered. We will see how to adjust this value in a later chapter. Let’s say we want to find the commands we used to list /usr/bin. One way we could do this:</p><p>在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想在自己曾经用过的命令中，找出和/usr/bin这一目录相关的。那么我们就可以这样做：</p><pre><code>[me@linuxbox ~]$ history | grep /usr/bin</code></pre><p>And let’s say that among our results we got a line containing an interesting command like this:</p><p>比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；</p><pre><code>88  ls -l /usr/bin &gt; ls-output.txt</code></pre><p>The number “88” is the line number of the command in the history list. We could use this immediately using another type of expansion called history expansion. To use our discovered line we could do this:</p><p>数字 “88” 是这个命令在历史列表中的行号。我们可以使用另一种叫做 历史命令展开的方式，来调用“88”所代表的这一行命令：</p><pre><code>[me@linuxbox ~]$ !88</code></pre><p>bash will expand “!88” into the contents of the eighty-eighth line in the history list. There are other forms of history expansion that we will cover a little later. bash also provides the ability to search the history list incrementally. This means that we can tell bash to search the history list as we enter characters, with each additional character further refining our search. To start incremental search type Ctrl-r followed by the text you are looking for. When you find it, you can either type Enter to execute the command or type Ctrl-j to copy the line from the history list to the current command line. To find the next occurrence of the text (moving “up” the history list), type Ctrl-r again. To quit searching, type either Ctrl-g or Ctrl-c. Here we see it in action:</p><p>bash 会把 “!88” 展开成为历史列表中88行的内容。还有其它的历史命令展开形式，我们一会儿 讨论它们。bash 也具有增量搜索历史列表的能力。意思是在字符输入的同时，bash 会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入 Ctrl-r来启动增量搜索， 接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。现在看看它的实际效果：</p><pre><code>[me@linuxbox ~]$</code></pre><p>First type Ctrl-r:</p><p>首先输入 Ctrl-r:</p><pre><code>(reverse-i-search)`&#39;:</code></pre><p>The prompt changes to indicate that we are performing a reverse incremental search. It is “reverse” because we are searching from “now” to some time in the past. Next, we start typing our search text. In this example “/usr/bin”:</p><p>提示符改变，显示我们正在执行反向增量搜索。搜索过程是”反向的”，因为我们按照从”现在”到过去 某个时间段的顺序来搜寻。下一步，我们开始输入要查找的文本。在这个例子里是 “/usr/bin”：</p><pre><code>(reverse-i-search)`/usr/bin&#39;: ls -l /usr/bin &gt; ls-output.txt</code></pre><blockquote><p>上面这一行冒号后面的第一个”/”会高亮显示。</p></blockquote><p>Immediately, the search returns our result. With our result, we can execute the command by pressing Enter, or we can copy the command to our current command line for further editing by typing Ctrl-j. Let’s copy it. Type Ctrl-j:</p><p>即刻，搜索返回我们需要的结果。我们可以按下 Enter 键来执行这个命令，或者我们可以按下Ctrl-j复制 这个命令到我们当前的命令行，来进一步编辑它。好了现在我们复制它，输入 Ctrl-j：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</code></pre><p>Our shell prompt returns and our command line is loaded and ready for action! The table below lists some of the keystrokes used to manipulate the history list:</p><p>我们的 shell 提示符重新出现，命令行加载完毕，准备接受下一命令！ 下表列出了一些按键组合， 这些按键可以用来操作历史列表：</p><table><thead><tr><th align="left">Key</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Ctrl-p</td><td align="left">Move to the previous history entry. Same action as the up arrow.</td></tr><tr><td align="left">Ctrl-n</td><td align="left">Move to the next history entry. Same action as the down arrow.</td></tr><tr><td align="left">Alt-&lt;</td><td align="left">Move to the beginning (top) of the history list.</td></tr><tr><td align="left">Alt-&gt;</td><td align="left">Move to the end (bottom) of the history list, i.e., the current command line.</td></tr><tr><td align="left">Ctrl-r</td><td align="left">Reverse incremental search. Searches incrementally from the current command line up the history list.</td></tr><tr><td align="left">Alt-p</td><td align="left">Reverse search, non-incremental. With this key, type in the search string and press enter before the search is performed.</td></tr><tr><td align="left">Alt-n</td><td align="left">Forward search, non-incremental.</td></tr><tr><td align="left">Ctrl-o</td><td align="left">Execute the current item in the history list and advance to the next one. This is handy if you are trying to re-execute a sequence of commands in the history list.</td></tr></tbody></table><table><thead><tr><th align="left">按键</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">Ctrl-p</td><td align="left">移动到上一个历史条目。类似于上箭头按键。</td></tr><tr><td align="left">Ctrl-n</td><td align="left">移动到下一个历史条目。类似于下箭头按键。</td></tr><tr><td align="left">Alt-&lt;</td><td align="left">移动到历史列表开头。</td></tr><tr><td align="left">Alt-&gt;</td><td align="left">移动到历史列表结尾，即当前命令行。</td></tr><tr><td align="left">Ctrl-r</td><td align="left">反向增量搜索。从当前命令行开始，向上增量搜索。</td></tr><tr><td align="left">Alt-p</td><td align="left">反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter来执行搜索）。</td></tr><tr><td align="left">Alt-n</td><td align="left">向前搜索，非增量。</td></tr><tr><td align="left">Ctrl-o</td><td align="left">执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。</td></tr></tbody></table><h3 id="历史命令展开"><a href="#历史命令展开" class="headerlink" title="历史命令展开"></a>历史命令展开</h3><p>The shell offers a specialized type of expansion for items in the history list by using the “!” character. We have already seen how the exclamation point can be followed by a number to insert an entry from the history list. There are a number of other expansion features:</p><p>通过使用 “!” 字符，shell 为历史列表中的命令，提供了一个特殊的展开类型。我们已经知道一个感叹号 ，其后再加上一个数字，可以把来自历史列表中的命令插入到命令行中。这里还有一些其它的展开特性：</p><table><thead><tr><th align="left">Sequence</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">!!</td><td align="left">Repeat the last command. It is probably easier to press up arrow and enter.</td></tr><tr><td align="left">!number</td><td align="left">Repeat history list item number.</td></tr><tr><td align="left">!string</td><td align="left">Repeat last history list item starting with string.</td></tr><tr><td align="left">!?string</td><td align="left">Repeat last history list item containing string.</td></tr></tbody></table><table><thead><tr><th align="left">序列</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">!!</td><td align="left">重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。</td></tr><tr><td align="left">!number</td><td align="left">重复历史列表中第 number 行的命令。</td></tr><tr><td align="left">!string</td><td align="left">重复最近历史列表中，以这个字符串开头的命令。</td></tr><tr><td align="left">!?string</td><td align="left">重复最近历史列表中，包含这个字符串的命令。</td></tr></tbody></table><p>I would caution against using the “!string” and “!?string” forms unless you are absolutely sure of the contents of the history list items.</p><p>应该小心谨慎地使用 “!string” 和 “!?string” 格式，除非你完全确信历史列表条目的内容。</p><p>There are many more elements available in the history expansion mechanism, but this subject is already too arcane and our heads may explode if we continue. The HISTORY EXPANSION section of the bash man page goes into all the gory details. Feel free to explore!</p><p>在历史展开机制中，还有许多可利用的特点，但是这个题目已经太晦涩难懂了， 如果我们再继续讨论的话，我们的头可能要爆炸了。bash 手册页的 HISTORY EXPANSION 部分详尽地讲述了所有要素。</p><blockquote><p>script</p><p>脚本</p><p>In addition to the command history feature in bash, most Linux distributions include a program called script that can be used to record an entire shell session and store it in a file. The basic syntax of the command is:</p><p>除了 bash 中的命令历史特性，许多 Linux 发行版包括一个叫做 script 的程序， 这个程序可以记录整个 shell 会话，并把 shell 会话存在一个文件里面。这个命令的基本语法是：</p><p><em>script [file]</em></p><p>where file is the name of the file used for storing the recording. If no file is specified, the file typescript is used. See the script man page for a complete list of the program’s options and features.</p><p>命令中的 file 是指用来存储 shell 会话记录的文件名。如果没有指定文件名，则使用文件 typescript。查看脚本的手册页，可以得到一个关于 script 程序选项和特点的完整列表。</p></blockquote><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>In this chapter we have covered some of the keyboard tricks that the shell provides to help hardcore typists reduce their workloads. I suspect that as time goes by and you become more involved with the command line, you will refer back to this chapter to pick up more of these tricks. For now, consider them optional and potentially helpful.</p><p>在这一章中，我们已经讨论了一些由 shell 提供的键盘操作技巧，这些技巧是来帮助打字员减少工作量的。 随着时光流逝，你和命令行打交道越来越多，我猜想你会重新翻阅这一章的内容，学会更多的技巧。 目前，你就认为它们是可选的，潜在地有帮助的。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The Wikipedia has a good article on computer terminals:</p></li><li><p>Wikipedia 上有一篇关于计算机终端的好文章：</p><p><a href="http://en.wikipedia.org/wiki/Computer_terminal" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Computer_terminal</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八章 从shell眼中看世界</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%BB%8Eshell%E7%9C%BC%E4%B8%AD%E7%9C%8B%E4%B8%96%E7%95%8C/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%BB%8Eshell%E7%9C%BC%E4%B8%AD%E7%9C%8B%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>In this chapter we are going to look at some of the “magic” that occurs on the command line when you press the enter key. While we will examine several interesting and complex features of the shell, we will do it with just one new command:</p><p>在这一章我们将看到，当你按下 enter 键后，发生在命令行中的一些“魔法”。尽管我们会 深入研究几个复杂而有趣的 shell 特性，但我们只需要使用一个新命令：</p><ul><li>echo - Display a line of text</li><li>echo － 显示一行文本</li></ul><h3 id="字符-展开"><a href="#字符-展开" class="headerlink" title="(字符)展开"></a>(字符)展开</h3><p>Each time you type a command line and press the enter key, bash performs several processes upon the text before it carries out your command. We have seen a couple of cases of how a simple character sequence, for example “*”, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, you type something and it is expanded into something else before the shell acts upon it. To demonstrate what we mean by this, let’s take a look at the echo command. echo is a shell builtin that performs a very simple task. It prints out its text arguments on standard output:</p><p>每当你输入一个命令并按下 enter 键，bash 会在执行你的命令之前对输入 的字符完成几个步骤的处理。我们已经见过几个例子：例如一个简单的字符序列”*”, 对 shell 来说有着多么丰富的涵义。这背后的的过程叫做（字符）展开。通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。为了说明这一点 ，让我们看一看 echo 命令。echo 是一个 shell 内建命令，可以完成非常简单的任务。 它将它的文本参数打印到标准输出中。</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo this is a testthis is a test</code></pre><p>That’s pretty straightforward. Any argument passed to echo gets displayed. Let’s try another example:</p><p>这个命令的作用相当简单明了。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。 让我们试试另一个例子：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo *Desktop Documents ls-output.txt Music Pictures Public Templates Videos</code></pre><p>So what just happened? Why didn’t echo print “<em>”? As you recall from our work with wildcards, the “</em>” character means match any characters in a filename, but what we didn’t see in our original discussion was how the shell does that. The simple answer is that the shell expands the “<em>” into something else (in this instance, the names of the files in the current working directory) before the echo command is executed. When the enter key is pressed, the shell automatically expands any qualifying characters on the command line before the command is carried out, so the echo command never saw the “</em>”, only its expanded result. Knowing this, we can see that echo behaved as expected.</p><p>那么刚才发生了什么事情呢？ 为什么 echo 不打印”<em>“呢？如果你回忆起我们所学过的 关于通配符的内容，这个”</em>“字符意味着匹配文件名中的任意字符，但在原先的讨论 中我们并不知道 shell 是怎样实现这个功能的。简单的答案就是 shell 在 echo 命 令被执行前把”<em>“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。 当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符， 所以 echo 命令的实际参数并不是”</em>“，而是它展开后的结果。知道了这个以后， 我们就能明白 echo 的行为符合预期。</p><h3 id="路径名展开"><a href="#路径名展开" class="headerlink" title="路径名展开"></a>路径名展开</h3><p>The mechanism by which wildcards work is called pathname expansion. If we try some of the techniques that we employed in our earlier chapters, we will see that they are really expansions. Given a home directory that looks like this:</p><p>通配符所依赖的工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧， 我们会看到它们实际上是展开。给定一个家目录，它看起来像这样：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ lsDesktop   ls-output.txt   Pictures   Templates....</code></pre><p>we could carry out the following expansions:</p><p>我们能够执行以下的展开：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo D*Desktop  Documents</code></pre><p>and:</p><p>和：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo *sDocuments Pictures Templates Videos</code></pre><p>or even:</p><p>甚至是：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo [[:upper:]]*Desktop Documents Music Pictures Public Templates Videos</code></pre><p>and looking beyond our home directory:</p><p>查看家目录之外的目录：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo /usr/*/share/usr/kerberos/share  /usr/local/share</code></pre><blockquote><p>Pathname Expansion Of Hidden Files</p><p>隐藏文件路径名展开</p><p>As we know, filenames that begin with a period character are hidden. Pathname expansion also respects this behavior. An expansion such as:</p><p>正如我们知道的，以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种 行为。像这样的展开：</p><p><em>echo *</em></p><p>does not reveal hidden files.</p><p>不会显示隐藏文件</p><p>It might appear at first glance that we could include hidden files in an expansion by starting the pattern with a leading period, like this:</p><p>直觉告诉我们，如果展开模式以一个圆点开头，我们就能够在展开中包含隐藏文件， 就像这样：</p><p><em>echo .*</em></p><p>It almost works. However, if we examine the results closely, we will see that the names “.” and “..” will also appear in the results. Since these names refer to the current working directory and its parent directory, using this pattern will likely produce an incorrect result. We can see this if we try the command:</p><p>它几乎要起作用了。然而，如果我们仔细检查一下输出结果，我们会看到名字”.” 和”..”也出现在结果中。由于它们是指当前工作目录和父目录，使用这种 模式可能会产生不正确的结果。我们可以通过这个命令来验证：</p><p><em>ls -d .\</em> | less*</p><p>To correctly perform pathname expansion in this situation, we have to employ a more specific pattern. This will work correctly:</p><p>为了在这种情况下正确地完成路径名展开，我们应该使用一个更精确的模式。 这个模式会正确地工作：</p><p><em>ls -d .[!.]?*</em></p><p>This pattern expands into every filename that begins with a period, does not include a second period, contains at least one additional character and can be followed by any other characters. This will work correctly with most hidden files (though it still won’t include filenames with multiple leading periods). The ls command with the -A option (“almost all”) will provide a correct listing of hidden files:</p><p>这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：</p><p><em>ls -A</em></p></blockquote><h3 id="波浪线展开"><a href="#波浪线展开" class="headerlink" title="波浪线展开"></a>波浪线展开</h3><p>As you may recall from our introduction to the cd command, the tilde character (“~”) has a special meaning. When used at the beginning of a word, it expands into the name of the home directory of the named user, or if no user is named, the home directory of the current user:</p><p>可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“~”)有特殊的含义。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo ~/home/me</code></pre><p>If user “foo” has an account, then:</p><p>如果有用户”foo”这个帐号，那么：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo ~foo/home/foo</code></pre><h3 id="算术表达式展开"><a href="#算术表达式展开" class="headerlink" title="算术表达式展开"></a>算术表达式展开</h3><p>The shell allows arithmetic to be performed by expansion. This allow us to use the shell prompt as a calculator:</p><p>shell 在展开中执行算数表达式。这允许我们把 shell 提示当作计算器来使用：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $((2 + 2))4</code></pre><p>Arithmetic expansion uses the form:</p><p>算术表达式展开使用这种格式：</p><pre class=" language-shell"><code class="language-shell">$((expression))</code></pre><p>where expression is an arithmetic expression consisting of values and arithmetic operators.</p><p>（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。</p><p>Arithmetic expansion only supports integers (whole numbers, no decimals), but can perform quite a number of different operations. Here are a few of the supported operators:</p><p>算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是 一些它支持的操作符：</p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">Addition</td></tr><tr><td align="left">-</td><td align="left">Subtraction</td></tr><tr><td align="left">*</td><td align="left">Multiplication</td></tr><tr><td align="left">/</td><td align="left">Division(but remember, since expansion only supports integer arithmetic, results are integers.)</td></tr><tr><td align="left">%</td><td align="left">Modulo, which simply means, “remainder”.</td></tr><tr><td align="left">**</td><td align="left">Exponentiation</td></tr></tbody></table><table><thead><tr><th align="left">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加</td></tr><tr><td align="left">-</td><td align="left">减</td></tr><tr><td align="left">*</td><td align="left">乘</td></tr><tr><td align="left">/</td><td align="left">除（但是记住，因为展开只是支持整数除法，所以结果是整数。）</td></tr><tr><td align="left">%</td><td align="left">取余，只是简单的意味着，“余数”</td></tr><tr><td align="left">**</td><td align="left">取幂</td></tr></tbody></table><p>Spaces are not significant in arithmetic expressions and expressions may be nested. For example, to multiply five squared by three:</p><p>在算术表达式中空格并不重要，并且表达式可以嵌套。例如，5的平方乘以3：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $(($((5**2)) * 3))75</code></pre><p>Single parentheses may be used to group multiple subexpressions. With this technique, we can rewrite the example above and get the same result using a single expansion instead of two:</p><p>一对括号可以用来把多个子表达式括起来。通过这个技术，我们可以重写上面的例子， 同时用一个展开代替两个，来得到一样的结果：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $(((5**2) * 3))75</code></pre><p>Here is an example using the division and remainder operators. Notice the effect of integer division:</p><p>这是一个使用除法和取余操作符的例子。注意整数除法的结果：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo Five divided by two equals $((5/2))Five divided by two equals 2[me@linuxbox ~]$ echo with $((5%2)) left over.with 1 left over.</code></pre><p>Arithmetic expansion is covered in greater detail in Chapter 35.</p><p>在35章会更深入地讨论算术表达式的内容。</p><h3 id="花括号展开"><a href="#花括号展开" class="headerlink" title="花括号展开"></a>花括号展开</h3><p>Perhaps the strangest expansion is called brace expansion. With it, you can create multiple text strings from a pattern containing braces. Here’s an example:</p><p>可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back</code></pre><p>Patterns to be brace expanded may contain a leading portion called a preamble and a trailing portion called a postscript. The brace expression itself may contain either a comma-separated list of strings, or a range of integers or single characters. The pattern may not contain embedded whitespace. Here is an example using a range of integers:</p><p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能 嵌入空白字符。这个例子中使用了一个整数区间：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo Number_{1..5}Number_1  Number_2  Number_3  Number_4  Number_5</code></pre><p>A range of letters in reverse order:</p><p>倒序排列的字母区间：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo {Z..A}Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</code></pre><p>Brace expansions may be nested:</p><p>花括号展开可以嵌套：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}baA1b aA2b aB3b aB4b</code></pre><p>So what is this good for? The most common application is to make lists of files or directories to be created. For example, if we were photographers and had a large collection of images that we wanted to organize into years and months, the first thing we might do is create a series of directories named in numeric “Year-Month” format. This way, the directory names will sort in chronological order. We could type out a complete list of directories, but that’s a lot of work and it’s error-prone too. Instead, we could do this:</p><p>那么这对什么有好处呢？最常见的应用是，创建一系列的文件或目录列表。例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，可以使目录名按照 年代顺序排列。我们可以手动键入整个目录列表，但是工作量太大了，并且易于出错。 反之，我们可以这样做：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>me@linuxbox ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> Pics<span class="token punctuation">[</span>me@linuxbox ~<span class="token punctuation">]</span>$ <span class="token function">cd</span> Pics<span class="token punctuation">[</span>me@linuxbox Pics<span class="token punctuation">]</span>$ <span class="token function">mkdir</span> <span class="token punctuation">{</span>2007<span class="token punctuation">..</span>2009<span class="token punctuation">}</span>-0<span class="token punctuation">{</span>1<span class="token punctuation">..</span>9<span class="token punctuation">}</span> <span class="token punctuation">{</span>2007<span class="token punctuation">..</span>2009<span class="token punctuation">}</span>-<span class="token punctuation">{</span>10<span class="token punctuation">..</span>12<span class="token punctuation">}</span><span class="token punctuation">[</span>me@linuxbox Pics<span class="token punctuation">]</span>$ <span class="token function">ls</span>2007-01 2007-07 2008-01 2008-07 2009-01 2009-072007-02 2007-08 2008-02 2008-08 2009-02 2009-082007-03 2007-09 2008-03 2008-09 2009-03 2009-092007-04 2007-10 2008-04 2008-10 2009-04 2009-102007-05 2007-11 2008-05 2008-11 2009-05 2009-112007-06 2007-12 2008-06 2008-12 2009-06 2009-12</code></pre><p>Pretty slick!</p><p>棒极了！</p><h3 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h3><p>We’re only going to touch briefly on parameter expansion in this chapter, but we’ll be covering it extensively later. It’s a feature that is more useful in shell scripts than directly on the command line. Many of its capabilities have to do with the system’s ability to store small chunks of data and to give each chunk a name. Many such chunks, more properly called variables, are available for your examination. For example, the variable named “USER” contains your user name. To invoke parameter expansion and reveal the contents of USER you would do this:</p><p>在这一章我们将会简单介绍参数展开，但会在后续章节中进行详细讨论。这个特性在 shell 脚本中比直接在命令行中更有用。 它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。例如，叫做”USER”的变量包含你的 用户名。可以这样做来调用参数，并查看 USER 中的内容，：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $USERme</code></pre><p>To see a list of available variables, try this:</p><p>要查看有效的变量列表，可以试试这个：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ printenv | less</code></pre><p>You may have noticed that with other types of expansion, if you mistype a pattern, the expansion will not take place and the echo command will simply display the mistyped pattern. With parameter expansion, if you misspell the name of a variable, the expansion will still take place, but will result in an empty string:</p><p>你可能注意到在其它展开类型中，如果你误输入一个模式，展开就不会发生。这时 echo 命令只简单地显示误键入的模式。但在参数展开中，如果你拼写错了一个变量名， 展开仍然会进行，只是展开的结果是一个空字符串：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $SUER[me@linuxbox ~]$</code></pre><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>Command substitution allows us to use the output of a command as an expansion:</p><p>命令替换允许我们把一个命令的输出作为一个展开模式来使用：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $(ls)Desktop Documents ls-output.txt Music Pictures Public TemplatesVideos</code></pre><p>One of my favorites goes something like this:</p><p>我最喜欢用的一行命令是像这样的：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ ls -l $(which cp)-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp</code></pre><p>Here we passed the results of which cp as an argument to the ls command, thereby getting the listing of of the cp program without having to know its full pathname. We are not limited to just simple commands. Entire pipelines can be used (only partial output shown):</p><p>这里我们把 which cp 的执行结果作为一个参数传递给 ls 命令，因此可以在不知道 cp 命令 完整路径名的情况下得到它的文件属性列表。我们不只限制于简单命令。也可以使用整个管道线 （只展示部分输出）：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)/usr/bin/bunzip2:     symbolic link to `bzip2'....</code></pre><p>In this example, the results of the pipeline became the argument list of the file command.</p><p>在这个例子中，管道线的输出结果成为 file 命令的参数列表。</p><p>There is an alternate syntax for command substitution in older shell programs which is also supported in bash. It uses back-quotes instead of the dollar sign and parentheses:</p><p>在旧版 shell 程序中，有另一种语法也支持命令替换，可与刚提到的语法轮换使用。 bash 也支持这种语法。它使用倒引号来代替美元符号和括号：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ ls -l `which cp`-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Now that we’ve seen how many ways the shell can perform expansions, it’s time to learn how we can control it. Take for example:</p><p>我们已经知道 shell 有许多方式可以完成展开，现在是时候学习怎样来控制展开了。 以下面例子来说明：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo this is a    testthis is a test</code></pre><p>or:</p><p>或者：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo The total is $100.00The total is 00.00</code></pre><p>In the first example, word-splitting by the shell removed extra whitespace from the echo command’s list of arguments. In the second example, parameter expansion substituted an empty string for the value of “$1” because it was an undefined variable. The shell provides a mechanism called quoting to selectively suppress unwanted expansions.</p><p>在第一个例子中，shell 利用单词分割删除掉 echo 命令的参数列表中多余的空格。在第二个例子中， 参数展开把 <code>$1</code> 的值替换为一个空字符串，因为 <code>1</code> 是没有定义的变量。shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。</p><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>The first type of quoting we will look at is double quotes. If you place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. The exceptions are $, \ (backslash), and ` (back-quote). This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed, but parameter expansion, arithmetic expansion, and command substitution are still carried out. Using double quotes, we can cope with filenames containing embedded spaces. Say we were the unfortunate victim of a file called <em>two words.txt</em>.If we tried to use this on the command line, word-splitting would cause this to be treated as two separate arguments rather than the desired single argument:</p><p>我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。 有几个例外： $，\ (反斜杠），和 `（倒引号）。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 <em>two words.txt</em> 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ ls -l two words.txtls: cannot access two: No such file or directoryls: cannot access words.txt: No such file or directory</code></pre><p>By using double quotes, we stop the word-splitting and get the desired result; further, we can even repair the damage:</p><p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ ls -l "two words.txt"-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt[me@linuxbox ~]$ mv "two words.txt" two_words.txt</code></pre><p>There! Now we don’t have to keep typing those pesky double quotes.</p><p>你瞧！现在我们不必一直输入那些讨厌的双引号了。</p><p>Remember, parameter expansion, arithmetic expansion, and command substitution still take place within double quotes:</p><p>记住，在双引号中，参数展开、算术表达式展开和命令替换仍然有效：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"me 4    February 2008Su Mo Tu We Th Fr Sa....</code></pre><p>We should take a moment to look at the effect of double quotes on command substitution. First let’s look a little deeper at how word splitting works. In our earlier example, we saw how word-splitting appears to remove extra spaces in our text:</p><p>我们应该花费一点时间来看一下双引号在命令替换中的效果。首先仔细研究一下单词分割 是怎样工作的。在之前的范例中，我们已经看到单词分割机制是怎样来删除文本中额外空格的：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo this is a   testthis is a test</code></pre><p>By default, word-splitting looks for the presence of spaces, tabs, and newlines (linefeed characters) and treats them as delimiters between words. This means that unquoted spaces, tabs, and newlines are not considered to be part of the text. They only serve as separators. Since they separate the words into different arguments, our example command line contains a command followed by four distinct arguments. If we add double quotes:</p><p>在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。由于它们把单词分为不同的参数，所以在上面的例子中， 命令行包含一个带有四个不同参数的命令。如果我们加上双引号：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo "this is a    test"this is a    test</code></pre><p>word-splitting is suppressed and the embedded spaces are not treated as delimiters, rather they become part of the argument. Once the double quotes are added, our command line contains a command followed by a single argument.</p><p>单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。 一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。</p><p>The fact that newlines are considered delimiters by the word-splitting mechanism causes an interesting, albeit subtle, effect on command substitution. Consider the following:</p><p>事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。 考虑下面的例子：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo $(cal)February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 1415 16 17 18 19 20 21 22 23 24 25 26 27 28 29[me@linuxbox ~]$ echo "$(cal)"February 2008....</code></pre><p>In the first instance, the unquoted command substitution resulted in a command line containing thirty-eight arguments. In the second, a command line with one argument that includes the embedded spaces and newlines.</p><p>在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><p>If we need to suppress all expansions, we use single quotes. Here is a comparison of unquoted, double quotes, and single quotes:</p><p>如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USERtext /home/me/ls-output.txt a b foo 4 me[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"text ~/*.txt   {a,b} foo 4 me[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER</code></pre><p>As we can see, with each succeeding level of quoting, more and more of the expansions are suppressed.</p><p>正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>Sometimes we only want to quote a single character. To do this, we can precede a character with a backslash, which in this context is called the escape character. Often this is done inside double quotes to selectively prevent an expansion:</p><p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"The balance for user me is: $5.00</code></pre><p>It is also common to use escaping to eliminate the special meaning of a character in a filename. For example, it is possible to use characters in filenames that normally have special meaning to the shell. These would include “$”, “!”, “&amp;”, “ “, and others. To include a special character in a filename you can to this:</p><p>使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名 中包含特殊字符，你可以这样做：</p><pre class=" language-shell"><code class="language-shell">[me@linuxbox ~]$ mv bad\&filename good_filename</code></pre><p>To allow a backslash character to appear, escape it by typing “\”. Note that within single quotes, the backslash loses its special meaning and is treated as an ordinary character.</p><p>为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。</p><blockquote><p>Backslash Escape Sequences</p><p>反斜杠转义字符序列</p><p>In addition to its role as the escape character, the backslash is also used as part of a notation to represent certain special characters called control codes. The first thirty-two characters in the ASCII coding scheme are used to transmit commands to teletype-like devices. Some of these codes are familiar (tab, backspace, linefeed, and carriage return), while others are not (null, end-of-transmission, and acknowledge).</p><p>反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种 特殊字符，这些特殊字符叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到电报机 之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其它 一些编码就不熟悉了（空值，传输结束码，和确认）。</p><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody><tr><td>\a</td><td>Bell(“Alert”-causes the computer to beep)</td></tr><tr><td>\b</td><td>Backspace</td></tr><tr><td>\n</td><td>Newline. On Unix-like systems, this produces a linefeed.</td></tr><tr><td>\r</td><td>Carriage return</td></tr><tr><td>\t</td><td>Tab</td></tr></tbody></table><table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td>\a</td><td>响铃（”警告”－导致计算机嘟嘟响）</td></tr><tr><td>\b</td><td>退格符</td></tr><tr><td>\n</td><td>新的一行。在类 Unix 系统中，产生换行。</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr></tbody></table><p>The table above lists some of the common backslash escape sequences. The idea behind this representation using the backslash originated in the C programming language and has been adopted by many others, including the shell.</p><p>上表列出了一些常见的反斜杠转义字符序列。这种利用反斜杠的表示法背后的思想来源于 C 编程语言， 许多其它语言也采用了这种表示方法，包括 shell。</p><p>Adding the ‘-e’ option to echo will enable interpretation of escape sequences. You may also place them inside $’ ‘. Here, using the sleep command, a simple program that just waits for the specified number of seconds and then exits, we can create a primitive countdown timer:</p><p>echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $’ ‘ 里面。 以下例子中，我们可以使用 sleep 命令创建一个简单的倒数计数器（ sleep 是一个简单的程序， 它会等待指定的秒数，然后退出）：</p><p><em>sleep 10; echo -e “Time’s up\a”</em></p><p>We could also do this: 我们也可以这样做：</p><p><em>sleep 10; echo “Time’s up” $’\a’</em></p></blockquote><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>As we move forward with using the shell, we will find that expansions and quoting will be used with increasing frequency, so it makes sense to get a good understanding of the way they works. In fact, it could be argued that they are the most important subjects to learn about the shell. Without a proper understanding of expansion, the shell will always be a source of mystery and confusion, and much of it potential power wasted.</p><p>随着我们继续学习 shell，你会发现使用展开和引用的频率逐渐多起来，所以能够很好的 理解它们的工作方式很有意义。事实上，可以这样说，它们是学习 shell 的最重要的主题。 如果没有准确地理解展开模式，shell 总是神秘和混乱的源泉，并且 shell 潜在的能力也 浪费掉了。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The bash man page has major sections on both expansion and quoting which cover these topics in a more formal manner.</p></li><li><p>Bash 手册页有主要段落是关于展开和引用的，它们以更正式的方式介绍了这些题目。</p></li><li><p>The Bash Reference Manual also contains chapters on expansion and quoting:</p></li><li><p>Bash 参考手册也包含章节，介绍展开和引用：</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七章 重定义</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%87%8D%E5%AE%9A%E4%B9%89/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%87%8D%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>In this lesson we are going to unleash what may be the coolest feature of the command line. It’s called I/O redirection. The “I/O” stands for input/output and with this facility you can redirect the input and output of commands to and from files, as well as connect multiple commands together into powerful command pipelines. To show off this facility, we will introduce the following commands:</p><p>这堂课，我们来介绍可能是命令行最酷的特性。它叫做 I/O 重定向。”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。为了展示这个工具，我们将叙述 以下命令：</p><ul><li>cat - Concatenate files</li><li>sort - Sort lines of text</li><li>uniq - Report or omit repeated lines</li><li>grep - Print lines matching a pattern</li><li>wc - Print newline, word, and byte counts for each file</li><li>head - Output the first part of a file</li><li>tail - Output the last part of a file</li><li>tee - Read from standard input and write to standard output and files</li><li>cat － 连接文件</li><li>sort － 排序文本行</li><li>uniq － 报道或省略重复行</li><li>grep － 打印匹配行</li><li>wc － 打印文件中换行符，字，和字节个数</li><li>head － 输出文件第一部分</li><li>tail - 输出文件最后一部分</li><li>tee - 从标准输入读取数据，并同时写到标准输出和文件</li></ul><h3 id="标准输入、输出和错误"><a href="#标准输入、输出和错误" class="headerlink" title="标准输入、输出和错误"></a>标准输入、输出和错误</h3><p>Many of the programs that we have used so far produce output of some kind. This output often consists of two types. First, we have the program’s results; that is, the data the program is designed to produce, and second, we have status and error messages that tell us how the program is getting along. If we look at a command like ls, we can see that it displays its results and its error messages on the screen.</p><p>到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。 第一，程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息， 这些告诉我们程序进展。如果我们观察一个命令，像 ls，会看到它的运行结果和错误信息 显示在屏幕上。</p><p>Keeping with the Unix theme of “everything is a file,” programs such as ls actually send their results to a special file called standard output (often expressed as stdout) and their status messages to another file called standard error (stderr). By default, both standard output and standard error are linked to the screen and not saved into a disk file. In addition, many programs take input from a facility called standard input (stdin) which is, by default, attached to the keyboard.</p><p>与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。</p><p>I/O redirection allows us to change where output goes and where input comes from. Normally, output goes to the screen and input comes from the keyboard, but with I/O redirection, we can change that.</p><p>I/O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘， 但是通过 I/O 重定向，我们可以做出改变。</p><h3 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h3><p>I/O redirection allows us to redefine where standard output goes. To redirect standard output to another file besides the screen, we use the “&gt;” redirection operator followed by the name of the file. Why would we want to do this? It’s often useful to store the output of a command in a file. For example, we could tell the shell to send the output of the ls command to the file ls-output.txt instead of the screen:</p><p>I/O 重定向允许我们来重定义标准输出的地点。我们使用 “&gt;” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt</code></pre><p>Here, we created a long listing of the /usr/bin directory and sent the results to the file ls-output.txt. Let’s examine the redirected output of the command:</p><p>这里，我们创建了一个长长的目录/usr/bin 列表，并且输送程序运行结果到文件 ls-output.txt 中。 我们检查一下重定向的命令输出结果：</p><pre><code>[me@linuxbox ~]$ ls -l ls-output.txt-rw-rw-r-- 1   me   me    167878 2008-02-01 15:07 ls-output.txt</code></pre><p>Good; a nice, large, text file. If we look at the file with less, we will see that the file ls-output.txt does indeed contain the results from our ls command:</p><p>好；一个不错的大型文本文件。如果我们用 less 阅读器来查看这个文件，我们会看到文件 ls-output.txt 的确包含 ls 命令的执行结果。</p><pre><code>[me@linuxbox ~]$ less ls-output.txt</code></pre><p>Now, let’s repeat our redirection test, but this time with a twist. We’ll change the name of the directory to one that does not exist:</p><p>现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。</p><pre><code>[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txtls: cannot access /bin/usr: No such file or directory</code></pre><p>We received an error message. This makes sense since we specified the non-existent directory /bin/usr, but why was the error message displayed on the screen rather than being redirected to the file ls-output.txt? The answer is that the ls program does not send its error messages to standard output. Instead, like most well-written Unix programs, it sends its error messages to standard error. Since we only redirected standard output and not standard error, the error message was still sent to the screen. We’ll see how to redirect standard error in just a minute, but first, let’s look at what happened to our output file:</p><p>我们收到一个错误信息。这讲得通，因为我们指定了一个不存在的目录/bin/usr, 但是为什么这条错误信息显示在屏幕上而不是被重定向到文件 ls-output.txt？答案是， ls 程序不把它的错误信息输送到标准输出。反而，像许多写得不错的 Unix 程序，ls 把 错误信息送到标准错误。因为我们只是重定向了标准输出，而没有重定向标准错误， 所以错误信息被送到屏幕。马上，我们将知道怎样重定向标准错误，但是首先看一下 我们的输出文件发生了什么事情。</p><pre><code>me@linuxbox ~]$ ls -l ls-output.txt-rw-rw-r-- 1 me   me    0 2008-02-01 15:08 ls-output.txt</code></pre><p>The file now has zero length! This is because, when we redirect output with the “&gt;” redirection operator, the destination file is always rewritten from the beginning. Since our ls command generated no results and only an error message, the redirection operation started to rewrite the file and then stopped because of the error, resulting in its truncation. In fact, if we ever need to actually truncate a file (or create a new, empty file) we can use a trick like this:</p><p>文件长度为零！这是因为，当我们使用 “&gt;” 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后 由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：</p><pre><code>[me@linuxbox ~]$ &gt; ls-output.txt</code></pre><p>Simply using the redirection operator with no command preceding it will truncate an existing file or create a new, empty file.</p><p>简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是 创建一个新的空文件。</p><p>So, how can we append redirected output to a file instead of overwriting the file from the beginning? For that, we use the “&gt;&gt;” redirection operator, like so:</p><p>所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”&gt;&gt;“重定向符，像这样：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt</code></pre><p>Using the “&gt;&gt;” operator will result in the output being appended to the file. If the file does not already exist, it is created just as though the “&gt;” operator had been used. Let’s put it to the test:</p><p>使用”&gt;&gt;“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”&gt;”操作符。把它放到测试中：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt[me@linuxbox ~]$ ls -l /usr/bin &gt;&gt; ls-output.txt[me@linuxbox ~]$ ls -l ls-output.txt-rw-rw-r-- 1 me   me    503634 2008-02-01 15:45 ls-output.txt</code></pre><p>We repeated the command three times resulting in an output file three times as large.</p><p>我们重复执行命令三次，导致输出文件大小是原来的三倍。</p><h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><p>Redirecting standard error lacks the ease of a dedicated redirection operator. To redirect standard error we must refer to its file descriptor. A program can produce output on any of several numbered file streams. While we have referred to the first three of these file streams as standard input, output and error, the shell references them internally as file descriptors zero, one and two, respectively. The shell provides a notation for redirecting files using the file descriptor number. Since standard error is the same as file descriptor number two, we can redirect standard error with this notation:</p><p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：</p><pre><code>[me@linuxbox ~]$ ls -l /bin/usr 2&gt; ls-error.txt</code></pre><p>The file descriptor “2” is placed immediately before the redirection operator to perform the redirection of standard error to the file ls-error.txt.</p><p>文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。</p><h3 id="重定向标准输出和错误到同一个文件"><a href="#重定向标准输出和错误到同一个文件" class="headerlink" title="重定向标准输出和错误到同一个文件"></a>重定向标准输出和错误到同一个文件</h3><p>There are cases in which we may wish to capture all of the output of a command to a single file. To do this, we must redirect both standard output and standard error at the same time. There are two ways to do this. First, the traditional way, which works with old versions of the shell:</p><p>可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法， 在旧版本 shell 中也有效：</p><pre><code>[me@linuxbox ~]$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</code></pre><p>Using this method, we perform two redirections. First we redirect standard output to the file ls-output.txt and then we redirect file descriptor two (standard error) to file descriptor one (standard output) using the notation 2&gt;&amp;1.</p><p>使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。</p><hr><p>Notice that the order of the redirections is significant. The redirection of standard error must always occur after redirecting standard output or it doesn’t work. In the example above,</p><p>注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，</p><pre><code>&gt;ls-output.txt 2&gt;&amp;1</code></pre><p>redirects standard error to the file ls-output.txt, but if the order is changed to</p><p>重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：</p><pre><code>2&gt;&amp;1 &gt;ls-output.txt</code></pre><p>standard error is directed to the screen.</p><p>则标准错误定向到屏幕。</p><hr><p>Recent versions of bash provide a second, more streamlined method for performing this combined redirection:</p><p>现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。</p><pre><code>[me@linuxbox ~]$ ls -l /bin/usr &amp;&gt; ls-output.txt</code></pre><p>In this example, we use the single notation &amp;&gt; to redirect both standard output and standard error to the file ls-output.txt.</p><p>在这个例子里面，我们使用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。</p><h3 id="处理不需要的输出"><a href="#处理不需要的输出" class="headerlink" title="处理不需要的输出"></a>处理不需要的输出</h3><p>Sometimes “silence is golden,” and we don’t want output from a command, we just want to throw it away. This applies particularly to error and status messages. The system provides a way to do this by redirecting output to a special file called “/dev/null”. This file is a system device called a bit bucket which accepts input and does nothing with it. To suppress error messages from a command, we do this:</p><p>有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：</p><pre><code>[me@linuxbox ~]$ ls -l /bin/usr 2&gt; /dev/null</code></pre><blockquote><p>/dev/null in Unix Culture</p><p>Unix 文化中的/dev/null</p><p>The bit bucket is an ancient Unix concept and due to its universality, has appeared in many parts of Unix culture. When someone says he/she is sending your comments to /dev/null, now you know what it means. For more examples, see the Wikipedia article on “/dev/null”.</p><p>位存储桶是个古老的 Unix 概念，由于它的普遍性，它的身影出现在 Unix 文化的 许多部分。当有人说他/她正在发送你的评论到/dev/null，现在你应该知道那是 什么意思了。更多的例子，可以阅读 Wikipedia 关于”/dev/null”的文章。</p></blockquote><h3 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h3><p>Up to now, we haven’t encountered any commands that make use of standard input (actually we have, but we’ll reveal that surprise a little bit later), so we need to introduce one.</p><p>到目前为止，我们还没有遇到一个命令是利用标准输入的（实际上我们遇到过了，但是 一会儿再揭晓谜底），所以我们需要介绍一个。</p><h3 id="cat-－-连接文件"><a href="#cat-－-连接文件" class="headerlink" title="cat － 连接文件"></a>cat － 连接文件</h3><p>The cat command reads one or more files and copies them to standard output like so:</p><p>cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:</p><pre><code>cat [file]</code></pre><p>In most cases, you can think of cat as being analogous to the TYPE command in DOS. You can use it to display files without paging, for example:</p><p>在大多数情况下，你可以认为 cat 命令相似于 DOS 中的 TYPE 命令。你可以使用 cat 来显示 文件而没有分页，例如：</p><pre><code>[me@linuxbox ~]$ cat ls-output.txt</code></pre><p>will display the contents of the file ls-output.txt. cat is often used to display short text files. Since cat can accept more than one file as an argument, it can also be used to join files together. Say we have downloaded a large file that has been split into multiple parts (multimedia files are often split this way on USENET), and we want to join them back together. If the files were named:</p><p>将会显示文件 ls-output.txt 的内容。cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个 大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离）， 我们想把它们连起来。如果文件命名为：</p><p>movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099</p><p>we could join them back together with this command:</p><p>我们能用这个命令把它们连接起来：</p><pre><code>cat movie.mpeg.0* &gt; movie.mpeg</code></pre><p>Since wildcards always expand in sorted order, the arguments will be arranged in the correct order.</p><p>因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。</p><p>This is all well and good, but what does this have to do with standard input? Nothing yet, but let’s try something else. What happens if we type “cat” with no arguments:</p><p>这很好，但是这和标准输入有什么关系呢？没有任何关系，让我们试着做些其他的工作。 如果我们输入不带参数的”cat”命令，会发生什么呢：</p><pre><code>[me@linuxbox ~]$ cat</code></pre><p>Nothing happens, it just sits there like it’s hung. It may seem that way, but it’s really doing exactly what it’s supposed to.</p><p>没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该做的事情：</p><p>If cat is not given any arguments, it reads from standard input and since standard input is, by default, attached to the keyboard, it’s waiting for us to type something! Try this:</p><p>如果 cat 没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘， 它正在等待我们输入数据！试试这个：</p><pre><code>[me@linuxbox ~]$ catThe quick brown fox jumped over the lazy dog.</code></pre><p>Next, type a Ctrl-d (i.e., hold down the Ctrl key and press “d”) to tell cat that it has reached end of file (EOF) on standard input:</p><p>下一步，输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）：</p><pre><code>[me@linuxbox ~]$ catThe quick brown fox jumped over the lazy dog.The quick brown fox jumped over the lazy dog.</code></pre><p>In the absence of filename arguments, cat copies standard input to standard output, so we see our line of text repeated. We can use this behavior to create short text files. Let’s say that we wanted to create a file called “lazy_dog.txt” containing the text in our example. We would do this:</p><p>由于没有文件名参数，cat 复制标准输入到标准输出，所以我们看到文本行重复出现。 我们可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做”lazy_dog.txt” 的文件，这个文件包含例子中的文本。我们这样做：</p><pre><code>[me@linuxbox ~]$ cat &gt; lazy_dog.txtThe quick brown fox jumped over the lazy dog.</code></pre><p>Type the command followed by the text we want in to place in the file. Remember to type Ctrl-d at the end. Using the command line, we have implemented the world’s dumbest word processor! To see our results, we can use cat to copy the file to stdout again:</p><p>输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我们 实现了世界上最低能的文字处理器！看一下运行结果，我们使用 cat 来复制文件内容到 标准输出：</p><pre><code>[me@linuxbox ~]$ cat lazy_dog.txtThe quick brown fox jumped over the lazy dog.</code></pre><p>Now that we know how cat accepts standard input, in addition to filename arguments, let’s try redirecting standard input:</p><p>现在我们知道 cat 怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：</p><pre><code>[me@linuxbox ~]$ cat &lt; lazy_dog.txtThe quick brown fox jumped over the lazy dog.</code></pre><p>Using the “&lt;” redirection operator, we change the source of standard input from the keyboard to the file lazy_dog.txt. We see that the result is the same as passing a single filename argument. This is not particularly useful compared to passing a filename argument, but it serves to demonstrate using a file as a source of standard input. Other commands make better use of standard input, as we shall soon see.</p><p>使用“&lt;”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.tx。我们看到结果 和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，不是特别有意义， 但它是用来说明把一个文件作为标准输入源。有其他的命令更好地利用了标准输入，我们不久将会看到。</p><p>Before we move on, check out the man page for cat, as it has several interesting options.</p><p>在我们继续之前，查看 cat 的手册页，因为它有几个有趣的选项。</p><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><p>The ability of commands to read data from standard input and send to standard output is utilized by a shell feature called pipelines. Using the pipe operator “|” (vertical bar), the standard output of one command can be piped into the standard input of another:</p><p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：</p><pre><code>command1 | command2</code></pre><p>To fully demonstrate this, we are going to need some commands. Remember how we said there was one we already knew that accepts standard input? It’s less. We can use less to display, page-by-page, the output of any command that sends its results to standard output:</p><p>为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个 命令接受标准输入？它是 less 命令。我们用 less 来一页一页地显示任何命令的输出，命令把 它的运行结果输送到标准输出：</p><pre><code>[me@linuxbox ~]$ ls -l /usr/bin | less</code></pre><p>This is extremely handy! Using this technique, we can conveniently examine the output of any command that produces standard output.</p><p>这极其方便！使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Pipelines are often used to perform complex operations on data. It is possible to put several commands together into a pipeline. Frequently, the commands used this way are referred to as filters. Filters take input, change it somehow and then output it. The first one we will try is sort. Imagine we wanted to make a combined list of all of the executable programs in /bin and /usr/bin, put them in sorted order and view it:</p><p>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：</p><pre><code>[me@linuxbox ~]$ ls /bin /usr/bin | sort | less</code></pre><p>Since we specified two directories (/bin and /usr/bin), the output of ls would have consisted of two sorted lists, one for each directory. By including sort in our pipeline, we changed the data to produce a single, sorted list.</p><p>因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。</p><h3 id="uniq-报道或忽略重复行"><a href="#uniq-报道或忽略重复行" class="headerlink" title="uniq - 报道或忽略重复行"></a>uniq - 报道或忽略重复行</h3><p>The uniq command is often used in conjunction with sort. uniq accepts a sorted list of data from either standard input or a single filename argument (see the uniq man page for details) and, by default, removes any duplicates from the list. So, to make sure our list has no duplicates (that is, any programs of the same name that appear in both the /bin and /usr/bin directories) we will add uniq to our pipeline:</p><p>uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序 列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信 我们的列表中不包含重复句子（这是说，出现在目录/bin 和/usr/bin 中重名的程序），我们添加 uniq 到我们的管道线中：</p><pre><code>[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less</code></pre><p>In this example, we use uniq to remove any duplicates from the output of the sort command. If we want to see the list of duplicates instead, we add the “-d” option to uniq like so:</p><p>在这个例子中，我们使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项，就像这样：</p><pre><code>[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less</code></pre><h3 id="wc-－-打印行数、字数和字节数"><a href="#wc-－-打印行数、字数和字节数" class="headerlink" title="wc － 打印行数、字数和字节数"></a>wc － 打印行数、字数和字节数</h3><p>The wc (word count) command is used to display the number of lines, words, and bytes contained in files. For example:</p><p>wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。例如：</p><pre><code>[me@linuxbox ~]$ wc ls-output.txt7902 64566 503634 ls-output.txt</code></pre><p>In this case it prints out three numbers: lines, words, and bytes contained in ls- output.txt. Like our previous commands, if executed without command line arguments, wc accepts standard input. The “-l” option limits its output to only report lines. Adding it to a pipeline is a handy way to count things. To see the number of programs we have in our sorted list, we can do this:</p><p>在这个例子中，wc 打印出来三个数字：包含在文件 ls-output.txt 中的行数，单词数和字节数， 正如我们先前的命令，如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：</p><pre><code>[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l2728</code></pre><h3 id="grep-－-打印匹配行"><a href="#grep-－-打印匹配行" class="headerlink" title="grep － 打印匹配行"></a>grep － 打印匹配行</h3><p>grep is a powerful program used to find text patterns within files. It’s used like this:</p><p>grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：</p><pre><code>grep pattern [file...]</code></pre><p>When grep encounters a “pattern” in the file, it prints out the lines containing it. The patterns that grep can match can be very complex, but for now we will concentrate on simple text matches. We’ll cover the advanced patterns, called regular expressions in a later chapter.</p><p>当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。grep 能够匹配的模式可以 很复杂，但是现在我们把注意力集中在简单文本匹配上面。在后面的章节中，我们将会研究 高级模式，叫做正则表达式。</p><p>Let’s say we want to find all the files in our list of programs that had the word “zip” embedded in the name. Such a search might give us an idea of some of the programs on our system that had something to do with file compression. We would do this:</p><p>比如说，我们想在我们的程序列表中，找到文件名中包含单词”zip”的所有文件。这样一个搜索， 可能让我们了解系统中的一些程序与文件压缩有关系。这样做：</p><pre><code>[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zipbunzip2bzip2gunzip...</code></pre><p>There are a couple of handy options for grep: “-i” which causes grep to ignore case when performing the search (normally searches are case sensitive) and “-v” which tells grep to only print lines that do not match the pattern.</p><p>grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</p><h3 id="head-tail-－-打印文件开头部分-结尾部分"><a href="#head-tail-－-打印文件开头部分-结尾部分" class="headerlink" title="head / tail － 打印文件开头部分/结尾部分"></a>head / tail － 打印文件开头部分/结尾部分</h3><p>Sometimes you don’t want all of the output from a command. You may only want the first few lines or the last few lines. The head command prints the first ten lines of a file and the tail command prints the last ten lines. By default, both commands print ten lines of text, but this can be adjusted with the “-n” option:</p><p>有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。</p><pre><code>[me@linuxbox ~]$ head -n 5 ls-output.txttotal 343496...[me@linuxbox ~]$ tail -n 5 ls-output.txt...</code></pre><p>These can be used in pipelines as well:</p><p>它们也能用在管道线中：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | tail -n 5znew...</code></pre><p>tail has an option which allows you to view files in real-time. This is useful for watching the progress of log files as they are being written. In the following example, we will look at the messages file in /var/log. Superuser privileges are required to do this on some Linux distributions, since the /var/log/messages file may contain security information:</p><p>tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在 一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages 可能包含安全信息。</p><pre><code>[me@linuxbox ~]$ tail -f /var/log/messagesFeb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1....</code></pre><p>Using the “-f” option, tail continues to monitor the file and when new lines are appended, they immediately appear on the display. This continues until you type Ctrl-c.</p><p>使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</p><h3 id="tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件"><a href="#tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件" class="headerlink" title="tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件"></a>tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件</h3><p>In keeping with our plumbing metaphor, Linux provides a command called tee which creates a “tee” fitting on our pipe. The tee program reads standard input and copies it to both standard output (allowing the data to continue down the pipeline) and to one or more files. This is useful for capturing a pipeline’s contents at an intermediate stage of processing. Here we repeat one of our earlier examples, this time including tee to capture the entire directory listing to the file ls.txt before grep filters the pipeline’s contents:</p><p>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：</p><pre><code>[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zipbunzip2bzip2....</code></pre><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><p>As always, check out the documentation of each of the commands we have covered in this chapter. We have only seen their most basic usage. They all have a number of interesting options. As we gain Linux experience, we will see that the redirection feature of the command line is extremely useful for solving specialized problems. There are many commands that make use of standard input and output, and almost all command line programs use standard error to display their informative messages.</p><p>一如既往，查看这章学到的每一个命令的文档。我们已经知道了他们最基本的用法。 它们还有很多有趣的选项。随着我们 Linux 经验的积累，我们会了解命令行重定向特性 在解决特殊问题时非常有用处。有许多命令利用标准输入和输出，而几乎所有的命令行 程序都使用标准错误来显示它们的详细信息。</p><blockquote><p>Linux Is About Imagination</p><p>Linux 可以激发我们的想象</p><p>When I am asked to explain the difference between Windows and Linux, I often use a toy analogy.</p><p>当我被要求解释 Windows 与 Linux 之间的差异时，我经常拿玩具来作比喻。</p><p>Windows is like a Game Boy. You go to the store and buy one all shiny new in the box. You take it home, turn it on and play with it. Pretty graphics, cute sounds. After a while though, you get tired of the game that came with it so you go back to the store and buy another one. This cycle repeats over and over. Finally, you go back to the store and say to the person behind the counter, “I want a game that does this!” only to be told that no such game exists because there is no “market demand” for it. Then you say, “But I only need to change this one thing!” The person behind the counter says you can’t change it. The games are all sealed up in their cartridges. You discover that your toy is limited to the games that others have decided that you need and no more.</p><p>Windows 就像一个游戏机。你去商店，买了一个包装在盒子里面的全新的游戏机。 你把它带回家，打开盒子，开始玩游戏。精美的画面，动人的声音。玩了一段时间之后， 你厌倦了它自带的游戏，所以你返回商店，又买了另一个游戏机。这个过程反复重复。 最后，你玩腻了游戏机自带的游戏，你回到商店，告诉售货员，“我想要一个这样的游戏！” 但售货员告诉你没有这样的游戏存在，因为它没有“市场需求”。然后你说，“但是我只 需要修改一下这个游戏！“，售货员又告诉你不能修改它。所有游戏都被封装在它们的 存储器中。到头来，你发现你的玩具只局限于别人为你规定好的游戏。</p><p>Linux, on the other hand, is like the world’s largest Erector Set. You open it up and it’s just a huge collection of parts. A lot of steel struts, screws, nuts, gears, pulleys, motors, and a few suggestions on what to build. So you start to play with it. You build one of the suggestions and then another. After a while you discover that you have your own ideas of what to make. You don’t ever have to go back to the store, as you already have everything you need. The Erector Set takes on the shape of your imagination. It does what you want.</p><p>另一方面，Linux 就像一个全世界上最大的建造模型。你打开它，发现它只是一个巨大的 部件集合。有许多钢支柱、螺钉、螺母、齿轮、滑轮、发动机和一些怎样来建造它的说明书。 然后你开始摆弄它。你建造了一个又一个样板模型。过了一会儿，你发现你要建造自己的模型。 你不必返回商店，因为你已经拥有了你需要的一切。建造模型以你构想的形状为模板，搭建 你想要的模型。</p><p>Your choice of toys is, of course, a personal thing, so which toy would you find more satisfying?</p><p>当然，选择哪一个玩具，是你的事情，那么你觉得哪个玩具更令人满意呢？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六章 使用命令</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Up to this point, we have seen a series of mysterious commands, each with its own mysterious options and arguments. In this chapter, we will attempt to remove some of that mystery and even create some of our own commands. The commands introduced in this chapter are:</p><p>在这之前，我们已经知道了一系列神秘的命令，每个命令都有自己奇妙的 选项和参数。在这一章中，我们将试图去掉一些神秘性，甚至创建我们自己 的命令。这一章将介绍以下命令：</p><ul><li>type – Indicate how a command name is interpreted</li><li>type – 说明怎样解释一个命令名</li><li>which – Display which executable program will be executed</li><li>which – 显示会执行哪个可执行程序</li><li>man – Display a command’s manual page</li><li>man – 显示命令手册页</li><li>apropos – Display a list of appropriate commands</li><li>apropos – 显示一系列适合的命令</li><li>info – Display a command’s info entry</li><li>info – 显示命令 info</li><li>whatis – Display a very brief description of a command</li><li>whatis – 显示一个命令的简洁描述</li><li>alias – Create an alias for a command</li><li>alias – 创建命令别名</li></ul><h3 id="到底什么是命令？"><a href="#到底什么是命令？" class="headerlink" title="到底什么是命令？"></a>到底什么是命令？</h3><p>A command can be one of four different things:</p><p>命令可以是下面四种形式之一：</p><ol><li>An executable program like all those files we saw in /usr/bin. Within this category, programs can be compiled binaries such as programs written in C and C++, or programs written in scripting languages such as the shell, perl, python, ruby, etc.</li><li>A command built into the shell itself. bash supports a number of commands internally called shell builtins. The cd command, for example, is a shell builtin.</li><li>A shell function. These are miniature shell scripts incorporated into the environment. We will cover configuring the environment and writing shell functions in later chapters, but for now, just be aware that they exist.</li><li>An alias. Commands that we can define ourselves, built from other commands.</li><li>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。</li><li>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。</li><li>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。</li><li>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</li></ol><h3 id="识别命令"><a href="#识别命令" class="headerlink" title="识别命令"></a>识别命令</h3><p>It is often useful to know exactly which of the four kinds of commands is being used and Linux provides a couple of ways to find out.</p><p>这经常很有用，能确切地知道正在使用四类命令中的哪一类。Linux 提供了一对方法来 弄明白命令类型。</p><h3 id="type-－-显示命令的类型"><a href="#type-－-显示命令的类型" class="headerlink" title="type － 显示命令的类型"></a>type － 显示命令的类型</h3><p>The type command is a shell builtin that displays the kind of command the shell will execute, given a particular command name. It works like this:</p><p>type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。 它像这样工作：</p><pre><code>type command</code></pre><p>Where “command” is the name of the command you want to examine. Here are some examples:</p><p>“command”是你要检测的命令名。这里有些例子：</p><pre><code>[me@linuxbox ~]$ type typetype is a shell builtins[me@linuxbox ~]$ type lsls is aliased to `ls --color=tty`[me@linuxbox ~]$ type cpcp is /bin/cp</code></pre><p>Here we see the results for three different commands. Notice that the one for ls (taken from a Fedora system) and how the ls command is actually an alias for the ls command with the “–color=tty” option added. Now we know why the output from ls is displayed in color!</p><p>我们看到这三个不同命令的检测结果。注意，ls 命令（在 Fedora 系统中）的检查结果，ls 命令实际上 是 ls 命令加上选项”–color=tty”的别名。现在我们知道为什么 ls 的输出结果是有颜色的！</p><h3 id="which-－-显示一个可执行程序的位置"><a href="#which-－-显示一个可执行程序的位置" class="headerlink" title="which － 显示一个可执行程序的位置"></a>which － 显示一个可执行程序的位置</h3><p>Sometimes there is more than one version of an executable program installed on a system. While this is not very common on desktop systems, it’s not unusual on large servers. To determine the exact location of a given executable, the which command is used:</p><p>有时候在一个操作系统中，不只安装了可执行程序的一个版本。虽然在桌面系统中这并不普遍， 但在大型服务器中却很平常。为了确定所给定的执行程序的准确位置，使用 which 命令：</p><pre><code>[me@linuxbox ~]$ which ls/bin/ls</code></pre><p>which only works for executable programs, not builtins nor aliases that are substitutes for actual executable programs. When we try to use which on a shell builtin, for example, cd, we either get no response or an error message:</p><p>这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物。 当我们试着使用 shell 内建命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：</p><pre><code>[me@linuxbox ~]$ which cd/usr/bin/which: no cd in(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)</code></pre><p>which is a fancy way of saying “command not found.”</p><p>说“命令没有找到”，真是很奇特。</p><h3 id="得到命令文档"><a href="#得到命令文档" class="headerlink" title="得到命令文档"></a>得到命令文档</h3><p>With this knowledge of what a command is, we can now search for the documentation available for each kind of command.</p><p>知道了什么是命令，现在我们来寻找每一类命令的可得到的文档。</p><h3 id="help-－-得到-shell-内建命令的帮助文档"><a href="#help-－-得到-shell-内建命令的帮助文档" class="headerlink" title="help － 得到 shell 内建命令的帮助文档"></a>help － 得到 shell 内建命令的帮助文档</h3><p>bash has a built-in help facility available for each of the shell builtins. To use it, type “help” followed by the name of the shell builtin. For example:</p><p>bash 有一个内建的帮助工具，可供每一个 shell 内建命令使用。输入“help”，接着是 shell 内部命令名。例如：</p><pre><code>[me@linuxbox ~]$ help cdcd: cd [-L|-P] [dir]Change ...</code></pre><p>A note on notation: When square brackets appear in the description of a command’s syntax, they indicate optional items. A vertical bar character indicates mutually exclusive items. In the case of the cd command above:</p><p>注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：</p><pre><code>cd [-L|-P] [dir]</code></pre><p>This notation says that the command cd may be followed optionally by either a “-L” or a “-P” and further, optionally followed by the argument “dir”.</p><p>这种表示法说明，cd 命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。</p><p>While the output of help for the cd commands is concise and accurate, it is by no means tutorial and as we can see, it also seems to mention a lot of things we haven’t talked about yet! Don’t worry. We’ll get there.</p><p>虽然 cd 命令的帮助文档很简洁准确，但它决不是教程。正如我们所看到的，它似乎提到了许多 我们还没有谈论到的东西！不要担心，我们会学到的。</p><h3 id="–help-显示用法信息"><a href="#–help-显示用法信息" class="headerlink" title="–help - 显示用法信息"></a>–help - 显示用法信息</h3><p>Many executable programs support a “–help” option that displays a description of the command’s supported syntax and options. For example:</p><p>许多可执行程序支持一个 –help 选项，这个选项是显示命令所支持的语法和选项说明。例如：</p><pre><code>[me@linuxbox ~]$ mkdir --helpUsage: mkdir [OPTION] DIRECTORY...Create ...</code></pre><p>Some programs don’t support the “–help” option, but try it anyway. Often it results in an error message that will reveal the same usage information.</p><p>一些程序不支持 –help 选项，但不管怎样试一下。这经常会导致输出错误信息，但同时能 揭示一样的命令用法信息。</p><h3 id="man-－-显示程序手册页"><a href="#man-－-显示程序手册页" class="headerlink" title="man － 显示程序手册页"></a>man － 显示程序手册页</h3><p>Most executable programs intended for command line use provide a formal piece of documentation called a manual or man page. A special paging program called man is used to view them. It is used like this:</p><p>许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页(man page)。一个特殊的叫做 man 的分页程序，可用来浏览他们。它是这样使用的：</p><pre><code>man program</code></pre><p>where “program” is the name of the command to view.</p><p>“program”是要浏览的命令名。</p><p>Man pages vary somewhat in format but generally contain a title, a synopsis of the command’s syntax, a description of the command’s purpose, and a listing and description of each of the command’s options. Man pages, however, do not usually include examples, and are intended as a reference, not a tutorial. As an example, let’s try viewing the man page for the ls command:</p><p>手册文档的格式有点不同，一般地包含一个标题、命令语法的纲要、命令用途的说明、 以及每个命令选项的列表和说明。然而，手册文档通常并不包含实例，它打算 作为一本参考手册，而不是教程。作为一个例子，浏览一下 ls 命令的手册文档：</p><pre><code>[me@linuxbox ~]$ man ls</code></pre><p>On most Linux systems, man uses less to display the manual page, so all of the familiar less commands work while displaying the page.</p><p>在大多数 Linux 系统中，man 使用 less 工具来显示参考手册，所以当浏览文档时，你所熟悉的 less 命令都能有效。</p><p>The “manual” that man displays is broken into sections and not only covers user commands but also system administration commands, programming interfaces, file formats and more. The table below describes the layout of the manual:</p><p>man 所显示的参考手册，被分成几个章节，它们不仅仅包括用户命令，也包括系统管理员 命令、程序接口、文件格式等等。下表描绘了手册的布局：</p><table><thead><tr><th align="left">Section</th><th align="left">Contents</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">User commands</td></tr><tr><td align="left">2</td><td align="left">Programming interfaces kernel system calls</td></tr><tr><td align="left">3</td><td align="left">Programming interfaces to the C library</td></tr><tr><td align="left">4</td><td align="left">Special files such as device nodes and drivers</td></tr><tr><td align="left">5</td><td align="left">File formats</td></tr><tr><td align="left">6</td><td align="left">Games and amusements such as screen savers</td></tr><tr><td align="left">7</td><td align="left">Miscellaneous</td></tr><tr><td align="left">8</td><td align="left">System administration commands</td></tr></tbody></table><table><thead><tr><th align="left">章节</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">用户命令</td></tr><tr><td align="left">2</td><td align="left">程序接口内核系统调用</td></tr><tr><td align="left">3</td><td align="left">C 库函数程序接口</td></tr><tr><td align="left">4</td><td align="left">特殊文件，比如说设备结点和驱动程序</td></tr><tr><td align="left">5</td><td align="left">文件格式</td></tr><tr><td align="left">6</td><td align="left">游戏娱乐，如屏幕保护程序</td></tr><tr><td align="left">7</td><td align="left">其他方面</td></tr><tr><td align="left">8</td><td align="left">系统管理员命令</td></tr></tbody></table><p>Sometimes we need to look in a specific section of the manual to find what we are looking for. This is particularly true if we are looking for a file format that is also the name of a command. Without specifying a section number, we will always get the first instance of a match, probably in section 1. To specify a section number, we use man like this:</p><p>有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息。 如果我们要查找一种文件格式，而同时它也是一个命令名时,这种情况尤其正确。 没有指定章节号，我们总是得到第一个匹配项，可能在第一章节。我们这样使用 man 命令， 来指定章节号：</p><pre><code>man section search_term</code></pre><p>For example:</p><p>例如：</p><pre><code>[me@linuxbox ~]$ man 5 passwd</code></pre><p>This will display the man page describing the file format of the /etc/passwd file.</p><p>命令运行结果会显示文件 /etc/passwd 的文件格式说明手册。</p><h3 id="apropos-－-显示适当的命令"><a href="#apropos-－-显示适当的命令" class="headerlink" title="apropos － 显示适当的命令"></a>apropos － 显示适当的命令</h3><p>It is also possible to search the list of man pages for possible matches based on a search term. It’s very crude but sometimes helpful. Here is an example of a search for man pages using the search term “floppy”:</p><p>也有可能搜索参考手册列表，基于某个关键字的匹配项。虽然很粗糙但有时很有用。 下面是一个以”floppy”为关键词来搜索参考手册的例子：</p><pre><code>[me@linuxbox ~]$ apropos floppycreate_floppy_devices (8)   - udev callout to create all possible...</code></pre><p>The first field in each line of output is the name of the man page, the second field shows the section. Note that the man command with the “-k” option performs the exact same function as apropos.</p><p>输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man 命令加上”-k”选项， 和 apropos 完成一样的功能。</p><h3 id="whatis-－-显示非常简洁的命令说明"><a href="#whatis-－-显示非常简洁的命令说明" class="headerlink" title="whatis － 显示非常简洁的命令说明"></a>whatis － 显示非常简洁的命令说明</h3><p>The whatis program displays the name and a one line description of a man page matching a specified keyword:</p><p>whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明：</p><blockquote><p>The Most Brutal Man Page Of Them All</p><p>最晦涩难懂的手册页</p><p>As we have seen, the manual pages supplied with Linux and other Unix-like systems are intended as reference documentation and not as tutorials. Many man pages are hard to read, but I think that the grand prize for difficulty has got to go to the man page for bash. As I was doing my research for this book, I gave it careful review to ensure that I was covering most of its topics. When printed, it’s over eighty pages long and extremely dense, and its structure makes absolutely no sense to a new user.</p><p>正如我们所看到的，Linux 和类 Unix 的系统提供的手册页，只是打算作为参考手册使用， 而不是教程。许多手册页都很难阅读，但是我认为由于阅读难度而能拿到特等奖的手册页应该是 bash 手册页。因为我正在为这本书做我的研究，所以我很仔细地浏览了整个 bash 手册，为的是确保我讲述了 大部分的 bash 主题。当把 bash 参考手册整个打印出来，其篇幅有八十多页且内容极其紧密， 但对于初学者来说，其结构安排毫无意义。</p><p>On the other hand, it is very accurate and concise, as well as being extremely complete. So check it out if you dare and look forward to the day when you can read it and it all makes sense.</p><p>另一方面，bash 参考手册的内容非常简明精确，同时也非常完善。所以，如果你有胆量就查看一下， 并且期望有一天你能读懂它。</p></blockquote><h3 id="info-－-显示程序-Info-条目"><a href="#info-－-显示程序-Info-条目" class="headerlink" title="info － 显示程序 Info 条目"></a>info － 显示程序 Info 条目</h3><p>The GNU Project provides an alternative to man pages for their programs, called “info.” Info pages are displayed with a reader program named, appropriately enough, info. Info pages are hyperlinked much like web pages. Here is a sample:</p><p>GNU 项目提供了一个命令程序手册页的替代物，称为”info”。info 内容可通过 info 阅读器 程序读取。info 页是超级链接形式的，和网页很相似。这有个例子：</p><pre><code>File: coreutils.info,    Node: ls invocation,    Next: dir invocation, Up: Directory listing10.1 `ls&#39;: List directory contents==================================...</code></pre><p>The info program reads info files, which are tree structured into individual nodes, each containing a single topic. Info files contain hyperlinks that can move you from node to node. A hyperlink can be identified by its leading asterisk, and is activated by placing the cursor upon it and pressing the enter key.</p><p>info 程序读取 info 文件，info 文件是树型结构，分化为各个结点，每一个包含一个题目。 info 文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过 它开头的星号来辨别出来，把光标放在它上面并按下 enter 键，就可以激活它。</p><p>To invoke info, type “info” followed optionally by the name of a program. Below is a table of commands used to control the reader while displaying an info page:</p><p>输入”info”，接着输入程序名称，启动 info。下表中的命令，当显示一个 info 页面时， 用来控制阅读器。</p><table><thead><tr><th align="left">Command</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">?</td><td align="left">Display command help</td></tr><tr><td align="left">PgUp or Backspace</td><td align="left">Display privious page</td></tr><tr><td align="left">PgDn or Space</td><td align="left">Display next page</td></tr><tr><td align="left">n</td><td align="left">Next - Display the next node</td></tr><tr><td align="left">p</td><td align="left">Previous - Display the previous node</td></tr><tr><td align="left">u</td><td align="left">Up - Display the parent node of the currently displayed node, usually a menu.</td></tr><tr><td align="left">Enter</td><td align="left">Follow the hyperlink at the cursor location</td></tr><tr><td align="left">q</td><td align="left">Quit</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">?</td><td align="left">显示命令帮助</td></tr><tr><td align="left">PgUp or Backspace</td><td align="left">显示上一页</td></tr><tr><td align="left">PgDn or Space</td><td align="left">显示下一页</td></tr><tr><td align="left">n</td><td align="left">下一个 - 显示下一个结点</td></tr><tr><td align="left">p</td><td align="left">上一个 - 显示上一个结点</td></tr><tr><td align="left">u</td><td align="left">Up - 显示当前所显示结点的父结点，通常是个菜单</td></tr><tr><td align="left">Enter</td><td align="left">激活光标位置下的超级链接</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr></tbody></table><p>Most of the command line programs we have discussed so far are part of the GNU Project’s “coreutils” package, so typing:</p><p>到目前为止，我们所讨论的大多数命令行程序，属于 GNU 项目”coreutils”包，所以输入：</p><pre><code>[me@linuxbox ~]$ info coreutils</code></pre><p>will display a menu page with hyperlinks to each program contained in the coreutils package.</p><p>将会显示一个包含超级链接的手册页，这些超级链接指向包含在 coreutils 包中的各个程序。</p><h3 id="README-和其它程序文档"><a href="#README-和其它程序文档" class="headerlink" title="README 和其它程序文档"></a>README 和其它程序文档</h3><p>Many software packages installed on your system have documentation files residing in the /usr/share/doc directory. Most of these are stored in plain text format and can be viewed with less. Some of the files are in HTML format and can be viewed with a web browser. We may encounter some files ending with a “.gz” extension. This indicates that they have been compressed with the gzip compression program. The gzip package includes a special version of less called zless that will display the contents of gzip-compressed text files.</p><p>许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc 目录下。 这些文件大多数是以文本文件的形式存储的，可用 less 阅读器来浏览。一些文件是 HTML 格式， 可用网页浏览器来阅读。我们可能遇到许多以”.gz”结尾的文件。这表示 gzip 压缩程序 已经压缩了这些文件。gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩的文本文件的内容。</p><h3 id="用别名（alias）创建你自己的命令"><a href="#用别名（alias）创建你自己的命令" class="headerlink" title="用别名（alias）创建你自己的命令"></a>用别名（alias）创建你自己的命令</h3><p>Now for our very first experience with programming! We will create a command of our own using the alias command. But before we start, we need to reveal a small command line trick. It’s possible to put more than one command on a line by separating each command with a semicolon character. It works like this:</p><p>现在是时候，感受第一次编程经历了！我们将用 alias 命令创建我们自己的命令。但在 开始之前，我们需要展示一个命令行小技巧。可以把多个命令放在同一行上，命令之间 用”;”分开。它像这样工作：</p><pre><code>command1; command2; command3...</code></pre><p>Here’s the example we will use:</p><p>我们会用到下面的例子：</p><pre><code>[me@linuxbox ~]$ cd /usr; ls; cd -bin  games    kerberos  lib64    local  share  tmp...[me@linuxbox ~]$</code></pre><p>As we can see, we have combined three commands on one line. First we change directory to /usr then list the directory and finally return to the original directory (by using ‘cd -‘) so we end up where we started. Now let’s turn this sequence into a new command using alias. The first thing we have to do is dream up a name for our new command. Let’s try “test”. Before we do that, it would be a good idea to find out if the name “test” is already being used. To find out, we can use the type command again:</p><p>正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录 内容，最后回到原始目录（用命令”cd -“）,结束在开始的地方。现在，通过 alias 命令 把这一串命令转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。 比方说”test”。在使用”test”之前，查明是否”test”命令名已经存在系统中，是个很不错 的主意。为了查清此事，可以使用 type 命令：</p><pre><code>[me@linuxbox ~]$ type testtest is a shell builtin</code></pre><p>Oops! The name “test” is already taken. Let’s try “foo”:</p><p>哦！”test”名字已经被使用了。试一下”foo”:</p><pre><code>[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p>Great! “foo” is not taken. So let’s create our alias:</p><p>太棒了！”foo”还没被占用。创建命令别名：</p><pre><code>[me@linuxbox ~]$ alias foo=&#39;cd /usr; ls; cd -&#39;</code></pre><p>Notice the structure of this command:</p><p>注意命令结构：</p><pre><code>alias name=&#39;string&#39;</code></pre><p>After the command “alias” we give alias a name followed immediately (no whitespace allowed) by an equals sign, followed immediately by a quoted string containing the meaning to be assigned to the name. After we define our alias, it can be used anywhere the shell would expect a command. Let’s try it:</p><p>在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。试一下：</p><pre><code>[me@linuxbox ~]$ foobin   games   kerberos  lib64    local   share  tmp...[me@linuxbox ~]$</code></pre><p>We can also use the type command again to see our alias:</p><p>我们也可以使用 type 命令来查看我们的别名：</p><pre><code>[me@linuxbox ~]$ type foofoo is aliased to `cd /usr; ls ; cd -&#39;</code></pre><p>To remove an alias, the unalias command is used, like so:</p><p>删除别名，使用 unalias 命令，像这样：</p><pre><code>[me@linuxbox ~]$ unalias foo[me@linuxbox ~]$ type foobash: type: foo: not found</code></pre><p>While we purposefully avoided naming our alias with an existing command name, it is not uncommon to do so. This is often done to apply a commonly desired option to each invocation of a common command. For instance, we saw earlier how the ls command is often aliased to add color support:</p><p>虽然我们有意避免使用已经存在的命令名来命名我们的别名，但这是常做的事情。通常， 会把一个普遍用到的选项加到一个经常使用的命令后面。例如，之前见到的 ls 命令，会 带有色彩支持：</p><pre><code>[me@linuxbox ~]$ type lsls is aliased to &#39;ls --color=tty&#39;</code></pre><p>To see all the aliases defined in the environment, use the alias command without arguments. Here are some of the aliases defined by default on a Fedora system. Try and figure out what they all do:</p><p>要查看所有定义在系统环境中的别名，使用不带参数的 alias 命令。下面在 Fedora 系统中 默认定义的别名。试着弄明白，它们是做什么的：</p><pre><code>[me@linuxbox ~]$ aliasalias l.=&#39;ls -d .* --color=tty&#39;...</code></pre><p>There is one tiny problem with defining aliases on the command line. They vanish when your shell session ends. In a later chapter, we will see how to add our own aliases to the files that establish the environment each time we log on, but for now, enjoy the fact that we have taken our first, albeit tiny, step into the world of shell programming!</p><p>在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失。随后的章节里， 我们会了解怎样把自己的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。 现在，好好享受我们刚经历过的，步入 shell 编程世界的第一步吧，虽然微小。</p><h3 id="拜访老朋友"><a href="#拜访老朋友" class="headerlink" title="拜访老朋友"></a>拜访老朋友</h3><p>Now that we have learned how to find the documentation for commands, go and look up the documentation for all the commands we have encountered so far. Study what additional options are available and try them out!</p><p>既然我们已经学习了怎样找到命令的帮助文档，那就试着查阅，到目前为止，我们学到的所有 命令的文档。学习命令其它可用的选项，练习一下！</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>There are many online sources of documentation for Linux and the command line. Here are some of the best:</p></li><li><p>在网上，有许多关于 Linux 和命令行的文档。以下是一些最好的文档：</p></li><li><p>The Bash Reference Manual is a reference guide to the bash shell. It’s still a reference work but contains examples and is easier to read than the bash man page.</p></li><li><p>Bash 参考手册是一本 bash shell 的参考指南。它仍然是一本参考书，但是包含了很多 实例，而且它比 bash 手册页容易阅读。</p><p><a href="http://www.gnu.org/software/bash/manual/bashref.html" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html</a></p></li><li><p>The Bash FAQ contains answers to frequently asked questions regarding bash. This list is aimed at intermediate to advanced users, but contains a lot of good information.</p></li><li><p>Bash FAQ 包含关于 bash，而经常提到的问题的答案。这个列表面向 bash 的中高级用户， 但它包含了许多有帮助的信息。</p><p><a href="http://mywiki.wooledge.org/BashFAQ" target="_blank" rel="noopener">http://mywiki.wooledge.org/BashFAQ</a></p></li><li><p>The GNU Project provides extensive documentation for its programs, which form the core of the Linux command line experience. You can see a complete list here:</p></li><li><p>GUN 项目为它的程序提供了大量的文档，这些文档组成了 Linux 命令行实验的核心。 这里你可以看到一个完整的列表：</p><p><a href="http://www.gnu.org/manual/manual.html" target="_blank" rel="noopener">http://www.gnu.org/manual/manual.html</a></p></li><li><p>Wikipedia has an interesting article on man pages:</p></li><li><p>Wikipedia 有一篇关于手册页的有趣文章：</p><p><a href="http://en.wikipedia.org/wiki/Man_page" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Man_page</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五章 操作文件和目录</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>At this point, we are ready for some real work! This chapter will introduce the following commands:</p><p>此时此刻，我们已经准备好了做些真正的工作！这一章节将会介绍以下命令：</p><ul><li>cp – Copy files and directories</li><li>mv – Move/rename files and directories</li><li>mkdir – Create directories</li><li>rm – Remove files and directories</li><li>ln – Create hard and symbolic links</li><li>cp — 复制文件和目录</li><li>mv — 移动/重命名文件和目录</li><li>mkdir — 创建目录</li><li>rm — 删除文件和目录</li><li>ln — 创建硬链接和符号链接</li></ul><p>These five commands are among the most frequently used Linux commands. They are used for manipulating both files and directories.</p><p>这五个命令属于最常使用的 Linux 命令之列。它们用来操作文件和目录。</p><p>Now, to be frank, some of the tasks performed by these commands are more easily done with a graphical file manager. With a file manager, we can drag and drop a file from one directory to another, cut and paste files, delete files, etc. So why use these old command line programs?</p><p>现在，坦诚地说，用图形文件管理器来完成一些由这些命令执行的任务会更容易些。使用文件管理器， 我们可以把文件从一个目录拖放到另一个目录、剪贴和粘贴文件、删除文件等等。那么， 为什么还使用早期的命令行程序呢？</p><p>The answer is power and flexibility. While it is easy to perform simple file manipulations with a graphical file manager, complicated tasks can be easier with the command line programs. For example, how could we copy all the HTML files from one directory to another, but only copy files that do not exist in the destination directory or are newer than the versions in the destination directory? Pretty hard with a file manager. Pretty easy with the command line:</p><p>答案是命令行程序，功能强大灵活。虽然图形文件管理器能轻松地实现简单的文件操作，但是对于 复杂的文件操作任务，则使用命令行程序比较容易完成。例如，怎样拷贝一个目录下所有的HTML文件 ——这些文件在目标目录不存在或者版本比目标目录的文件更新——到目标目录呢？ 要完成这个任务，使用文件管理器相当难，使用命令行相当容易：</p><pre><code>cp -u *.html destination</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>Before we begin using our commands, we need to talk about a shell feature that makes these commands so powerful. Since the shell uses filenames so much, it provides special characters to help you rapidly specify groups of filenames. These special characters are called wildcards. Using wildcards (which is also known as globbing) allow you to select filenames based on patterns of characters. The table below lists the wildcards and what they select:</p><p>在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell 特性。因为 shell 频繁地使用 文件名，shell 提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。 使用通配符（也以文件名代换著称）允许你依据字符的组合模式来选择文件名。下表列出这些通配符 以及它们所选择的对象：</p><table><thead><tr><th align="left">Wildcard</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">Matches any characters</td></tr><tr><td align="left">?</td><td align="left">Matches any single character</td></tr><tr><td align="left">[characters]</td><td align="left">Matches any character that is a member of the set characters</td></tr><tr><td align="left">[!characters]</td><td align="left">Matches any character that is not a member of the set characters</td></tr><tr><td align="left">[[:class:]]</td><td align="left">Matches any character that is a member of the specified class</td></tr></tbody></table><table><thead><tr><th align="left">通配符</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配任意多个字符（包括零个或一个）</td></tr><tr><td align="left">?</td><td align="left">匹配任意一个字符（不包括零个）</td></tr><tr><td align="left">[characters]</td><td align="left">匹配任意一个属于字符集中的字符</td></tr><tr><td align="left">[!characters]</td><td align="left">匹配任意一个不是字符集中的字符</td></tr><tr><td align="left">[[:class:]]</td><td align="left">匹配任意一个属于指定字符类中的字符</td></tr></tbody></table><p>Table 5-2 lists the most commonly used character classes:</p><p>表5-2列出了最常使用的字符类：</p><table><thead><tr><th align="left">Character Class</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">[:alnum:]</td><td align="left">Matches any alphanumeric character</td></tr><tr><td align="left">[:alpha:]</td><td align="left">Matches any alphabetic character</td></tr><tr><td align="left">[:digit:]</td><td align="left">Matches any numeral</td></tr><tr><td align="left">[:lower:]</td><td align="left">Matches any lowercase letter</td></tr><tr><td align="left">[:upper:]</td><td align="left">Matches any uppercase letter</td></tr></tbody></table><table><thead><tr><th align="left">字符类</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">[:alnum:]</td><td align="left">匹配任意一个字母或数字</td></tr><tr><td align="left">[:alpha:]</td><td align="left">匹配任意一个字母</td></tr><tr><td align="left">[:digit:]</td><td align="left">匹配任意一个数字</td></tr><tr><td align="left">[:lower:]</td><td align="left">匹配任意一个小写字母</td></tr><tr><td align="left">[:upper:]</td><td align="left">匹配任意一个大写字母</td></tr></tbody></table><p>Using wildcards makes it possible to construct very sophisticated selection criteria for filenames. Here are some examples of patterns and what they match:</p><p>借助通配符，为文件名构建非常复杂的选择标准成为可能。下面是一些类型匹配的范例:</p><table><thead><tr><th align="left">Pattern</th><th align="left">Matches</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">All files</td></tr><tr><td align="left">g*</td><td align="left">All file beginning with “g”</td></tr><tr><td align="left">b*.txt</td><td align="left">Any file beginning with “b” followed by any characters and ending with “.txt”</td></tr><tr><td align="left">Data???</td><td align="left">Any file beginning with “Data” followed by exactly three characters</td></tr><tr><td align="left">[abc]*</td><td align="left">Any file beginning with either an “a”, a “b”, or a “c”</td></tr><tr><td align="left">BACKUP.[0-9][0-9][0-9]</td><td align="left">Any file beginning with “BACKUP.” followed by exactly three numerals</td></tr><tr><td align="left">[[:upper:]]*</td><td align="left">Any file beginning with an uppercase letter</td></tr><tr><td align="left">[![:digit:]]*</td><td align="left">Any file not beginning with a numeral</td></tr><tr><td align="left">*[[:lower:]123]</td><td align="left">Any file ending with a lowercase letter or the numerals “1”, “2”, or “3”</td></tr></tbody></table><table><thead><tr><th align="left">模式</th><th align="left">匹配对象</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">所有文件</td></tr><tr><td align="left">g*</td><td align="left">文件名以“g”开头的文件</td></tr><tr><td align="left">b*.txt</td><td align="left">以”b”开头，中间有零个或任意多个字符，并以”.txt”结尾的文件</td></tr><tr><td align="left">Data???</td><td align="left">以“Data”开头，其后紧接着3个字符的文件</td></tr><tr><td align="left">[abc]*</td><td align="left">文件名以”a”,”b”,或”c”开头的文件</td></tr><tr><td align="left">BACKUP.[0-9][0-9][0-9]</td><td align="left">以”BACKUP.”开头，并紧接着3个数字的文件</td></tr><tr><td align="left">[[:upper:]]*</td><td align="left">以大写字母开头的文件</td></tr><tr><td align="left">[![:digit:]]*</td><td align="left">不以数字开头的文件</td></tr><tr><td align="left">*[[:lower:]123]</td><td align="left">文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</td></tr></tbody></table><p>Wildcards can be used with any command that accepts filenames as arguments, but we’ll talk more about that in Chapter 8.</p><p>接受文件名作为参数的任何命令，都可以使用通配符，我们会在第八章更深入地谈到这个知识点。</p><blockquote><p>Character Ranges</p><p>字符范围</p><p>If you are coming from another Unix-like environment or have been reading some other books on this subject, you may have encountered the [A-Z] or the [a-z] character range notations. These are traditional Unix notations and worked in older versions of Linux as well. They can still work, but you have to be very careful with them because they will not produce the expected results unless properly configured. For now, you should avoid using them and use character classes instead.</p><p>如果你用过别的类 Unix 系统的操作环境，或者是读过这方面的书籍，你可能遇到过[A-Z]或 [a-z]形式的字符范围表示法。这些都是传统的 Unix 表示法，并且在早期的 Linux 版本中仍有效。 虽然它们仍然起作用，但是你必须小心地使用它们，因为它们不会产生你期望的输出结果，除非 你合理地配置它们。从现在开始，你应该避免使用它们，并且用字符类来代替它们。</p><p>Wildcards Work In The GUI Too</p><p>通配符在 GUI 中也有效</p><p>Wildcards are especially valuable not only because they are used so frequently on the command line, but are also supported by some graphical file managers.</p><p>通配符非常重要，不仅因为它们经常用在命令行中，而且一些图形文件管理器也支持它们。</p><ul><li>In Nautilus (the file manager for GNOME), you can select files using the Edit/Select Pattern menu item. Just enter a file selection pattern with wildcards and the files in the currently viewed directory will be highlighted for selection.</li><li>In Dolphin and Konqueror (the file managers for KDE), you can enter wildcards directly on the location bar. For example, if you want to see all the files starting with a lowercase “u” in the /usr/bin directory, type “/usr/bin/u*” into the location bar and it will display the result.</li><li>在 Nautilus (GNOME 文件管理器）中，可以通过 Edit/Select 模式菜单项来选择文件。 输入一个用通配符表示的文件选择模式后，那么当前所浏览的目录中，所匹配的文件名就会高亮显示。</li><li>在 Dolphin 和 Konqueror（KDE 文件管理器）中，可以在地址栏中直接输入通配符。例如， 如果你想查看目录 /usr/bin 中，所有以小写字母 ‘u’ 开头的文件， 在地址栏中敲入 ‘/usr/bin/u*‘，则 文件管理器会显示匹配的结果。</li></ul><p>Many ideas originally found in the command line interface make their way into the graphical interface, too. It is one of the many things that make the Linux desktop so powerful.</p><p>最初源于命令行界面中的想法，在图形界面中也适用。这就是使 Linux 桌面系统 如此强大的众多原因中的一个</p></blockquote><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir - 创建目录"></a>mkdir - 创建目录</h3><p>The mkdir command is used to create directories. It works like this:</p><p>mkdir 命令是用来创建目录的。它这样工作：</p><pre><code>mkdir directory...</code></pre><p><strong>A note on notation:</strong> When three periods follow an argument in the description of a command (as above), it means that the argument can be repeated, thus:</p><p><strong>注意表示法:</strong> 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，就像这样：</p><pre><code>mkdir dir1</code></pre><p>would create a single directory named “dir1”, while</p><p>会创建一个名为”dir1”的目录，而</p><pre><code>mkdir dir1 dir2 dir3</code></pre><p>would create three directokries named “dir1”, “dir2”, “dir3”.</p><p>会创建三个目录，名为 dir1, dir2, dir3。</p><h3 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp - 复制文件和目录"></a>cp - 复制文件和目录</h3><p>The cp command copies files or directories. It can be used two different ways:</p><p>cp 命令，复制文件或者目录。它有两种使用方法：</p><pre><code>cp item1 item2</code></pre><p>to copy the single file or directory “item1” to file or directory “item2” and:</p><p>复制单个文件或目录”item1”到文件或目录”item2”，和：</p><pre><code>cp item... directory</code></pre><p>to copy multiple items (either files or directories) into a directory.</p><p>复制多个项目（文件或目录）到一个目录下。</p><h3 id="有用的选项和实例"><a href="#有用的选项和实例" class="headerlink" title="有用的选项和实例"></a>有用的选项和实例</h3><p>Here are some of the commonly used options (the short option and the equivalent long option) for cp:</p><p>这里列举了 cp 命令一些有用的选项（短选项和等效的长选项）：</p><table><thead><tr><th align="left">Option</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-a, –archive</td><td align="left">Copy the files and directories and all of their attributes, including ownerships and permissions. Normally, copies take on the default attributes of the user performing the copy</td></tr><tr><td align="left">-i, –interactive</td><td align="left">Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, cp will silently overwrite files.</td></tr><tr><td align="left">-r, –recursive</td><td align="left">Recursively copy directories and their contents. This option (or the -a option) is required when copying directories.</td></tr><tr><td align="left">-u, –update</td><td align="left">When copying files from one directory to another, only copy files that either don’t exist, or are newer than the existing corresponding files, in the destination directory.</td></tr><tr><td align="left">-v, –verbose</td><td align="left">Display informative messages as the copy is performed.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">-a, –archive</td><td align="left">复制文件和目录，以及它们的属性，包括所有权和权限。 通常，副本具有用户所操作文件的默认属性。</td></tr><tr><td align="left">-i, –interactive</td><td align="left">在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</td></tr><tr><td align="left">-r, –recursive</td><td align="left">递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</td></tr><tr><td align="left">-u, –update</td><td align="left">当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td></tr><tr><td align="left">-v, –verbose</td><td align="left">显示翔实的命令操作信息</td></tr></tbody></table><table><thead><tr><th align="left">Command</th><th align="left">Results</th></tr></thead><tbody><tr><td align="left">cp file1 file2</td><td align="left">Copy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created.</td></tr><tr><td align="left">cp -i file1 file2</td><td align="left">Same as above, except that if file2 exists, the user is prompted before it is overwritten.</td></tr><tr><td align="left">cp file1 file2 dir1</td><td align="left">Copy file1 and file2 into directory dir1. dir1 must already exist.</td></tr><tr><td align="left">cp dir1/* dir2</td><td align="left">Using a wildcard, all the files in dir1 are copied into dir2. dir2 must already exist.</td></tr><tr><td align="left">cp -r dir1 dir2</td><td align="left">Copy the contents of directory dir1 to directory dir2. If directory dir2 does not exist, it is created and, after the copy, will contain the same contents as directory dir1. If directory dir2 does exist, then directory dir1 (and its contents) will be copied into dir2.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">cp file1 file2</td><td align="left">复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。</td></tr><tr><td align="left">cp -i file1 file2</td><td align="left">这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。</td></tr><tr><td align="left">cp file1 file2 dir1</td><td align="left">复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。</td></tr><tr><td align="left">cp dir1/* dir2</td><td align="left">使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。</td></tr><tr><td align="left">cp -r dir1 dir2</td><td align="left">复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。</td></tr></tbody></table><h3 id="mv-移动和重命名文件"><a href="#mv-移动和重命名文件" class="headerlink" title="mv - 移动和重命名文件"></a>mv - 移动和重命名文件</h3><p>The mv command performs both file moving and file renaming, depending on how it is used. In either case, the original filename no longer exists after the operation. mv is used in much the same way as cp:</p><p>mv 命令可以执行文件移动和文件命名任务，这依赖于你怎样使用它。任何一种 情况下，完成操作之后，原来的文件名不再存在。mv 使用方法与 cp 很相像：</p><pre><code>mv item1 item2</code></pre><p>to move or rename file or directory “item1” to “item2” or:</p><p>把文件或目录 “item1” 移动或重命名为 “item2”, 或者：</p><pre><code>mv item... directory</code></pre><p>to move one or more items from one directory to another.</p><p>把一个或多个条目从一个目录移动到另一个目录中。</p><h3 id="有用的选项和实例-1"><a href="#有用的选项和实例-1" class="headerlink" title="有用的选项和实例"></a>有用的选项和实例</h3><p>mv shares many of the same options as cp:</p><p>mv 与 cp 共享了很多一样的选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-i –interactive</td><td align="left">Before overwriting an existing file, prompt the user for confirmation. <strong>If this option is not specified, mv command will silently overwrite files</strong></td></tr><tr><td align="left">-u –update</td><td align="left">When moving files from one directory to another, only move files that either don’t exist, or are newer than the existing corresponding files in the destination directory.</td></tr><tr><td align="left">-v –verbose</td><td align="left">Display informative messages as the move is performed.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">-i –interactive</td><td align="left">在重写一个已经存在的文件之前，提示用户确认信息。 <strong>如果不指定这个选项，mv 命令会默认重写文件内容。</strong></td></tr><tr><td align="left">-u –update</td><td align="left">当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</td></tr><tr><td align="left">-v –verbose</td><td align="left">当操作 mv 命令时，显示翔实的操作信息。</td></tr></tbody></table><table><thead><tr><th>mv file1 file2</th><th>Move file1 to file2. <strong>If file2 exists, it is overwritten with the contents of files.</strong> If file2 does not exist, it is created. <strong>In either case, file1 ceases to exist.</strong></th></tr></thead><tbody><tr><td>mv -i file1 file2</td><td>Same as above, except that if file2 exists, the user is prompted before it is overwritten.</td></tr><tr><td>mv file1 file2 dir1</td><td>Move file1 and file2 into dirctory dir1. dir1 must already exist.</td></tr><tr><td>mv dir1 dir2</td><td>if directory dir2 does not exist, create directory dir2 and move the contents of directory dir1 into dir2 and delete directory dir1. if directory dir2 does exist, move directory dir1 (and its contents) into directory dir2.</td></tr></tbody></table><table><thead><tr><th>mv file1 file2</th><th>移动 file1 到 file2。<strong>如果 file2 存在，它的内容会被 file1 的内容重写。</strong> 如果 file2 不存在，则创建 file2。 <strong>这两种情况下，file1 都不再存在。</strong></th></tr></thead><tbody><tr><td>mv -i file1 file2</td><td>除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。</td></tr><tr><td>mv file1 file2 dir1</td><td>移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。</td></tr><tr><td>mv dir1 dir2</td><td>如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。</td></tr></tbody></table><h3 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm - 删除文件和目录"></a>rm - 删除文件和目录</h3><p>The rm command is used to remove(delete)files and directories:</p><p>rm 命令用来移除（删除）文件和目录：</p><pre><code>rm item...</code></pre><p>where “item” is one or more files or directories.</p><p>“item”代表一个或多个文件或目录。</p><h3 id="有用的选项和实例-2"><a href="#有用的选项和实例-2" class="headerlink" title="有用的选项和实例"></a>有用的选项和实例</h3><p>Here are some of the common options for rm:</p><p>下表是一些普遍使用的 rm 选项：</p><table><thead><tr><th align="left">Option</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-i, –interactive</td><td align="left">Before deleting an existing file, prompt the user for confirmation. <strong>If this option is not specified, rm will silently delete files.</strong></td></tr><tr><td align="left">-r, –recursive</td><td align="left">Recursively delete directories. This means that if a directory being deleted has subdirectories, delete them too. To delete a directory, this option must be specified.</td></tr><tr><td align="left">-f, –force</td><td align="left">Ignore nonexistent files and do not prompt. This overrides the –interactive option.</td></tr><tr><td align="left">-v, –verbose</td><td align="left">Display informative messages as the deletion is performed.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">-i, –interactive</td><td align="left">在删除已存在的文件前，提示用户确认信息。 <strong>如果不指定这个选项，rm 会默默地删除文件</strong></td></tr><tr><td align="left">-r, –recursive</td><td align="left">递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td></tr><tr><td align="left">-f, –force</td><td align="left">忽视不存在的文件，不显示提示信息。这选项覆盖了“–interactive”选项。</td></tr><tr><td align="left">-v, –verbose</td><td align="left">在执行 rm 命令时，显示翔实的操作信息。</td></tr></tbody></table><table><thead><tr><th align="left">Command</th><th align="left">Results</th></tr></thead><tbody><tr><td align="left">rm file1</td><td align="left">Delete file1 silently</td></tr><tr><td align="left">rm -i file1</td><td align="left">Same as above, except that the user is prompted for confirmation before the deletion is performed.</td></tr><tr><td align="left">rm -r file1 dir1</td><td align="left">Delete file1 and dir1 and its contents.</td></tr><tr><td align="left">rm -rf file1 dir1</td><td align="left">Same as above, except that if either file1 or dir1 do not exist, rm will continue silently.</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">rm file1</td><td align="left">默默地删除文件</td></tr><tr><td align="left">rm -i file1</td><td align="left">除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。</td></tr><tr><td align="left">rm -r file1 dir1</td><td align="left">删除文件 file1, 目录 dir1，及 dir1 中的内容。</td></tr><tr><td align="left">rm -rf file1 dir1</td><td align="left">同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</td></tr></tbody></table><blockquote><p>Be Careful With rm!</p><p>小心 rm!</p><p>Unix-like operating systems such as Linux do not have an undelete command. Once you delete something with rm, it’s gone. Linux assumes you’re smart and you know what you’re doing.</p><p>类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。</p><p>Be particularly careful with wildcards. Consider this classic example. Let’s say you want to delete just the HTML files in a directory. To do this, you type:</p><p>尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录中的 HTML 文件。输入：</p><p><em>rm \</em>.html*</p><p>which is correct, but if you accidentally place a space between the “*” and the “.html” like so:</p><p>这是正确的，如果你不小心在 “*” 和 “.html” 之间多输入了一个空格，就像这样：</p><p><em>rm \</em> .html*</p><p>the rm command will delete all the files in the directory and then complain that there is no file called “.html”.</p><p>这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做 “.html”。</p><p><em>Here is a useful tip.</em> Whenever you use wildcards with rm (besides carefully checking your typing!), test the wildcard first with ls. This will let you see the files that will be deleted. Then press the up arrow key to recall the command and replace the ls with rm.</p><p><em>小贴士。</em> 当你使用带有通配符的rm命令时（除了仔细检查输入的内容外）， 先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。</p></blockquote><h3 id="ln-—-创建链接"><a href="#ln-—-创建链接" class="headerlink" title="ln — 创建链接"></a>ln — 创建链接</h3><p>The ln command is used to create either hard or symbolic links. It is used in one of two ways:</p><p>ln 命令既可创建硬链接，也可以创建符号链接。可以用其中一种方法来使用它：</p><pre><code>ln file link</code></pre><p>to create a hard link, and:</p><p>创建硬链接，和：</p><pre><code>ln -s item link</code></pre><p>to create a symbolic link where “item” is either a file or a directory.</p><p>创建符号链接，”item” 可以是一个文件或是一个目录。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>Hard links are the original Unix way of creating links; symbolic links are more modern. By default, every file has a single hard link that gives the file its name. When we create a hard link, we create an additional directory entry for a file. Hard links have two important limitations:</p><p>与更加现代的符号链接相比，硬链接是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接， 这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。 硬链接有两个重要局限性：</p><ol><li>A hard link cannot reference a file outside its own file system. This means a link may not reference a file that is not on the same disk partition as the link itself.</li><li>A hard link may not reference a directory.</li><li>一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。</li><li>一个硬链接不能关联一个目录。</li></ol><p>A hard link is indistinguishable from the file itself. Unlike a symbolic link, when you list a directory containing a hard link you will see no special indication of the link. When a hard link is deleted, the link is removed but the contents of the file itself continue to exist (that is, its space is not deallocated) until all links to the file are deleted. It is important to be aware of hard links because you might encounter them from time to time, but modern practice prefers symbolic links, which we will cover next.</p><p>一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录 内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配）， 直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时 会遇到它们，但现在实际中更喜欢使用符号链接，下一步我们会讨论符号链接。</p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>Symbolic links were created to overcome the limitations of hard links. Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory. In this regard, they operate in much the same way as a Windows shortcut though of course, they predate the Windows feature by many years ;-)</p><p>创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面， 它们和 Windows 的快捷方式差不多，当然，符号链接早于 Windows 的快捷方式 很多年;-)</p><p>A file pointed to by a symbolic link, and the symbolic link itself are largely indistinguishable from one another. For example, if you write some something to the symbolic link, the referenced file is also written to. However when you delete a symbolic link, only the link is deleted, not the file itself. If the file is deleted before the symbolic link, the link will continue to exist, but will point to nothing. In this case, the link is said to be broken. In many implementations, the ls command will display broken links in a distinguishing color, such as red, to reveal their presence.</p><p>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。</p><p>The concept of links can seem very confusing, but hang in there. We’re going to try all this stuff and it will, hopefully, become clear.</p><p>关于链接的概念，看起来很迷惑，但不要胆怯。我们将要试着练习 这些命令，希望，它变得清晰起来。</p><h3 id="创建游戏场（实战演习）"><a href="#创建游戏场（实战演习）" class="headerlink" title="创建游戏场（实战演习）"></a>创建游戏场（实战演习）</h3><p>Since we are going to do some real file manipulation, let’s build a safe place to “play” with our file manipulation commands. First we need a directory to work in. We’ll create one in our home directory and call it “playground.”</p><p>下面我们将要做些真正的文件操作，让我们先建立一个安全地带， 来玩一下文件操作命令。首先，我们需要一个工作目录。在我们的 家目录下创建一个叫做“playground”的目录。</p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>The mkdir command is used to create a directory. To create our playground directory we will first make sure we are in our home directory and will then create the new directory:</p><p>mkdir 命令被用来创建目录。首先确定我们在我们的家目录下，然后创建 playground 目录：</p><pre><code>[me@linuxbox ~]$ cd[me@linuxbox ~]$ mkdir playground</code></pre><p>To make our playground a little more interesting, let’s create a couple of directories inside it called “dir1” and “dir2”. To do this, we will change our current working directory to playground and execute another mkdir:</p><p>为了让我们的游戏场更加有趣，在 playground 目录下创建一对目录 ，分别叫做 “dir1” 和 “dir2”。更改我们的当前工作目录到 playground，然后 执行 mkdir 命令：</p><pre><code>[me@linuxbox ~]$ cd playground[me@linuxbox playground]$ mkdir dir1 dir2</code></pre><p>Notice that the mkdir command will accept multiple arguments allowing us to create both directories with a single command.</p><p>注意到 mkdir 命令可以接受多个参数，它允许我们用一个命令来创建这两个目录。</p><p>###　复制文件</p><p>Next, let’s get some data into our playground. We’ll do this by copying a file. Using the cp command, we’ll copy the passwd file from the /etc directory to the current working directory:</p><p>下一步，让我们输入一些数据到我们的游戏场中。我们可以通过复制一个文件来实现目的。 我们使用 cp 命令从 /etc 目录复制 passwd 文件到当前工作目录下：</p><pre><code>[me@linuxbox playground]$ cp /etc/passwd .</code></pre><p>Notice how we used the shorthand for the current working directory, the single trailing period. So now if we perform an ls, we will see our file:</p><p>请注意，我们使用命令末尾的一个圆点来简化当前工作目录的写法。如果我们执行 ls 命令， 可以看到我们的文件：</p><pre><code>[me@linuxbox playground]$ ls -ltotal 12drwxrwxr-x 2  me  me   4096 2008-01-10 16:40 dir1drwxrwxr-x 2  me  me   4096 2008-01-10 16:40 dir2-rw-r--r-- 1  me  me   1650 2008-01-10 16:07 passwd</code></pre><p>Now, just for fun, let’s repeat the copy using the “-v” option (verbose) to see what it does:</p><p>现在，仅仅是为了高兴，重复操作复制命令，使用”-v”选项（详细），看看它做了些什么：</p><pre><code>[me@linuxbox playground]$ cp -v /etc/passwd .`/etc/passwd&#39; -&gt; `./passwd&#39;</code></pre><p>The cp command performed the copy again, but this time displayed a concise message indicating what operation it was performing. Notice that cp overwrote the first copy without any warning. Again this is a case of cp assuming that you know what you’re are doing. To get a warning, we’ll include the “-i” (interactive) option:</p><p>cp 命令再一次执行了复制操作，但是这次显示了一条简洁的信息，指明它 进行了什么操作。注意，cp 没有警告，就重写了第一次复制的文件。这是一个案例， cp 会假设你知道自己在做什么。如果希望得到警告的话，需要加入“-i”（互动）选项：</p><pre><code>[me@linuxbox playground]$ cp -i /etc/passwd .cp: overwrite `./passwd&#39;?</code></pre><p>Responding to the prompt by entering a “y” will cause the file to be overwritten, any other character (for example, “n”) will cause cp to leave the file alone.</p><p>在提示信息后输入”y”，文件就会被重写，输入其它的字符（例如，”n”） cp 命令会保留原文件。</p><h3 id="移动和重命名文件"><a href="#移动和重命名文件" class="headerlink" title="移动和重命名文件"></a>移动和重命名文件</h3><p>Now, the name “passwd” doesn’t seem very playful and this is a playground, so let’s change it to something else:</p><p>现在，”passwd” 这个名字，看起来不怎么有趣，这是个游戏场，所以我们给它改个名字：</p><pre><code>[me@linuxbox playground]$ mv passwd fun</code></pre><p>Let’s pass the fun around a little by moving our renamed file to each of the directories and back again:</p><p>让我们来传送 fun 文件，通过移动重命名的文件到各个子目录， 然后再把它移回到当前目录：</p><pre><code>[me@linuxbox playground]$ mv fun dir1</code></pre><p>to move it first to directory dir1, then:</p><p>首先，把 fun 文件移动目录 dir1 中，然后：</p><pre><code>[me@linuxbox playground]$ mv dir1/fun dir2</code></pre><p>to move it from dir1 to dir2, then:</p><p>再把 fun 文件从 dir1 移到目录 dir2, 然后：</p><pre><code>[me@linuxbox playground]$ mv dir2/fun .</code></pre><p>to finally bringing it back to the current working directory. Next, let’s see the effect of mv on directories. First we will move our data file into dir1 again:</p><p>最后，再把 fun 文件带回到当前工作目录。接下来，来看看移动目录的效果。 首先，我们先移动我们的数据文件到 dir1 目录：</p><pre><code>[me@linuxbox playground]$ mv fun dir1</code></pre><p>then move dir1 into dir2 and confirm it with ls:</p><p>然后移动 dir1到 dir2目录，用 ls 来确认执行结果:</p><pre><code>[me@linuxbox playground]$ mv dir1 dir2[me@linuxbox playground]$ ls -l dir2total 4drwxrwxr-x 2 me me 4096 2008-01-11 06:06 dir1[me@linuxbox playground]$ ls -l dir2/dir1total 4-rw-r--r-- 1 me me 1650 2008-01-10 16:33 fun</code></pre><p>Note that since dir2 already existed, mv moved dir1 into dir2. If dir2 had not existed, mv would have renamed dir1 to dir2. Lastly, let’s put everything back:</p><p>注意：因为目录 dir2 已经存在，mv 命令会把 dir1 移动到 dir2 目录中。如果 dir2 不存在， mv 会把dir1重命名为 dir2。最后，让我们把所有的东西放回原处：</p><pre><code>[me@linuxbox playground]$ mv dir2/dir1 .[me@linuxbox playground]$ mv dir1/fun .</code></pre><h3 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h3><p>Now we’ll try some links. First the hard links. We’ll create some links to our data file like so:</p><p>现在，我们试着创建链接。首先是硬链接。我们创建一些关联我们 数据文件的链接：</p><pre><code>[me@linuxbox playground]$ ln fun fun-hard[me@linuxbox playground]$ ln fun dir1/fun-hard[me@linuxbox playground]$ ln fun dir2/fun-hard</code></pre><p>So now we have four instances of the file “fun”. Let’s take a look our playground directory:</p><p>所以现在，我们有四个文件”fun”的实例。看一下目录 playground 中的内容：</p><pre><code>[me@linuxbox playground]$ ls -ltotal 16drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir1drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir2-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard</code></pre><p>One thing you notice is that the second field in the listing for fun and fun-hard both contain a “4” which is the number of hard links that now exist for the file. You’ll remember that a file will always have at least one because the file’s name is created by a link. So, how do we know that fun and fun-hard are, in fact, the same file? In this case, ls is not very helpful. While we can see that fun and fun-hard are both the same size (field 5), our listing provides no way to be sure. To solve this problem, we’re going to have to dig a little deeper.</p><p>注意到一件事，列表中，文件 fun 和 fun-hard 的第二个字段是”4”，这个数字 是文件”fun”的硬链接数目。你要记得一个文件至少有一个硬链接，因为文件 名就是由链接创建的。那么，我们怎样知道实际上 fun 和 fun-hard 是同一个文件呢？ 在这个例子里，ls 不是很有用。虽然我们能够看到 fun 和 fun-hard 文件大小一样 （第五字段），但我们的列表没有提供可靠的信息来确定（这两个文件一样）。 为了解决这个问题，我们更深入的研究一下。</p><p>When thinking about hard links, it is helpful to imagine that files are made up of two parts: the data part containing the file’s contents and the name part which holds the file’s name. When we create hard links, we are actually creating additional name parts that all refer to the same data part. The system assigns a chain of disk blocks to what is called an inode, which is then associated with the name part. Each hard link therefore refers to a specific inode containing the file’s contents.</p><p>当考虑到硬链接的时候，我们可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分 ，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分， 并且这些名字都关联到相同的数据部分。这时系统会分配一连串的磁盘块给所谓的索引节点，然后索引节点与文 件名字部分相关联。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。</p><p>The ls command has a way to reveal this information. It is invoked with the “-i” option:</p><p>ls 命令有一种方法，来展示（文件索引节点）的信息。在命令中加上”-i”选项：</p><pre><code>[me@linuxbox playground]$ ls -litotal 1612353539 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir112353540 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir212353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun-hard</code></pre><p>In this version of the listing, the first field is the inode number and, as we can see, both fun and fun-hard share the same inode number, which confirms they are the same file.</p><p>在这个版本的列表中，第一字段表示文件索引节点号，正如我们所见到的， fun 和 fun-hard 共享一样的索引节点号，这就证实这两个文件是同一个文件。</p><h3 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><p>Symbolic links were created to overcome the two disadvantages of hard links: hard links cannot span physical devices and hard links cannot reference directories, only files. Symbolic links are a special type of file that contains a text pointer to the target file or directory.</p><p>建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。</p><p>Creating symbolic links is similar to creating hard links:</p><p>符号链接的建立过程相似于创建硬链接：</p><pre><code>[me@linuxbox playground]$ ln -s fun fun-sym[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym</code></pre><p>The first example is pretty straightforward, we simply add the “-s” option to create a symbolic link rather than a hard link. But what about the next two? Remember, when we create a symbolic link, we are creating a text description of where the target file is relative to the symbolic link. It’s easier to see if we look at the ls output:</p><p>第一个例子相当直接，在 ln 命令中，简单地加上”-s”选项就可以创建一个符号链接， 而不是一个硬链接。下面两个例子又是怎样呢？ 记住，当我们创建一个符号链接 的时候，会建立一个目标文件在哪里和符号链接有关联的文本描述。如果我们看看 ls 命令的输出结果，比较容易理解。</p><pre><code>[me@linuxbox playground]$ ls -l dir1total 4-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hardlrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -&gt; ../fun</code></pre><p>The listing for fun-sym in dir1 shows that is it a symbolic link by the leading “l” in the first field and that it points to “../fun”, which is correct. Relative to the location of fun-sym, fun is in the directory above it. Notice too, that the length of the symbolic link file is 6, the number of characters in the string “../fun” rather than the length of the file to which it is pointing.</p><p>目录 dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符”l” 可知，并且它还指向”../fun”，也是正确的。相对于 fun-sym 的存储位置，fun 在它的 上一个目录。同时注意，符号链接文件的长度是6，这是字符串”../fun”所包含的字符数， 而不是符号链接所指向的文件长度。</p><p>When creating symbolic links, you can either use absolute pathnames:</p><p>当建立符号链接时，你既可以使用绝对路径名：</p><pre><code>ln -s /home/me/playground/fun dir1/fun-sym</code></pre><p>or relative pathnames, as we did in our earlier example. Using relative pathnames is more desirable because it allows a directory containing symbolic links to be renamed and/or moved without breaking the links.</p><p>也可用相对路径名，正如前面例题所展示的。使用相对路径名更令人满意， 因为它允许一个包含符号链接的目录重命名或移动，而不会破坏链接。</p><p>In addition to regular files, symbolic links can also reference directories:</p><p>除了普通文件，符号链接也能关联目录：</p><pre><code>[me@linuxbox playground]$ ln -s dir1 dir1-sym[me@linuxbox playground]$ ls -ltotal 16...省略</code></pre><h3 id="移动文件和目录"><a href="#移动文件和目录" class="headerlink" title="移动文件和目录"></a>移动文件和目录</h3><p>As we covered earlier, the rm command is used to delete files and directories. We are going to use it to clean up our playground a little bit. First, let’s delete one of our hard links:</p><p>正如我们之前讨论的，rm 命令被用来删除文件和目录。我们将要使用它 来清理一下我们的游戏场。首先，删除一个硬链接：</p><pre><code>[me@linuxbox playground]$ rm fun-hard[me@linuxbox playground]$ ls -ltotal 12...省略</code></pre><p>That worked as expected. The file fun-hard is gone and the link count shown for fun is reduced from four to three, as indicated in the second field of the directory listing. Next, we’ll delete the file fun, and just for enjoyment, we’ll include the “-i” option to show what that does:</p><p>结果不出所料。文件 fun-hard 消失了，文件 fun 的链接数从4减到3，正如 目录列表第二字段所示。下一步，我们会删除文件 fun，仅为了娱乐，我们会加入”-i” 选项，看一看它的作用：</p><pre><code>[me@linuxbox playground]$ rm -i funrm: remove regular file `fun&#39;?</code></pre><p>Enter “y” at the prompt and the file is deleted. But let’s look at the output of ls now. Noticed what happened to fun-sym? Since it’s a symbolic link pointing to a now- nonexistent file, the link is broken:</p><p>在提示符下输入”y”，删除文件。让我们看一下 ls 的输出结果。注意，fun-sym 发生了 什么事? 因为它是一个符号链接，指向已经不存在的文件，链接已经坏了：</p><pre><code>[me@linuxbox playground]$ ls -ltotal 8drwxrwxr-x 2 me  me     4096 2008-01-15 15:17 dir1lrwxrwxrwx 1 me  me        4 2008-01-16 14:45 dir1-sym -&gt; dir1drwxrwxr-x 2 me  me     4096 2008-01-15 15:17 dir2lrwxrwxrwx 1 me  me        3 2008-01-15 15:15 fun-sym -&gt; fun</code></pre><p>Most Linux distributions configure ls to display broken links. On a Fedora box, broken links are displayed in blinking red text! The presence of a broken link is not, in and of itself dangerous but it is rather messy. If we try to use a broken link we will see this:</p><p>大多数 Linux 的发行版本配置 ls 显示损坏的链接。在 Fedora 系统中，坏的链接以闪烁的 红色文本显示！损坏链接的出现，并不危险，但是相当混乱。如果我们试着使用 损坏的链接，会看到以下情况：</p><pre><code>[me@linuxbox playground]$ less fun-symfun-sym: No such file or directory</code></pre><p>Let’s clean up a little. We’ll delete the symbolic links:</p><p>稍微清理一下现场。删除符号链接：</p><pre><code>[me@linuxbox playground]$ rm fun-sym dir1-sym[me@linuxbox playground]$ ls -ltotal 8drwxrwxr-x 2 me  me    4096 2008-01-15 15:17 dir1drwxrwxr-x 2 me  me    4096 2008-01-15 15:17 dir2</code></pre><p>One thing to remember about symbolic links is that most file operations are carried out on the link’s target, not the link itself. rm is an exception. When you delete a link, it is the link that is deleted, not the target.</p><p>对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。</p><p>Finally, we will remove our playground. To do this, we will return to our home directory and use rm with the recursive option (-r) to delete playground and all of its contents, including its subdirectories:</p><p>最后，我们将删除我们的游戏场。为了完成这个工作，我们将返回到 我们的家目录，然后用 rm 命令加上选项(-r)，来删除目录 playground， 和目录下的所有内容，包括子目录：</p><pre><code>[me@linuxbox playground]$ cd[me@linuxbox ~]$ rm -r playground</code></pre><blockquote><p>Creating Symlinks With The GUI</p><p>用 GUI 来创建符号链接</p><p>The file managers in both GNOME and KDE provide an easy and automatic method of creating symbolic links. With GNOME, holding the Ctrl+Shift keys while dragging a file will create a link rather than copying (or moving) the file. In KDE, a small menu appears whenever a file is dropped, offering a choice of copying, moving, or linking the file.</p><p>文件管理器 GNOME 和 KDE 都提供了一个简单而且自动化的方法来创建符号链接。 在 GNOME 里面，当拖动文件时，同时按下 Ctrl+Shift 按键会创建一个链接，而不是 复制（或移动）文件。在 KDE 中，无论什么时候放下一个文件，会弹出一个小菜单， 这个菜单会提供复制，移动，或创建链接文件选项。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>We’ve covered a lot of ground here and it will take a while to fully sink in. Perform the playground exercise over and over until it makes sense. It is important to get a good understanding of basic file manipulation commands and wildcards. Feel free to expand on the playground exercise by adding more files and directories, using wildcards to specify files for various operations. The concept of links is a little confusing at first, but take the time to learn how they work. They can be a real lifesaver.</p><p>在这一章中，我们已经研究了许多基础知识。我们得花费一些时间来全面地理解。 反复练习 playground 例题，直到你觉得它有意义。能够良好地理解基本文件操作 命令和通配符，非常重要。随意通过添加文件和目录来拓展 playground 练习， 使用通配符来为各种各样的操作命令指定文件。关于链接的概念，在刚开始接触 时会觉得有点迷惑，花些时间来学习它们是怎样工作的。它们能成为真正的救星。</p>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四章 探究操作系统</title>
      <link href="/2019/07/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A2%E7%A9%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A2%E7%A9%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Now that we know how to move around the file system, it’s time for a guided tour of our Linux system. Before we start however, we’re going to learn some more commands that will be useful along the way:</p><p>既然我们已经知道了如何在文件系统中跳转，是时候开始 Linux 操作系统之旅了。然而在开始之前，我们先学习一些对研究 Linux 系统有帮助的命令。</p><ul><li>ls – List directory contents</li><li>file – Determine file type</li><li>less – View file contents</li><li>ls — 列出目录内容</li><li>file — 确定文件类型</li><li>less — 浏览文件内容</li></ul><h3 id="ls-乐趣"><a href="#ls-乐趣" class="headerlink" title="ls 乐趣"></a>ls 乐趣</h3><p>The ls command is probably the most used command, and for good reason. With it, we can see directory contents and determine a variety of important file and directory attributes. As we have seen, we can simply type ls to see a list of files and subdirectories contained in the current working directory:</p><p>ls 可能是用户最常使用的命令了，这自有它的道理。通过它，我们可以知道目录的内容，以及各种各样重要文件和目录的 属性。正如我们已经见到的，只要简单地输入 ls 就能看到在当前目录下所有文件和子目录的列表。</p><pre><code>[me@linuxbox ~]$ lsDesktop Documents Music Pictures Publica Templates Videos</code></pre><p>Besides the current working directory, we can specify the directory to list, like so:</p><p>除了当前工作目录以外，也可以指定别的目录，就像这样：</p><pre><code>me@linuxbox ~]$ ls /usrbin games   kerberos    libexec  sbin   srcetc include lib         local    share  tmp</code></pre><p>Or even specify multiple directories. In this example we will list both the user’s home directory (symbolized by the “~” character) and the /usr directory:</p><p>甚至可以列出多个指定目录的内容。在这个例子中，将会列出用户家目录（用字符“~”代表）和/usr 目录的内容：</p><pre><code>[me@linuxbox ~]$ ls ~ /usr/home/me:Desktop  Documents  Music  Pictures  Public  Templates  Videos/usr:bin  games      kerberos  libexec  sbin   srcetc  include    lib       local    share  tmp</code></pre><p>We can also change the format of the output to reveal more detail:</p><p>我们也可以改变输出格式，来得到更多的细节：</p><pre><code>[me@linuxbox ~]$ ls -ltotal 56drwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Desktopdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Documentsdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Musicdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Picturesdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Publicdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Templatesdrwxrwxr-x 2  me  me  4096  2007-10-26  17:20  Videos</code></pre><p>By adding “-l” to the command, we changed the output to the long format.</p><p>使用 ls 命令的“-l”选项，则结果以长模式输出。</p><h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数"></a>选项和参数</h3><p>This brings us to a very important point about how most commands work. Commands are often followed by one or more options that modify their behavior, and further, by one or more arguments, the items upon which the command acts. So most commands look kind of like this:</p><p>我们将学习一个非常重要的知识点，即大多数命令是如何工作的。命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。所以大多数命令看起来像这样：</p><pre><code>command -options arguments</code></pre><p>Most commands use options consisting of a single character preceded by a dash, for example, “-l”, but many commands, including those from the GNU Project, also support long options, consisting of a word preceded by two dashes. Also, many commands allow multiple short options to be strung together. In this example, the ls command is given two options, the “l” option to produce long format output, and the “t” option to sort the result by the file’s modification time.</p><p>大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然， 许多命令也允许把多个短选项串在一起使用。下面这个例子，ls 命令有两个选项， “l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。</p><pre><code>[me@linuxbox ~]$ ls -lt</code></pre><p>We’ll add the long option “–reverse” to reverse the order of the sort:</p><p>加上长选项 “–reverse”，则结果会以相反的顺序输出：</p><pre><code>[me@linuxbox ~]$ ls -lt --reverse</code></pre><p>The ls command has a large number of possible options. The most common are listed in the Table 4-1.</p><p>ls 命令有大量的选项。表4-1列出了最常使用的选项。</p><table><thead><tr><th align="left">Option</th><th align="left">Long Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">–all</td><td align="left">List all files, even those with names that begin with a period, which are normally not listed(i.e.,hidden).</td></tr><tr><td align="left">-d</td><td align="left">–directory</td><td align="left">Ordinaryly,if a directory is specified, ls will list the contents of the directory, not the directory itself. Use this option in conjunction with the -l option to see details about the directory rather than its contents.</td></tr><tr><td align="left">-F</td><td align="left">–classify</td><td align="left">This option will append an indicator character to the end of each listed name. For example, a ‘/‘ if the name is a directory.</td></tr><tr><td align="left">-h</td><td align="left">–human-readable</td><td align="left">In long format listings, display file sizes in human readable format rather than in bytes.</td></tr><tr><td align="left">-l</td><td align="left"></td><td align="left">Display results in long format.</td></tr><tr><td align="left">-r</td><td align="left">–reverse</td><td align="left">Display the results in reverse order. Normally, ls display its results in ascending alphabetical order.</td></tr><tr><td align="left">-S</td><td align="left"></td><td align="left">Sort results by file size.</td></tr><tr><td align="left">-t</td><td align="left"></td><td align="left">Sort by modification time.</td></tr></tbody></table><table><thead><tr><th align="left">选项</th><th align="left">长选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">–all</td><td align="left">列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。</td></tr><tr><td align="left">-d</td><td align="left">–directory</td><td align="left">通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</td></tr><tr><td align="left">-F</td><td align="left">–classify</td><td align="left">这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’/‘字符。</td></tr><tr><td align="left">-h</td><td align="left">–human-readable</td><td align="left">当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。</td></tr><tr><td align="left">-l</td><td align="left"></td><td align="left">以长格式显示结果。</td></tr><tr><td align="left">-r</td><td align="left">–reverse</td><td align="left">以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。</td></tr><tr><td align="left">-S</td><td align="left"></td><td align="left">命令输出结果按照文件大小来排序。</td></tr><tr><td align="left">-t</td><td align="left"></td><td align="left">按照修改时间来排序。</td></tr></tbody></table><h3 id="深入研究长格式输出"><a href="#深入研究长格式输出" class="headerlink" title="深入研究长格式输出"></a>深入研究长格式输出</h3><p>As we saw before, the “-l” option causes ls to display its results in long format. This format contains a great deal of useful information. Here is the Examples directory from an Ubuntu system:</p><p>正如我们先前知道的，“-l”选项导致 ls 的输出结果以长格式输出。这种格式包含大量的有用信息。下面的例子目录来自 于 Ubuntu 系统：</p><pre><code>-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg-rw-r--r-- 1 root root 1186219 2007-04-03 11:05 kubuntu-leaflet.png-rw-r--r-- 1 root root   47584 2007-04-03 11:05 logo-Edubuntu.png-rw-r--r-- 1 root root   44355 2007-04-03 11:05 logo-Kubuntu.png-rw-r--r-- 1 root root   34391 2007-04-03 11:05 logo-Ubuntu.png-rw-r--r-- 1 root root   32059 2007-04-03 11:05 oo-cd-cover.odf-rw-r--r-- 1 root root  159744 2007-04-03 11:05 oo-derivatives.doc-rw-r--r-- 1 root root   27837 2007-04-03 11:05 oo-maxwell.odt-rw-r--r-- 1 root root   98816 2007-04-03 11:05 oo-trig.xls-rw-r--r-- 1 root root  453764 2007-04-03 11:05 oo-welcome.odt-rw-r--r-- 1 root root  358374 2007-04-03 11:05 ubuntu Sax.ogg</code></pre><p>Let’s look at the different fields from one of the files and examine their meanings:</p><p>选一个文件，来看一下各个输出字段的含义：</p><table><thead><tr><th align="left">Field</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-rw-r–r–</td><td align="left">Access rights to the file. The first character indicates the type of file. Among the different types, a leading dash means a regular file, while a “d” indicates a directory. The next three characters are the access rights for the file’s owner, the next three are for members of the file’s group, and the final three are for everyone else. The full meaning of this is discussed in Chapter 10 – Permissions.</td></tr><tr><td align="left">1</td><td align="left">File’s number of hard links. See the discussion of links later in this chapter.</td></tr><tr><td align="left">root</td><td align="left">The user name of the file’s owner.</td></tr><tr><td align="left">root</td><td align="left">The name of the group which owns the file.</td></tr><tr><td align="left">32059</td><td align="left">Size of the file in bytes.</td></tr><tr><td align="left">2007-04-03 11:05</td><td align="left">Date and time of the file’s last modification.</td></tr><tr><td align="left">oo-cd-cover.odf</td><td align="left">Name of the file.</td></tr></tbody></table><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-rw-r–r–</td><td align="left">对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。</td></tr><tr><td align="left">1</td><td align="left">文件的硬链接数目。参考随后讨论的关于链接的内容。</td></tr><tr><td align="left">root</td><td align="left">文件所有者的用户名。</td></tr><tr><td align="left">root</td><td align="left">文件所属用户组的名字。</td></tr><tr><td align="left">32059</td><td align="left">以字节数表示的文件大小。</td></tr><tr><td align="left">2007-04-03 11:05</td><td align="left">上次修改文件的时间和日期。</td></tr><tr><td align="left">oo-cd-cover.odf</td><td align="left">文件名。</td></tr></tbody></table><h3 id="确定文件类型"><a href="#确定文件类型" class="headerlink" title="确定文件类型"></a>确定文件类型</h3><p>As we explore the system it will be useful to know what files contain. To do this we will use the file command to determine a file’s type. As we discussed earlier, filenames in Linux are not required to reflect a file’s contents. While a filename like “picture.jpg” would normally be expected to contain a JPEG compressed image, it is not required to in Linux. We can invoke the file command this way:</p><p>随着探究操作系统的进行，知道文件包含的内容是很有用的。我们将用 file 命令来确定文件的类型。我们之前讨论过， 在 Linux 系统中，并不要求文件名来反映文件的内容。然而，一个类似 “picture.jpg” 的文件名，我们会期望它包含 JPEG 压缩图像，但 Linux 却不这样要求它。可以这样调用 file 命令：</p><pre><code>file filename</code></pre><p>When invoked, the file command will print a brief description of the file’s contents. For example:</p><p>当调用 file 命令后，file 命令会打印出文件内容的简单描述。例如：</p><pre><code>[me@linuxbox ~]$ file picture.jpgpicture.jpg: JPEG image data, JFIF standard 1.01</code></pre><p>There are many kinds of files. In fact, one of the common ideas in Unix-like operating systems such as Linux is that “everything is a file.” As we proceed with our lessons, we will see just how true that statement is.</p><p>有许多种类型的文件。事实上，在类 Unix 操作系统中比如说 Linux 中，有个普遍的观念就是“一切皆文件”。 随着课程的进行，我们将会明白这句话是多么的正确。</p><p>While many of the files on your system are familiar, for example MP3 and JPEG, there are many kinds that are a little less obvious and a few that are quite strange.</p><p>虽然系统中许多文件格式是熟悉的，例如 MP3和 JPEG 文件，但也有一些文件格式不太常见，极少数文件相当陌生。</p><h3 id="用-less-浏览文件内容"><a href="#用-less-浏览文件内容" class="headerlink" title="用 less 浏览文件内容"></a>用 less 浏览文件内容</h3><p>The less command is a program to view text files. Throughout our Linux system, there are many files that contain human-readable text. The less program provides a convenient way to examine them.</p><p>less 命令是一个用来浏览文本文件的程序。纵观 Linux 系统，有许多人类可读的文本文件。less 程序为我们检查文本文件 提供了方便。</p><blockquote><p>What Is “Text”</p><p>什么是“文本”</p><p>There are many ways to represent information on a computer. All methods involve defining a relationship between the information and some numbers that will be used to represent it. Computers, after all, only understand numbers and all data is converted to numeric representation.</p><p>在计算机中，有许多方法可以表达信息。所有的方法都涉及到，在信息与一些数字之间确立一种关系，而这些数字可以 用来代表信息。毕竟，计算机只能理解数字，这样所有的数据都被转换成数值来表示。</p><p>Some of these representation systems are very complex (such as compressed video files), while others are rather simple. One of the earliest and simplest is called ASCII text. ASCII (pronounced “As-Key”) is short for American Standard Code for Information Interchange. This is a simple encoding scheme that was first used on Teletype machines to map keyboard characters to numbers.</p><p>有些数值表达法非常复杂（例如压缩的视频文件），而其它的就相当简单。最早也是最简单的一种表达法，叫做 ASCII 文本。ASCII（发音是”As-Key”）是美国信息交换标准码的简称。这是一个简单的编码方法，它首先 被用在电传打字机上，用来实现键盘字符到数字的映射。</p><p>Text is a simple one-to-one mapping of characters to numbers. It is very compact. Fifty characters of text translates to fifty bytes of data. It is important to understand that text only contains a simple mapping of characters to numbers. It is not the same as a word processor document such as one created by Microsoft Word or OpenOffice.org Writer. Those files, in contrast to simple ASCII text, contain many non-text elements that are used to describe its structure and formatting. Plain ASCII text files contain only the characters themselves and a few rudimentary control codes like tabs, carriage returns and line feeds. Throughout a Linux system, many files are stored in text format and there are many Linux tools that work with text files. Even Windows recognizes the importance of this format. The well-known NOTEPAD.EXE program is an editor for plain ASCII text files.</p><p>文本是简单的字符与数字之间的一对一映射。它非常紧凑。五十个字符的文本翻译成五十个字节的数据。文本只是包含 简单的字符到数字的映射，理解这点很重要。它和一些文字处理器文档不一样，比如说由微软或 OpenOffice.org 文档 编辑器创建的文件。这些文件，和简单的 ASCII 文件形成鲜明对比，它们包含许多非文本元素，来描述它的结构和格式。 纯 ASCII 文件只包含字符本身，和一些基本的控制符，像制表符、回车符及换行符。纵观 Linux 系统，许多文件以文本格式存储，也有许多 Linux 工具来处理文本文件。甚至 Windows 也承认这种文件格式的重要性。著名的 NOTEPAD.EXE 程序就是一个纯 ASCII 文本文件编辑器。</p></blockquote><p>Why would we want to examine text files? Because many of the files that contain system settings (called configuration files) are stored in this format, and being able to read them gives us insight about how the system works. In addition, many of the actual programs that the system uses (called scripts) are stored in this format. In later chapters, we will learn how to edit text files in order to modify systems settings and write our own scripts, but for now we will just look at their contents.</p><p>为什么我们要查看文本文件呢？ 因为许多包含系统设置的文件（叫做配置文件），是以文本格式存储的，阅读它们 可以更深入的了解系统是如何工作的。另外，许多系统所用到的实际程序（叫做脚本）也是以这种格式存储的。 在随后的章节里，我们将要学习怎样编辑文本文件以修改系统设置，还要学习编写自己的脚本文件，但现在我们只是看看它们的内容而已。</p><p>The less command is used like this:</p><p>less 命令是这样使用的：</p><pre><code>less filename</code></pre><p>Once started, the less program allows you to scroll forward and backward through a text file. For example, to examine the file that defines all the system’s user accounts, enter the following command:</p><p>一旦运行起来，less 程序允许你前后滚动文件。例如，要查看一个定义了系统中全部用户身份的文件，输入以下命令：</p><pre><code>[me@linuxbox ~]$ less /etc/passwd</code></pre><p>Once the less program starts, we may view the contents of the file. If the file is longer than one page, we can scroll up and down. To exit less, press the “q” key. The table below lists the most common keyboard commands used by less.</p><p>一旦 less 程序运行起来，我们就能浏览文件内容了。如果文件内容多于一页，那么我们可以上下滚动文件。按下“q”键， 退出 less 程序。</p><p>下表列出了 less 程序最常使用的键盘命令。</p><table><thead><tr><th align="left">Command</th><th align="left">Action</th></tr></thead><tbody><tr><td align="left">Page UP or b</td><td align="left">Scroll back one page</td></tr><tr><td align="left">Page Down or space</td><td align="left">Scroll forward one page</td></tr><tr><td align="left">UP Arrow</td><td align="left">Scroll Up one line</td></tr><tr><td align="left">Down Arrow</td><td align="left">Scrow Down one line</td></tr><tr><td align="left">G</td><td align="left">Move to the end of the text file</td></tr><tr><td align="left">1G or g</td><td align="left">Move to the beginning of the text file</td></tr><tr><td align="left">/charaters</td><td align="left">Search forward for the next occurrence of characters</td></tr><tr><td align="left">n</td><td align="left">Search forward for the next occurrence of the previous search</td></tr><tr><td align="left">h</td><td align="left">Display help screen</td></tr><tr><td align="left">q</td><td align="left">Quit less</td></tr></tbody></table><table><thead><tr><th align="left">命令</th><th align="left">行为</th></tr></thead><tbody><tr><td align="left">Page UP or b</td><td align="left">向上翻滚一页</td></tr><tr><td align="left">Page Down or space</td><td align="left">向下翻滚一页</td></tr><tr><td align="left">UP Arrow</td><td align="left">向上翻滚一行</td></tr><tr><td align="left">Down Arrow</td><td align="left">向下翻滚一行</td></tr><tr><td align="left">G</td><td align="left">移动到最后一行</td></tr><tr><td align="left">1G or g</td><td align="left">移动到开头一行</td></tr><tr><td align="left">/charaters</td><td align="left">向前查找指定的字符串</td></tr><tr><td align="left">n</td><td align="left">向前查找下一个出现的字符串，这个字符串是之前所指定查找的</td></tr><tr><td align="left">h</td><td align="left">显示帮助屏幕</td></tr><tr><td align="left">q</td><td align="left">退出 less 程序</td></tr></tbody></table><h3 id="less-就是-more（禅语：色即是空）"><a href="#less-就是-more（禅语：色即是空）" class="headerlink" title="less 就是 more（禅语：色即是空）"></a>less 就是 more（禅语：色即是空）</h3><p>The less program was designed as an improved replacement of an earlier Unix program called more. The name “less” is a play on the phrase “less is more”—a motto of modernist architects and designers.</p><p>less 程序是早期 Unix 程序 more 的改进版。“less” 这个名字，对习语 “less is more” 开了个玩笑， 这个习语是现代主义建筑师和设计者的座右铭。</p><p>less falls into the class of programs called “pagers,” programs that allow the easy viewing of long text documents in a page by page manner. Whereas the more program could only page forward, the less program allows paging both forward and backward and has many other features as well.</p><p>less 属于”页面调度器”类程序，这些程序允许以逐页方式轻松浏览长文本文档。 more 程序只能向前翻页，而 less 程序允许前后翻页，此外还有很多其它的特性。</p><h3 id="旅行指南"><a href="#旅行指南" class="headerlink" title="旅行指南"></a>旅行指南</h3><p>The file system layout on your Linux system is much like that found on other Unix-like systems. The design is actually specified in a published standard called the Linux Filesystem Hierarchy Standard. Not all Linux distributions conform to the standard exactly but most come pretty close.</p><p>Linux 系统中，文件系统布局与类 Unix 系统的文件布局很相似。实际上，一个已经发布的标准， 叫做 Linux 文件系统层次标准，详细说明了这种设计模式。不是所有Linux发行版都根据这个标准，但 大多数都是。</p><p>Next, we are going to wander around the file system ourselves to see what makes our Linux system tick. This will give you a chance to practice your navigation skills. One of the things we will discover is that many of the interesting files are in plain human- readable text. As we go about our tour, try the following:</p><p>下一步，我们将在文件系统中漫游，来了解 Linux 系统的工作原理。这会给你一个温习跳转命令的机会。 我们会发现很多有趣的文件都是纯人类可读文本。下面旅行开始，做做以下练习：</p><ol><li>cd into a given directory</li><li>List the directory contents with ls -l</li><li>If you see an interesting file, determine its contents with file</li><li>If it looks like it might be text, try viewing it with less</li><li>cd 到给定目录</li><li>列出目录内容 ls -l</li><li>如果看到一个有趣的文件，用 file 命令确定文件内容</li><li>如果文件看起来像文本，试着用 less 命令浏览它</li></ol><hr><p>Remember the copy and paste trick! If you are using a mouse, you can double click on a filename to copy it and middle click to paste it into commands.</p><p>记得复制和粘贴技巧！如果你正在使用鼠标，双击文件名，来复制它，然后按下鼠标中键，粘贴文件名到命令行中。</p><hr><p>As we wander around, don’t be afraid to look at stuff. Regular users are largely prohibited from messing things up. That’s the system administrators job! If a command complains about something, just move on to something else. Spend some time looking around. The system is ours to explore. Remember, in Linux, there are no secrets! Table 4-4 lists just a few of the directories we can explore. Feel free to try more!</p><p>在系统中漫游时，不要害怕四处看看。普通用户是很难把东西弄乱的。那是系统管理员的工作！ 如果一个命令抱怨一些事情，不要管它，尝试一下别的东西。花一些时间四处看看。 系统是我们自己的，尽情地探究吧。记住在 Linux 中，没有秘密存在！ 表4-4仅仅列出了一些我们可以浏览的目录。随意尝试更多！</p><table><thead><tr><th align="left">Drectory</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">/</td><td align="left">The root directory.Where everything begins.</td></tr><tr><td align="left">/bin</td><td align="left">Contains binaries (programs) that must be present for the system to boot and run.</td></tr><tr><td align="left">/boot</td><td align="left">Contains the linux kernel, intial RAM disk image (for drivers needed at boot time), and the boot loader.Interesting files:/boot/grub/grub.conf or menu.lst, which are used to configure the boot loader./boot/vmlinuz,the linux kernel.</td></tr><tr><td align="left">/dev</td><td align="left">This is a special directory which contains device nodes. “Everything is a file” also applies to devices. Here is where the kernel maintains a list of all the devices it understands.</td></tr><tr><td align="left">/etc</td><td align="left">The /etc directory contains all of the system-wide configuration files. It also contains a collection of shell scripts which start each of the system services at boot time. Everything in this directory should be readable text.Interesting files:While everything in /etc is interesting, here are some of my all-time favorites:/etc/crontab, a file that defines when automated jobs will run./etc/fstab, a table of storage devices and their associated mount points./etc/passwd, a list of the user accounts.</td></tr><tr><td align="left">/home</td><td align="left">In normal configurations, each user is given a directory in /home. Ordinary users can only write files in their home directories. This limitation protects the system from errant user activity.</td></tr><tr><td align="left">/lib</td><td align="left">Contains shared library files used by the core system programs. These are similar to DLLs in Windows.</td></tr><tr><td align="left">/lost+found</td><td align="left">Each formatted partition or device using a Linux file system, such as ext3, will have this directory. It is used in the case of a partial recovery from a file system corruption event. Unless something really bad has happened to your system, this directory will remain empty.</td></tr><tr><td align="left">/media</td><td align="left">On modern Linux systems the /media directory will contain the mount points for removable media such USB drives, CD-ROMs, etc. that are mounted automatically at insertion.</td></tr><tr><td align="left">/mnt</td><td align="left">On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually.</td></tr><tr><td align="left">/opt</td><td align="left">The /opt directory is used to install “optional” software. This is mainly used to hold commercial software products that may be installed on your system.</td></tr><tr><td align="left">/proc</td><td align="left">The /proc directory is special. It’s not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give you a picture of how the kernel sees your computer.</td></tr><tr><td align="left">/root</td><td align="left">This is the home directory for the root account.</td></tr><tr><td align="left">/sbin</td><td align="left">This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser.</td></tr><tr><td align="left">/tmp</td><td align="left">The /tmp directory is intended for storage of temporary, transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted.</td></tr><tr><td align="left">/usr</td><td align="left">The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users.</td></tr><tr><td align="left">/usr/bin</td><td align="left">/usr/bin contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs.</td></tr><tr><td align="left">/usr/lib</td><td align="left">The shared libraries for the programs in /usr/bin.</td></tr><tr><td align="left">/usr/local</td><td align="left">The /usr/local tree is where programs that are not included with your distribution but are intended for system- wide use are installed. Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it.</td></tr><tr><td align="left">/usr/sbin</td><td align="left">Contains more system administration programs.</td></tr><tr><td align="left">/usr/share</td><td align="left">/usr/share contains all the shared data used by programs in /usr/bin. This includes things like default configuration files, icons, screen backgrounds, sound files, etc.</td></tr><tr><td align="left">/usr/share/doc</td><td align="left">Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package.</td></tr><tr><td align="left">/var</td><td align="left">With the exception of /tmp and /home, the directories we have looked at so far remain relatively static, that is, their contents don’t change. The /var directory tree is where data that is likely to change is stored. Various databases, spool files, user mail, etc. are located here.</td></tr><tr><td align="left">/var/log</td><td align="left">/var/log contains log files, records of various system activity. These are very important and should be monitored from time to time. The most useful one is /var/log/messages. Note that for security reasons on some systems, you must be the superuser to view log files.</td></tr></tbody></table><table><thead><tr><th align="left">目录</th><th align="left">评论</th></tr></thead><tbody><tr><td align="left">/</td><td align="left">根目录，万物起源。</td></tr><tr><td align="left">/bin</td><td align="left">包含系统启动和运行所必须的二进制程序。</td></tr><tr><td align="left">/boot</td><td align="left">包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。</td></tr><tr><td align="left">/dev</td><td align="left">这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。</td></tr><tr><td align="left">/etc</td><td align="left">这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。</td></tr><tr><td align="left">/home</td><td align="left">在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。</td></tr><tr><td align="left">/lib</td><td align="left">包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。</td></tr><tr><td align="left">/lost+found</td><td align="left">每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。</td></tr><tr><td align="left">/media</td><td align="left">在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。</td></tr><tr><td align="left">/mnt</td><td align="left">在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。</td></tr><tr><td align="left">/opt</td><td align="left">这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。</td></tr><tr><td align="left">/proc</td><td align="left">这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。</td></tr><tr><td align="left">/root</td><td align="left">root 帐户的家目录。</td></tr><tr><td align="left">/sbin</td><td align="left">这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。</td></tr><tr><td align="left">/tmp</td><td align="left">这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。</td></tr><tr><td align="left">/usr</td><td align="left">在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。</td></tr><tr><td align="left">/usr/bin</td><td align="left">/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。</td></tr><tr><td align="left">/usr/lib</td><td align="left">包含由/usr/bin 目录中的程序所用的共享库。</td></tr><tr><td align="left">/usr/local</td><td align="left">这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。</td></tr><tr><td align="left">/usr/sbin</td><td align="left">包含许多系统管理程序。</td></tr><tr><td align="left">/usr/share</td><td align="left">/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。</td></tr><tr><td align="left">/usr/share/doc</td><td align="left">大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。</td></tr><tr><td align="left">/var</td><td align="left">除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。</td></tr><tr><td align="left">/var/log</td><td align="left">这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。</td></tr></tbody></table><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>As we look around, we are likely to see a directory listing with an entry like this:</p><p>在我们到处查看时，我们可能会看到一个目录，列出像这样的一条信息：</p><pre><code>lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -&gt; libc-2.6.so</code></pre><p>Notice how the first letter of the listing is “l” and the entry seems to have two filenames? This is a special kind of a file called a symbolic link (also known as a soft link or symlink.) In most Unix-like systems it is possible to have a file referenced by multiple names. While the value of this may not be obvious, it is really a useful feature.</p><p>注意看，为何这条信息第一个字符是“l”，并且有两个文件名呢？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink ）。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。虽然这种特性的意义并不明显，但它真的很有用。</p><p>Picture this scenario: a program requires the use of a shared resource of some kind contained in a file named “foo,” but “foo” has frequent version changes. It would be good to include the version number in the filename so the administrator or other interested party could see what version of “foo” is installed. This presents a problem. If we change the name of the shared resource, we have to track down every program that might use it and change it to look for a new resource name every time a new version of the resource is installed. That doesn’t sound like fun at all.</p><p>描绘一下这样的情景：一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是“foo”经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个“foo”版本。 这会导致另一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。</p><p>Here is where symbolic links save the day. Let’s say we install version 2.6 of “foo,” which has the filename “foo-2.6” and then create a symbolic link simply called “foo” that points to “foo-2.6.” This means that when a program opens the file “foo”, it is actually opening the file “foo-2.6”. Now everybody is happy. The programs that rely on “foo” can find it and we can still see what actual version is installed. When it is time to upgrade to “foo-2.7,” we just add the file to our system, delete the symbolic link “foo” and create a new one that points to the new version. Not only does this solve the problem of the version upgrade, but it also allows us to keep both versions on our machine. Imagine that “foo-2.7” has a bug (damn those developers!) and we need to revert to the old version. Again, we just delete the symbolic link pointing to the new version and create a new symbolic link pointing to the old version.</p><p>这就是符号链接存在至今的原因。比方说，我们安装了文件 “foo” 的 2.6 版本，它的 文件名是 “foo-2.6”，然后创建了叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。 这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。 现在，每个人都很高兴。依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。 当升级到 “foo-2.7” 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。 假想 “foo-2.7” 有个错误（该死的开发者！），那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。</p><p>The directory listing above (from the /lib directory of a Fedora system) shows a symbolic link called “libc.so.6” that points to a shared library file called “libc-2.6.so.” This means that programs looking for “libc.so.6” will actually get the file “libc-2.6.so.” We will learn how to create symbolic links in the next chapter.</p><p>在上面列出的目录（来自于 Fedora 的 /lib 目录）展示了一个叫做 “libc.so.6” 的符号链接，这个符号链接指向一个 叫做 “libc-2.6.so” 的共享库文件。这意味着，寻找文件 “libc.so.6” 的程序，实际上得到是文件 “libc-2.6.so”。 在下一章节，我们将学习如何建立符号链接。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>While we are on the subject of links, we need to mention that there is a second type of link called a hard link. Hard links also allow files to have multiple names, but they do it in a different way. We’ll talk more about the differences between symbolic and hard links in the next chapter.</p><p>讨论到链接问题，我们需要提一下，还有一种链接类型，叫做硬链接。硬链接同样允许文件有多个名字， 但是硬链接以不同的方法来创建多个文件名。在下一章中，我们会谈到更多符号链接与硬链接之间的差异问题。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><ul><li><p>The full version of the Linux Filesystem Hierarchy Standard can be found here:</p></li><li><p>完整的 Linux 文件系统层次体系标准可通过以下链接找到：</p><p><a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">http://www.pathname.com/fhs/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三章 文件系统中跳转</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%B7%B3%E8%BD%AC/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>The first thing we need to learn to do (besides just typing) is how to navigate the file system on our Linux system. In this chapter we will introduce the following commands:</p><p>我们需要学习的第一件事（除了打字之外）是如何在 Linux 文件系统中跳转。 在这一章节中，我们将介绍以下命令：</p><ul><li>pwd - Print name of current working directory</li><li>cd - Change directory</li><li>ls - List directory contents</li><li>pwd — 打印出当前工作目录名</li><li>cd — 更改目录</li><li>ls — 列出目录内容</li></ul><h3 id="理解文件系统树"><a href="#理解文件系统树" class="headerlink" title="理解文件系统树"></a>理解文件系统树</h3><p>Like Windows, a Unix-like operating system such as Linux organizes its files in what is called a hierarchical directory structure. This means that they are organized in a tree-like pattern of directories (sometimes called folders in other systems), which may contain files and other directories. The first directory in the file system is called the root directory. The root directory contains files and subdirectories, which contain more files and subdirectories and so on and so on.</p><p>类似于 Windows，一个“类 Unix” 的操作系统，比如说 Linux，以分层目录结构来组织所有文件。 这就意味着所有文件组成了一棵树型目录（有时候在其它系统中叫做文件夹）， 这个目录树可能包含文件和其它的目录。文件系统中的第一级目录称为根目录。 根目录包含文件和子目录，子目录包含更多的文件和子目录，依此类推。</p><p>Note that unlike Windows, which has a separate file system tree for each storage device, Unix-like systems such as Linux always have a single file system tree, regardless of how many drives or storage devices are attached to the computer. Storage devices are attached (or more correctly, mounted) at various points on the tree according to the whims of the system administrator, the person (or persons) responsible for the maintenance of the system.</p><p>注意(类 Unix 系统)不像 Windows ，每个存储设备都有一个独自的文件系统。类 Unix 操作系统， 比如 Linux，总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。 根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或着更精确些，是挂载到）目录树的各个节点上。</p><h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p>Most of us are probably familiar with a graphical file manager which represents the file system tree as in Figure 1. Notice that the tree is usually shown upended, that is, with the root at the top and the various branches descending below.</p><p><img src="https://billie66.github.io/TLCL/book/images/3.png" alt="img"><br>图1: 由图形化文件管理器显示的文件系统树</p><p>大多数人都可能熟悉如图1所示描述文件系统树的图形文件管理器。注意， 通常这是一棵 倒置的树，也就是说，树根在最上面，而各个枝干在下面展开。</p><p>However, the command line has no pictures, so to navigate the file system tree we need to think of it in a different way.</p><p>然而，命令行没有这样的图片，所以我们需要把文件系统树想象成别的样子（而不是这张图片）。</p><p>Imagine that the file system is a maze shaped like an upside-down tree and we are able to stand in the middle of it. At any given time, we are inside a single directory and we can see the files contained in the directory and the pathway to the directory above us (called the parent directory) and any subdirectories below us. The directory we are standing in is called the current working directory. To display the current working directory, we use the pwd (print working directory) command.</p><p>把文件系统想象成一个迷宫形状，就像一棵倒立的大树，我们站在迷宫的中间位置。 在任意时刻，我们处于一个目录里面，我们能看到这个目录包含的所有文件， 以及通往上面目录（父目录）的路径，和下面的各个子目录。我们所在的目录则称为 当前工作目录。我们使用 pwd（print working directory(的缩写)）命令，来显示当前工作目录。</p><pre><code>[me@linuxbox ~]$ pwd/home/me</code></pre><p>When we first log in to our system (or start a terminal emulator session) our current working directory is set to our home directory. Each user account is given its own home directory and when operating as a regular user, the home directory is the only place the user is allowed to write files.</p><p>当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户写入文件的地方。</p><h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h3><p>To list the files and directories in the current working directory, we use the ls command.</p><p>列出一个目录包含的文件及子目录，使用 ls 命令。</p><pre><code>[me@linuxbox ~]$ lsDesktop Documents Music Pictures Public Templates Videos</code></pre><p>Actually, we can use the ls command to list the contents of any directory, not just the current working directory, and there are many other fun things it can do as well. We’ll spend more time with ls in the next chapter.</p><p>实际上，用 ls 命令可以列出任一个目录的内容，而不只是当前工作目录的内容。 ls 命令还能完成许多有趣的事情。在下一章节，我们将介绍更多关于 ls 的知识。</p><h3 id="更改当前工作目录"><a href="#更改当前工作目录" class="headerlink" title="更改当前工作目录"></a>更改当前工作目录</h3><p>To change your working directory (where we are standing in our tree-shaped maze) we use the cd command. To do this, type cd followed by the pathname of the desired working directory. A pathname is the route we take along the branches of the tree to get to the directory we want. Pathnames can be specified in one of two different ways; as absolute pathnames or as relative pathnames. Let’s deal with absolute pathnames first.</p><p>要更改工作目录（此刻，我们站在树形迷宫里面），我们用 cd 命令。输入 cd, 然后输入你想要去的工作目录的路径名。路径名就是沿着目录树的分支 到达想要的目录期间所经过的路线。路径名可通过两种方式来指定，一种是绝对路径， 另一种是相对路径。我们先来介绍绝对路径。</p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>An absolute pathname begins with the root directory and follows the tree branch by branch until the path to the desired directory or file is completed. For example, there is a directory on your system in which most of your system’s programs are installed. The pathname of the directory is /usr/bin. This means from the root directory (represented by the leading slash in the pathname) there is a directory called “usr” which contains a directory called “bin”.</p><p>绝对路径开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。 例如，你的系统中有一个目录，大多数系统程序都安装在这个目录下。这个目录的 路径名是 /usr/bin。它意味着从根目录（用开头的“/”表示）开始，有一个叫 “usr” 的 目录包含了目录 “bin”。</p><pre><code>[me@linuxbox ~]$ cd /usr/bin[me@linuxbox bin]$ pwd/usr/bin[me@linuxbox bin]$ ls...Listing of many, many files ...</code></pre><p>Now we can see that we have changed the current working directory to /usr/bin and that it is full of files. Notice how the shell prompt has changed? As a convenience, it is usually set up to automatically display the name of the working directory.</p><p>我们把工作目录转到 /usr/bin 目录下，里面装满了文件。注意 shell 提示符是怎样改变的吗？ 为了方便，通常终端提示符自动显示工作目录名。</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>Where an absolute pathname starts from the root directory and leads to its destination, a relative pathname starts from the working directory. To do this, it uses a couple of special symbols to represent relative positions in the file system tree. These special symbols are “.” (dot) and “..” (dot dot).</p><p>绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录。 为了做到这个（用相对路径表示）， 我们在文件系统树中用一对特殊符号来表示相对位置。 这对特殊符号是 “.” (点) 和 “..” (点点)。</p><p>The “.” symbol refers to the working directory and the “..” symbol refers to the working directory’s parent directory. Here is how it works. Let’s change the working directory to /usr/bin again:</p><p>符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录。下面的例子说明怎样使用它。 让我们再次把工作目录切换到 /usr/bin：</p><pre><code>[me@linuxbox ~]$ cd /usr/bin[me@linuxbox bin]$ pwd/usr/bin</code></pre><p>Okay, now let’s say that we wanted to change the working directory to the parent of /usr/bin which is /usr. We could do that two different ways. Either with an absolute pathname:</p><p>好了，比方说我们想更改工作目录到 /usr/bin 的父目录 /usr。可以通过两种方法来实现。可以使用以下绝对路径名：</p><pre><code>[me@linuxbox bin]$ cd /usr[me@linuxbox usr]$ pwd/usr</code></pre><p>Or, with a relative pathname:</p><p>或者， 也可以使用相对路径：</p><pre><code>[me@linuxbox bin]$ cd ..[me@linuxbox usr]$ pwd/usr</code></pre><p>Two different methods with identical results. Which one should we use? The one that requires the least typing!</p><p>两种不同的方法，一样的结果。我们应该选哪一个呢？ 选输入量最少的那个！</p><p>Likewise, we can change the working directory from /usr to /usr/bin in two different ways. Either using an absolute pathname:</p><p>同样地，从目录 /usr/ 到 /usr/bin 也有两种途径。可以使用绝对路径：</p><pre><code>[me@linuxbox usr]$ cd /usr/bin[me@linuxbox bin]$ pwd/usr/bin</code></pre><p>Or, with a relative pathname:</p><p>或者，也可以用相对路径：</p><pre><code>[me@linuxbox usr]$ cd ./bin[me@linuxbox bin]$ pwd/usr/bin</code></pre><p>Now, there is something important that I must point out here. In almost all cases, you can omit the “./”. It is implied. Typing:</p><p>有一件很重要的事，我必须指出来。在几乎所有的情况下，你可以省略”./”。它是隐含的。输入：</p><pre><code>[me@linuxbox usr]$ cd bin</code></pre><p>does the same thing. In general, if you do not specify a pathname to something, the working directory will be assumed.</p><p>实现相同的效果。如果不指定一个文件的路径，那它被默认为在当前工作目录下。</p><h3 id="有用的快捷键"><a href="#有用的快捷键" class="headerlink" title="有用的快捷键"></a>有用的快捷键</h3><p>In table 3-1 we see some useful ways the current working directory can be quickly changed.</p><p>在表3-1中，列举出了一些快速改变当前工作目录的有效方法。</p><table><thead><tr><th align="left">Shortcut</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">cd</td><td align="left">Changes the working directory to your home directory.</td></tr><tr><td align="left">cd -</td><td align="left">Changes the working directory to the previous working directory.</td></tr><tr><td align="left">cd ~user_name</td><td align="left">Changes the working directory to the home directory of user_name. For example, cd ~bob will change the directory to the home directory of user “bob.”</td></tr></tbody></table><table><thead><tr><th align="left">快捷键</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left">cd</td><td align="left">更改工作目录到你的家目录。</td></tr><tr><td align="left">cd -</td><td align="left">更改工作目录到先前的工作目录。</td></tr><tr><td align="left">cd ~user_name</td><td align="left">更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。</td></tr></tbody></table><blockquote><p>Important Facts About Filenames</p><ol><li>Filenames that begin with a period character are hidden. This only means that ls will not list them unless you say ls -a. When your account was created, several hidden files were placed in your home directory to configure things for your account. Later on we will take a closer look at some of these files to see how you can customize your environment. In addition, some applications place their configuration and settings files in your home directory as hidden files.</li><li>Filenames and commands in Linux, like Unix, are case sensitive. The filenames “File1” and “file1” refer to different files.</li><li>Linux has no concept of a “file extension” like some other operating systems. You may name files any way you like. The contents and/or purpose of a file is determined by other means. Although Unix-like operating system don’t use file extensions to determine the contents/purpose of files, some application programs do.</li><li>Though Linux supports long filenames which may contain embedded spaces and punctuation characters, limit the punctuation characters in the names of files you create to period, dash, and underscore. Most importantly, do not embed spaces in filenames. If you want to represent spaces between words in a filename, use underscore characters. You will thank yourself later.</li></ol><p>关于文件名的重要规则</p><ol><li>以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。当你创建帐号后，几个配置帐号的隐藏文件被放置在 你的家目录下。稍后，我们会仔细研究一些隐藏文件，来定制你的系统环境。 另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。</li><li>文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。</li><li>Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何名字 来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统， 不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。</li><li>虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与 词间的空格，用下划线字符来代替。过些时候，你会感激自己这样做。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二章 什么是shell</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFshell/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFshell/</url>
      
        <content type="html"><![CDATA[<p>When we speak of the command line, we are really referring to the shell. The shell is a program that takes keyboard commands and passes them to the operating system to carry out. Almost all Linux distributions supply a shell program from the GNU Project called bash. The name “bash” is an acronym for “Bourne Again SHell”, a reference to the fact bash is an enhanced replacement for sh, the original Unix shell program written by Steve Bourne.</p><p>一说到命令行，我们真正指的是 shell。shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。“bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。</p><h3 id="终端仿真器"><a href="#终端仿真器" class="headerlink" title="终端仿真器"></a>终端仿真器</h3><p>When using a graphical user interface, we need another program called a terminal emulator to interact with the shell. If we look through our desktop menus, we will probably find one. KDE uses konsole and GNOME uses gnome-terminal, though it’s likely called simply “terminal” on our menu. There are a number of other terminal emulators available for Linux, but they all basically do the same thing; give us access to the shell. You will probably develop a preference for one or another based on the number of bells and whistles it has.</p><p>当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。 如果我们浏览一下桌面菜单，可能会找到一个。虽然在菜单里它可能都 被简单地称为 “terminal”，但是 KDE 用的是 konsole , 而 GNOME 则使用 gnome-terminal。 还有其他一些终端仿真器可供 Linux 使用，但基本上，它们都完成同样的事情， 让我们能访问 shell。也许，你可能会因为附加的一系列花俏功能而喜欢上某个终端。</p><h3 id="第一次按键"><a href="#第一次按键" class="headerlink" title="第一次按键"></a>第一次按键</h3><p>So let’s get started. Launch the terminal emulator! Once it comes up, we should see somehing like this:</p><p>好，开始吧。启动终端仿真器！一旦它运行起来，我们应该看到一行像这样的文字：</p><pre><code>[me@linuxbox ~]$</code></pre><p>This is called a shell prompt and it will appear whenever the shell is ready to accept input. While it may vary in appearance somewhat depending on the distribution, it will usually include your username@machinename, followed by the current working directory (more about that in a little bit) and a dollar sign.</p><p>这叫做 shell 提示符，无论何时当 shell 准备好了去接受输入时，它就会出现。然而， 它可能会以各种各样的面孔显示，这则取决于不同的 Linux 发行版， 它通常包括你的用户名@主机名，紧接着当前工作目录（稍后会有更多介绍）和一个美元符号。</p><p>If the last character of the prompt is a pound sign (“#”) rather than a dollar sign, the terminal session has superuser privileges. This means either we are logged in as the root user or we selected a terminal emulator that provides superuser (administrative) privileges.</p><p>如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户（管理员）权限。</p><p>Assuming that things are good so far, let’s try some typing. Type some gibberish at the prompt like so:</p><p>假定到目前为止，所有事情都进行顺利，那我们试着键入字符吧。在提示符下敲入 一些像下面一样的乱七八糟的字符：</p><pre><code>[me@linuxbox ~]$ kaekfjaeifj</code></pre><p>Since this command makes no sense, the shell will tell us so and give us another chance:</p><p>因为这个命令没有任何意义，所以 shell 会提示错误信息，并让我们再试一下：</p><pre><code>bash: kaekfjaeifj: command not found[me@linuxbox ~]$</code></pre><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><p>If we press the up-arrow key, we will see that the previous command “kaekfjaeifj” reappears after the prompt. This is called command history. Most Linux distributions remember the last five hundred commands by default. Press the down-arrow key and the previous command disappears.</p><p>如果按下上箭头按键，我们会看到刚才输入的命令“kaekfjaeifj”重新出现在提示符之后。 这就叫做命令历史。许多 Linux 发行版默认保存最后输入的500个命令。 按下下箭头按键，先前输入的命令就消失了。</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>Recall the previous command with the up-arrow key again. Now try the left and right-arrow keys. See how we can position the cursor anywhere on the command line? This makes editing commands easy.</p><p>可借助上箭头按键，来获得上次输入的命令。现在试着使用左右箭头按键。 看一下怎样把光标定位到命令行的任意位置？通过使用箭头按键，使编辑命令变得轻松些。</p><h3 id="关于鼠标和光标"><a href="#关于鼠标和光标" class="headerlink" title="关于鼠标和光标"></a>关于鼠标和光标</h3><p>While the shell is all about the keyboard, you can also use a mouse with your terminal emulator. There is a mechanism built into the X Window System (the underlying engine that makes the GUI go) that supports a quick copy and paste technique. If you highlight some text by holding down the left mouse button and dragging the mouse over it (or double clicking on a word), it is copied into a buffer maintained by X. Pressing the middle mouse button will cause the text to be pasted at the cursor location. Try it.</p><p>虽然，shell 是和键盘打交道的，但你也可以在终端仿真器里使用鼠标。X 窗口系统 （使 GUI 工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。 如果你按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标中键， 这些文本就被粘贴到光标所在的位置。试试看。</p><p>Note: Don’t be tempted to use Ctrl-c and Ctrl-v to perform copy and paste inside a terminal window. They don’t work. These control codes have different meanings to the shell and were assigned many years before Microsoft Windows.</p><p>注意： 不要在一个终端窗口里使用 Ctrl-c 和 Ctrl-v 快捷键来执行拷贝和粘贴操作。 它们不起作用。对于 shell 来说，这两个控制代码有着不同的含义，它们在早于 Microsoft Windows （定义复制粘贴的含义）许多年之前就赋予了不同的意义。</p><p>Your graphical desktop environment (most likely KDE or GNOME), in an effort to behave like Windows, probably has its focus policy set to “click to focus.” This means for a window to get focus (become active) you need to click on it. This is contrary to the traditional X behavior of “focus follows mouse” which means that a window gets focus by just passing the mouse over it. The window will not come to the foreground until you click on it but it will be able to receive input. Setting the focus policy to “focus follows mouse” will make the copy and paste technique even more useful. Give it a try. I think if you give it a chance you will prefer it. You will find this setting in the configuration program for your window manager.</p><p>你的图形桌面环境（像 KDE 或 GNOME），努力想和 Windows 一样，可能会把它的聚焦策略 设置成“单击聚焦”。这意味着，为了让窗口聚焦（变成活动窗口）你需要单击它。 这与“聚焦跟随着鼠标”的传统 X 行为不同，传统 X 行为是指只要把鼠标移动到一个窗口的上方。 它能接受输入， 但是直到你单击窗口之前它都不会成为前端窗口。 设置聚焦策略为“聚焦跟随着鼠标”，可以使拷贝和粘贴更方便易用。尝试一下。 我想如果你试了一下你会喜欢上它的。你能在窗口管理器的配置程序中找到这个设置。</p><h3 id="试试运行一些简单命令"><a href="#试试运行一些简单命令" class="headerlink" title="试试运行一些简单命令"></a>试试运行一些简单命令</h3><p>Now that we have learned to type, let’s try a few simple commands. The first one is date. This command displays the current time and date.</p><p>现在，我们学习了怎样输入命令，那我们执行一些简单的命令吧。第一个命令是 date。 这个命令显示系统当前时间和日期。</p><pre><code>[me@linuxbox ~]$ dateThu Oct 25 13:51:54 EDT 2007</code></pre><p>A related command is cal which, by default, displays a calendar of the current month.</p><p>一个相关联的命令，cal，它默认显示当前月份的日历。</p><pre><code>[me@linuxbox ~]$ calOctober 2007Su Mo Tu We Th Fr Sa1 2 3 4 5 67 8 9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre><p>To see the current amount of free space on your disk drives, type df:</p><p>查看磁盘剩余空间的数量，输入 df:</p><pre><code>[me@linuxbox ~]$ dfFilesystem           1K-blocks      Used Available Use% Mounted on/dev/sda2             15115452   5012392   9949716  34% //dev/sda5             59631908  26545424  30008432  47% /home/dev/sda1               147764     17370   122765   13% /boottmpfs                   256856         0   256856    0% /dev/shm</code></pre><p>Likewise, to display the amount of free memory, type the free command.</p><p>同样地，显示空闲内存的数量，输入命令 free。</p><pre><code>[me@linuxbox ~]$ freetotal       used       free     shared    buffers     cachedMem:       2059676     846456    1213220          044028      360568-/+ buffers/cache:     441860    1617816Swap:      1042428          0    1042428</code></pre><h3 id="结束终端会话"><a href="#结束终端会话" class="headerlink" title="结束终端会话"></a>结束终端会话</h3><p>We can end a terminal session by either closing the terminal emulator window, or by entering the exit command at the shell prompt:</p><p>我们可以通过关闭终端仿真器窗口，或者是在 shell 提示符下输入 exit 命令来终止一个终端会话：</p><pre><code>[me@linuxbox ~]$ exit</code></pre><h3 id="幕后控制台"><a href="#幕后控制台" class="headerlink" title="幕后控制台"></a>幕后控制台</h3><p>Even if we have no terminal emulator running, several terminal sessions continue to run behind the graphical desktop. Called virtual terminals or virtual consoles, these sessions can be accessed on most Linux distributions by pressing Ctrl- Alt-F1 through Ctrl-Alt-F6 on most systems. When a session is accessed, it presents a login prompt into which we can enter our user name and password. To switch from one virtual console to another, press Alt and F1-F6. To return to the graphical desktop, press Alt-F7.</p><p>即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端 或者是虚拟控制台。在大多数 Linux 发行版中，这些终端会话都可以通过按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问。当一个会话被访问的时候， 它会显示登录提示框，我们需要输入用户名和密码。要从一个虚拟控制台转换到另一个， 按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>To learn more about Steve Bourne, father of the Bourne Shell, see this Wikipedia article:</p><ul><li><p>想了解更多关于 Steve Bourne 的故事，Bourne Shell 之父，读一下这篇文章：</p><p><a href="http://en.wikipedia.org/wiki/Steve_Bourne" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Steve_Bourne</a></p></li></ul><p>Here is an article about the concept of shells in computing:</p><ul><li><p>这是一篇关于在计算机领域里，shells 概念的文章：</p><p><a href="http://en.wikipedia.org/wiki/Shell_(computing)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Shell_(computing)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章 引言</title>
      <link href="/2019/07/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80/"/>
      <url>/2019/07/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>I want to tell you a story.</p><p>我想给大家讲个故事。</p><p>No, not the story of how, in 1991, Linus Torvalds wrote the first version of the Linux kernel. You can read that story in lots of Linux books. Nor am I going to tell you the story of how, some years earlier, Richard Stallman began the GNU Project to create a free Unix-like operating system. That’s an important story too, but most other Linux books have that one, as well.</p><p>故事内容不是 Linus Torvalds 在1991年怎样写了 Linux 内核的第一个版本， 因为这些内容你可以在许多 Linux 书籍中读到。我也不是来告诉你，更早之前，Richard Stallman 是如何开始 GNU 项目，设计了一个免费的类Unix 的操作系统。那也是一个很有意义的故事， 但大多数 Linux 书籍也讲到了它。</p><p>No, I want to tell you the story of how you can take back control of your computer.</p><p>我想告诉大家一个你如何才能夺回计算机管理权的故事。</p><p>When I began working with computers as a college student in the late 1970s, there was a revolution going on. The invention of the microprocessor had made it possible for ordinary people like you and me to actually own a computer. It’s hard for many people today to imagine what the world was like when only big business and big government ran all the computers. Let’s just say, you couldn’t get much done.</p><p>在20世纪70年代末，我刚开始和计算机打交道时，正进行着一场革命，那时的我还是一名大学生。 微处理器的发明，使普通老百姓（就如你和我）真正拥有一台计算机成为可能。今天， 人们难以想象，只有大企业和强大的政府才能够拥有计算机的世界，是怎样的一个世界。 简单说，你做不了多少事情。</p><p>Today, the world is very different. Computers are everywhere, from tiny wristwatches to giant data centers to everything in between. In addition to ubiquitous computers, we also have a ubiquitous network connecting them together. This has created a wondrous new age of personal empowerment and creative freedom, but over the last couple of decades something else has been happening. A single giant corporation has been imposing its control over most of the world’s computers and deciding what you can and cannot do with them. Fortunately, people from all over the world are doing something about it. They are fighting to maintain control of their computers by writing their own software. They are building Linux.</p><p>今天，世界已经截然不同了。计算机遍布各个领域，从小手表到大型数据中心，及大小介于它们之间的每件东西。 除了随处可见的计算机之外，我们还有一个无处不在的连接所有计算机的网络。这已经开创了一个奇妙的， 个人授权和创作自由的新时代，但是在过去的二三十年里，正在发生另一些事情。一个大公司不断地把它的 管理权强加到世界上绝大多数的计算机上，并且决定你对计算机的操作权力。幸运地是，来自世界各地的人们， 正积极努力地做些事情来改变这种境况。通过编写自己的软件，他们一直在为维护电脑的管理权而战斗着。 他们建设着 Linux。</p><p>Many people speak of “freedom” with regard to Linux, but I don’t think most people know what this freedom really means. Freedom is the power to decide what your computer does, and the only way to have this freedom is to know what your computer is doing. Freedom is a computer that is without secrets, one where everything can be known if you care enough to find out.</p><p>一提到 Linux，许多人都会说到“自由”，但我不认为他们都知道“自由”的真正涵义。“自由”是一种权力， 它决定你的计算机能做什么，同时能够拥有这种“自由”的唯一方式就是知道计算机正在做什么。 “自由”是指一台没有任何秘密的计算机，你可以从它那里了解一切，只要你用心的去寻找。</p><h3 id="为什么使用命令行"><a href="#为什么使用命令行" class="headerlink" title="为什么使用命令行"></a>为什么使用命令行</h3><p>Have you ever noticed in the movies when the “super hacker,”— you know, the guy who can break into the ultra-secure military computer in under thirty seconds —sits down at the computer, he never touches a mouse? It’s because movie makers realize that we, as human beings, instinctively know the only way to really get anything done on a computer is by typing on a keyboard.</p><p>你是否注意到，在电影中一个“超级黑客”坐在电脑前，从不摸一下鼠标， 就能够在30秒内侵入到超安全的军用计算机中。这是因为电影制片人意识到， 作为人类，本能地知道让计算机圆满完成工作的唯一途径，是用键盘来操纵计算机。</p><p>Most computer users today are only familiar with the graphical user interface (GUI) and have been taught by vendors and pundits that the command line interface (CLI) is a terrifying thing of the past. This is unfortunate, because a good command line interface is a marvelously expressive way of communicating with a computer in much the same way the written word is for human beings. It’s been said that “graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible” and this is still very true today.</p><p>现在，大多数的计算机用户只是熟悉图形用户界面（GUI），并且产品供应商和此领域的学者会灌输给用户这样的思想， 命令行界面（CLI）是过去使用的一种很恐怖的东西。这就很不幸，因为一个好的命令行界面， 是用来和计算机进行交流沟通的非常有效的方式，正像人类社会使用文字互通信息一样。人们说，“图形用户界面让简单的任务更容易完成， 而命令行界面使完成复杂的任务成为可能”，到现在这句话仍然很正确。</p><p>Since Linux is modeled after the Unix family of operating systems, it shares the same rich heritage of command line tools as Unix. Unix came into prominence during the early 1980s (although it was first developed a decade earlier), before the widespread adoption of the graphical user interface and, as a result, developed an extensive command line interface instead. In fact, one of the strongest reasons early adopters of Linux chose it over, say, Windows NT was the powerful command line interface which made the “difficult tasks possible.”</p><p>因为 Linux 是以 Unix 家族的操作系统为模型写成的，所以它分享了 Unix 丰富的命令行工具。 Unix 在20世纪80年代初显赫一时(虽然，开发它在更早之前），结果，在普遍地使用图形界面之前， 开发了一种广泛的命令行界面。事实上，很多人选择 Linux（而不是其他的系统，比如说 Windows NT）是因为其可以使“完成复杂的任务成为可能”的强大的命令行界面。</p><h3 id="这本书讲什么"><a href="#这本书讲什么" class="headerlink" title="这本书讲什么"></a>这本书讲什么</h3><p>This book is a broad overview of “living” on the Linux command line. Unlike some books that concentrate on just a single program, such as the shell program, bash, this book will try to convey how to get along with the command line interface in a larger sense. How does it all work? What can it do? What’s the best way to use it?</p><p>这本书介绍如何生存在 Linux 命令行的世界。不像一些书籍仅仅涉及一个程序，比如像 shell 程序，bash。 这本书将试着向你传授如何与命令行界面友好相处。 它是怎样工作的？ 它能做什么？ 使用它的最好方法是什么？</p><p>This is not a book about Linux system administration. While any serious discussion of the command line will invariably lead to system administration topics, this book only touches on a few administration issues. It will, however, prepare the reader for additional study by providing a solid foundation in the use of the command line, an essential tool for any serious system administration task.</p><p><strong>这不是一本关于 Linux 系统管理的书</strong>。然而任何一个关于命令行的深入讨论，都一定会牵涉到 系统管理方面的内容，这本书仅仅提到一点儿管理方面的知识。但是这本书为读者准备好了学习更多内容的坚实基础， 毕竟要胜任系统管理工作也需要良好的命令行使用基本功。</p><p>This book is very Linux-centric. Many other books try to broaden their appeal by including other platforms such as generic Unix and MacOS X. In doing so, they “water down” their content to feature only general topics. This book, on the other hand, only covers contemporary Linux distributions. Ninety-five percent of the content is useful for users of other Unix-like systems, but this book is highly targeted at the modern Linux command line user.</p><p><strong>这本书是围绕 Linux 而写的</strong>。许多书籍，为了扩大自身的影响力，会包含一些其它平台的知识， 比如 Unix, MacOS X 等。这样做，很多内容只能比较空泛的去讲了。另一方面， 这本书只研究了当代 Linux 发行版。虽然，对于使用其它类 Unix 系统的用户来说， 书中95％的内容是有用的，但这本书主要面向的对象是现代 Linux 命令行用户。</p><h3 id="谁应该读这本书"><a href="#谁应该读这本书" class="headerlink" title="谁应该读这本书"></a>谁应该读这本书</h3><p>This book is for new Linux users who have migrated from other platforms. Most likely you are a “power user” of some version of Microsoft Windows. Perhaps your boss has told you to administer a Linux server, or maybe you’re just a desktop user who is tired of all the security problems and want to give Linux a try. That’s fine.here.All are welcome</p><p>这本书是为已经从其它平台移民到 Linux 系统的新手而写的。最有可能，你是使用某个 Windows 版本的高手。 或许是老板让你去管理一个 Linux 服务器，或许你只是一个桌面用户，厌倦了系统出现的各种 安全防御问题，而想要体验一下 Linux。很好，这里欢迎你们！</p><p>That being said, there is no shortcut to Linux enlightenment. Learning the command line is challenging and takes real effort. It’s not that it’s so hard, but rather it’s so vast. The average Linux system has literally thousands of programs you can employ on the command line. Consider yourself warned; learning the command line is not a casual endeavor.</p><p>不过一般来说，对于 Linux 的启蒙教育，没有捷径可言。学习命令行富于挑战性，而且很费气力。 这并不是说 Linux 命令行很难学，而是它的知识量很大，不容易掌握。Linux 操作系统， 差不多有数以千计的命令可供用户操作。由此可见，要给自己提个醒，命令行可不是轻轻松松就能学好的。</p><p>On the other hand, learning the Linux command line is extremely rewarding. If you think you’re a “power user” now, just wait. You don’t know what real power is — yet. And, unlike many other computer skills, knowledge of the command line is long lasting. The skills learned today will still be useful ten years from now. The command line has survived the test of time.</p><p>另一方面，学习 Linux 命令行会让你受益匪浅，给你极大的回报。如果你认为， 现在你已经是高手了。别急，其实你还不知道什么才是真正的高手。不像其他一些计算机技能， 一段时间之后可能就被淘汰了，命令行知识却不会落伍，你今天所学到的，在十年以后， 都会有用处。命令行通过了时间的考验。</p><p>It is also assumed that you have no programming experience, but not to worry, we’ll start you down that path as well.</p><p>如果你没有编程经验，也不要担心，我会带你入门。</p><h3 id="这本书的内容"><a href="#这本书的内容" class="headerlink" title="这本书的内容"></a>这本书的内容</h3><p>This material is presented in a carefully chosen sequence, much like a tutor sitting next to you guiding you along. Many authors treat this material in a “systematic” fashion, which makes sense from a writer’s perspective, but can be very confusing to new users.</p><p>这些材料是经过精心安排的，很像一位老师坐在你身旁，耐心地指导你。 许多作者用系统化的方式讲解这些材料，虽然从一个作者的角度考虑很有道理，但对于 Linux 新手来说， 他们可能会感到非常困惑。</p><p>Another goal is to acquaint you with the Unix way of thinking, which is different from the Windows way of thinking. Along the way, we’ll go on a few side trips to help you understand why certain things work the way they do and how they got that way. Linux is not just a piece of software, it’s also a small part of the larger Unix culture, which has its own language and history. I might throw in a rant or two, as well.</p><p>另一个目的，是想让读者熟悉 Unix 的思维方式，这种思维方式与 Windows 不同。在学习过程中， 我们会帮助你理解为什么某些命令那样工作，以及它们是如何工作的。 Linux 不仅是一款软件，也是 Unix 文化的一小部分，它有自己的语言和历史渊源。 同时，我也许会说些过激的话。</p><p>This book is divided into five parts, each covering some aspect of the command line experience. Besides the first part, which you are reading now, this book contains:</p><p>这本书共分为五部分，每一部分讲述了不同方面的命令行知识。除了第一部分， 也就是你正在阅读的这一部分，这本书还包括：</p><ul><li>Part 2 – Learning The Shell starts our exploration of the basic language of the command line including such things as the structure of commands, file system navigation, command line editing, and finding help and documentation for commands.</li><li>Part 3 – Configuration And The Environment covers editing configuration files that control the computer’s operation from the command line.</li><li>Part 4 – Common Tasks And Essential Tools explores many of the ordinary tasks that are commonly performed from the command line. Unix-like operating systems, such as Linux, contain many “classic” command line programs that are used to perform powerful operations on data.</li><li>Part 5 – Writing Shell Scripts introduces shell programming, an admittedly rudimentary, but easy to learn, technique for automating many common computing tasks. By learning shell programming, you will become familiar with concepts that can be applied to many other programming languages.</li><li>第二部分 — 学习 shell 开始探究命令行基本语言，包括命令组成结构， 文件系统浏览，编写命令行，查找命令帮助文档。</li><li>第三部分 — 配置文件及环境 讲述了如何编写配置文件，通过配置文件，用命令行来 操控计算机。</li><li>第四部分 — 常见任务及主要工具 探究了许多命令行经常执行的普通任务。类似于 Unix 的操作系统，例如 Linux, 包括许多经典的命令行程序，这些程序可以用来对数据进行 强大的操作。</li><li>第五部分 — 编写 Shell 脚本 介绍了 shell 编程，一个无可否认的基本技能，能够自动化许多 常见的计算任务，很容易学。通过学习 shell 编程，你会逐渐熟悉一些关于编程语言方面的概念， 这些概念也适用于其他的编程语言。</li></ul><h3 id="怎样阅读这本书"><a href="#怎样阅读这本书" class="headerlink" title="怎样阅读这本书"></a>怎样阅读这本书</h3><p>Start at the beginning of the book and follow it to the end. It isn’t written as a reference work, it’s really more like a story with a beginning, middle, and an end.</p><p>从头到尾的阅读。它并不是一本技术参考手册，实际上它更像一本故事书，有开头，过程，结尾。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>To use this book, all you will need is a working Linux installation. You can get this in one of two ways:</p><p>为了使用这本书，你需要安装 Linux 操作系统。你可以通过两种方式，来完成安装。</p><ol><li>Install Linux on a (not so new) computer. It doesn’t matter which distribution you choose, though most people today start out with either Ubuntu, Fedora, or . If in doubt, try Ubuntu first. Installing a modern Linux distribution can be ridiculously easy or ridiculously difficult depending on your hardware. I suggest a desktop computer that is a couple of years old and has at least 256 megabytes of RAM and 6 gigabytes of free hard disk space. Avoid laptops and wireless networks if at all possible, as these are often more difficult to get working.</li><li>Use a “Live CD.” One of the cool things you can do with many Linux distributions is run them directly from a CDROM without installing them at all. Just go into your BIOS setup and set your computer to “Boot from CDROM,” insert the live CD, and reboot. Using a live CD is a great way to test a computer for Linux compatibility prior to installation. The disadvantage of using a live CD is that it may be very slow compared to having Linux installed on your hard drive. Both Ubuntu and Fedora (among others) have live CD versions.</li><li>在一台（不用很新）的电脑上安装 Linux。你选择哪个 Linux 发行版安装，是无关紧要的事。 虽然大多数人一开始选择安装 Ubuntu, Fedora, 或者 OpenSUSE。如果你拿不定主意，那就先试试 Ubuntu。 由于主机硬件配置不同，安装 Linux 时，你可能不费吹灰之力就装上了，也可能费了九牛二虎之力还装不上。 所以我建议，一台使用了几年的台式机，至少要有256M 的内存，6G 的硬盘可用空间。尽可能避免使用 笔记本电脑和无线网络，在 Linux 环境下，它们经常不能工作。</li><li>使用“Live CD.” 许多 Linux 发行版都自带一个比较酷的功能，你可以直接从系统安装盘 CDROM 中运行 Linux， 而不必安装 Linux。开机进入 BIOS 设置界面，更改引导项，设置为“从 CDROM 启动”。</li></ol><p>Regardless of how you install Linux, you will need to have occasional superuser (i.e., administrative) privileges to carry out the lessons in this book.</p><p>不管你怎样安装 Linux，为了练习书中介绍的知识，你需要有超级用户（管理员）权限。</p><p>After you have a working installation, start reading and follow along with your own computer. Most of the material in this book is “hands on,” so sit down and get typing!</p><p>当你在自己的电脑上安装了 Linux 系统之后，就开始一边阅读本书，一边练习吧。本书大部分内容 都可以自己动手练习，坐下来，敲入命令，体验一下吧。</p><blockquote><p>Why I Don’t Call It “GNU/Linux”</p><p>In some quarters, it’s politically correct to call the Linux operating system the “GNU/Linux operating system.” The problem with “Linux” is that there is no completely correct way to name it because it was written by many different people in a vast, distributed development effort. Technically speaking, Linux is the name of the operating system’s kernel, nothing more. The kernel is very important of course, since it makes the operating system go, but it’s not enough to form a complete operating system.</p><p>Enter Richard Stallman, the genius-philosopher who founded the Free Software movement, started the Free Software Foundation, formed the GNU Project, wrote the first version of the GNU C Compiler (gcc), created the GNU General Public License (the GPL), etc., etc., etc. He insists that you call it “GNU/Linux” to properly reflect the contributions of the GNU Project. While the GNU Project predates the Linux kernel, and the project’s contributions are extremely deserving of recognition, placing them in the name is unfair to everyone else who made significant contributions. Besides, I think “Linux/GNU” would be more technically accurate since the kernel boots first and everything else runs on top of it.</p><p>In popular usage, “Linux” refers to the kernel and all the other free and open source software found in the typical Linux distribution; that is, the entire Linux ecosystem, not just the GNU components. The operating system marketplace seems to prefer one-word names such as DOS, Windows, MacOS, Solaris, Irix, AIX. I have chosen to use the popular format. If, however, you prefer to use “GNU/Linux” instead, please perform a mental search and replace while reading this book. I won’t mind.</p><p>为什么我不叫它“GNU/Linux”</p><p>在某些领域，把 Linux 操作系统称为“GNU/Linux 操作系统”， 则政治立场正确。但“Linux”的问题是， 没有一个完全正确的方式能命名它，因为它是由许许多多，分布在世界各地的贡献者们，合作开发而成的。 从技术层面讲，Linux 只是操作系统的内核名字，没别的含义。当然内核非常重要，因为有它， 操作系统才能运行起来，但它并不能构成一个完备的操作系统。</p><p>Richard Stallman 是一个天才的哲学家，自由软件运动创始人，自由软件基金会创办者，他创建了 GNU 工程， 编写了第一版 GNU C 编译器（gcc），创立了 GNU 通用公共协议（the GPL)等等。 他坚持把 Linux 称为“GNU/Linux”，为的是准确地反映 GNU 工程对 Linux 操作系统的贡献。 然而，尽管 GNU 项目早于 Linux 内核，项目的贡献应该得到极高的赞誉，但是把 GNU 用在 Linux 名字里， 这对其他为 Linux 的发展做出重大贡献的程序员来说，就不公平了。而且，我觉得要是叫也要叫 “Linux/GNU” 比较准确一些， 因为内核会先启动，其他一切都运行在内核之上。</p><p>在目前流行的用法中，“Linux”指的是内核以及在一个典型的 Linux 发行版中所包含的所有免费及开源软件； 也就是说，整个 Linux 生态系统，不只有 GNU 项目软件。在操作系统商界，好像喜欢使用单个词的名字， 比如说 DOS, Windows, MacOS, Solaris, Irix, AIX. 所以我选择用流行的命名规则。然而， 如果你喜欢用“GNU/Linux”，当你读这本书时，可以在脑子里搜索并替换“Linux”。我不介意。</p></blockquote><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>Here are some Wikipedia articles on the famous people mentioned in this chapter:</p><p>Wikipedia 网站上有些介绍本章提到的名人的文章，以下是链接地址：</p><ul><li><a href="http://en.wikipedia.org/wiki/Linux_Torvalds" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Linux_Torvalds</a></li><li><a href="http://en.wikipedia.org/wiki/Richard_Stallman" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Richard_Stallman</a></li></ul><p>The Free Software Foundation and the GNU Project:</p><p>介绍自由软件基金会及 GNU 项目的网站和文章：</p><ul><li><a href="http://en.wikipedia.org/wiki/Free_Software_Foundation" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Free_Software_Foundation</a></li><li><a href="http://www.fsf.org/" target="_blank" rel="noopener">http://www.fsf.org</a></li><li><a href="http://www.gnu.org/" target="_blank" rel="noopener">http://www.gnu.org</a></li></ul><p>Richard Stallman has written extensively on the “GNU/Linux” naming issue:</p><p>Richard Stallman 用了大量的文字来叙述“GNU/Linux”的命名问题，可以浏览以下网页：</p><ul><li><a href="http://www.gnu.org/gnu/why-gnu-linux.html" target="_blank" rel="noopener">http://www.gnu.org/gnu/why-gnu-linux.html</a></li><li><a href="http://www.gnu.org/gnu/gnu-linux-faq.html#tools" target="_blank" rel="noopener">http://www.gnu.org/gnu/gnu-linux-faq.html#tools</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> TLCL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git起步</title>
      <link href="/2019/07/15/Git%E8%B5%B7%E6%AD%A5/"/>
      <url>/2019/07/15/Git%E8%B5%B7%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><p><img src="https://git-scm.com/book/en/v2/images/local.png" alt="本地版本控制图解"></p><p>Figure 1. 本地版本控制.</p><p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 <code>rcs</code> 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p><p><img src="https://git-scm.com/book/en/v2/images/centralized.png" alt="集中化的版本控制图解"></p><p>Figure 2. 集中化的版本控制.</p><p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p><img src="https://git-scm.com/book/en/v2/images/distributed.png" alt="分布式版本控制图解"></p><p>Figure 3. 分布式版本控制.</p><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><h2 id="Git简史"><a href="#Git简史" class="headerlink" title="Git简史"></a>Git简史</h2><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统（参见 <a href>Git 分支</a>）。</p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><p>那么，简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在开始学习 Git 的时候，请努力分清你对其它版本管理系统的已有认识，如 Subversion 和 Perforce 等；这么做能帮助你使用工具时避免发生混淆。 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><p><img src="https://git-scm.com/book/en/v2/images/deltas.png" alt="存储每个文件与初始版本的差异。"></p><p>Figure 4. 存储每个文件与初始版本的差异.</p><p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p><p><img src="https://git-scm.com/book/en/v2/images/snapshots.png" alt="Git 存储项目随时间改变的快照。"></p><p>Figure 5. 存储项目随时间改变的快照.</p><p>这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 稍后我们在<a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a>讨论 Git 分支管理时，将探究这种方式对待数据所能获得的益处。</p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。 因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这也意味着你离线或者没有 VPN 时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。 如你回家后 VPN 客户端不正常，你仍能工作。 使用其它系统，做到如此是不可能或很费力的。 比如，用 Perforce，你没有连接服务器时几乎不能做什么事；用 Subversion 和 CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。 这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。</p><h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p><pre><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre><p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a>Git 一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考<a href="https://git-scm.com/book/zh/v2/ch00/r_undoing" target="_blank" rel="noopener">撤消操作</a>。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>好，请注意。 如果你希望后面的学习更顺利，记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="工作目录、暂存区域以及 Git 仓库。"></p><p>Figure 6. 工作目录、暂存区域以及 Git 仓库.</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><p>如果 Git 目录中保存着特定版本的文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在<a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics" target="_blank" rel="noopener">Git 基础</a>一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>Git 有多种使用方式。 你可以使用原生的命令行模式，也可以使用 GUI 模式，这些 GUI 软件也能提供多种功能。 在本书中，我们将使用命令行模式。 这是因为首先，只有在命令行模式下你才能执行 Git 的 <strong>所有</strong> 命令，而大多数的 GUI 软件只实现了 Git 所有功能的一个子集以降低操作难度。 如果你学会了在命令行下如何操作，那么你在操作 GUI 软件时应该也不会遇到什么困难，但是，反之则不成立。 此外，由于每个人的想法与侧重点不同，不同的人常常会安装不同的 GUI 软件，但 <em>所有</em> 人一定会有命令行工具。</p><p>假如你是 Mac 用户，我们希望你懂得如何使用终端（Terminal）；假如你是 Windows 用户，我们希望你懂得如何使用命令窗口（Command Prompt）或 PowerShell。 如果你尚未掌握以上技能，我们建议你先停下来快速学习一下，本书中的讲述和举例将用到这些技能。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>在你开始使用 Git 前，需要将它安装在你的计算机上。 即便已经安装，最好将它升级到最新的版本。 你可以通过软件包或者其它安装程序来安装，或者下载源码编译安装。</p><table><thead><tr><th>Note</th><th>本书写作时使用的 Git 版本为 <strong>2.0.0</strong>。 我们使用的大部分命令仍然可以在很古老的 Git 版本上使用，但也有少部分命令不好用或者在旧版本中的行为有差异。 因为 Git 在保持向后兼容方面表现很好，本书使用的这些命令在 2.0 之后的版本应该有效。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="在-Linux-上安装"><a href="#在-Linux-上安装" class="headerlink" title="在 Linux 上安装"></a>在 Linux 上安装</h3><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以 Fedora 上为例，你可以使用 yum：</p><pre class=" language-console"><code class="language-console">  $ sudo yum install git</code></pre><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p><pre class=" language-console"><code class="language-console">  $ sudo apt-get install git</code></pre><p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="http://git-scm.com/download/linux。" target="_blank" rel="noopener">http://git-scm.com/download/linux。</a></p><h3 id="在-Mac-上安装"><a href="#在-Mac-上安装" class="headerlink" title="在 Mac 上安装"></a>在 Mac 上安装</h3><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 <em>git</em> 命令即可。 如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac。" target="_blank" rel="noopener">http://git-scm.com/download/mac。</a></p><p><img src="https://git-scm.com/book/en/v2/images/git-osx-installer.png" alt="Git OS X 安装程序。"></p><p>Figure 7. Git OS X 安装程序.</p><p>你也可以将它作为 GitHub for Mac 的一部分来安装。 它们的图形化 Git 工具有一个安装命令行工具的选项。 你可以从 GitHub for Mac 网站下载该工具，网址为 <a href="http://mac.github.com/" target="_blank" rel="noopener">http://mac.github.com</a>。</p><h3 id="在-Windows-上安装"><a href="#在-Windows-上安装" class="headerlink" title="在 Windows 上安装"></a>在 Windows 上安装</h3><p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a href="http://git-scm.com/download/win，下载会自动开始。" target="_blank" rel="noopener">http://git-scm.com/download/win，下载会自动开始。</a> 要注意这是一个名为 Git for Windows的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a href="http://msysgit.github.io/。" target="_blank" rel="noopener">http://msysgit.github.io/。</a></p><p>另一个简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的 CRLF 设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a href="http://windows.github.com/" target="_blank" rel="noopener">http://windows.github.com</a>。</p><h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><p>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。</p><p>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p><pre class=" language-console"><code class="language-console">  $ sudo yum install curl-devel expat-devel gettext-devel \    openssl-devel zlib-devel  $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \    libz-dev libssl-dev</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p><pre class=" language-console"><code class="language-console">  $ sudo yum install asciidoc xmlto docbook2x  $ sudo apt-get install asciidoc xmlto docbook2x</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href="https://www.kernel.org/pub/software/scm/git，或从" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href="https://github.com/git/git/releases。" target="_blank" rel="noopener">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。</p><p>接着，编译并安装：</p><pre class=" language-console"><code class="language-console">  $ tar -zxf git-2.0.0.tar.gz  $ cd git-2.0.0  $ make configure  $ ./configure --prefix=/usr  $ make all doc info  $ sudo make install install-doc install-html install-info</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p><pre class=" language-console"><code class="language-console">  $ git clone git://git.kernel.org/pub/scm/git/git.git</code></pre><h2 id="初次运行Git前的配置"><a href="#初次运行Git前的配置" class="headerlink" title="初次运行Git前的配置"></a>初次运行Git前的配置</h2><p>既然已经在系统上安装了 Git，你会想要做几件事来定制你的 Git 环境。 每台计算机上只需要配置一次，程序升级时会保留配置信息。 你可以在任何时候再次通过运行命令来修改它们。</p><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code>选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li></ol><p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><pre class=" language-console"><code class="language-console">$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com</code></pre><p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><pre class=" language-console"><code class="language-console">$ git config --global core.editor emacs</code></pre><table><thead><tr><th>Warning</th><th>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><pre class=" language-console"><code class="language-console">$ git config --listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto...</code></pre><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><pre class=" language-console"><code class="language-console">$ git config user.nameJohn Doe</code></pre><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p><pre class=" language-console"><code class="language-console">$ git help <verb>$ git <verb> --help$ man git-<verb></code></pre><p>例如，要想获得 config 命令的手册，执行</p><pre class=" language-console"><code class="language-console">$ git help config</code></pre><p>这些命令很棒，因为你随时随地可以使用而无需联网。 如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器（ irc.freenode.net ）的 <code>#git</code> 或 <code>#github</code> 频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你应该已经对 Git 是什么、Git 与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。 现在，在你的个人系统中应该也有了一份能够工作的 Git 版本。 是时候开始学习有关 Git 的基础知识了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装deepin之后的环境、软件安装（不断更新）</title>
      <link href="/2019/07/12/%E5%AE%89%E8%A3%85deepin%E4%B9%8B%E5%90%8E%E7%9A%84%E7%8E%AF%E5%A2%83%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2019/07/12/%E5%AE%89%E8%A3%85deepin%E4%B9%8B%E5%90%8E%E7%9A%84%E7%8E%AF%E5%A2%83%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="C-编译环境"><a href="#C-编译环境" class="headerlink" title="C++编译环境"></a>C++编译环境</h3><p><strong>安装：</strong></p><p><code>sudo apt-get install g++</code></p><p><strong>使用：</strong></p><p>编写cpp文件如hello.cpp</p><p>cd到hello.cpp文件所在目录</p><p>执行<code>g++ hello.cpp</code>        自动生成一个a.out文件        运行输入 ./a.out</p><p>执行<code>g++ hello.cpp -o hello</code>    生成一个hello文件        运行输入 ./hello</p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p><strong>安装：</strong></p><p>从 <a href="https://www.anaconda.com/" target="_blank" rel="noopener">anaconda官网</a> 下载最新linux版本，形如Anaconda3-2019.03-Linux-x86_64.sh</p><p><code>sh Anaconda3-2019.03-Linux-x86_64.sh</code> 进行安装</p><p><strong>配置环境：</strong></p><p>编辑文件</p><p><code>sudo vim /etc/profile</code></p><p>末尾添加如下:</p><pre><code># Anacondaexport PATH=/home/sk/anaconda3/bin:$PATH</code></pre><p>刷新配置</p><p><code>source /etc/profile</code></p><p><strong>使用：</strong></p><p><code>jupyter notebook</code></p><h3 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h3><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">jdk官网</a> 下载deb安装包</p><p>deepin可以直接使用软件包管理器傻瓜式安装</p><p>默认安装在/usr/lib/jvm/jdkxxxx</p><p><code>sudo vim /etc/profile</code></p><p>或<code>sudo vim /etc/bash.bashrc</code></p><p>末尾添加如下（只需更改jdk-12.0.1即可）</p><pre class=" language-b"><code class="language-b"># jdk环境变量JAVA_HOME=/usr/lib/jvm/jdk-12.0.1CLASSPATH=.:$JAVA_HOME/bin.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH</code></pre><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs官网</a> 下载tar.gz版</p><p>cd到安装包所在目录，依次执行下列语句</p><p><code>tar  xf node-v5.10.1-linux-x64.tar.gz -C /usr/local/</code></p><p><code>cd /sur/local/</code></p><p><code>mv node-v5.10.1-linux-x64/ nodejs</code></p><p><code>ln -s /usr/local/nodejs/bin/node /usr/local/bin</code><br><code>ln -s /usr/local/nodejs/bin/npm /usr/local/bin</code></p><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p><code>sudo apt-get install git</code></p><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p><code>sudo npm install hexo-cli -g</code></p><p>将hexo命令添加到全局：hexo在nodejs的lib/node_modules/hexo-cli/bin</p><p>采用软连接的方式：</p><p><code>sudo ln -s /usr/local/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</code></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>windows10中的字体在C:\Windows\Fonts中</p><p>复制到linux系统的/usr/share/fonts/目录下新建的windows-fonts文件夹下</p><p>刷新字体</p><p><code>fc-cache</code></p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="md编辑器Tupora"><a href="#md编辑器Tupora" class="headerlink" title="md编辑器Tupora"></a>md编辑器Tupora</h3><p>官网给出的下载语句</p><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/markdown/Typora.jpg" alt></p><p>在<strong>deepin</strong>上的语句应为：</p><p><code>wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</code></p><p><code>sudo vim /etc/apt/source.list</code></p><p>在文件末尾添加</p><pre><code># add Typora&#39;s repositorydeb https://typora.io/linux ./</code></pre><p>保存退出，运行 <code>sudo apt-get update</code></p><p>运行安装程序 <code>sudo apt-get install typora</code></p><h3 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h3><p><code>sudo apt-get install mysql-server mysql-client</code></p><p>查看user和password内容</p><p><code>sudo cat /etc/mysql/debian.cnf</code></p><p><code>mysql -u 用户名 -p 密码</code></p><p><code>update mysql.user set plugin=&quot;mysql_native_password&quot; where user=&quot;root&quot;;</code></p><p>设置mysql登录密码</p><p><code>update mysql.user set authentication_string=password(&#39;你自己设的密码&#39;) where user=&#39;root&#39;and Host = &#39;localhost&#39;;</code></p><p>退出mysql</p><p><code>exit;</code></p><p>重启数据库</p><p><code>sudo service mysql restart</code></p><p>登录</p><p><code>mysql -u root -p</code></p><p>输入密码</p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p><a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="noopener">官网 </a>下载最新版tar.gz包</p><p><code>cd /opt</code></p><p><code>sudo mkdir idea</code></p><p>把软件包复制到idea目录下</p><p><code>cd idea</code></p><p><code>sudo tar -zxvf ideaIU-2019.1.3.tar.gz</code></p><p><code>cd ideaIU-2019.1.3/bin</code></p><p><code>sudo ./idea.sh</code></p><p>启动：</p><p><code>cd /opt/idea/idea-IU-191.7479.19/bin</code></p><p><code>./idea.sh</code></p><p>快捷图标设置：</p><p>略</p><p><strong>激活：</strong></p><blockquote><p>==</p><p>您好！感谢光临小店，订单508717440769201932</p><p>网站实时获取激活码（因激活码太长，请务必用电脑打开网址）<br><a href="http://www.100c1.com/portal/page/index/id/2.html" target="_blank" rel="noopener">http://www.100c1.com/portal/page/index/id/2.html</a><br>打开网址，输入订单号，获取激活码。<br>凭订单号  终身享受获取激活资格<br>网站激活码下方有下载，安装，汉化，教程的链接<br>-——————————————————————–<br>（如果您以前破解过，会导致激活不成功，请看这里解决<br><a href="http://www.100c1.com/portal/article/index/id/30.html）" target="_blank" rel="noopener">http://www.100c1.com/portal/article/index/id/30.html）</a></p><p>记得再来哦~~^0^</p><p>==</p></blockquote><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">官网</a> 下载，我下载的是apache-tomcat-8.5.42.tar.gz</p><p>下载后复制到opt下新建的tomcat文件夹下并解压</p><p><code>tar -zxvf apache-tomcat-8.5.42.tar.gz</code></p><p><code>cd /opt/tomcat/apache-tomcat-8.5.42/bin</code></p><p>开启服务：</p><p><code>./startup.sh</code></p><p>关闭服务：</p><p><code>./shutdown.sh</code></p><h3 id="XMind-ZEN"><a href="#XMind-ZEN" class="headerlink" title="XMind ZEN"></a>XMind ZEN</h3><p><strong>安装：</strong></p><p><a href="https://www.xmind.net/zen/" target="_blank" rel="noopener">官网</a> 下载deb包</p><p>拖入到软件包管理器中自动安装</p><p><strong>去水印：</strong></p><p><code>cd /opt/XMind ZEN/resources/app/out</code></p><ul><li>pdf-footer-zh-CN.svg</li><li>png-watermark-zh-CN.svg</li><li>print-watermark-zh-CN.svg</li></ul><p>将这三个文件的通过文本编辑器打开，删除文件中的内容</p>]]></content>
      
      
      <categories>
          
          <category> deepin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deepin </tag>
            
            <tag> 环境 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/11/hello-world/"/>
      <url>/2019/07/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/05/09/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/09/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-标题-Headers"><a href="#1-标题-Headers" class="headerlink" title="1.标题(Headers)"></a>1.标题(Headers)</h2><blockquote><p>Markdown 标题支持两种形式：</p></blockquote><h3 id="1-1用-6个-标记"><a href="#1-1用-6个-标记" class="headerlink" title="1.1用~6个#标记"></a>1.1用~6个#标记</h3><blockquote><p>在 标题开头 加上1~6个#，依次代表一级标题、二级标题….六级标题</p></blockquote><pre><code># 一级标题 `&lt;h1&gt;`## 二级标题 `&lt;h2&gt;`### 三级标题 `&lt;h3&gt;`#### 四级标题 `&lt;h4&gt;`##### 五级标题 `&lt;h5&gt;`###### 六级标题 `&lt;h6&gt;`</code></pre><a id="more"></a><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="1-2用-和-标记"><a href="#1-2用-和-标记" class="headerlink" title="1.2用=和-标记"></a>1.2用=和-标记</h3><blockquote><p>在 标题底下 加上任意个=代表一级标题，-代表二级标题</p></blockquote><pre><code>一级标题========二级标题---------</code></pre><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h2 id="2-列表-Lists"><a href="#2-列表-Lists" class="headerlink" title="2.列表(Lists)"></a>2.列表(Lists)</h2><blockquote><p>Markdown 支持有序列表和无序列表。</p></blockquote><h3 id="2-1无序列表-Unordered-Lists"><a href="#2-1无序列表-Unordered-Lists" class="headerlink" title="2.1无序列表(Unordered Lists)"></a>2.1无序列表(Unordered Lists)</h3><blockquote><p>无序列表使用-、+和*作为列表标记：</p></blockquote><pre><code>- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue</code></pre><ul><li>Red</li><li>Green</li><li>Blue</li></ul><ul><li>Red</li><li>Green</li><li>Blue</li></ul><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="2-2有序列表-Ordered-Lists"><a href="#2-2有序列表-Ordered-Lists" class="headerlink" title="2.2有序列表(Ordered Lists)"></a>2.2有序列表(Ordered Lists)</h3><blockquote><p>有序列表则使用数字加英文句点来表示：</p></blockquote><pre><code>1. Red2. Green5. 不管前面序号对错依次排列</code></pre><ol><li>Red</li><li>Green</li><li>不管前面序号对错依次排列</li></ol><h3 id="2-3列表嵌套"><a href="#2-3列表嵌套" class="headerlink" title="2.3列表嵌套"></a>2.3列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ol><li>二级有序列表内容</li></ol></li></ol><h2 id="3-引用-Reference"><a href="#3-引用-Reference" class="headerlink" title="3.引用(Reference)"></a>3.引用(Reference)</h2><blockquote><p>引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语<br>法。</p></blockquote><h3 id="3-1常见的引用方法："><a href="#3-1常见的引用方法：" class="headerlink" title="3.1常见的引用方法："></a>3.1常见的引用方法：</h3><pre><code>&gt; 这是一段引用    //在`&gt;`后面有 1 个空格&gt; &gt;     这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre><blockquote><p>这是一段引用    //在<code>&gt;</code>后面有 1 个空格</p><pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre></blockquote><pre><code>&gt; 代码例子：&gt;       protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    }</code></pre><blockquote><p>代码例子：</p><pre><code>protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}</code></pre></blockquote><h3 id="3-2分级引用"><a href="#3-2分级引用" class="headerlink" title="3.2分级引用"></a>3.2分级引用</h3><pre><code>&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; #### 这是一个四级标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol></blockquote><blockquote><p>建立多级列表时，每个子级别都要比上个级别前面多打2个以上空格。<br>在 「 * 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。<br>有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。<br>注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其<br>作为标记。</p></blockquote><h2 id="4-文字样式-Text-Styling"><a href="#4-文字样式-Text-Styling" class="headerlink" title="4.文字样式(Text Styling)"></a>4.文字样式(Text Styling)</h2><h3 id="4-1基本语法"><a href="#4-1基本语法" class="headerlink" title="4.1基本语法"></a>4.1基本语法</h3><blockquote><p>两个或-代表加粗，一个或-代表斜体，~~代表删除。</p></blockquote><pre><code>**加粗的文字**  或者 __加粗的文字__*倾斜的文字* 或者 _倾斜的文字_***斜体加粗的文字*** 或者 ___斜体加粗的文字___~~加删除线的文字~~:==高亮 #807700==  或者 ==高亮==`底纹`</code></pre><p><strong>加粗的文字</strong>  或者 <strong>加粗的文字</strong></p><p><em>倾斜的文字</em> 或者 <em>倾斜的文字</em></p><p><strong><em>斜体加粗的文字</em></strong> 或者 <strong><em>斜体加粗的文字</em></strong></p><p><del>加删除线的文字</del></p><p> :==高亮 #807700==  或者 ==高亮==</p><p><code>底纹</code></p><h3 id="4-2非基本语法"><a href="#4-2非基本语法" class="headerlink" title="4.2非基本语法"></a>4.2非基本语法</h3><p>字体上标（superscript）和下标（subscript ）</p><h4 id="4-2-1简书上，字体上、下标的语法为："><a href="#4-2-1简书上，字体上、下标的语法为：" class="headerlink" title="4.2.1简书上，字体上、下标的语法为："></a>4.2.1简书上，字体上、下标的语法为：</h4><pre><code>&lt;sup&gt;上标文字&lt;/sup&gt;&lt;sub&gt;下标文字&lt;/sup&gt;</code></pre><p><sup>上标文字</sup></p><p><sub>下标文字</sub></p><h4 id="4-2-2Typora中，字体上、下标的语法为："><a href="#4-2-2Typora中，字体上、下标的语法为：" class="headerlink" title="4.2.2Typora中，字体上、下标的语法为："></a>4.2.2Typora中，字体上、下标的语法为：</h4><pre><code>这是^上标文字^这是~下标文字~</code></pre><p>这是^上标文字^</p><p>这是<del>下标文字</del></p><h2 id="5-图片与链接-Image-amp-Links"><a href="#5-图片与链接-Image-amp-Links" class="headerlink" title="5.图片与链接(Image &amp; Links)"></a>5.图片与链接(Image &amp; Links)</h2><blockquote><p>图片与链接的语法很像，区别在一个 ! 号。</p><p>注：Markdown 不能设置图片大小，如果必须设置则应使用HTML标记 &lt; img &gt;</p></blockquote><pre><code>图片：![]() ![图片描述(可忽略)](链接的地址)链接：[]() [链接描述](链接的地址)This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link.<br><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><blockquote><p>链接又分为行内式、参考式和 自动链接：</p><blockquote><p>内联（Inline）：以中括号[]标记显示的链接文本，后面紧跟用小括号()包围的链接。 如果链接 Title 属性，则在链接中使用空格加”Title 属性”，即Title。</p></blockquote></blockquote><pre><code>这是行内式链接：[Mou](http://25.io/mou/)。这是参考式链接：[Mou][url]，其中url为链接标记，可置于文中任意位置。[url]: 25.io/mou/</code></pre><p>这是行内式链接：<a href="http://25.io/mou/" target="_blank" rel="noopener">Mou</a>。</p><p>这是参考式链接：<a href="25.io/mou/">Mou</a>，其中url为链接标记，可置于文中任意位置。</p><blockquote><p>链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)</p></blockquote><pre><code>这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://25.io/mou/&gt;</code></pre><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="http://25.io/mou/" target="_blank" rel="noopener">http://25.io/mou/</a></p><pre><code>这是图片：![][Mou icon][Mou icon]: http://mouapp.com/Mou_128.png</code></pre><p>这是图片：<img src="http://mouapp.com/Mou_128.png" alt></p><pre><code>添加图片的使用方法基本上和链接类似，只是在中括号前加叹号!，即![Image Title](URL &quot;Image Title&quot;)。</code></pre><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557646743750&di=509ba5d2314d2b87ff6697e2dc36614e&imgtype=0&src=http%3A%2F%2Fcdn.ifanr.cn%2Fwp-content%2Fuploads%2F2014%2F06%2Fgithub.png" alt="GitHub Mark"></p><p>注：Markdown本身语法不支持链接在新页面中打开，有些平台可以，而有些平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><pre><code>&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</code></pre><p>示例<br><a href="https://github.com/chenshuoke" target="_blank">我的Github</a></p><h2 id="6-代码块引用-Fenced-Code-Blocks"><a href="#6-代码块引用-Fenced-Code-Blocks" class="headerlink" title="6.代码块引用(Fenced Code Blocks)"></a>6.代码块引用(Fenced Code Blocks)</h2><blockquote><p>代码分为行内代码和代码块。</p></blockquote><h3 id="6-1行内代码"><a href="#6-1行内代码" class="headerlink" title="6.1行内代码"></a>6.1行内代码</h3><blockquote><p>` 符号位于Tab键上方，1键左边</p></blockquote><blockquote><p>行内代码使用 <code>代码</code> 标识，可嵌入文字中<br>需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。</p></blockquote><pre><code>`Hello world`</code></pre><p><code>Hello world</code></p><h3 id="6-2代码框"><a href="#6-2代码框" class="headerlink" title="6.2代码框"></a>6.2代码框</h3><blockquote><p>两对```包裹,如果引用的语句为多行，可以将 置于这段代码的首行和末行。<br>代码前加四个空格键<br>代码前加一个 tab 键</p></blockquote><pre><code>Code Line 1Code Line 2Code Line 3</code></pre><p>代码语法高亮在```后面加上空格和语言名称即可</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="7-表格-Tables"><a href="#7-表格-Tables" class="headerlink" title="7.表格(Tables)"></a>7.表格(Tables)</h2><blockquote><p>表格对齐格式<br>居左：:—-<br>居中：:—-:或—–<br>居右：—-:<br>例子：</p></blockquote><pre><code>|标题|标题|标题||:---|:---:|---:||居左文本|居中文本|居右文本|</code></pre><table><thead><tr><th align="left">标题</th><th align="center">标题</th><th align="right">标题</th></tr></thead><tbody><tr><td align="left">居左文本</td><td align="center">居中文本</td><td align="right">居右文本</td></tr></tbody></table><h2 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8.分隔线"></a>8.分隔线</h2><p>在一行中用三个以上的、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。<br>在一行中使用三个或三个以上的、-或_可以添加分隔线，中间插入空格，但是不能有其他字符。</p><pre><code>***---_____* * *</code></pre><hr><hr><hr><hr><blockquote><p>效果均为一条分割线</p></blockquote><h2 id="9-脚注-注解-Footnotes"><a href="#9-脚注-注解-Footnotes" class="headerlink" title="9.脚注|注解(Footnotes)"></a>9.脚注|注解(Footnotes)</h2><h3 id="9-1使用-来定义脚注："><a href="#9-1使用-来定义脚注：" class="headerlink" title="9.1使用[^]来定义脚注："></a>9.1使用[^]来定义脚注：</h3><pre><code>这是一个脚注的例子[^1][^1]: 这里是脚注</code></pre><p>这是一个脚注的例子[^1]<br>[^1]: 这里是脚注</p><blockquote><p>该页面不支持，遂用图片显示</p></blockquote><img align="left" src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/markdown/Footnotes.jpg"><br>### 9.2注释<p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。</p><pre><code>&lt;!--注释--&gt;</code></pre><h2 id="10-常用弥补Markdown的Html标签"><a href="#10-常用弥补Markdown的Html标签" class="headerlink" title="10.常用弥补Markdown的Html标签"></a>10.常用弥补Markdown的Html标签</h2><h3 id="10-1字体"><a href="#10-1字体" class="headerlink" title="10.1字体"></a>10.1字体</h3><pre><code>&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</code></pre><p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font><br><font color="#0000ff">字体颜色</font></p><h3 id="10-2换行"><a href="#10-2换行" class="headerlink" title="10.2换行"></a>10.2换行</h3><pre><code>使用html标签`&lt;br/&gt;`&lt;br/&gt;换行</code></pre><p>使用html标签<code>&lt;br/&gt;</code><br>换行</p><h3 id="10-3文本对齐方式"><a href="#10-3文本对齐方式" class="headerlink" title="10.3文本对齐方式"></a>10.3文本对齐方式</h3><pre><code>&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;</code></pre><p align="left">居左文本</p><p align="center">居中文本</p><p align="right">居右文本</p>### 10.4下划线<pre><code>&lt;u&gt;下划线文本&lt;/u&gt;</code></pre><p><u>下划线文本</u></p><h2 id="11-任务列表"><a href="#11-任务列表" class="headerlink" title="11.任务列表"></a>11.任务列表</h2><pre><code>【减号+[+空格或x+]+空格】- [ ] [links](), **formatting**, and ~~tags~~ supported- [x] list syntax required (any unordered or ordered list supported)- [ ] this is a complete item- [x] this is an incomplete item</code></pre><ul><li><input disabled type="checkbox"> <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li><li><input checked disabled type="checkbox"> list syntax required (any unordered or ordered list supported)</li><li><input disabled type="checkbox"> this is a complete item</li><li><input checked disabled type="checkbox"> this is an incomplete item</li></ul><p>注：简书不支持该语法，Typora、Day One 2、马克飞象、Cmd Markdown等编辑器支持。</p><h2 id="12-转义字符-Backslash-Escapes"><a href="#12-转义字符-Backslash-Escapes" class="headerlink" title="12.转义字符(Backslash Escapes)"></a>12.转义字符(Backslash Escapes)</h2><blockquote><p>Markdown 可以利用反斜杠\来插入一些在语法中有其它意义的符号，例如：如果想要用星号加在文字旁边的方式来做出强调效果，可以在星号的前面加上反斜杠：</p></blockquote><pre><code>\*literal asterisks\*</code></pre><p>*literal asterisks*</p><h2 id="13-流程图-Flow-Chart"><a href="#13-流程图-Flow-Chart" class="headerlink" title="13.流程图(Flow Chart)"></a>13.流程图(Flow Chart)</h2><ul><li>流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素)<br></li><li>创建流程（元素）：tag=&gt;type: content:&gt;url<ul><li>tag 是流程图中的标签，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。</li><li>type 用来确定标签的类型，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型</li><li>标签有6种类型：start end operation subroutine condition inputoutput</li><li>content 是流程图文本框中的描述内容，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格</li><li>url是一个连接，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面<br></li></ul></li><li>指向流程(连接元素)：标识（类别）-&gt;下一个标识<ul><li>使用 -&gt; 来连接两个元素</li><li>对于condition类型，有yes和no两个分支，如示例中的cond(yes)和cond(no)</li><li>每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。<br></li></ul></li></ul><pre class=" language-flow"><code class="language-flow">st=>start: 开始op=>operation: My Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op</code></pre><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/markdown/FlowChart1.jpg" alt></p><pre class=" language-flow"><code class="language-flow">st=>start: 开始e=>end: 登录io1=>inputoutput: 输入用户名密码sub1=>subroutine: 数据库查询子类cond=>condition: 是否有此用户cond2=>condition: 密码是否正确op=>operation: 读入用户信息st->io1->sub1->condcond(yes,right)->cond2cond(no)->io1(right)cond2(yes,right)->op->econd2(no)->io1</code></pre><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/markdown/FlowChart2.jpg" alt></p><pre class=" language-flow"><code class="language-flow">st=>start: Start:>https://www.jpjbp.com/io=>inputoutput: verificationop=>operation: Your Operationcond=>condition: Yes or No?sub=>subroutine: Your Subroutinee=>endst->io->op->condcond(yes)->econd(no)->sub->io</code></pre><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/markdown/FlowChart3.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android组件之Fragment、FragmentTabHost</title>
      <link href="/2019/05/08/Android%E7%BB%84%E4%BB%B6%E4%B9%8BFragment%E3%80%81FragmentTabHost/"/>
      <url>/2019/05/08/Android%E7%BB%84%E4%BB%B6%E4%B9%8BFragment%E3%80%81FragmentTabHost/</url>
      
        <content type="html"><![CDATA[<h2 id="Fragment和FtagmentTabHost的用法"><a href="#Fragment和FtagmentTabHost的用法" class="headerlink" title="Fragment和FtagmentTabHost的用法"></a>Fragment和FtagmentTabHost的用法</h2><p>结合<strong>Fragment</strong>与<strong>FragmentTabHost</strong>实现如图所示程序界面和<strong>底部菜单栏</strong>功能</p><p>底部菜单栏有5个按钮，程序启动时默认进入主页按钮页面，该页面采用Fragment实现</p><p>按不同的按钮，可以在不同的界面切换，每个界面都采用Fragment实现。</p><p>另外，每个按钮具有两种不同的状态。其他界面分别采用线性布局、相对布局、表布局与网格布局设计</p><center class="half"><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_1.png" height="500" width="240"> <a id="more"></a> <img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_2.png" height="500" width="240"> <img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_3.png" height="500" width="240"> <img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_4.png" height="500" width="240"> <img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_5.png" height="500" width="240"></p></center><blockquote><p>代码如下</p></blockquote><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_menu2.jpg" align="top"> <img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_Fragment/Lab_2_4_menu1.jpg"></p><p>其中home_default.jpg为主页面图片(建议选择手机壁纸尝试，大小合适)</p><p>其他图片来源：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a></p><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><h4 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 存放主要页面内容 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FrameLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/contentLayout<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FrameLayout</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 底层菜单 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.v4.app.FragmentTabHost</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:id/tabhost<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#F6F6F6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>android.support.v4.app.FragmentTabHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="fragment-1-xml"><a href="#fragment-1-xml" class="headerlink" title="fragment_1.xml"></a>fragment_1.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.constraint.ConstraintLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/imageview<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>scaleType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>centerCrop<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/home_default<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>android.support.constraint.ConstraintLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="fragment-2-xml"><a href="#fragment-2-xml" class="headerlink" title="fragment_2.xml"></a>fragment_2.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/layout01<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_name<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/user_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/edit<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#808080<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_cancel<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/cancel<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_confirm<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/confirm<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>180dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>180dp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="fragment-3-xml"><a href="#fragment-3-xml" class="headerlink" title="fragment_3.xml"></a>fragment_3.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/layout02<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_name<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/user_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/edit<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#808080<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_confirm<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/confirm<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/edit<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_toLeftOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/btn_cancel<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_toStartOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/btn_cancel<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_cancel<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/cancel<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/edit<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="fragment-4-xml"><a href="#fragment-4-xml" class="headerlink" title="fragment_4.xml"></a>fragment_4.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TableLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/layout03<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TableRow</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/user_name<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#808080<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5.5<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TableRow</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TableRow</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/confirm<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/cancel<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginEnd</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>30dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TableRow</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TableLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="fragment-5-xml"><a href="#fragment-5-xml" class="headerlink" title="fragment_5.xml"></a>fragment_5.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GridLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/layout04<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>useDefaultMargins</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>columnCount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>horizontal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_columnSpan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center_horizontal<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/tv_gridlayout<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/user_name<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>        <span class="token attr-name"><span class="token namespace">android:</span>ems</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_columnSpan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#808080<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/password<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>        <span class="token attr-name"><span class="token namespace">android:</span>ems</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_columnSpan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#808080<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/empty<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fill_horizontal<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/next<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fill_horizontal<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GridLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="tabcontent"><a href="#tabcontent" class="headerlink" title="tabcontent"></a>tabcontent</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 底部菜单详细布局 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/image<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>40dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>40dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>focusable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/tab_home_btn<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/text<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>首页<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>13sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="tab-home-btn-xml"><a href="#tab-home-btn-xml" class="headerlink" title="tab_home_btn.xml"></a>tab_home_btn.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token comment" spellcheck="true">&lt;!-- Android中的Selector主要是用来改变ListView和Button控件的默认背景 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 选中时的图片背景 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/home_selected<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 默认时的背景图片 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/home<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- android:state_selected选中 --></span>    <span class="token comment" spellcheck="true">&lt;!-- android:state_focused获得焦点 --></span>    <span class="token comment" spellcheck="true">&lt;!-- android:state_pressed点击 --></span>    <span class="token comment" spellcheck="true">&lt;!-- android:state_enabled设置是否响应时间，指所有事件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="tab-linear-btn-xml"><a href="#tab-linear-btn-xml" class="headerlink" title="tab_linear_btn.xml"></a>tab_linear_btn.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/linear_selected<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/linear<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="tab-relative-btn-xml"><a href="#tab-relative-btn-xml" class="headerlink" title="tab_relative_btn.xml"></a>tab_relative_btn.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/relative_selected<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/relative<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="tab-table-btn-xml"><a href="#tab-table-btn-xml" class="headerlink" title="tab_table_btn.xml"></a>tab_table_btn.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/table_selected<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/table<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="tab-grid-btn-xml"><a href="#tab-grid-btn-xml" class="headerlink" title="tab_grid_btn.xml"></a>tab_grid_btn.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/grid_selected<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/grid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="strings-xml"><a href="#strings-xml" class="headerlink" title="strings.xml"></a>strings.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Lab_2_4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cancel<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>取消<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>confirm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>确定<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tv_gridlayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是关于GridLayout的示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>empty<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>清空输入<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>next<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下一步<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><h3 id="JAVA文件"><a href="#JAVA文件" class="headerlink" title="JAVA文件"></a>JAVA文件</h3><h4 id="FragmentHome"><a href="#FragmentHome" class="headerlink" title="FragmentHome"></a>FragmentHome</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>Lab_2_4<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v4<span class="token punctuation">.</span>app<span class="token punctuation">.</span>Fragment<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>LayoutInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FragmentHome</span> <span class="token keyword">extends</span> <span class="token class-name">Fragment</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> View <span class="token function">onCreateView</span><span class="token punctuation">(</span>LayoutInflater inflater<span class="token punctuation">,</span> ViewGroup container<span class="token punctuation">,</span> Bundle savedInsanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> inflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>fragment_1<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>FragmentLinear、FragmentRelative、FragmentTable、FragmentGrid</strong><br>这几个文件代码与FragmentHome相同,只需要将最后一句<br><code>return inflater.inflate(R.layout.fragment_1, null);</code><br>中的fragment_1更改一下即可</p></blockquote><p><strong>FragmentLinear</strong>中更改为 fragment_2</p><p><strong>FragmentRelative</strong>中更改为 fragment_3</p><p><strong>FragmentTable</strong>中更改为 fragment_4</p><p><strong>FragmentGrid</strong>中更改为 fragment_5</p><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>Lab_2_4<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>Color<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v4<span class="token punctuation">.</span>app<span class="token punctuation">.</span>FragmentActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v4<span class="token punctuation">.</span>app<span class="token punctuation">.</span>FragmentTabHost<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>LayoutInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ImageView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TabHost<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">FragmentActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> DEFAULT_BACKGROUND_COLOR <span class="token operator">=</span> Color<span class="token punctuation">.</span><span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">243</span><span class="token punctuation">,</span> <span class="token number">243</span><span class="token punctuation">,</span> <span class="token number">243</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义FragmentTabHost对象</span>    <span class="token keyword">private</span> FragmentTabHost fragmentTabHost<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义一个布局填充器成员变量</span>    <span class="token keyword">private</span> LayoutInflater layoutInflater<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Tab选项卡的文字</span>    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> texts <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"主页"</span><span class="token punctuation">,</span> <span class="token string">"线性布局"</span><span class="token punctuation">,</span> <span class="token string">"相对布局"</span><span class="token punctuation">,</span> <span class="token string">"表布局"</span><span class="token punctuation">,</span> <span class="token string">"网格布局"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义数组来存放按钮图片</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> imageButton <span class="token operator">=</span> <span class="token punctuation">{</span>R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>tab_home_btn<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>tab_linear_btn<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>tab_relative_btn<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>tab_table_btn<span class="token punctuation">,</span> R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>tab_grid_btn<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义数组来存放Fragment界面</span>    <span class="token keyword">private</span> Class<span class="token punctuation">[</span><span class="token punctuation">]</span> fragmentArray <span class="token operator">=</span> <span class="token punctuation">{</span>FragmentHome<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> FragmentLinear<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> FragmentRelative<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> FragmentTable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> FragmentGrid<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle saveInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>saveInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        layoutInflater <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自定义方法</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//实例化tabhost</span>        fragmentTabHost <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>tabhost<span class="token punctuation">)</span><span class="token punctuation">;</span>        fragmentTabHost<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">getSupportFragmentManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>contentLayout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//去除分割线</span>        fragmentTabHost<span class="token punctuation">.</span><span class="token function">getTabWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDividerDrawable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> texts<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//为每一个Tab按钮设置Tag，图标和文字</span>            <span class="token comment" spellcheck="true">//TabSpec是指每个Tab的标签，Indicator用来加载Tab的view。</span>            TabHost<span class="token punctuation">.</span>TabSpec spec <span class="token operator">=</span> fragmentTabHost<span class="token punctuation">.</span><span class="token function">newTabSpec</span><span class="token punctuation">(</span>texts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIndicator</span><span class="token punctuation">(</span><span class="token function">getTabItemView</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将Tab按钮添加进Tab选项卡中</span>            fragmentTabHost<span class="token punctuation">.</span><span class="token function">addTab</span><span class="token punctuation">(</span>spec<span class="token punctuation">,</span> fragmentArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置背景(必须在addTab之后，由于需要子节点(底部菜单按钮)否则会出现空指针异常)</span>            <span class="token comment" spellcheck="true">//fragmentTabHost.getTabWidget().getChildAt(i).setBackgroundResource(R.drawable.home_btn_bg);</span>            fragmentTabHost<span class="token punctuation">.</span><span class="token function">getTabWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChildAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBackgroundColor</span><span class="token punctuation">(</span>DEFAULT_BACKGROUND_COLOR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//增加Tabs的高度</span>            <span class="token comment" spellcheck="true">//tabHost.getTabWidget().getChildAt(i).getLayoutParams().height = (int) height;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//设置默认打开选择的fragment</span>        fragmentTabHost<span class="token punctuation">.</span><span class="token function">setCurrentTabByTag</span><span class="token punctuation">(</span>texts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//给每个Tab按钮设置图案和文字</span>    <span class="token keyword">private</span> View <span class="token function">getTabItemView</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取得布局实例</span>        View view <span class="token operator">=</span> layoutInflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>tabcontent<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//取得布局对象</span>        ImageView imageView <span class="token operator">=</span> view<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>        TextView textView <span class="token operator">=</span> view<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置图标</span>        imageView<span class="token punctuation">.</span><span class="token function">setImageResource</span><span class="token punctuation">(</span>imageButton<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置标题</span>        textView<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>texts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> view<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fragment </tag>
            
            <tag> FragmentTabHost </tag>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub搭建Hexo博客</title>
      <link href="/2019/05/02/%E5%88%A9%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/05/02/%E5%88%A9%E7%94%A8GitHub%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><ol><li>Node.js</li><li>Git</li><li>编辑器</li></ol></blockquote><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>官方网址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>点击最新版，下载一个形如<strong>node-v12.1.0-x64.msi</strong>的文件，下载完成后点击安装</p><p>安装步骤：<a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p><p>注意：如果选择了<strong>Add to PATH</strong>了，则无需手动配置环境变量，直接测试即可</p><a id="more"></a><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>官方网址：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>安装步骤：<a href="https://www.cnblogs.com/wj-1314/p/7993819.html" target="_blank" rel="noopener">https://www.cnblogs.com/wj-1314/p/7993819.html</a></p><p><a href="https://blog.csdn.net/sishen47k/article/details/80211002" target="_blank" rel="noopener">详细步骤</a></p><h3 id="安装编辑器"><a href="#安装编辑器" class="headerlink" title="安装编辑器"></a>安装编辑器</h3><p>编辑器有很多可以选择</p><p>如<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime</a>、<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vs code</a>(推荐这两个，轻便功能全插件多)</p><p>注：sublime是款收费软件，但是可以无限试用</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android组件之ProgressDialog</title>
      <link href="/2019/04/29/Android%E7%BB%84%E4%BB%B6%E4%B9%8BProgressDialog/"/>
      <url>/2019/04/29/Android%E7%BB%84%E4%BB%B6%E4%B9%8BProgressDialog/</url>
      
        <content type="html"><![CDATA[<h2 id="ProgressDialog的用法"><a href="#ProgressDialog的用法" class="headerlink" title="ProgressDialog的用法"></a>ProgressDialog的用法</h2><p>使用ProgressDialog实现如下程序界面和功能</p><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ProgressDialog/Lab_2_3_2_1.png" height="500" width="240"></div><a id="more"></a><ol><li>点击圆型进度条</li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ProgressDialog/Lab_2_3_2_2.png" height="500" width="240"></div><ol start="2"><li>点击长条型进度条</li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ProgressDialog/Lab_2_3_2_3.png" height="500" width="240"></div><blockquote><p>代码如下</p></blockquote><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><h4 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>18dp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn1_name<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>18sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn2_name<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>18sp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="strings-xml"><a href="#strings-xml" class="headerlink" title="strings.xml"></a>strings.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Lab_2_3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn1_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>圆型进度条对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn2_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>长条进度条对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><h3 id="Java文件"><a href="#Java文件" class="headerlink" title="Java文件"></a>Java文件</h3><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_32<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>SuppressLint<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ProgressDialog<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Handler<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Message<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toast<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token keyword">implements</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span> <span class="token punctuation">{</span>    Button btn_1<span class="token punctuation">;</span>    Button btn_2<span class="token punctuation">;</span>    ProgressDialog progressdialog<span class="token punctuation">;</span>    ProgressDialog progressDialog<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> currentProgress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> add <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MAXVALUE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_1 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_2 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_2<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_1<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_2<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_1<span class="token operator">:</span>                progressdialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgressDialog</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressdialog<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressdialog <span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"这是一个圆型进度条对话框"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressdialog<span class="token punctuation">.</span><span class="token function">setCancelable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressdialog<span class="token punctuation">.</span><span class="token function">setCanceledOnTouchOutside</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressdialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_2<span class="token operator">:</span>                progressDialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgressDialog</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"这是一个长条型进度条对话框"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置弹窗标题</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 能够返回</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setCancelable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 设置在点击Dialog外能否反回</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setCanceledOnTouchOutside</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置进度条</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setMax</span><span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//progressDialog.setProgress(100);</span>                <span class="token comment" spellcheck="true">//设置进度条是否明确</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setIndeterminate</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置进度条样式</span>                <span class="token comment" spellcheck="true">//ProgressDialog.STYLE_SPINNER 环形进度条</span>                <span class="token comment" spellcheck="true">//ProgressDialog.STYLE_HORIZONTAL 水平样式的进度条</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setProgressStyle</span><span class="token punctuation">(</span>ProgressDialog<span class="token punctuation">.</span>STYLE_HORIZONTAL<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//这里设置的是是否显示进度,设为false才是显示的哦！</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setIndeterminate</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                progressDialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//进度条的前进</span>                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>                        <span class="token keyword">while</span><span class="token punctuation">(</span>currentProgress <span class="token operator">&lt;</span> MAXVALUE<span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//这里的算法是决定进度条变化的,可以按需要写</span>                            currentProgress <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">usetime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//把信息码发送给handle让更新界面</span>                            handler<span class="token punctuation">.</span><span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">"ERROR"</span><span class="token punctuation">,</span>Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这里设置一个耗时的方法:</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">usetime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        add<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> add<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"HandlerLeak"</span><span class="token punctuation">)</span>    Handler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>what <span class="token operator">==</span> <span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                progressDialog<span class="token punctuation">.</span><span class="token function">setProgress</span><span class="token punctuation">(</span>currentProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentProgress <span class="token operator">>=</span> MAXVALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                progressDialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//currentProgress = 0;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ProgressDialog </tag>
            
            <tag> 进度条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android组件之AlertDialog</title>
      <link href="/2019/04/29/Android%E7%BB%84%E4%BB%B6%E4%B9%8BAlertDialog/"/>
      <url>/2019/04/29/Android%E7%BB%84%E4%BB%B6%E4%B9%8BAlertDialog/</url>
      
        <content type="html"><![CDATA[<h2 id="AlertDialog的几种用法"><a href="#AlertDialog的几种用法" class="headerlink" title="AlertDialog的几种用法"></a>AlertDialog的几种用法</h2><p>使用AlertDialog实现如下程序和功能</p><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_1.png" height="500" width="240"></div><a id="more"></a><ol><li>点击确定对话框</li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_2.png" height="500" width="240"></div><ol start="2"><li>点击列表对话框</li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_3.png" height="500" width="240"></div><ol start="3"><li>点击单选对话框 </li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_4.png" height="500" width="240"></div><ol start="4"><li>点击复选对话框</li></ol><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_5.png" height="500" width="240"></div><ol start="5"><li><p>点击自定义对话框</p><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_6.png" height="500" width="240"></div></li></ol><blockquote><p>代码如下</p></blockquote><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><img src="http://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_AlertDialog/Lab_2_3_1_menu.jpg"><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><h4 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/tv_1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn_2<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_3<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn_3<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_4<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn_4<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/btn_5<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/btn_5<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="login-dialog-xml"><a href="#login-dialog-xml" class="headerlink" title="login_dialog.xml"></a>login_dialog.xml</h4><blockquote><p>此文件为自定义对话框的布局文件</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_3<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/tv_3<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/et_1<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>inputType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/tv_3<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_toEndOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/tv_3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_4<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>25dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/tv_4<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20sp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EditText</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/et_2<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>inputType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>textPassword<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/tv_4<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_toEndOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/tv_4<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_alignStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/et_1<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_alignLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/et_1<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/et_1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="colors-xml"><a href="#colors-xml" class="headerlink" title="colors.xml"></a>colors.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorPrimary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#008577<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorPrimaryDark<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00574B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorAccent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D81B60<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colorBlack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#000000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><p><strong>strings.xml</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>AlertDialog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tv_1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>AlertDialog示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn_1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>确认对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn_2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>列表对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn_3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>单选对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn_4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>多选对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn_5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>自定义对话框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tv_3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tv_4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>string</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><h3 id="Java文件"><a href="#Java文件" class="headerlink" title="Java文件"></a>Java文件</h3><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_3<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>DialogInterface<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AlertDialog<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>text<span class="token punctuation">.</span>Editable<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>text<span class="token punctuation">.</span>TextWatcher<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>LayoutInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">.</span>OnClickListener<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Button<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>EditText<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toast<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button btn_1<span class="token punctuation">;</span>    <span class="token keyword">public</span> Button btn_2<span class="token punctuation">;</span>    <span class="token keyword">public</span> Button btn_3<span class="token punctuation">;</span>    <span class="token keyword">public</span> Button btn_4<span class="token punctuation">;</span>    <span class="token keyword">public</span> Button btn_5<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initViews</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initViews</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        btn_1 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_2 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_2<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_3 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_3<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_4 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_4<span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_5 <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>btn_5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//确认对话框</span>        btn_1<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                AlertDialog dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建对话框</span>                dialog<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置对话框icon</span>                dialog<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"删除对话框"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置对话框标题</span>                dialog<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"真的要删除该联系人吗？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置文字显示内容</span>                <span class="token comment" spellcheck="true">//分别设置三个button</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_POSITIVE<span class="token punctuation">,</span><span class="token string">"是"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭对话框</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">"删除成功"</span><span class="token punctuation">,</span>Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_NEUTRAL<span class="token punctuation">,</span><span class="token string">"查看详情"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_NEGATIVE<span class="token punctuation">,</span> <span class="token string">"否"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭对话框</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">"删除失败"</span><span class="token punctuation">,</span>Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示对话框</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//列表对话框</span>        btn_2<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始化字符串数组</span>                <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"苹果"</span><span class="token punctuation">,</span><span class="token string">"芒果"</span><span class="token punctuation">,</span><span class="token string">"草莓"</span><span class="token punctuation">,</span><span class="token string">"香蕉"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                AlertDialog<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化builder</span>                builder<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置图标</span>                builder<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"你喜欢哪种水果？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置标题</span>                <span class="token comment" spellcheck="true">//设置列表</span>                builder<span class="token punctuation">.</span><span class="token function">setItems</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span>strArray<span class="token punctuation">[</span>which<span class="token punctuation">]</span><span class="token punctuation">,</span>Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                builder<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并显示对话框</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//单选对话框</span>        btn_3<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始化字符串数组</span>                <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"苹果"</span><span class="token punctuation">,</span><span class="token string">"芒果"</span><span class="token punctuation">,</span><span class="token string">"草莓"</span><span class="token punctuation">,</span><span class="token string">"香蕉"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> AlertDialog<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化builder</span>                builder<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置图标</span>                builder<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"你喜欢吃哪种水果？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置标题</span>                <span class="token comment" spellcheck="true">//设置单选列表</span>                builder<span class="token punctuation">.</span><span class="token function">setSingleChoiceItems</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//创建对话框</span>                AlertDialog dialog <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置确定按钮</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_POSITIVE<span class="token punctuation">,</span><span class="token string">"确定"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置取消按钮</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_NEGATIVE<span class="token punctuation">,</span><span class="token string">"取消"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示对话框</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//多选对话框</span>        btn_4<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始化字符串数组</span>                <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"苹果"</span><span class="token punctuation">,</span><span class="token string">"芒果"</span><span class="token punctuation">,</span><span class="token string">"草莓"</span><span class="token punctuation">,</span><span class="token string">"香蕉"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> AlertDialog<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化builder</span>                builder<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置图标</span>                builder<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"你喜欢吃哪种水果？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置标题</span>                <span class="token comment" spellcheck="true">//设置多选列表</span>                builder<span class="token punctuation">.</span><span class="token function">setMultiChoiceItems</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnMultiChoiceClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isChecked<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//创建对话框</span>                AlertDialog dialog <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置确定按钮</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_POSITIVE<span class="token punctuation">,</span><span class="token string">"确定"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置取消按钮</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>DialogInterface<span class="token punctuation">.</span>BUTTON_NEGATIVE<span class="token punctuation">,</span> <span class="token string">"取消"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        dialog<span class="token punctuation">.</span><span class="token function">dismiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//显示对话框</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//自定义对话框</span>        btn_5<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//实例化布局</span>                View view <span class="token operator">=</span> LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>login_dialog<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//找到并对自定义布局中的控件进行操作的示例</span>                <span class="token comment" spellcheck="true">/*                EditText et_1 = view.findViewById(R.id.et_1);                EditText et_2 = view.findViewById(R.id.et_2);                et_1.addTextChangedListener(new TextWatcher() {                    @Override                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {                    }                    @Override                    public void onTextChanged(CharSequence s, int start, int before, int count) {                    }                    @Override                    public void afterTextChanged(Editable s) {                    }                });                */</span>                <span class="token comment" spellcheck="true">//创建对话框</span>                AlertDialog dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>ic_launcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置图标</span>                dialog<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"用户登录"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置标题</span>                dialog<span class="token punctuation">.</span><span class="token function">setView</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加布局</span>                <span class="token comment" spellcheck="true">//设置按键</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>AlertDialog<span class="token punctuation">.</span>BUTTON_POSITIVE<span class="token punctuation">,</span> <span class="token string">"登录"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">setButton</span><span class="token punctuation">(</span>AlertDialog<span class="token punctuation">.</span>BUTTON_NEGATIVE<span class="token punctuation">,</span> <span class="token string">"取消"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>DialogInterface dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlertDialog </tag>
            
            <tag> 对话框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加</title>
      <link href="/2019/04/15/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/04/15/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p></blockquote><blockquote><p>输出：7 -&gt; 0 -&gt; 8</p></blockquote><blockquote><p>原因：342 + 465 = 807</p></blockquote><hr><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法：初等数学"><a href="#方法：初等数学" class="headerlink" title="方法：初等数学"></a>方法：初等数学</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 <em>carry = 1</em> 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。</p><p>伪代码如下：</p><ul><li><p>将当前结点初始化为返回列表的哑结点。</p></li><li><p>将进位 <em>carry</em> 初始化为 0。</p></li><li><p>将 <em>p</em> 和 <em>q</em> 分别初始化为列表 <em>l1</em> 和 <em>l2</em> 的头部。</p></li><li><p>遍历列表 <em>l1</em> 和 <em>l2</em> 直至到达它们的尾端。</p><ul><li><p>将 <em>x</em> 设为结点 <em>p</em> 的值。如果 <em>p</em> 已经到达 <em>l1</em> 的末尾，则将其值设置为 0。</p></li><li><p>将 <em>y</em> 设为结点 <em>q</em> 的值。如果 <em>q</em> 已经到达 <em>l2</em> 的末尾，则将其值设置为 0。</p></li><li><p>设定 <em>sum = x + y + carry</em>。</p></li><li><p>更新进位的值，<em>carry = sum</em> / 10。</p></li><li><p>创建一个数值为 (<em>sum mod</em> 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</p></li><li><p>同时，将 <em>p</em> 和 <em>q</em> 前进到下一个结点。 </p></li></ul></li><li><p>检查 <em>carry</em> = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。</p></li><li><p>返回哑结点的下一个结点。</p></li></ul><p>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><p>请特别注意以下情况：</p><table><thead><tr><th align="left">测试用例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">l1 = [0,1] <br> l2 = [0,1,2]</td><td align="left">当一个列表比另一个列表长时。</td></tr><tr><td align="left">l1 = []<br>l2 = [0,1]</td><td align="left">当一个列表为空时，即出现空列表。</td></tr><tr><td align="left">l1 = [9,9]<br>l2 = [1]</td><td align="left">求和运算最后可能出现额外的进位，这一点很容易被遗忘</td></tr></tbody></table><p><strong>Java</strong></p><pre class=" language-Java"><code class="language-Java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    ListNode dummyHead = new ListNode(0);    ListNode p = l1, q = l2, curr = dummyHead;    int carry = 0;    while (p != null || q != null) {        int x = (p != null) ? p.val : 0;        int y = (q != null) ? q.val : 0;        int sum = carry + x + y;        carry = sum / 10;        curr.next = new ListNode(sum % 10);        curr = curr.next;        if (p != null) p = p.next;        if (q != null) q = q.next;    }    if (carry > 0) {        curr.next = new ListNode(carry);    }    return dummyHead.next;}</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：<em>O(max(m, n))*，假设 *m</em> 和 <em>n</em> 分别表示 <em>l1</em> 和 <em>l2</em> 的长度，上面的算法最多重复 <em>max(m,n)</em> 次。</p></li><li><p>空间复杂度：<em>O(max(m,n))*， 新列表的长度最多为 *max(m,n)</em>+1。</p></li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如果链表中的数字不是按逆序存储的呢？例如：</p><p>(3→4→2) + (4→6→5) = 8→0→7</p><p>本文来自<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/2019/04/15/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/04/15/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><hr><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>暴力很简单。遍历每个元素<em>x</em>，并查找是否存在一个值与<em>target-x</em>相等的目标元素</p><p><strong>Java</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> i<span class="token punctuation">,</span> j <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p>时间复杂度：<em>O(n^2)*，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 *O(n)</em> 的时间。因此时间复杂度为 <em>O(n^2)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h3 id="方法二：两遍哈希表"><a href="#方法二：两遍哈希表" class="headerlink" title="方法二：两遍哈希表"></a>方法二：两遍哈希表</h3><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p><p>通过以空间换取速度的方式，我们可以将查找时间从 <em>O(n)</em> 降低到 <em>O(1)</em>。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 <em>O(n)</em>。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 <em>O(1)</em>。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素  <em>(target - nums[i])*是否存在于表中。注意，该目标元素不能是 *nums[i]</em> 本身！</p><p><strong>Java</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p>时间复杂度：<em>O(n)</em>，我们把含有<em>n</em>个元素的列表便利两次。由于哈希表将查找时间缩短到<em>O(1)</em>，所以时间复杂度为<em>O(n)</em>。</p></li><li><p>空间复杂度: <em>O(n)*，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 *n</em> 个元素。</p></li></ul><h3 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><p><strong>Java</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> complement <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>complement<span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No two sum solution"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p>时间复杂度：<em>O(n)*，我们只遍历了包含有 *n</em> 个元素的列表一次。在表中进行的每次查找只花费 <em>O(1)</em> 的时间。</p></li><li><p>空间复杂度：<em>O(n)*， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 *n</em> 个元素。</p></li></ul><p>本文来自<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android组件之ListView</title>
      <link href="/2019/04/11/Android%E7%BB%84%E4%BB%B6%E4%B9%8BListView/"/>
      <url>/2019/04/11/Android%E7%BB%84%E4%BB%B6%E4%B9%8BListView/</url>
      
        <content type="html"><![CDATA[<h2 id="ListView简单用法"><a href="#ListView简单用法" class="headerlink" title="ListView简单用法"></a>ListView简单用法</h2><p>当选择某一ListView子项，TextView中会显示所选子项内容</p><div align="center"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ListView/Lab_2_2.png" height="500" width="240"></div><a id="more"></a><blockquote><p>代码如下</p></blockquote><h3 id="布局文件："><a href="#布局文件：" class="headerlink" title="布局文件："></a>布局文件：</h3><h4 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/ll_1<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/textView<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MenuDemo<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textColor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorBlack<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>25sp<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ListView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/listView<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ListView</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="JAVA文件："><a href="#JAVA文件：" class="headerlink" title="JAVA文件："></a>JAVA文件：</h3><h4 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_2<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>AdapterView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ArrayAdapter<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ListView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>AdapterView<span class="token punctuation">.</span>OnItemClickListener<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"移动应用开发技术"</span><span class="token punctuation">,</span><span class="token string">"计算机组成原理"</span><span class="token punctuation">,</span><span class="token string">"数据结构"</span><span class="token punctuation">,</span><span class="token string">"操作系统"</span><span class="token punctuation">,</span><span class="token string">"面向对象技术"</span><span class="token punctuation">,</span><span class="token string">"逻辑设计"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//在MianActivity类的onCreate函数内部构造适配器</span>        ArrayAdapter<span class="token operator">&lt;</span>String<span class="token operator">></span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayAdapter</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>                MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">//context上下文</span>                android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>simple_list_item_1<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//子项布局id</span>                data<span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">//数据</span>        ListView listView <span class="token operator">=</span> <span class="token punctuation">(</span>ListView<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>listView<span class="token punctuation">)</span><span class="token punctuation">;</span>        listView<span class="token punctuation">.</span><span class="token function">setAdapter</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> TextView textView <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>textView<span class="token punctuation">)</span><span class="token punctuation">;</span>        listView<span class="token punctuation">.</span><span class="token function">setOnItemClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnItemClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//list点击事件</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onItemClick</span><span class="token punctuation">(</span>AdapterView<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> p1<span class="token punctuation">,</span> View p2<span class="token punctuation">,</span> <span class="token keyword">int</span> p3<span class="token punctuation">,</span> <span class="token keyword">long</span> p4<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO: Implement this method</span>                textView<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="采用自定义布局BaseAdapter修改列表颜色"><a href="#采用自定义布局BaseAdapter修改列表颜色" class="headerlink" title="采用自定义布局BaseAdapter修改列表颜色"></a>采用自定义布局<strong>BaseAdapter</strong>修改列表颜色</h2><p>如图所示</p><center class="half"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ListView/Lab_2_2_1.png" height="500" width="240"><img src="https://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ListView/Lab_2_2_2.png" height="500" width="240"></center><blockquote><p>代码如下</p></blockquote><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><img src="http://chenshuoke-pictures.oss-cn-beijing.aliyuncs.com/Android/Android_ListView/Lab_2_2_menu.jpg"><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><h4 id="activity-main-xml-1"><a href="#activity-main-xml-1" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ListView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/lv<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ListView</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h4 id="list-item-xml"><a href="#list-item-xml" class="headerlink" title="list_item.xml"></a>list_item.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/ll<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/image_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@mipmap/ic_launcher<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/ll_1<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>paddingTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_1<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>第一行<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>15sp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/tv_2<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>第二行<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>textSize</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>22sp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_marginStart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">></span></span></code></pre><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="item-default-1-xml"><a href="#item-default-1-xml" class="headerlink" title="item_default_1.xml"></a>item_default_1.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorBlue<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="item-default-2-xml"><a href="#item-default-2-xml" class="headerlink" title="item_default_2.xml"></a>item_default_2.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorGray<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h4 id="item-select-xml"><a href="#item-select-xml" class="headerlink" title="item_select.xml"></a>item_select.xml</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorRed<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/colorRed<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">></span></span></code></pre><h3 id="java文件"><a href="#java文件" class="headerlink" title="java文件"></a>java文件</h3><h4 id="Item-java"><a href="#Item-java" class="headerlink" title="Item.java"></a>Item.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_22<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> image<span class="token punctuation">;</span>    <span class="token keyword">private</span> String first<span class="token punctuation">;</span>    <span class="token keyword">private</span> String second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Item</span><span class="token punctuation">(</span><span class="token keyword">int</span> image<span class="token punctuation">,</span> String first<span class="token punctuation">,</span> String second<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>image <span class="token operator">=</span> image<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> image<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setImage</span><span class="token punctuation">(</span><span class="token keyword">int</span> image<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>image <span class="token operator">=</span> image<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span>String first<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span>String second<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="ItemAdapter-java"><a href="#ItemAdapter-java" class="headerlink" title="ItemAdapter.java"></a>ItemAdapter.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_22<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>LayoutInflater<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>BaseAdapter<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ImageView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>TextView<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">BaseAdapter</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//声明一个链表和Context对象</span>    <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Item<span class="token operator">></span> mList<span class="token punctuation">;</span>    <span class="token keyword">private</span> Context mContext<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ItemAdapter</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>Item<span class="token operator">></span> mList<span class="token punctuation">,</span>Context mContext<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mList<span class="token operator">=</span>mList<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mContext<span class="token operator">=</span>mContext<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getItem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> position<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> View <span class="token function">getView</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> View convertView<span class="token punctuation">,</span> ViewGroup parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//加载一个适配器界面</span>        convertView<span class="token operator">=</span>LayoutInflater<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>mContext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>list_item<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实例化元件</span>        ImageView image <span class="token operator">=</span> <span class="token punctuation">(</span>ImageView<span class="token punctuation">)</span> convertView<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>image_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        TextView text1 <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span> convertView<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>tv_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        TextView text2 <span class="token operator">=</span> <span class="token punctuation">(</span>TextView<span class="token punctuation">)</span> convertView<span class="token punctuation">.</span><span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>tv_2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//元件获取数据</span>        image<span class="token punctuation">.</span><span class="token function">setImageResource</span><span class="token punctuation">(</span>mList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        text1<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>mList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        text2<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>mList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为ListView设置隔行不同的背景颜色</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            convertView<span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span>convertView<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>                    R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>item_default_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            convertView<span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span>convertView<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>                    R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>item_default_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> convertView<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="MainActivity-java-1"><a href="#MainActivity-java-1" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>lab_2_22<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>support<span class="token punctuation">.</span>v7<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatActivity<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>os<span class="token punctuation">.</span>Bundle<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>View<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>AdapterView<span class="token punctuation">;</span><span class="token keyword">import</span> android<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>ListView<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> View oldView<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> oldPosition<span class="token punctuation">;</span>    <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Item<span class="token operator">></span> mList<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token keyword">private</span>  ListView listView<span class="token punctuation">;</span>    <span class="token keyword">private</span> Context mContext<span class="token punctuation">;</span>    <span class="token keyword">private</span> ItemAdapter adapter<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        mContext<span class="token operator">=</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">;</span>        listView <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>lv<span class="token punctuation">)</span><span class="token punctuation">;</span>        mList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化LinkedList</span>        <span class="token comment" spellcheck="true">//R.mipmap.img即为图中所示图片（滑稽）</span>        mList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token string">"姓名"</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//增加数据到链表</span>        mList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token string">"性别"</span><span class="token punctuation">,</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token string">"年龄"</span><span class="token punctuation">,</span><span class="token string">"25"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token string">"居住地"</span><span class="token punctuation">,</span><span class="token string">"开封"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>mipmap<span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token string">"邮箱"</span><span class="token punctuation">,</span><span class="token string">"zhangsan@henu.edu.cn"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ItemAdapter</span><span class="token punctuation">(</span>mList<span class="token punctuation">,</span>mContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置适配器</span>        listView<span class="token punctuation">.</span><span class="token function">setAdapter</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ListView设置适配器</span>        listView<span class="token punctuation">.</span><span class="token function">setOnItemClickListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AdapterView<span class="token punctuation">.</span>OnItemClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onItemClick</span><span class="token punctuation">(</span>AdapterView<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> parent<span class="token punctuation">,</span> View view<span class="token punctuation">,</span> <span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//第一行的颜色还原</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>oldPosition <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                        oldView<span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>                            R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>item_default_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span>                    <span class="token comment" spellcheck="true">//第二行的颜色还原</span>                        oldView<span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span>view<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDrawable</span><span class="token punctuation">(</span>                            R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>item_default_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//这里因为第一此点击之前不用还原</span>                    <span class="token comment" spellcheck="true">//Toast.makeText(MainActivity.this,"之前未选中元素",Toast.LENGTH_SHORT ).show();</span>                <span class="token punctuation">}</span>                view<span class="token punctuation">.</span><span class="token function">setBackgroundResource</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>item_select<span class="token punctuation">)</span><span class="token punctuation">;</span>                oldView <span class="token operator">=</span> view<span class="token punctuation">;</span>                oldPosition <span class="token operator">=</span> position<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
